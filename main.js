/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to2, from2, except, desc) => {
  if (from2 && typeof from2 === "object" || typeof from2 === "function") {
    for (let key of __getOwnPropNames(from2))
      if (!__hasOwnProp.call(to2, key) && key !== except)
        __defProp(to2, key, { get: () => from2[key], enumerable: !(desc = __getOwnPropDesc(from2, key)) || desc.enumerable });
  }
  return to2;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};

// node_modules/hammerjs/hammer.js
var require_hammer = __commonJS({
  "node_modules/hammerjs/hammer.js"(exports, module2) {
    (function(window2, document2, exportName, undefined2) {
      "use strict";
      var VENDOR_PREFIXES = ["", "webkit", "Moz", "MS", "ms", "o"];
      var TEST_ELEMENT = document2.createElement("div");
      var TYPE_FUNCTION = "function";
      var round2 = Math.round;
      var abs = Math.abs;
      var now = Date.now;
      function setTimeoutContext(fn, timeout, context) {
        return setTimeout(bindFn(fn, context), timeout);
      }
      function invokeArrayArg(arg, fn, context) {
        if (Array.isArray(arg)) {
          each2(arg, context[fn], context);
          return true;
        }
        return false;
      }
      function each2(obj, iterator, context) {
        var i;
        if (!obj) {
          return;
        }
        if (obj.forEach) {
          obj.forEach(iterator, context);
        } else if (obj.length !== undefined2) {
          i = 0;
          while (i < obj.length) {
            iterator.call(context, obj[i], i, obj);
            i++;
          }
        } else {
          for (i in obj) {
            obj.hasOwnProperty(i) && iterator.call(context, obj[i], i, obj);
          }
        }
      }
      function deprecate(method, name, message) {
        var deprecationMessage = "DEPRECATED METHOD: " + name + "\n" + message + " AT \n";
        return function() {
          var e = new Error("get-stack-trace");
          var stack = e && e.stack ? e.stack.replace(/^[^\(]+?[\n$]/gm, "").replace(/^\s+at\s+/gm, "").replace(/^Object.<anonymous>\s*\(/gm, "{anonymous}()@") : "Unknown Stack Trace";
          var log = window2.console && (window2.console.warn || window2.console.log);
          if (log) {
            log.call(window2.console, deprecationMessage, stack);
          }
          return method.apply(this, arguments);
        };
      }
      var assign;
      if (typeof Object.assign !== "function") {
        assign = function assign2(target) {
          if (target === undefined2 || target === null) {
            throw new TypeError("Cannot convert undefined or null to object");
          }
          var output = Object(target);
          for (var index2 = 1; index2 < arguments.length; index2++) {
            var source = arguments[index2];
            if (source !== undefined2 && source !== null) {
              for (var nextKey in source) {
                if (source.hasOwnProperty(nextKey)) {
                  output[nextKey] = source[nextKey];
                }
              }
            }
          }
          return output;
        };
      } else {
        assign = Object.assign;
      }
      var extend = deprecate(function extend2(dest, src, merge3) {
        var keys = Object.keys(src);
        var i = 0;
        while (i < keys.length) {
          if (!merge3 || merge3 && dest[keys[i]] === undefined2) {
            dest[keys[i]] = src[keys[i]];
          }
          i++;
        }
        return dest;
      }, "extend", "Use `assign`.");
      var merge2 = deprecate(function merge3(dest, src) {
        return extend(dest, src, true);
      }, "merge", "Use `assign`.");
      function inherit(child, base, properties) {
        var baseP = base.prototype, childP;
        childP = child.prototype = Object.create(baseP);
        childP.constructor = child;
        childP._super = baseP;
        if (properties) {
          assign(childP, properties);
        }
      }
      function bindFn(fn, context) {
        return function boundFn() {
          return fn.apply(context, arguments);
        };
      }
      function boolOrFn(val, args) {
        if (typeof val == TYPE_FUNCTION) {
          return val.apply(args ? args[0] || undefined2 : undefined2, args);
        }
        return val;
      }
      function ifUndefined(val1, val2) {
        return val1 === undefined2 ? val2 : val1;
      }
      function addEventListeners(target, types, handler) {
        each2(splitStr(types), function(type) {
          target.addEventListener(type, handler, false);
        });
      }
      function removeEventListeners(target, types, handler) {
        each2(splitStr(types), function(type) {
          target.removeEventListener(type, handler, false);
        });
      }
      function hasParent(node, parent) {
        while (node) {
          if (node == parent) {
            return true;
          }
          node = node.parentNode;
        }
        return false;
      }
      function inStr(str, find) {
        return str.indexOf(find) > -1;
      }
      function splitStr(str) {
        return str.trim().split(/\s+/g);
      }
      function inArray(src, find, findByKey) {
        if (src.indexOf && !findByKey) {
          return src.indexOf(find);
        } else {
          var i = 0;
          while (i < src.length) {
            if (findByKey && src[i][findByKey] == find || !findByKey && src[i] === find) {
              return i;
            }
            i++;
          }
          return -1;
        }
      }
      function toArray(obj) {
        return Array.prototype.slice.call(obj, 0);
      }
      function uniqueArray(src, key, sort) {
        var results = [];
        var values = [];
        var i = 0;
        while (i < src.length) {
          var val = key ? src[i][key] : src[i];
          if (inArray(values, val) < 0) {
            results.push(src[i]);
          }
          values[i] = val;
          i++;
        }
        if (sort) {
          if (!key) {
            results = results.sort();
          } else {
            results = results.sort(function sortUniqueArray(a, b) {
              return a[key] > b[key];
            });
          }
        }
        return results;
      }
      function prefixed(obj, property) {
        var prefix, prop;
        var camelProp = property[0].toUpperCase() + property.slice(1);
        var i = 0;
        while (i < VENDOR_PREFIXES.length) {
          prefix = VENDOR_PREFIXES[i];
          prop = prefix ? prefix + camelProp : property;
          if (prop in obj) {
            return prop;
          }
          i++;
        }
        return undefined2;
      }
      var _uniqueId = 1;
      function uniqueId() {
        return _uniqueId++;
      }
      function getWindowForElement(element) {
        var doc = element.ownerDocument || element;
        return doc.defaultView || doc.parentWindow || window2;
      }
      var MOBILE_REGEX = /mobile|tablet|ip(ad|hone|od)|android/i;
      var SUPPORT_TOUCH = "ontouchstart" in window2;
      var SUPPORT_POINTER_EVENTS = prefixed(window2, "PointerEvent") !== undefined2;
      var SUPPORT_ONLY_TOUCH = SUPPORT_TOUCH && MOBILE_REGEX.test(navigator.userAgent);
      var INPUT_TYPE_TOUCH = "touch";
      var INPUT_TYPE_PEN = "pen";
      var INPUT_TYPE_MOUSE = "mouse";
      var INPUT_TYPE_KINECT = "kinect";
      var COMPUTE_INTERVAL = 25;
      var INPUT_START = 1;
      var INPUT_MOVE = 2;
      var INPUT_END = 4;
      var INPUT_CANCEL = 8;
      var DIRECTION_NONE = 1;
      var DIRECTION_LEFT = 2;
      var DIRECTION_RIGHT = 4;
      var DIRECTION_UP = 8;
      var DIRECTION_DOWN = 16;
      var DIRECTION_HORIZONTAL = DIRECTION_LEFT | DIRECTION_RIGHT;
      var DIRECTION_VERTICAL = DIRECTION_UP | DIRECTION_DOWN;
      var DIRECTION_ALL = DIRECTION_HORIZONTAL | DIRECTION_VERTICAL;
      var PROPS_XY = ["x", "y"];
      var PROPS_CLIENT_XY = ["clientX", "clientY"];
      function Input(manager, callback2) {
        var self2 = this;
        this.manager = manager;
        this.callback = callback2;
        this.element = manager.element;
        this.target = manager.options.inputTarget;
        this.domHandler = function(ev) {
          if (boolOrFn(manager.options.enable, [manager])) {
            self2.handler(ev);
          }
        };
        this.init();
      }
      Input.prototype = {
        /**
         * should handle the inputEvent data and trigger the callback
         * @virtual
         */
        handler: function() {
        },
        /**
         * bind the events
         */
        init: function() {
          this.evEl && addEventListeners(this.element, this.evEl, this.domHandler);
          this.evTarget && addEventListeners(this.target, this.evTarget, this.domHandler);
          this.evWin && addEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);
        },
        /**
         * unbind the events
         */
        destroy: function() {
          this.evEl && removeEventListeners(this.element, this.evEl, this.domHandler);
          this.evTarget && removeEventListeners(this.target, this.evTarget, this.domHandler);
          this.evWin && removeEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);
        }
      };
      function createInputInstance(manager) {
        var Type;
        var inputClass = manager.options.inputClass;
        if (inputClass) {
          Type = inputClass;
        } else if (SUPPORT_POINTER_EVENTS) {
          Type = PointerEventInput;
        } else if (SUPPORT_ONLY_TOUCH) {
          Type = TouchInput;
        } else if (!SUPPORT_TOUCH) {
          Type = MouseInput;
        } else {
          Type = TouchMouseInput;
        }
        return new Type(manager, inputHandler);
      }
      function inputHandler(manager, eventType, input) {
        var pointersLen = input.pointers.length;
        var changedPointersLen = input.changedPointers.length;
        var isFirst = eventType & INPUT_START && pointersLen - changedPointersLen === 0;
        var isFinal = eventType & (INPUT_END | INPUT_CANCEL) && pointersLen - changedPointersLen === 0;
        input.isFirst = !!isFirst;
        input.isFinal = !!isFinal;
        if (isFirst) {
          manager.session = {};
        }
        input.eventType = eventType;
        computeInputData(manager, input);
        manager.emit("hammer.input", input);
        manager.recognize(input);
        manager.session.prevInput = input;
      }
      function computeInputData(manager, input) {
        var session = manager.session;
        var pointers = input.pointers;
        var pointersLength = pointers.length;
        if (!session.firstInput) {
          session.firstInput = simpleCloneInputData(input);
        }
        if (pointersLength > 1 && !session.firstMultiple) {
          session.firstMultiple = simpleCloneInputData(input);
        } else if (pointersLength === 1) {
          session.firstMultiple = false;
        }
        var firstInput = session.firstInput;
        var firstMultiple = session.firstMultiple;
        var offsetCenter = firstMultiple ? firstMultiple.center : firstInput.center;
        var center = input.center = getCenter2(pointers);
        input.timeStamp = now();
        input.deltaTime = input.timeStamp - firstInput.timeStamp;
        input.angle = getAngle(offsetCenter, center);
        input.distance = getDistance(offsetCenter, center);
        computeDeltaXY(session, input);
        input.offsetDirection = getDirection(input.deltaX, input.deltaY);
        var overallVelocity = getVelocity(input.deltaTime, input.deltaX, input.deltaY);
        input.overallVelocityX = overallVelocity.x;
        input.overallVelocityY = overallVelocity.y;
        input.overallVelocity = abs(overallVelocity.x) > abs(overallVelocity.y) ? overallVelocity.x : overallVelocity.y;
        input.scale = firstMultiple ? getScale(firstMultiple.pointers, pointers) : 1;
        input.rotation = firstMultiple ? getRotation(firstMultiple.pointers, pointers) : 0;
        input.maxPointers = !session.prevInput ? input.pointers.length : input.pointers.length > session.prevInput.maxPointers ? input.pointers.length : session.prevInput.maxPointers;
        computeIntervalInputData(session, input);
        var target = manager.element;
        if (hasParent(input.srcEvent.target, target)) {
          target = input.srcEvent.target;
        }
        input.target = target;
      }
      function computeDeltaXY(session, input) {
        var center = input.center;
        var offset = session.offsetDelta || {};
        var prevDelta = session.prevDelta || {};
        var prevInput = session.prevInput || {};
        if (input.eventType === INPUT_START || prevInput.eventType === INPUT_END) {
          prevDelta = session.prevDelta = {
            x: prevInput.deltaX || 0,
            y: prevInput.deltaY || 0
          };
          offset = session.offsetDelta = {
            x: center.x,
            y: center.y
          };
        }
        input.deltaX = prevDelta.x + (center.x - offset.x);
        input.deltaY = prevDelta.y + (center.y - offset.y);
      }
      function computeIntervalInputData(session, input) {
        var last = session.lastInterval || input, deltaTime = input.timeStamp - last.timeStamp, velocity, velocityX, velocityY, direction;
        if (input.eventType != INPUT_CANCEL && (deltaTime > COMPUTE_INTERVAL || last.velocity === undefined2)) {
          var deltaX = input.deltaX - last.deltaX;
          var deltaY = input.deltaY - last.deltaY;
          var v = getVelocity(deltaTime, deltaX, deltaY);
          velocityX = v.x;
          velocityY = v.y;
          velocity = abs(v.x) > abs(v.y) ? v.x : v.y;
          direction = getDirection(deltaX, deltaY);
          session.lastInterval = input;
        } else {
          velocity = last.velocity;
          velocityX = last.velocityX;
          velocityY = last.velocityY;
          direction = last.direction;
        }
        input.velocity = velocity;
        input.velocityX = velocityX;
        input.velocityY = velocityY;
        input.direction = direction;
      }
      function simpleCloneInputData(input) {
        var pointers = [];
        var i = 0;
        while (i < input.pointers.length) {
          pointers[i] = {
            clientX: round2(input.pointers[i].clientX),
            clientY: round2(input.pointers[i].clientY)
          };
          i++;
        }
        return {
          timeStamp: now(),
          pointers,
          center: getCenter2(pointers),
          deltaX: input.deltaX,
          deltaY: input.deltaY
        };
      }
      function getCenter2(pointers) {
        var pointersLength = pointers.length;
        if (pointersLength === 1) {
          return {
            x: round2(pointers[0].clientX),
            y: round2(pointers[0].clientY)
          };
        }
        var x = 0, y = 0, i = 0;
        while (i < pointersLength) {
          x += pointers[i].clientX;
          y += pointers[i].clientY;
          i++;
        }
        return {
          x: round2(x / pointersLength),
          y: round2(y / pointersLength)
        };
      }
      function getVelocity(deltaTime, x, y) {
        return {
          x: x / deltaTime || 0,
          y: y / deltaTime || 0
        };
      }
      function getDirection(x, y) {
        if (x === y) {
          return DIRECTION_NONE;
        }
        if (abs(x) >= abs(y)) {
          return x < 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;
        }
        return y < 0 ? DIRECTION_UP : DIRECTION_DOWN;
      }
      function getDistance(p1, p2, props) {
        if (!props) {
          props = PROPS_XY;
        }
        var x = p2[props[0]] - p1[props[0]], y = p2[props[1]] - p1[props[1]];
        return Math.sqrt(x * x + y * y);
      }
      function getAngle(p1, p2, props) {
        if (!props) {
          props = PROPS_XY;
        }
        var x = p2[props[0]] - p1[props[0]], y = p2[props[1]] - p1[props[1]];
        return Math.atan2(y, x) * 180 / Math.PI;
      }
      function getRotation(start, end) {
        return getAngle(end[1], end[0], PROPS_CLIENT_XY) + getAngle(start[1], start[0], PROPS_CLIENT_XY);
      }
      function getScale(start, end) {
        return getDistance(end[0], end[1], PROPS_CLIENT_XY) / getDistance(start[0], start[1], PROPS_CLIENT_XY);
      }
      var MOUSE_INPUT_MAP = {
        mousedown: INPUT_START,
        mousemove: INPUT_MOVE,
        mouseup: INPUT_END
      };
      var MOUSE_ELEMENT_EVENTS = "mousedown";
      var MOUSE_WINDOW_EVENTS = "mousemove mouseup";
      function MouseInput() {
        this.evEl = MOUSE_ELEMENT_EVENTS;
        this.evWin = MOUSE_WINDOW_EVENTS;
        this.pressed = false;
        Input.apply(this, arguments);
      }
      inherit(MouseInput, Input, {
        /**
         * handle mouse events
         * @param {Object} ev
         */
        handler: function MEhandler(ev) {
          var eventType = MOUSE_INPUT_MAP[ev.type];
          if (eventType & INPUT_START && ev.button === 0) {
            this.pressed = true;
          }
          if (eventType & INPUT_MOVE && ev.which !== 1) {
            eventType = INPUT_END;
          }
          if (!this.pressed) {
            return;
          }
          if (eventType & INPUT_END) {
            this.pressed = false;
          }
          this.callback(this.manager, eventType, {
            pointers: [ev],
            changedPointers: [ev],
            pointerType: INPUT_TYPE_MOUSE,
            srcEvent: ev
          });
        }
      });
      var POINTER_INPUT_MAP = {
        pointerdown: INPUT_START,
        pointermove: INPUT_MOVE,
        pointerup: INPUT_END,
        pointercancel: INPUT_CANCEL,
        pointerout: INPUT_CANCEL
      };
      var IE10_POINTER_TYPE_ENUM = {
        2: INPUT_TYPE_TOUCH,
        3: INPUT_TYPE_PEN,
        4: INPUT_TYPE_MOUSE,
        5: INPUT_TYPE_KINECT
        // see https://twitter.com/jacobrossi/status/480596438489890816
      };
      var POINTER_ELEMENT_EVENTS = "pointerdown";
      var POINTER_WINDOW_EVENTS = "pointermove pointerup pointercancel";
      if (window2.MSPointerEvent && !window2.PointerEvent) {
        POINTER_ELEMENT_EVENTS = "MSPointerDown";
        POINTER_WINDOW_EVENTS = "MSPointerMove MSPointerUp MSPointerCancel";
      }
      function PointerEventInput() {
        this.evEl = POINTER_ELEMENT_EVENTS;
        this.evWin = POINTER_WINDOW_EVENTS;
        Input.apply(this, arguments);
        this.store = this.manager.session.pointerEvents = [];
      }
      inherit(PointerEventInput, Input, {
        /**
         * handle mouse events
         * @param {Object} ev
         */
        handler: function PEhandler(ev) {
          var store = this.store;
          var removePointer = false;
          var eventTypeNormalized = ev.type.toLowerCase().replace("ms", "");
          var eventType = POINTER_INPUT_MAP[eventTypeNormalized];
          var pointerType = IE10_POINTER_TYPE_ENUM[ev.pointerType] || ev.pointerType;
          var isTouch = pointerType == INPUT_TYPE_TOUCH;
          var storeIndex = inArray(store, ev.pointerId, "pointerId");
          if (eventType & INPUT_START && (ev.button === 0 || isTouch)) {
            if (storeIndex < 0) {
              store.push(ev);
              storeIndex = store.length - 1;
            }
          } else if (eventType & (INPUT_END | INPUT_CANCEL)) {
            removePointer = true;
          }
          if (storeIndex < 0) {
            return;
          }
          store[storeIndex] = ev;
          this.callback(this.manager, eventType, {
            pointers: store,
            changedPointers: [ev],
            pointerType,
            srcEvent: ev
          });
          if (removePointer) {
            store.splice(storeIndex, 1);
          }
        }
      });
      var SINGLE_TOUCH_INPUT_MAP = {
        touchstart: INPUT_START,
        touchmove: INPUT_MOVE,
        touchend: INPUT_END,
        touchcancel: INPUT_CANCEL
      };
      var SINGLE_TOUCH_TARGET_EVENTS = "touchstart";
      var SINGLE_TOUCH_WINDOW_EVENTS = "touchstart touchmove touchend touchcancel";
      function SingleTouchInput() {
        this.evTarget = SINGLE_TOUCH_TARGET_EVENTS;
        this.evWin = SINGLE_TOUCH_WINDOW_EVENTS;
        this.started = false;
        Input.apply(this, arguments);
      }
      inherit(SingleTouchInput, Input, {
        handler: function TEhandler(ev) {
          var type = SINGLE_TOUCH_INPUT_MAP[ev.type];
          if (type === INPUT_START) {
            this.started = true;
          }
          if (!this.started) {
            return;
          }
          var touches = normalizeSingleTouches.call(this, ev, type);
          if (type & (INPUT_END | INPUT_CANCEL) && touches[0].length - touches[1].length === 0) {
            this.started = false;
          }
          this.callback(this.manager, type, {
            pointers: touches[0],
            changedPointers: touches[1],
            pointerType: INPUT_TYPE_TOUCH,
            srcEvent: ev
          });
        }
      });
      function normalizeSingleTouches(ev, type) {
        var all = toArray(ev.touches);
        var changed = toArray(ev.changedTouches);
        if (type & (INPUT_END | INPUT_CANCEL)) {
          all = uniqueArray(all.concat(changed), "identifier", true);
        }
        return [all, changed];
      }
      var TOUCH_INPUT_MAP = {
        touchstart: INPUT_START,
        touchmove: INPUT_MOVE,
        touchend: INPUT_END,
        touchcancel: INPUT_CANCEL
      };
      var TOUCH_TARGET_EVENTS = "touchstart touchmove touchend touchcancel";
      function TouchInput() {
        this.evTarget = TOUCH_TARGET_EVENTS;
        this.targetIds = {};
        Input.apply(this, arguments);
      }
      inherit(TouchInput, Input, {
        handler: function MTEhandler(ev) {
          var type = TOUCH_INPUT_MAP[ev.type];
          var touches = getTouches.call(this, ev, type);
          if (!touches) {
            return;
          }
          this.callback(this.manager, type, {
            pointers: touches[0],
            changedPointers: touches[1],
            pointerType: INPUT_TYPE_TOUCH,
            srcEvent: ev
          });
        }
      });
      function getTouches(ev, type) {
        var allTouches = toArray(ev.touches);
        var targetIds = this.targetIds;
        if (type & (INPUT_START | INPUT_MOVE) && allTouches.length === 1) {
          targetIds[allTouches[0].identifier] = true;
          return [allTouches, allTouches];
        }
        var i, targetTouches, changedTouches = toArray(ev.changedTouches), changedTargetTouches = [], target = this.target;
        targetTouches = allTouches.filter(function(touch) {
          return hasParent(touch.target, target);
        });
        if (type === INPUT_START) {
          i = 0;
          while (i < targetTouches.length) {
            targetIds[targetTouches[i].identifier] = true;
            i++;
          }
        }
        i = 0;
        while (i < changedTouches.length) {
          if (targetIds[changedTouches[i].identifier]) {
            changedTargetTouches.push(changedTouches[i]);
          }
          if (type & (INPUT_END | INPUT_CANCEL)) {
            delete targetIds[changedTouches[i].identifier];
          }
          i++;
        }
        if (!changedTargetTouches.length) {
          return;
        }
        return [
          // merge targetTouches with changedTargetTouches so it contains ALL touches, including 'end' and 'cancel'
          uniqueArray(targetTouches.concat(changedTargetTouches), "identifier", true),
          changedTargetTouches
        ];
      }
      var DEDUP_TIMEOUT = 2500;
      var DEDUP_DISTANCE = 25;
      function TouchMouseInput() {
        Input.apply(this, arguments);
        var handler = bindFn(this.handler, this);
        this.touch = new TouchInput(this.manager, handler);
        this.mouse = new MouseInput(this.manager, handler);
        this.primaryTouch = null;
        this.lastTouches = [];
      }
      inherit(TouchMouseInput, Input, {
        /**
         * handle mouse and touch events
         * @param {Hammer} manager
         * @param {String} inputEvent
         * @param {Object} inputData
         */
        handler: function TMEhandler(manager, inputEvent, inputData) {
          var isTouch = inputData.pointerType == INPUT_TYPE_TOUCH, isMouse = inputData.pointerType == INPUT_TYPE_MOUSE;
          if (isMouse && inputData.sourceCapabilities && inputData.sourceCapabilities.firesTouchEvents) {
            return;
          }
          if (isTouch) {
            recordTouches.call(this, inputEvent, inputData);
          } else if (isMouse && isSyntheticEvent.call(this, inputData)) {
            return;
          }
          this.callback(manager, inputEvent, inputData);
        },
        /**
         * remove the event listeners
         */
        destroy: function destroy() {
          this.touch.destroy();
          this.mouse.destroy();
        }
      });
      function recordTouches(eventType, eventData) {
        if (eventType & INPUT_START) {
          this.primaryTouch = eventData.changedPointers[0].identifier;
          setLastTouch.call(this, eventData);
        } else if (eventType & (INPUT_END | INPUT_CANCEL)) {
          setLastTouch.call(this, eventData);
        }
      }
      function setLastTouch(eventData) {
        var touch = eventData.changedPointers[0];
        if (touch.identifier === this.primaryTouch) {
          var lastTouch = { x: touch.clientX, y: touch.clientY };
          this.lastTouches.push(lastTouch);
          var lts = this.lastTouches;
          var removeLastTouch = function() {
            var i = lts.indexOf(lastTouch);
            if (i > -1) {
              lts.splice(i, 1);
            }
          };
          setTimeout(removeLastTouch, DEDUP_TIMEOUT);
        }
      }
      function isSyntheticEvent(eventData) {
        var x = eventData.srcEvent.clientX, y = eventData.srcEvent.clientY;
        for (var i = 0; i < this.lastTouches.length; i++) {
          var t = this.lastTouches[i];
          var dx = Math.abs(x - t.x), dy = Math.abs(y - t.y);
          if (dx <= DEDUP_DISTANCE && dy <= DEDUP_DISTANCE) {
            return true;
          }
        }
        return false;
      }
      var PREFIXED_TOUCH_ACTION = prefixed(TEST_ELEMENT.style, "touchAction");
      var NATIVE_TOUCH_ACTION = PREFIXED_TOUCH_ACTION !== undefined2;
      var TOUCH_ACTION_COMPUTE = "compute";
      var TOUCH_ACTION_AUTO = "auto";
      var TOUCH_ACTION_MANIPULATION = "manipulation";
      var TOUCH_ACTION_NONE = "none";
      var TOUCH_ACTION_PAN_X = "pan-x";
      var TOUCH_ACTION_PAN_Y = "pan-y";
      var TOUCH_ACTION_MAP = getTouchActionProps();
      function TouchAction(manager, value) {
        this.manager = manager;
        this.set(value);
      }
      TouchAction.prototype = {
        /**
         * set the touchAction value on the element or enable the polyfill
         * @param {String} value
         */
        set: function(value) {
          if (value == TOUCH_ACTION_COMPUTE) {
            value = this.compute();
          }
          if (NATIVE_TOUCH_ACTION && this.manager.element.style && TOUCH_ACTION_MAP[value]) {
            this.manager.element.style[PREFIXED_TOUCH_ACTION] = value;
          }
          this.actions = value.toLowerCase().trim();
        },
        /**
         * just re-set the touchAction value
         */
        update: function() {
          this.set(this.manager.options.touchAction);
        },
        /**
         * compute the value for the touchAction property based on the recognizer's settings
         * @returns {String} value
         */
        compute: function() {
          var actions = [];
          each2(this.manager.recognizers, function(recognizer) {
            if (boolOrFn(recognizer.options.enable, [recognizer])) {
              actions = actions.concat(recognizer.getTouchAction());
            }
          });
          return cleanTouchActions(actions.join(" "));
        },
        /**
         * this method is called on each input cycle and provides the preventing of the browser behavior
         * @param {Object} input
         */
        preventDefaults: function(input) {
          var srcEvent = input.srcEvent;
          var direction = input.offsetDirection;
          if (this.manager.session.prevented) {
            srcEvent.preventDefault();
            return;
          }
          var actions = this.actions;
          var hasNone = inStr(actions, TOUCH_ACTION_NONE) && !TOUCH_ACTION_MAP[TOUCH_ACTION_NONE];
          var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y) && !TOUCH_ACTION_MAP[TOUCH_ACTION_PAN_Y];
          var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X) && !TOUCH_ACTION_MAP[TOUCH_ACTION_PAN_X];
          if (hasNone) {
            var isTapPointer = input.pointers.length === 1;
            var isTapMovement = input.distance < 2;
            var isTapTouchTime = input.deltaTime < 250;
            if (isTapPointer && isTapMovement && isTapTouchTime) {
              return;
            }
          }
          if (hasPanX && hasPanY) {
            return;
          }
          if (hasNone || hasPanY && direction & DIRECTION_HORIZONTAL || hasPanX && direction & DIRECTION_VERTICAL) {
            return this.preventSrc(srcEvent);
          }
        },
        /**
         * call preventDefault to prevent the browser's default behavior (scrolling in most cases)
         * @param {Object} srcEvent
         */
        preventSrc: function(srcEvent) {
          this.manager.session.prevented = true;
          srcEvent.preventDefault();
        }
      };
      function cleanTouchActions(actions) {
        if (inStr(actions, TOUCH_ACTION_NONE)) {
          return TOUCH_ACTION_NONE;
        }
        var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X);
        var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y);
        if (hasPanX && hasPanY) {
          return TOUCH_ACTION_NONE;
        }
        if (hasPanX || hasPanY) {
          return hasPanX ? TOUCH_ACTION_PAN_X : TOUCH_ACTION_PAN_Y;
        }
        if (inStr(actions, TOUCH_ACTION_MANIPULATION)) {
          return TOUCH_ACTION_MANIPULATION;
        }
        return TOUCH_ACTION_AUTO;
      }
      function getTouchActionProps() {
        if (!NATIVE_TOUCH_ACTION) {
          return false;
        }
        var touchMap = {};
        var cssSupports = window2.CSS && window2.CSS.supports;
        ["auto", "manipulation", "pan-y", "pan-x", "pan-x pan-y", "none"].forEach(function(val) {
          touchMap[val] = cssSupports ? window2.CSS.supports("touch-action", val) : true;
        });
        return touchMap;
      }
      var STATE_POSSIBLE = 1;
      var STATE_BEGAN = 2;
      var STATE_CHANGED = 4;
      var STATE_ENDED = 8;
      var STATE_RECOGNIZED = STATE_ENDED;
      var STATE_CANCELLED = 16;
      var STATE_FAILED = 32;
      function Recognizer(options) {
        this.options = assign({}, this.defaults, options || {});
        this.id = uniqueId();
        this.manager = null;
        this.options.enable = ifUndefined(this.options.enable, true);
        this.state = STATE_POSSIBLE;
        this.simultaneous = {};
        this.requireFail = [];
      }
      Recognizer.prototype = {
        /**
         * @virtual
         * @type {Object}
         */
        defaults: {},
        /**
         * set options
         * @param {Object} options
         * @return {Recognizer}
         */
        set: function(options) {
          assign(this.options, options);
          this.manager && this.manager.touchAction.update();
          return this;
        },
        /**
         * recognize simultaneous with an other recognizer.
         * @param {Recognizer} otherRecognizer
         * @returns {Recognizer} this
         */
        recognizeWith: function(otherRecognizer) {
          if (invokeArrayArg(otherRecognizer, "recognizeWith", this)) {
            return this;
          }
          var simultaneous = this.simultaneous;
          otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
          if (!simultaneous[otherRecognizer.id]) {
            simultaneous[otherRecognizer.id] = otherRecognizer;
            otherRecognizer.recognizeWith(this);
          }
          return this;
        },
        /**
         * drop the simultaneous link. it doesnt remove the link on the other recognizer.
         * @param {Recognizer} otherRecognizer
         * @returns {Recognizer} this
         */
        dropRecognizeWith: function(otherRecognizer) {
          if (invokeArrayArg(otherRecognizer, "dropRecognizeWith", this)) {
            return this;
          }
          otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
          delete this.simultaneous[otherRecognizer.id];
          return this;
        },
        /**
         * recognizer can only run when an other is failing
         * @param {Recognizer} otherRecognizer
         * @returns {Recognizer} this
         */
        requireFailure: function(otherRecognizer) {
          if (invokeArrayArg(otherRecognizer, "requireFailure", this)) {
            return this;
          }
          var requireFail = this.requireFail;
          otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
          if (inArray(requireFail, otherRecognizer) === -1) {
            requireFail.push(otherRecognizer);
            otherRecognizer.requireFailure(this);
          }
          return this;
        },
        /**
         * drop the requireFailure link. it does not remove the link on the other recognizer.
         * @param {Recognizer} otherRecognizer
         * @returns {Recognizer} this
         */
        dropRequireFailure: function(otherRecognizer) {
          if (invokeArrayArg(otherRecognizer, "dropRequireFailure", this)) {
            return this;
          }
          otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
          var index2 = inArray(this.requireFail, otherRecognizer);
          if (index2 > -1) {
            this.requireFail.splice(index2, 1);
          }
          return this;
        },
        /**
         * has require failures boolean
         * @returns {boolean}
         */
        hasRequireFailures: function() {
          return this.requireFail.length > 0;
        },
        /**
         * if the recognizer can recognize simultaneous with an other recognizer
         * @param {Recognizer} otherRecognizer
         * @returns {Boolean}
         */
        canRecognizeWith: function(otherRecognizer) {
          return !!this.simultaneous[otherRecognizer.id];
        },
        /**
         * You should use `tryEmit` instead of `emit` directly to check
         * that all the needed recognizers has failed before emitting.
         * @param {Object} input
         */
        emit: function(input) {
          var self2 = this;
          var state = this.state;
          function emit(event) {
            self2.manager.emit(event, input);
          }
          if (state < STATE_ENDED) {
            emit(self2.options.event + stateStr(state));
          }
          emit(self2.options.event);
          if (input.additionalEvent) {
            emit(input.additionalEvent);
          }
          if (state >= STATE_ENDED) {
            emit(self2.options.event + stateStr(state));
          }
        },
        /**
         * Check that all the require failure recognizers has failed,
         * if true, it emits a gesture event,
         * otherwise, setup the state to FAILED.
         * @param {Object} input
         */
        tryEmit: function(input) {
          if (this.canEmit()) {
            return this.emit(input);
          }
          this.state = STATE_FAILED;
        },
        /**
         * can we emit?
         * @returns {boolean}
         */
        canEmit: function() {
          var i = 0;
          while (i < this.requireFail.length) {
            if (!(this.requireFail[i].state & (STATE_FAILED | STATE_POSSIBLE))) {
              return false;
            }
            i++;
          }
          return true;
        },
        /**
         * update the recognizer
         * @param {Object} inputData
         */
        recognize: function(inputData) {
          var inputDataClone = assign({}, inputData);
          if (!boolOrFn(this.options.enable, [this, inputDataClone])) {
            this.reset();
            this.state = STATE_FAILED;
            return;
          }
          if (this.state & (STATE_RECOGNIZED | STATE_CANCELLED | STATE_FAILED)) {
            this.state = STATE_POSSIBLE;
          }
          this.state = this.process(inputDataClone);
          if (this.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED | STATE_CANCELLED)) {
            this.tryEmit(inputDataClone);
          }
        },
        /**
         * return the state of the recognizer
         * the actual recognizing happens in this method
         * @virtual
         * @param {Object} inputData
         * @returns {Const} STATE
         */
        process: function(inputData) {
        },
        // jshint ignore:line
        /**
         * return the preferred touch-action
         * @virtual
         * @returns {Array}
         */
        getTouchAction: function() {
        },
        /**
         * called when the gesture isn't allowed to recognize
         * like when another is being recognized or it is disabled
         * @virtual
         */
        reset: function() {
        }
      };
      function stateStr(state) {
        if (state & STATE_CANCELLED) {
          return "cancel";
        } else if (state & STATE_ENDED) {
          return "end";
        } else if (state & STATE_CHANGED) {
          return "move";
        } else if (state & STATE_BEGAN) {
          return "start";
        }
        return "";
      }
      function directionStr(direction) {
        if (direction == DIRECTION_DOWN) {
          return "down";
        } else if (direction == DIRECTION_UP) {
          return "up";
        } else if (direction == DIRECTION_LEFT) {
          return "left";
        } else if (direction == DIRECTION_RIGHT) {
          return "right";
        }
        return "";
      }
      function getRecognizerByNameIfManager(otherRecognizer, recognizer) {
        var manager = recognizer.manager;
        if (manager) {
          return manager.get(otherRecognizer);
        }
        return otherRecognizer;
      }
      function AttrRecognizer() {
        Recognizer.apply(this, arguments);
      }
      inherit(AttrRecognizer, Recognizer, {
        /**
         * @namespace
         * @memberof AttrRecognizer
         */
        defaults: {
          /**
           * @type {Number}
           * @default 1
           */
          pointers: 1
        },
        /**
         * Used to check if it the recognizer receives valid input, like input.distance > 10.
         * @memberof AttrRecognizer
         * @param {Object} input
         * @returns {Boolean} recognized
         */
        attrTest: function(input) {
          var optionPointers = this.options.pointers;
          return optionPointers === 0 || input.pointers.length === optionPointers;
        },
        /**
         * Process the input and return the state for the recognizer
         * @memberof AttrRecognizer
         * @param {Object} input
         * @returns {*} State
         */
        process: function(input) {
          var state = this.state;
          var eventType = input.eventType;
          var isRecognized = state & (STATE_BEGAN | STATE_CHANGED);
          var isValid = this.attrTest(input);
          if (isRecognized && (eventType & INPUT_CANCEL || !isValid)) {
            return state | STATE_CANCELLED;
          } else if (isRecognized || isValid) {
            if (eventType & INPUT_END) {
              return state | STATE_ENDED;
            } else if (!(state & STATE_BEGAN)) {
              return STATE_BEGAN;
            }
            return state | STATE_CHANGED;
          }
          return STATE_FAILED;
        }
      });
      function PanRecognizer() {
        AttrRecognizer.apply(this, arguments);
        this.pX = null;
        this.pY = null;
      }
      inherit(PanRecognizer, AttrRecognizer, {
        /**
         * @namespace
         * @memberof PanRecognizer
         */
        defaults: {
          event: "pan",
          threshold: 10,
          pointers: 1,
          direction: DIRECTION_ALL
        },
        getTouchAction: function() {
          var direction = this.options.direction;
          var actions = [];
          if (direction & DIRECTION_HORIZONTAL) {
            actions.push(TOUCH_ACTION_PAN_Y);
          }
          if (direction & DIRECTION_VERTICAL) {
            actions.push(TOUCH_ACTION_PAN_X);
          }
          return actions;
        },
        directionTest: function(input) {
          var options = this.options;
          var hasMoved = true;
          var distance = input.distance;
          var direction = input.direction;
          var x = input.deltaX;
          var y = input.deltaY;
          if (!(direction & options.direction)) {
            if (options.direction & DIRECTION_HORIZONTAL) {
              direction = x === 0 ? DIRECTION_NONE : x < 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;
              hasMoved = x != this.pX;
              distance = Math.abs(input.deltaX);
            } else {
              direction = y === 0 ? DIRECTION_NONE : y < 0 ? DIRECTION_UP : DIRECTION_DOWN;
              hasMoved = y != this.pY;
              distance = Math.abs(input.deltaY);
            }
          }
          input.direction = direction;
          return hasMoved && distance > options.threshold && direction & options.direction;
        },
        attrTest: function(input) {
          return AttrRecognizer.prototype.attrTest.call(this, input) && (this.state & STATE_BEGAN || !(this.state & STATE_BEGAN) && this.directionTest(input));
        },
        emit: function(input) {
          this.pX = input.deltaX;
          this.pY = input.deltaY;
          var direction = directionStr(input.direction);
          if (direction) {
            input.additionalEvent = this.options.event + direction;
          }
          this._super.emit.call(this, input);
        }
      });
      function PinchRecognizer() {
        AttrRecognizer.apply(this, arguments);
      }
      inherit(PinchRecognizer, AttrRecognizer, {
        /**
         * @namespace
         * @memberof PinchRecognizer
         */
        defaults: {
          event: "pinch",
          threshold: 0,
          pointers: 2
        },
        getTouchAction: function() {
          return [TOUCH_ACTION_NONE];
        },
        attrTest: function(input) {
          return this._super.attrTest.call(this, input) && (Math.abs(input.scale - 1) > this.options.threshold || this.state & STATE_BEGAN);
        },
        emit: function(input) {
          if (input.scale !== 1) {
            var inOut = input.scale < 1 ? "in" : "out";
            input.additionalEvent = this.options.event + inOut;
          }
          this._super.emit.call(this, input);
        }
      });
      function PressRecognizer() {
        Recognizer.apply(this, arguments);
        this._timer = null;
        this._input = null;
      }
      inherit(PressRecognizer, Recognizer, {
        /**
         * @namespace
         * @memberof PressRecognizer
         */
        defaults: {
          event: "press",
          pointers: 1,
          time: 251,
          // minimal time of the pointer to be pressed
          threshold: 9
          // a minimal movement is ok, but keep it low
        },
        getTouchAction: function() {
          return [TOUCH_ACTION_AUTO];
        },
        process: function(input) {
          var options = this.options;
          var validPointers = input.pointers.length === options.pointers;
          var validMovement = input.distance < options.threshold;
          var validTime = input.deltaTime > options.time;
          this._input = input;
          if (!validMovement || !validPointers || input.eventType & (INPUT_END | INPUT_CANCEL) && !validTime) {
            this.reset();
          } else if (input.eventType & INPUT_START) {
            this.reset();
            this._timer = setTimeoutContext(function() {
              this.state = STATE_RECOGNIZED;
              this.tryEmit();
            }, options.time, this);
          } else if (input.eventType & INPUT_END) {
            return STATE_RECOGNIZED;
          }
          return STATE_FAILED;
        },
        reset: function() {
          clearTimeout(this._timer);
        },
        emit: function(input) {
          if (this.state !== STATE_RECOGNIZED) {
            return;
          }
          if (input && input.eventType & INPUT_END) {
            this.manager.emit(this.options.event + "up", input);
          } else {
            this._input.timeStamp = now();
            this.manager.emit(this.options.event, this._input);
          }
        }
      });
      function RotateRecognizer() {
        AttrRecognizer.apply(this, arguments);
      }
      inherit(RotateRecognizer, AttrRecognizer, {
        /**
         * @namespace
         * @memberof RotateRecognizer
         */
        defaults: {
          event: "rotate",
          threshold: 0,
          pointers: 2
        },
        getTouchAction: function() {
          return [TOUCH_ACTION_NONE];
        },
        attrTest: function(input) {
          return this._super.attrTest.call(this, input) && (Math.abs(input.rotation) > this.options.threshold || this.state & STATE_BEGAN);
        }
      });
      function SwipeRecognizer() {
        AttrRecognizer.apply(this, arguments);
      }
      inherit(SwipeRecognizer, AttrRecognizer, {
        /**
         * @namespace
         * @memberof SwipeRecognizer
         */
        defaults: {
          event: "swipe",
          threshold: 10,
          velocity: 0.3,
          direction: DIRECTION_HORIZONTAL | DIRECTION_VERTICAL,
          pointers: 1
        },
        getTouchAction: function() {
          return PanRecognizer.prototype.getTouchAction.call(this);
        },
        attrTest: function(input) {
          var direction = this.options.direction;
          var velocity;
          if (direction & (DIRECTION_HORIZONTAL | DIRECTION_VERTICAL)) {
            velocity = input.overallVelocity;
          } else if (direction & DIRECTION_HORIZONTAL) {
            velocity = input.overallVelocityX;
          } else if (direction & DIRECTION_VERTICAL) {
            velocity = input.overallVelocityY;
          }
          return this._super.attrTest.call(this, input) && direction & input.offsetDirection && input.distance > this.options.threshold && input.maxPointers == this.options.pointers && abs(velocity) > this.options.velocity && input.eventType & INPUT_END;
        },
        emit: function(input) {
          var direction = directionStr(input.offsetDirection);
          if (direction) {
            this.manager.emit(this.options.event + direction, input);
          }
          this.manager.emit(this.options.event, input);
        }
      });
      function TapRecognizer() {
        Recognizer.apply(this, arguments);
        this.pTime = false;
        this.pCenter = false;
        this._timer = null;
        this._input = null;
        this.count = 0;
      }
      inherit(TapRecognizer, Recognizer, {
        /**
         * @namespace
         * @memberof PinchRecognizer
         */
        defaults: {
          event: "tap",
          pointers: 1,
          taps: 1,
          interval: 300,
          // max time between the multi-tap taps
          time: 250,
          // max time of the pointer to be down (like finger on the screen)
          threshold: 9,
          // a minimal movement is ok, but keep it low
          posThreshold: 10
          // a multi-tap can be a bit off the initial position
        },
        getTouchAction: function() {
          return [TOUCH_ACTION_MANIPULATION];
        },
        process: function(input) {
          var options = this.options;
          var validPointers = input.pointers.length === options.pointers;
          var validMovement = input.distance < options.threshold;
          var validTouchTime = input.deltaTime < options.time;
          this.reset();
          if (input.eventType & INPUT_START && this.count === 0) {
            return this.failTimeout();
          }
          if (validMovement && validTouchTime && validPointers) {
            if (input.eventType != INPUT_END) {
              return this.failTimeout();
            }
            var validInterval = this.pTime ? input.timeStamp - this.pTime < options.interval : true;
            var validMultiTap = !this.pCenter || getDistance(this.pCenter, input.center) < options.posThreshold;
            this.pTime = input.timeStamp;
            this.pCenter = input.center;
            if (!validMultiTap || !validInterval) {
              this.count = 1;
            } else {
              this.count += 1;
            }
            this._input = input;
            var tapCount = this.count % options.taps;
            if (tapCount === 0) {
              if (!this.hasRequireFailures()) {
                return STATE_RECOGNIZED;
              } else {
                this._timer = setTimeoutContext(function() {
                  this.state = STATE_RECOGNIZED;
                  this.tryEmit();
                }, options.interval, this);
                return STATE_BEGAN;
              }
            }
          }
          return STATE_FAILED;
        },
        failTimeout: function() {
          this._timer = setTimeoutContext(function() {
            this.state = STATE_FAILED;
          }, this.options.interval, this);
          return STATE_FAILED;
        },
        reset: function() {
          clearTimeout(this._timer);
        },
        emit: function() {
          if (this.state == STATE_RECOGNIZED) {
            this._input.tapCount = this.count;
            this.manager.emit(this.options.event, this._input);
          }
        }
      });
      function Hammer2(element, options) {
        options = options || {};
        options.recognizers = ifUndefined(options.recognizers, Hammer2.defaults.preset);
        return new Manager(element, options);
      }
      Hammer2.VERSION = "2.0.7";
      Hammer2.defaults = {
        /**
         * set if DOM events are being triggered.
         * But this is slower and unused by simple implementations, so disabled by default.
         * @type {Boolean}
         * @default false
         */
        domEvents: false,
        /**
         * The value for the touchAction property/fallback.
         * When set to `compute` it will magically set the correct value based on the added recognizers.
         * @type {String}
         * @default compute
         */
        touchAction: TOUCH_ACTION_COMPUTE,
        /**
         * @type {Boolean}
         * @default true
         */
        enable: true,
        /**
         * EXPERIMENTAL FEATURE -- can be removed/changed
         * Change the parent input target element.
         * If Null, then it is being set the to main element.
         * @type {Null|EventTarget}
         * @default null
         */
        inputTarget: null,
        /**
         * force an input class
         * @type {Null|Function}
         * @default null
         */
        inputClass: null,
        /**
         * Default recognizer setup when calling `Hammer()`
         * When creating a new Manager these will be skipped.
         * @type {Array}
         */
        preset: [
          // RecognizerClass, options, [recognizeWith, ...], [requireFailure, ...]
          [RotateRecognizer, { enable: false }],
          [PinchRecognizer, { enable: false }, ["rotate"]],
          [SwipeRecognizer, { direction: DIRECTION_HORIZONTAL }],
          [PanRecognizer, { direction: DIRECTION_HORIZONTAL }, ["swipe"]],
          [TapRecognizer],
          [TapRecognizer, { event: "doubletap", taps: 2 }, ["tap"]],
          [PressRecognizer]
        ],
        /**
         * Some CSS properties can be used to improve the working of Hammer.
         * Add them to this method and they will be set when creating a new Manager.
         * @namespace
         */
        cssProps: {
          /**
           * Disables text selection to improve the dragging gesture. Mainly for desktop browsers.
           * @type {String}
           * @default 'none'
           */
          userSelect: "none",
          /**
           * Disable the Windows Phone grippers when pressing an element.
           * @type {String}
           * @default 'none'
           */
          touchSelect: "none",
          /**
           * Disables the default callout shown when you touch and hold a touch target.
           * On iOS, when you touch and hold a touch target such as a link, Safari displays
           * a callout containing information about the link. This property allows you to disable that callout.
           * @type {String}
           * @default 'none'
           */
          touchCallout: "none",
          /**
           * Specifies whether zooming is enabled. Used by IE10>
           * @type {String}
           * @default 'none'
           */
          contentZooming: "none",
          /**
           * Specifies that an entire element should be draggable instead of its contents. Mainly for desktop browsers.
           * @type {String}
           * @default 'none'
           */
          userDrag: "none",
          /**
           * Overrides the highlight color shown when the user taps a link or a JavaScript
           * clickable element in iOS. This property obeys the alpha value, if specified.
           * @type {String}
           * @default 'rgba(0,0,0,0)'
           */
          tapHighlightColor: "rgba(0,0,0,0)"
        }
      };
      var STOP = 1;
      var FORCED_STOP = 2;
      function Manager(element, options) {
        this.options = assign({}, Hammer2.defaults, options || {});
        this.options.inputTarget = this.options.inputTarget || element;
        this.handlers = {};
        this.session = {};
        this.recognizers = [];
        this.oldCssProps = {};
        this.element = element;
        this.input = createInputInstance(this);
        this.touchAction = new TouchAction(this, this.options.touchAction);
        toggleCssProps(this, true);
        each2(this.options.recognizers, function(item) {
          var recognizer = this.add(new item[0](item[1]));
          item[2] && recognizer.recognizeWith(item[2]);
          item[3] && recognizer.requireFailure(item[3]);
        }, this);
      }
      Manager.prototype = {
        /**
         * set options
         * @param {Object} options
         * @returns {Manager}
         */
        set: function(options) {
          assign(this.options, options);
          if (options.touchAction) {
            this.touchAction.update();
          }
          if (options.inputTarget) {
            this.input.destroy();
            this.input.target = options.inputTarget;
            this.input.init();
          }
          return this;
        },
        /**
         * stop recognizing for this session.
         * This session will be discarded, when a new [input]start event is fired.
         * When forced, the recognizer cycle is stopped immediately.
         * @param {Boolean} [force]
         */
        stop: function(force) {
          this.session.stopped = force ? FORCED_STOP : STOP;
        },
        /**
         * run the recognizers!
         * called by the inputHandler function on every movement of the pointers (touches)
         * it walks through all the recognizers and tries to detect the gesture that is being made
         * @param {Object} inputData
         */
        recognize: function(inputData) {
          var session = this.session;
          if (session.stopped) {
            return;
          }
          this.touchAction.preventDefaults(inputData);
          var recognizer;
          var recognizers = this.recognizers;
          var curRecognizer = session.curRecognizer;
          if (!curRecognizer || curRecognizer && curRecognizer.state & STATE_RECOGNIZED) {
            curRecognizer = session.curRecognizer = null;
          }
          var i = 0;
          while (i < recognizers.length) {
            recognizer = recognizers[i];
            if (session.stopped !== FORCED_STOP && // 1
            (!curRecognizer || recognizer == curRecognizer || // 2
            recognizer.canRecognizeWith(curRecognizer))) {
              recognizer.recognize(inputData);
            } else {
              recognizer.reset();
            }
            if (!curRecognizer && recognizer.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED)) {
              curRecognizer = session.curRecognizer = recognizer;
            }
            i++;
          }
        },
        /**
         * get a recognizer by its event name.
         * @param {Recognizer|String} recognizer
         * @returns {Recognizer|Null}
         */
        get: function(recognizer) {
          if (recognizer instanceof Recognizer) {
            return recognizer;
          }
          var recognizers = this.recognizers;
          for (var i = 0; i < recognizers.length; i++) {
            if (recognizers[i].options.event == recognizer) {
              return recognizers[i];
            }
          }
          return null;
        },
        /**
         * add a recognizer to the manager
         * existing recognizers with the same event name will be removed
         * @param {Recognizer} recognizer
         * @returns {Recognizer|Manager}
         */
        add: function(recognizer) {
          if (invokeArrayArg(recognizer, "add", this)) {
            return this;
          }
          var existing = this.get(recognizer.options.event);
          if (existing) {
            this.remove(existing);
          }
          this.recognizers.push(recognizer);
          recognizer.manager = this;
          this.touchAction.update();
          return recognizer;
        },
        /**
         * remove a recognizer by name or instance
         * @param {Recognizer|String} recognizer
         * @returns {Manager}
         */
        remove: function(recognizer) {
          if (invokeArrayArg(recognizer, "remove", this)) {
            return this;
          }
          recognizer = this.get(recognizer);
          if (recognizer) {
            var recognizers = this.recognizers;
            var index2 = inArray(recognizers, recognizer);
            if (index2 !== -1) {
              recognizers.splice(index2, 1);
              this.touchAction.update();
            }
          }
          return this;
        },
        /**
         * bind event
         * @param {String} events
         * @param {Function} handler
         * @returns {EventEmitter} this
         */
        on: function(events, handler) {
          if (events === undefined2) {
            return;
          }
          if (handler === undefined2) {
            return;
          }
          var handlers = this.handlers;
          each2(splitStr(events), function(event) {
            handlers[event] = handlers[event] || [];
            handlers[event].push(handler);
          });
          return this;
        },
        /**
         * unbind event, leave emit blank to remove all handlers
         * @param {String} events
         * @param {Function} [handler]
         * @returns {EventEmitter} this
         */
        off: function(events, handler) {
          if (events === undefined2) {
            return;
          }
          var handlers = this.handlers;
          each2(splitStr(events), function(event) {
            if (!handler) {
              delete handlers[event];
            } else {
              handlers[event] && handlers[event].splice(inArray(handlers[event], handler), 1);
            }
          });
          return this;
        },
        /**
         * emit event to the listeners
         * @param {String} event
         * @param {Object} data
         */
        emit: function(event, data) {
          if (this.options.domEvents) {
            triggerDomEvent(event, data);
          }
          var handlers = this.handlers[event] && this.handlers[event].slice();
          if (!handlers || !handlers.length) {
            return;
          }
          data.type = event;
          data.preventDefault = function() {
            data.srcEvent.preventDefault();
          };
          var i = 0;
          while (i < handlers.length) {
            handlers[i](data);
            i++;
          }
        },
        /**
         * destroy the manager and unbinds all events
         * it doesn't unbind dom events, that is the user own responsibility
         */
        destroy: function() {
          this.element && toggleCssProps(this, false);
          this.handlers = {};
          this.session = {};
          this.input.destroy();
          this.element = null;
        }
      };
      function toggleCssProps(manager, add) {
        var element = manager.element;
        if (!element.style) {
          return;
        }
        var prop;
        each2(manager.options.cssProps, function(value, name) {
          prop = prefixed(element.style, name);
          if (add) {
            manager.oldCssProps[prop] = element.style[prop];
            element.style[prop] = value;
          } else {
            element.style[prop] = manager.oldCssProps[prop] || "";
          }
        });
        if (!add) {
          manager.oldCssProps = {};
        }
      }
      function triggerDomEvent(event, data) {
        var gestureEvent = document2.createEvent("Event");
        gestureEvent.initEvent(event, true, true);
        gestureEvent.gesture = data;
        data.target.dispatchEvent(gestureEvent);
      }
      assign(Hammer2, {
        INPUT_START,
        INPUT_MOVE,
        INPUT_END,
        INPUT_CANCEL,
        STATE_POSSIBLE,
        STATE_BEGAN,
        STATE_CHANGED,
        STATE_ENDED,
        STATE_RECOGNIZED,
        STATE_CANCELLED,
        STATE_FAILED,
        DIRECTION_NONE,
        DIRECTION_LEFT,
        DIRECTION_RIGHT,
        DIRECTION_UP,
        DIRECTION_DOWN,
        DIRECTION_HORIZONTAL,
        DIRECTION_VERTICAL,
        DIRECTION_ALL,
        Manager,
        Input,
        TouchAction,
        TouchInput,
        MouseInput,
        PointerEventInput,
        TouchMouseInput,
        SingleTouchInput,
        Recognizer,
        AttrRecognizer,
        Tap: TapRecognizer,
        Pan: PanRecognizer,
        Swipe: SwipeRecognizer,
        Pinch: PinchRecognizer,
        Rotate: RotateRecognizer,
        Press: PressRecognizer,
        on: addEventListeners,
        off: removeEventListeners,
        each: each2,
        merge: merge2,
        extend,
        assign,
        inherit,
        bindFn,
        prefixed
      });
      var freeGlobal = typeof window2 !== "undefined" ? window2 : typeof self !== "undefined" ? self : {};
      freeGlobal.Hammer = Hammer2;
      if (typeof define === "function" && define.amd) {
        define(function() {
          return Hammer2;
        });
      } else if (typeof module2 != "undefined" && module2.exports) {
        module2.exports = Hammer2;
      } else {
        window2[exportName] = Hammer2;
      }
    })(window, document, "Hammer");
  }
});

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => CSVTableConverter
});
module.exports = __toCommonJS(main_exports);
var import_obsidian3 = require("obsidian");

// src/chartcolor.ts
var themeColors = {
  orange: {
    backgroundColor: [
      "rgba(233, 113, 50, 0.6)",
      "rgba(255, 159, 64, 0.6)",
      "rgba(255, 94, 77, 0.6)",
      "rgba(255, 190, 105, 0.6)"
    ],
    // Array of colors for pie chart segments
    borderColor: [
      "rgba(233, 113, 50, 1)",
      "rgba(255, 159, 64, 1)",
      "rgba(255, 94, 77, 1)",
      "rgba(255, 190, 105, 1)"
    ]
    // Array of colors for pie chart borders
  },
  blue: {
    backgroundColor: [
      "rgba(51, 102, 153, 0.6)",
      "rgba(72, 133, 237, 0.6)",
      "rgba(93, 165, 218, 0.6)",
      "rgba(128, 194, 255, 0.6)"
    ],
    borderColor: [
      "rgba(51, 102, 153, 1)",
      "rgba(72, 133, 237, 1)",
      "rgba(93, 165, 218, 1)",
      "rgba(128, 194, 255, 1)"
    ]
  },
  green: {
    backgroundColor: [
      "rgba(44, 159, 69, 0.6)",
      "rgba(75, 181, 67, 0.6)",
      "rgba(100, 193, 118, 0.6)",
      "rgba(145, 232, 66, 0.6)"
    ],
    borderColor: [
      "rgba(44, 159, 69, 1)",
      "rgba(75, 181, 67, 1)",
      "rgba(100, 193, 118, 1)",
      "rgba(145, 232, 66, 1)"
    ]
  },
  purple: {
    backgroundColor: [
      "rgba(108, 52, 131, 0.6)",
      "rgba(142, 68, 173, 0.6)",
      "rgba(165, 105, 189, 0.6)",
      "rgba(187, 143, 206, 0.6)"
    ],
    borderColor: [
      "rgba(108, 52, 131, 1)",
      "rgba(142, 68, 173, 1)",
      "rgba(165, 105, 189, 1)",
      "rgba(187, 143, 206, 1)"
    ]
  },
  red: {
    backgroundColor: [
      "rgba(192, 57, 43, 0.6)",
      "rgba(231, 76, 60, 0.6)",
      "rgba(235, 89, 72, 0.6)",
      "rgba(241, 98, 74, 0.6)"
    ],
    borderColor: [
      "rgba(192, 57, 43, 1)",
      "rgba(231, 76, 60, 1)",
      "rgba(235, 89, 72, 1)",
      "rgba(241, 98, 74, 1)"
    ]
  },
  gray: {
    backgroundColor: [
      "rgba(127, 140, 141, 0.6)",
      "rgba(149, 165, 166, 0.6)",
      "rgba(189, 195, 199, 0.6)",
      "rgba(204, 214, 217, 0.6)"
    ],
    borderColor: [
      "rgba(127, 140, 141, 1)",
      "rgba(149, 165, 166, 1)",
      "rgba(189, 195, 199, 1)",
      "rgba(204, 214, 217, 1)"
    ]
  },
  yellow: {
    backgroundColor: [
      "rgba(241, 196, 15, 0.6)",
      "rgba(247, 220, 111, 0.6)",
      "rgba(248, 231, 28, 0.6)",
      "rgba(253, 255, 130, 0.6)"
    ],
    borderColor: [
      "rgba(241, 196, 15, 1)",
      "rgba(247, 220, 111, 1)",
      "rgba(248, 231, 28, 1)",
      "rgba(253, 255, 130, 1)"
    ]
  },
  pink: {
    backgroundColor: [
      "rgba(233, 30, 99, 0.6)",
      "rgba(236, 72, 130, 0.6)",
      "rgba(241, 108, 150, 0.6)",
      "rgba(245, 136, 162, 0.6)"
    ],
    borderColor: [
      "rgba(233, 30, 99, 1)",
      "rgba(236, 72, 130, 1)",
      "rgba(241, 108, 150, 1)",
      "rgba(245, 136, 162, 1)"
    ]
  }
};

// src/settings.ts
var import_obsidian = require("obsidian");
var CSVTableConverterSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin2) {
    super(app, plugin2);
    this.plugin = plugin2;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    new import_obsidian.Setting(containerEl).setName("Default Delimiter").setDesc("Set the default delimiter for CSV").addText((text) => text.setPlaceholder("Enter delimiter, e.g. ,").setValue(this.plugin.settings.mySetting).onChange(async (value) => {
      this.plugin.settings.mySetting = value;
      await this.plugin.saveSettings();
    }));
  }
};

// src/chart.ts
var import_obsidian2 = require("obsidian");

// node_modules/@kurkle/color/dist/color.esm.js
function round(v) {
  return v + 0.5 | 0;
}
var lim = (v, l, h) => Math.max(Math.min(v, h), l);
function p2b(v) {
  return lim(round(v * 2.55), 0, 255);
}
function n2b(v) {
  return lim(round(v * 255), 0, 255);
}
function b2n(v) {
  return lim(round(v / 2.55) / 100, 0, 1);
}
function n2p(v) {
  return lim(round(v * 100), 0, 100);
}
var map$1 = { 0: 0, 1: 1, 2: 2, 3: 3, 4: 4, 5: 5, 6: 6, 7: 7, 8: 8, 9: 9, A: 10, B: 11, C: 12, D: 13, E: 14, F: 15, a: 10, b: 11, c: 12, d: 13, e: 14, f: 15 };
var hex = [..."0123456789ABCDEF"];
var h1 = (b) => hex[b & 15];
var h2 = (b) => hex[(b & 240) >> 4] + hex[b & 15];
var eq = (b) => (b & 240) >> 4 === (b & 15);
var isShort = (v) => eq(v.r) && eq(v.g) && eq(v.b) && eq(v.a);
function hexParse(str) {
  var len = str.length;
  var ret;
  if (str[0] === "#") {
    if (len === 4 || len === 5) {
      ret = {
        r: 255 & map$1[str[1]] * 17,
        g: 255 & map$1[str[2]] * 17,
        b: 255 & map$1[str[3]] * 17,
        a: len === 5 ? map$1[str[4]] * 17 : 255
      };
    } else if (len === 7 || len === 9) {
      ret = {
        r: map$1[str[1]] << 4 | map$1[str[2]],
        g: map$1[str[3]] << 4 | map$1[str[4]],
        b: map$1[str[5]] << 4 | map$1[str[6]],
        a: len === 9 ? map$1[str[7]] << 4 | map$1[str[8]] : 255
      };
    }
  }
  return ret;
}
var alpha = (a, f) => a < 255 ? f(a) : "";
function hexString(v) {
  var f = isShort(v) ? h1 : h2;
  return v ? "#" + f(v.r) + f(v.g) + f(v.b) + alpha(v.a, f) : void 0;
}
var HUE_RE = /^(hsla?|hwb|hsv)\(\s*([-+.e\d]+)(?:deg)?[\s,]+([-+.e\d]+)%[\s,]+([-+.e\d]+)%(?:[\s,]+([-+.e\d]+)(%)?)?\s*\)$/;
function hsl2rgbn(h, s, l) {
  const a = s * Math.min(l, 1 - l);
  const f = (n, k = (n + h / 30) % 12) => l - a * Math.max(Math.min(k - 3, 9 - k, 1), -1);
  return [f(0), f(8), f(4)];
}
function hsv2rgbn(h, s, v) {
  const f = (n, k = (n + h / 60) % 6) => v - v * s * Math.max(Math.min(k, 4 - k, 1), 0);
  return [f(5), f(3), f(1)];
}
function hwb2rgbn(h, w, b) {
  const rgb = hsl2rgbn(h, 1, 0.5);
  let i;
  if (w + b > 1) {
    i = 1 / (w + b);
    w *= i;
    b *= i;
  }
  for (i = 0; i < 3; i++) {
    rgb[i] *= 1 - w - b;
    rgb[i] += w;
  }
  return rgb;
}
function hueValue(r, g, b, d, max) {
  if (r === max) {
    return (g - b) / d + (g < b ? 6 : 0);
  }
  if (g === max) {
    return (b - r) / d + 2;
  }
  return (r - g) / d + 4;
}
function rgb2hsl(v) {
  const range = 255;
  const r = v.r / range;
  const g = v.g / range;
  const b = v.b / range;
  const max = Math.max(r, g, b);
  const min = Math.min(r, g, b);
  const l = (max + min) / 2;
  let h, s, d;
  if (max !== min) {
    d = max - min;
    s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
    h = hueValue(r, g, b, d, max);
    h = h * 60 + 0.5;
  }
  return [h | 0, s || 0, l];
}
function calln(f, a, b, c) {
  return (Array.isArray(a) ? f(a[0], a[1], a[2]) : f(a, b, c)).map(n2b);
}
function hsl2rgb(h, s, l) {
  return calln(hsl2rgbn, h, s, l);
}
function hwb2rgb(h, w, b) {
  return calln(hwb2rgbn, h, w, b);
}
function hsv2rgb(h, s, v) {
  return calln(hsv2rgbn, h, s, v);
}
function hue(h) {
  return (h % 360 + 360) % 360;
}
function hueParse(str) {
  const m = HUE_RE.exec(str);
  let a = 255;
  let v;
  if (!m) {
    return;
  }
  if (m[5] !== v) {
    a = m[6] ? p2b(+m[5]) : n2b(+m[5]);
  }
  const h = hue(+m[2]);
  const p1 = +m[3] / 100;
  const p2 = +m[4] / 100;
  if (m[1] === "hwb") {
    v = hwb2rgb(h, p1, p2);
  } else if (m[1] === "hsv") {
    v = hsv2rgb(h, p1, p2);
  } else {
    v = hsl2rgb(h, p1, p2);
  }
  return {
    r: v[0],
    g: v[1],
    b: v[2],
    a
  };
}
function rotate(v, deg) {
  var h = rgb2hsl(v);
  h[0] = hue(h[0] + deg);
  h = hsl2rgb(h);
  v.r = h[0];
  v.g = h[1];
  v.b = h[2];
}
function hslString(v) {
  if (!v) {
    return;
  }
  const a = rgb2hsl(v);
  const h = a[0];
  const s = n2p(a[1]);
  const l = n2p(a[2]);
  return v.a < 255 ? `hsla(${h}, ${s}%, ${l}%, ${b2n(v.a)})` : `hsl(${h}, ${s}%, ${l}%)`;
}
var map = {
  x: "dark",
  Z: "light",
  Y: "re",
  X: "blu",
  W: "gr",
  V: "medium",
  U: "slate",
  A: "ee",
  T: "ol",
  S: "or",
  B: "ra",
  C: "lateg",
  D: "ights",
  R: "in",
  Q: "turquois",
  E: "hi",
  P: "ro",
  O: "al",
  N: "le",
  M: "de",
  L: "yello",
  F: "en",
  K: "ch",
  G: "arks",
  H: "ea",
  I: "ightg",
  J: "wh"
};
var names$1 = {
  OiceXe: "f0f8ff",
  antiquewEte: "faebd7",
  aqua: "ffff",
  aquamarRe: "7fffd4",
  azuY: "f0ffff",
  beige: "f5f5dc",
  bisque: "ffe4c4",
  black: "0",
  blanKedOmond: "ffebcd",
  Xe: "ff",
  XeviTet: "8a2be2",
  bPwn: "a52a2a",
  burlywood: "deb887",
  caMtXe: "5f9ea0",
  KartYuse: "7fff00",
  KocTate: "d2691e",
  cSO: "ff7f50",
  cSnflowerXe: "6495ed",
  cSnsilk: "fff8dc",
  crimson: "dc143c",
  cyan: "ffff",
  xXe: "8b",
  xcyan: "8b8b",
  xgTMnPd: "b8860b",
  xWay: "a9a9a9",
  xgYF: "6400",
  xgYy: "a9a9a9",
  xkhaki: "bdb76b",
  xmagFta: "8b008b",
  xTivegYF: "556b2f",
  xSange: "ff8c00",
  xScEd: "9932cc",
  xYd: "8b0000",
  xsOmon: "e9967a",
  xsHgYF: "8fbc8f",
  xUXe: "483d8b",
  xUWay: "2f4f4f",
  xUgYy: "2f4f4f",
  xQe: "ced1",
  xviTet: "9400d3",
  dAppRk: "ff1493",
  dApskyXe: "bfff",
  dimWay: "696969",
  dimgYy: "696969",
  dodgerXe: "1e90ff",
  fiYbrick: "b22222",
  flSOwEte: "fffaf0",
  foYstWAn: "228b22",
  fuKsia: "ff00ff",
  gaRsbSo: "dcdcdc",
  ghostwEte: "f8f8ff",
  gTd: "ffd700",
  gTMnPd: "daa520",
  Way: "808080",
  gYF: "8000",
  gYFLw: "adff2f",
  gYy: "808080",
  honeyMw: "f0fff0",
  hotpRk: "ff69b4",
  RdianYd: "cd5c5c",
  Rdigo: "4b0082",
  ivSy: "fffff0",
  khaki: "f0e68c",
  lavFMr: "e6e6fa",
  lavFMrXsh: "fff0f5",
  lawngYF: "7cfc00",
  NmoncEffon: "fffacd",
  ZXe: "add8e6",
  ZcSO: "f08080",
  Zcyan: "e0ffff",
  ZgTMnPdLw: "fafad2",
  ZWay: "d3d3d3",
  ZgYF: "90ee90",
  ZgYy: "d3d3d3",
  ZpRk: "ffb6c1",
  ZsOmon: "ffa07a",
  ZsHgYF: "20b2aa",
  ZskyXe: "87cefa",
  ZUWay: "778899",
  ZUgYy: "778899",
  ZstAlXe: "b0c4de",
  ZLw: "ffffe0",
  lime: "ff00",
  limegYF: "32cd32",
  lRF: "faf0e6",
  magFta: "ff00ff",
  maPon: "800000",
  VaquamarRe: "66cdaa",
  VXe: "cd",
  VScEd: "ba55d3",
  VpurpN: "9370db",
  VsHgYF: "3cb371",
  VUXe: "7b68ee",
  VsprRggYF: "fa9a",
  VQe: "48d1cc",
  VviTetYd: "c71585",
  midnightXe: "191970",
  mRtcYam: "f5fffa",
  mistyPse: "ffe4e1",
  moccasR: "ffe4b5",
  navajowEte: "ffdead",
  navy: "80",
  Tdlace: "fdf5e6",
  Tive: "808000",
  TivedBb: "6b8e23",
  Sange: "ffa500",
  SangeYd: "ff4500",
  ScEd: "da70d6",
  pOegTMnPd: "eee8aa",
  pOegYF: "98fb98",
  pOeQe: "afeeee",
  pOeviTetYd: "db7093",
  papayawEp: "ffefd5",
  pHKpuff: "ffdab9",
  peru: "cd853f",
  pRk: "ffc0cb",
  plum: "dda0dd",
  powMrXe: "b0e0e6",
  purpN: "800080",
  YbeccapurpN: "663399",
  Yd: "ff0000",
  Psybrown: "bc8f8f",
  PyOXe: "4169e1",
  saddNbPwn: "8b4513",
  sOmon: "fa8072",
  sandybPwn: "f4a460",
  sHgYF: "2e8b57",
  sHshell: "fff5ee",
  siFna: "a0522d",
  silver: "c0c0c0",
  skyXe: "87ceeb",
  UXe: "6a5acd",
  UWay: "708090",
  UgYy: "708090",
  snow: "fffafa",
  sprRggYF: "ff7f",
  stAlXe: "4682b4",
  tan: "d2b48c",
  teO: "8080",
  tEstN: "d8bfd8",
  tomato: "ff6347",
  Qe: "40e0d0",
  viTet: "ee82ee",
  JHt: "f5deb3",
  wEte: "ffffff",
  wEtesmoke: "f5f5f5",
  Lw: "ffff00",
  LwgYF: "9acd32"
};
function unpack() {
  const unpacked = {};
  const keys = Object.keys(names$1);
  const tkeys = Object.keys(map);
  let i, j, k, ok, nk;
  for (i = 0; i < keys.length; i++) {
    ok = nk = keys[i];
    for (j = 0; j < tkeys.length; j++) {
      k = tkeys[j];
      nk = nk.replace(k, map[k]);
    }
    k = parseInt(names$1[ok], 16);
    unpacked[nk] = [k >> 16 & 255, k >> 8 & 255, k & 255];
  }
  return unpacked;
}
var names;
function nameParse(str) {
  if (!names) {
    names = unpack();
    names.transparent = [0, 0, 0, 0];
  }
  const a = names[str.toLowerCase()];
  return a && {
    r: a[0],
    g: a[1],
    b: a[2],
    a: a.length === 4 ? a[3] : 255
  };
}
var RGB_RE = /^rgba?\(\s*([-+.\d]+)(%)?[\s,]+([-+.e\d]+)(%)?[\s,]+([-+.e\d]+)(%)?(?:[\s,/]+([-+.e\d]+)(%)?)?\s*\)$/;
function rgbParse(str) {
  const m = RGB_RE.exec(str);
  let a = 255;
  let r, g, b;
  if (!m) {
    return;
  }
  if (m[7] !== r) {
    const v = +m[7];
    a = m[8] ? p2b(v) : lim(v * 255, 0, 255);
  }
  r = +m[1];
  g = +m[3];
  b = +m[5];
  r = 255 & (m[2] ? p2b(r) : lim(r, 0, 255));
  g = 255 & (m[4] ? p2b(g) : lim(g, 0, 255));
  b = 255 & (m[6] ? p2b(b) : lim(b, 0, 255));
  return {
    r,
    g,
    b,
    a
  };
}
function rgbString(v) {
  return v && (v.a < 255 ? `rgba(${v.r}, ${v.g}, ${v.b}, ${b2n(v.a)})` : `rgb(${v.r}, ${v.g}, ${v.b})`);
}
var to = (v) => v <= 31308e-7 ? v * 12.92 : Math.pow(v, 1 / 2.4) * 1.055 - 0.055;
var from = (v) => v <= 0.04045 ? v / 12.92 : Math.pow((v + 0.055) / 1.055, 2.4);
function interpolate(rgb1, rgb2, t) {
  const r = from(b2n(rgb1.r));
  const g = from(b2n(rgb1.g));
  const b = from(b2n(rgb1.b));
  return {
    r: n2b(to(r + t * (from(b2n(rgb2.r)) - r))),
    g: n2b(to(g + t * (from(b2n(rgb2.g)) - g))),
    b: n2b(to(b + t * (from(b2n(rgb2.b)) - b))),
    a: rgb1.a + t * (rgb2.a - rgb1.a)
  };
}
function modHSL(v, i, ratio) {
  if (v) {
    let tmp = rgb2hsl(v);
    tmp[i] = Math.max(0, Math.min(tmp[i] + tmp[i] * ratio, i === 0 ? 360 : 1));
    tmp = hsl2rgb(tmp);
    v.r = tmp[0];
    v.g = tmp[1];
    v.b = tmp[2];
  }
}
function clone(v, proto) {
  return v ? Object.assign(proto || {}, v) : v;
}
function fromObject(input) {
  var v = { r: 0, g: 0, b: 0, a: 255 };
  if (Array.isArray(input)) {
    if (input.length >= 3) {
      v = { r: input[0], g: input[1], b: input[2], a: 255 };
      if (input.length > 3) {
        v.a = n2b(input[3]);
      }
    }
  } else {
    v = clone(input, { r: 0, g: 0, b: 0, a: 1 });
    v.a = n2b(v.a);
  }
  return v;
}
function functionParse(str) {
  if (str.charAt(0) === "r") {
    return rgbParse(str);
  }
  return hueParse(str);
}
var Color = class {
  constructor(input) {
    if (input instanceof Color) {
      return input;
    }
    const type = typeof input;
    let v;
    if (type === "object") {
      v = fromObject(input);
    } else if (type === "string") {
      v = hexParse(input) || nameParse(input) || functionParse(input);
    }
    this._rgb = v;
    this._valid = !!v;
  }
  get valid() {
    return this._valid;
  }
  get rgb() {
    var v = clone(this._rgb);
    if (v) {
      v.a = b2n(v.a);
    }
    return v;
  }
  set rgb(obj) {
    this._rgb = fromObject(obj);
  }
  rgbString() {
    return this._valid ? rgbString(this._rgb) : void 0;
  }
  hexString() {
    return this._valid ? hexString(this._rgb) : void 0;
  }
  hslString() {
    return this._valid ? hslString(this._rgb) : void 0;
  }
  mix(color2, weight) {
    if (color2) {
      const c1 = this.rgb;
      const c2 = color2.rgb;
      let w2;
      const p = weight === w2 ? 0.5 : weight;
      const w = 2 * p - 1;
      const a = c1.a - c2.a;
      const w1 = ((w * a === -1 ? w : (w + a) / (1 + w * a)) + 1) / 2;
      w2 = 1 - w1;
      c1.r = 255 & w1 * c1.r + w2 * c2.r + 0.5;
      c1.g = 255 & w1 * c1.g + w2 * c2.g + 0.5;
      c1.b = 255 & w1 * c1.b + w2 * c2.b + 0.5;
      c1.a = p * c1.a + (1 - p) * c2.a;
      this.rgb = c1;
    }
    return this;
  }
  interpolate(color2, t) {
    if (color2) {
      this._rgb = interpolate(this._rgb, color2._rgb, t);
    }
    return this;
  }
  clone() {
    return new Color(this.rgb);
  }
  alpha(a) {
    this._rgb.a = n2b(a);
    return this;
  }
  clearer(ratio) {
    const rgb = this._rgb;
    rgb.a *= 1 - ratio;
    return this;
  }
  greyscale() {
    const rgb = this._rgb;
    const val = round(rgb.r * 0.3 + rgb.g * 0.59 + rgb.b * 0.11);
    rgb.r = rgb.g = rgb.b = val;
    return this;
  }
  opaquer(ratio) {
    const rgb = this._rgb;
    rgb.a *= 1 + ratio;
    return this;
  }
  negate() {
    const v = this._rgb;
    v.r = 255 - v.r;
    v.g = 255 - v.g;
    v.b = 255 - v.b;
    return this;
  }
  lighten(ratio) {
    modHSL(this._rgb, 2, ratio);
    return this;
  }
  darken(ratio) {
    modHSL(this._rgb, 2, -ratio);
    return this;
  }
  saturate(ratio) {
    modHSL(this._rgb, 1, ratio);
    return this;
  }
  desaturate(ratio) {
    modHSL(this._rgb, 1, -ratio);
    return this;
  }
  rotate(deg) {
    rotate(this._rgb, deg);
    return this;
  }
};

// node_modules/chart.js/dist/chunks/helpers.segment.js
function noop() {
}
var uid = (() => {
  let id = 0;
  return () => id++;
})();
function isNullOrUndef(value) {
  return value === null || typeof value === "undefined";
}
function isArray(value) {
  if (Array.isArray && Array.isArray(value)) {
    return true;
  }
  const type = Object.prototype.toString.call(value);
  if (type.slice(0, 7) === "[object" && type.slice(-6) === "Array]") {
    return true;
  }
  return false;
}
function isObject(value) {
  return value !== null && Object.prototype.toString.call(value) === "[object Object]";
}
function isNumberFinite(value) {
  return (typeof value === "number" || value instanceof Number) && isFinite(+value);
}
function finiteOrDefault(value, defaultValue) {
  return isNumberFinite(value) ? value : defaultValue;
}
function valueOrDefault(value, defaultValue) {
  return typeof value === "undefined" ? defaultValue : value;
}
var toPercentage = (value, dimension) => typeof value === "string" && value.endsWith("%") ? parseFloat(value) / 100 : +value / dimension;
var toDimension = (value, dimension) => typeof value === "string" && value.endsWith("%") ? parseFloat(value) / 100 * dimension : +value;
function callback(fn, args, thisArg) {
  if (fn && typeof fn.call === "function") {
    return fn.apply(thisArg, args);
  }
}
function each(loopable, fn, thisArg, reverse) {
  let i, len, keys;
  if (isArray(loopable)) {
    len = loopable.length;
    if (reverse) {
      for (i = len - 1; i >= 0; i--) {
        fn.call(thisArg, loopable[i], i);
      }
    } else {
      for (i = 0; i < len; i++) {
        fn.call(thisArg, loopable[i], i);
      }
    }
  } else if (isObject(loopable)) {
    keys = Object.keys(loopable);
    len = keys.length;
    for (i = 0; i < len; i++) {
      fn.call(thisArg, loopable[keys[i]], keys[i]);
    }
  }
}
function _elementsEqual(a0, a1) {
  let i, ilen, v0, v1;
  if (!a0 || !a1 || a0.length !== a1.length) {
    return false;
  }
  for (i = 0, ilen = a0.length; i < ilen; ++i) {
    v0 = a0[i];
    v1 = a1[i];
    if (v0.datasetIndex !== v1.datasetIndex || v0.index !== v1.index) {
      return false;
    }
  }
  return true;
}
function clone2(source) {
  if (isArray(source)) {
    return source.map(clone2);
  }
  if (isObject(source)) {
    const target = /* @__PURE__ */ Object.create(null);
    const keys = Object.keys(source);
    const klen = keys.length;
    let k = 0;
    for (; k < klen; ++k) {
      target[keys[k]] = clone2(source[keys[k]]);
    }
    return target;
  }
  return source;
}
function isValidKey(key) {
  return [
    "__proto__",
    "prototype",
    "constructor"
  ].indexOf(key) === -1;
}
function _merger(key, target, source, options) {
  if (!isValidKey(key)) {
    return;
  }
  const tval = target[key];
  const sval = source[key];
  if (isObject(tval) && isObject(sval)) {
    merge(tval, sval, options);
  } else {
    target[key] = clone2(sval);
  }
}
function merge(target, source, options) {
  const sources = isArray(source) ? source : [
    source
  ];
  const ilen = sources.length;
  if (!isObject(target)) {
    return target;
  }
  options = options || {};
  const merger = options.merger || _merger;
  let current;
  for (let i = 0; i < ilen; ++i) {
    current = sources[i];
    if (!isObject(current)) {
      continue;
    }
    const keys = Object.keys(current);
    for (let k = 0, klen = keys.length; k < klen; ++k) {
      merger(keys[k], target, current, options);
    }
  }
  return target;
}
function mergeIf(target, source) {
  return merge(target, source, {
    merger: _mergerIf
  });
}
function _mergerIf(key, target, source) {
  if (!isValidKey(key)) {
    return;
  }
  const tval = target[key];
  const sval = source[key];
  if (isObject(tval) && isObject(sval)) {
    mergeIf(tval, sval);
  } else if (!Object.prototype.hasOwnProperty.call(target, key)) {
    target[key] = clone2(sval);
  }
}
var keyResolvers = {
  // Chart.helpers.core resolveObjectKey should resolve empty key to root object
  "": (v) => v,
  // default resolvers
  x: (o) => o.x,
  y: (o) => o.y
};
function _splitKey(key) {
  const parts = key.split(".");
  const keys = [];
  let tmp = "";
  for (const part of parts) {
    tmp += part;
    if (tmp.endsWith("\\")) {
      tmp = tmp.slice(0, -1) + ".";
    } else {
      keys.push(tmp);
      tmp = "";
    }
  }
  return keys;
}
function _getKeyResolver(key) {
  const keys = _splitKey(key);
  return (obj) => {
    for (const k of keys) {
      if (k === "") {
        break;
      }
      obj = obj && obj[k];
    }
    return obj;
  };
}
function resolveObjectKey(obj, key) {
  const resolver = keyResolvers[key] || (keyResolvers[key] = _getKeyResolver(key));
  return resolver(obj);
}
function _capitalize(str) {
  return str.charAt(0).toUpperCase() + str.slice(1);
}
var defined = (value) => typeof value !== "undefined";
var isFunction = (value) => typeof value === "function";
var setsEqual = (a, b) => {
  if (a.size !== b.size) {
    return false;
  }
  for (const item of a) {
    if (!b.has(item)) {
      return false;
    }
  }
  return true;
};
function _isClickEvent(e) {
  return e.type === "mouseup" || e.type === "click" || e.type === "contextmenu";
}
var PI = Math.PI;
var TAU = 2 * PI;
var PITAU = TAU + PI;
var INFINITY = Number.POSITIVE_INFINITY;
var RAD_PER_DEG = PI / 180;
var HALF_PI = PI / 2;
var QUARTER_PI = PI / 4;
var TWO_THIRDS_PI = PI * 2 / 3;
var log10 = Math.log10;
var sign = Math.sign;
function almostEquals(x, y, epsilon) {
  return Math.abs(x - y) < epsilon;
}
function niceNum(range) {
  const roundedRange = Math.round(range);
  range = almostEquals(range, roundedRange, range / 1e3) ? roundedRange : range;
  const niceRange = Math.pow(10, Math.floor(log10(range)));
  const fraction = range / niceRange;
  const niceFraction = fraction <= 1 ? 1 : fraction <= 2 ? 2 : fraction <= 5 ? 5 : 10;
  return niceFraction * niceRange;
}
function _factorize(value) {
  const result = [];
  const sqrt = Math.sqrt(value);
  let i;
  for (i = 1; i < sqrt; i++) {
    if (value % i === 0) {
      result.push(i);
      result.push(value / i);
    }
  }
  if (sqrt === (sqrt | 0)) {
    result.push(sqrt);
  }
  result.sort((a, b) => a - b).pop();
  return result;
}
function isNumber(n) {
  return !isNaN(parseFloat(n)) && isFinite(n);
}
function almostWhole(x, epsilon) {
  const rounded = Math.round(x);
  return rounded - epsilon <= x && rounded + epsilon >= x;
}
function _setMinAndMaxByKey(array, target, property) {
  let i, ilen, value;
  for (i = 0, ilen = array.length; i < ilen; i++) {
    value = array[i][property];
    if (!isNaN(value)) {
      target.min = Math.min(target.min, value);
      target.max = Math.max(target.max, value);
    }
  }
}
function toRadians(degrees) {
  return degrees * (PI / 180);
}
function toDegrees(radians) {
  return radians * (180 / PI);
}
function _decimalPlaces(x) {
  if (!isNumberFinite(x)) {
    return;
  }
  let e = 1;
  let p = 0;
  while (Math.round(x * e) / e !== x) {
    e *= 10;
    p++;
  }
  return p;
}
function getAngleFromPoint(centrePoint, anglePoint) {
  const distanceFromXCenter = anglePoint.x - centrePoint.x;
  const distanceFromYCenter = anglePoint.y - centrePoint.y;
  const radialDistanceFromCenter = Math.sqrt(distanceFromXCenter * distanceFromXCenter + distanceFromYCenter * distanceFromYCenter);
  let angle = Math.atan2(distanceFromYCenter, distanceFromXCenter);
  if (angle < -0.5 * PI) {
    angle += TAU;
  }
  return {
    angle,
    distance: radialDistanceFromCenter
  };
}
function distanceBetweenPoints(pt1, pt2) {
  return Math.sqrt(Math.pow(pt2.x - pt1.x, 2) + Math.pow(pt2.y - pt1.y, 2));
}
function _angleDiff(a, b) {
  return (a - b + PITAU) % TAU - PI;
}
function _normalizeAngle(a) {
  return (a % TAU + TAU) % TAU;
}
function _angleBetween(angle, start, end, sameAngleIsFullCircle) {
  const a = _normalizeAngle(angle);
  const s = _normalizeAngle(start);
  const e = _normalizeAngle(end);
  const angleToStart = _normalizeAngle(s - a);
  const angleToEnd = _normalizeAngle(e - a);
  const startToAngle = _normalizeAngle(a - s);
  const endToAngle = _normalizeAngle(a - e);
  return a === s || a === e || sameAngleIsFullCircle && s === e || angleToStart > angleToEnd && startToAngle < endToAngle;
}
function _limitValue(value, min, max) {
  return Math.max(min, Math.min(max, value));
}
function _int16Range(value) {
  return _limitValue(value, -32768, 32767);
}
function _isBetween(value, start, end, epsilon = 1e-6) {
  return value >= Math.min(start, end) - epsilon && value <= Math.max(start, end) + epsilon;
}
function _lookup(table, value, cmp) {
  cmp = cmp || ((index2) => table[index2] < value);
  let hi = table.length - 1;
  let lo = 0;
  let mid;
  while (hi - lo > 1) {
    mid = lo + hi >> 1;
    if (cmp(mid)) {
      lo = mid;
    } else {
      hi = mid;
    }
  }
  return {
    lo,
    hi
  };
}
var _lookupByKey = (table, key, value, last) => _lookup(table, value, last ? (index2) => {
  const ti = table[index2][key];
  return ti < value || ti === value && table[index2 + 1][key] === value;
} : (index2) => table[index2][key] < value);
var _rlookupByKey = (table, key, value) => _lookup(table, value, (index2) => table[index2][key] >= value);
function _filterBetween(values, min, max) {
  let start = 0;
  let end = values.length;
  while (start < end && values[start] < min) {
    start++;
  }
  while (end > start && values[end - 1] > max) {
    end--;
  }
  return start > 0 || end < values.length ? values.slice(start, end) : values;
}
var arrayEvents = [
  "push",
  "pop",
  "shift",
  "splice",
  "unshift"
];
function listenArrayEvents(array, listener) {
  if (array._chartjs) {
    array._chartjs.listeners.push(listener);
    return;
  }
  Object.defineProperty(array, "_chartjs", {
    configurable: true,
    enumerable: false,
    value: {
      listeners: [
        listener
      ]
    }
  });
  arrayEvents.forEach((key) => {
    const method = "_onData" + _capitalize(key);
    const base = array[key];
    Object.defineProperty(array, key, {
      configurable: true,
      enumerable: false,
      value(...args) {
        const res = base.apply(this, args);
        array._chartjs.listeners.forEach((object) => {
          if (typeof object[method] === "function") {
            object[method](...args);
          }
        });
        return res;
      }
    });
  });
}
function unlistenArrayEvents(array, listener) {
  const stub = array._chartjs;
  if (!stub) {
    return;
  }
  const listeners = stub.listeners;
  const index2 = listeners.indexOf(listener);
  if (index2 !== -1) {
    listeners.splice(index2, 1);
  }
  if (listeners.length > 0) {
    return;
  }
  arrayEvents.forEach((key) => {
    delete array[key];
  });
  delete array._chartjs;
}
function _arrayUnique(items) {
  const set2 = new Set(items);
  if (set2.size === items.length) {
    return items;
  }
  return Array.from(set2);
}
var requestAnimFrame = function() {
  if (typeof window === "undefined") {
    return function(callback2) {
      return callback2();
    };
  }
  return window.requestAnimationFrame;
}();
function throttled(fn, thisArg) {
  let argsToUse = [];
  let ticking = false;
  return function(...args) {
    argsToUse = args;
    if (!ticking) {
      ticking = true;
      requestAnimFrame.call(window, () => {
        ticking = false;
        fn.apply(thisArg, argsToUse);
      });
    }
  };
}
function debounce(fn, delay) {
  let timeout;
  return function(...args) {
    if (delay) {
      clearTimeout(timeout);
      timeout = setTimeout(fn, delay, args);
    } else {
      fn.apply(this, args);
    }
    return delay;
  };
}
var _toLeftRightCenter = (align) => align === "start" ? "left" : align === "end" ? "right" : "center";
var _alignStartEnd = (align, start, end) => align === "start" ? start : align === "end" ? end : (start + end) / 2;
var _textX = (align, left, right, rtl) => {
  const check = rtl ? "left" : "right";
  return align === check ? right : align === "center" ? (left + right) / 2 : left;
};
function _getStartAndCountOfVisiblePoints(meta, points, animationsDisabled) {
  const pointCount = points.length;
  let start = 0;
  let count = pointCount;
  if (meta._sorted) {
    const { iScale, _parsed } = meta;
    const axis = iScale.axis;
    const { min, max, minDefined, maxDefined } = iScale.getUserBounds();
    if (minDefined) {
      start = _limitValue(Math.min(
        // @ts-expect-error Need to type _parsed
        _lookupByKey(_parsed, axis, min).lo,
        // @ts-expect-error Need to fix types on _lookupByKey
        animationsDisabled ? pointCount : _lookupByKey(points, axis, iScale.getPixelForValue(min)).lo
      ), 0, pointCount - 1);
    }
    if (maxDefined) {
      count = _limitValue(Math.max(
        // @ts-expect-error Need to type _parsed
        _lookupByKey(_parsed, iScale.axis, max, true).hi + 1,
        // @ts-expect-error Need to fix types on _lookupByKey
        animationsDisabled ? 0 : _lookupByKey(points, axis, iScale.getPixelForValue(max), true).hi + 1
      ), start, pointCount) - start;
    } else {
      count = pointCount - start;
    }
  }
  return {
    start,
    count
  };
}
function _scaleRangesChanged(meta) {
  const { xScale, yScale, _scaleRanges } = meta;
  const newRanges = {
    xmin: xScale.min,
    xmax: xScale.max,
    ymin: yScale.min,
    ymax: yScale.max
  };
  if (!_scaleRanges) {
    meta._scaleRanges = newRanges;
    return true;
  }
  const changed = _scaleRanges.xmin !== xScale.min || _scaleRanges.xmax !== xScale.max || _scaleRanges.ymin !== yScale.min || _scaleRanges.ymax !== yScale.max;
  Object.assign(_scaleRanges, newRanges);
  return changed;
}
var atEdge = (t) => t === 0 || t === 1;
var elasticIn = (t, s, p) => -(Math.pow(2, 10 * (t -= 1)) * Math.sin((t - s) * TAU / p));
var elasticOut = (t, s, p) => Math.pow(2, -10 * t) * Math.sin((t - s) * TAU / p) + 1;
var effects = {
  linear: (t) => t,
  easeInQuad: (t) => t * t,
  easeOutQuad: (t) => -t * (t - 2),
  easeInOutQuad: (t) => (t /= 0.5) < 1 ? 0.5 * t * t : -0.5 * (--t * (t - 2) - 1),
  easeInCubic: (t) => t * t * t,
  easeOutCubic: (t) => (t -= 1) * t * t + 1,
  easeInOutCubic: (t) => (t /= 0.5) < 1 ? 0.5 * t * t * t : 0.5 * ((t -= 2) * t * t + 2),
  easeInQuart: (t) => t * t * t * t,
  easeOutQuart: (t) => -((t -= 1) * t * t * t - 1),
  easeInOutQuart: (t) => (t /= 0.5) < 1 ? 0.5 * t * t * t * t : -0.5 * ((t -= 2) * t * t * t - 2),
  easeInQuint: (t) => t * t * t * t * t,
  easeOutQuint: (t) => (t -= 1) * t * t * t * t + 1,
  easeInOutQuint: (t) => (t /= 0.5) < 1 ? 0.5 * t * t * t * t * t : 0.5 * ((t -= 2) * t * t * t * t + 2),
  easeInSine: (t) => -Math.cos(t * HALF_PI) + 1,
  easeOutSine: (t) => Math.sin(t * HALF_PI),
  easeInOutSine: (t) => -0.5 * (Math.cos(PI * t) - 1),
  easeInExpo: (t) => t === 0 ? 0 : Math.pow(2, 10 * (t - 1)),
  easeOutExpo: (t) => t === 1 ? 1 : -Math.pow(2, -10 * t) + 1,
  easeInOutExpo: (t) => atEdge(t) ? t : t < 0.5 ? 0.5 * Math.pow(2, 10 * (t * 2 - 1)) : 0.5 * (-Math.pow(2, -10 * (t * 2 - 1)) + 2),
  easeInCirc: (t) => t >= 1 ? t : -(Math.sqrt(1 - t * t) - 1),
  easeOutCirc: (t) => Math.sqrt(1 - (t -= 1) * t),
  easeInOutCirc: (t) => (t /= 0.5) < 1 ? -0.5 * (Math.sqrt(1 - t * t) - 1) : 0.5 * (Math.sqrt(1 - (t -= 2) * t) + 1),
  easeInElastic: (t) => atEdge(t) ? t : elasticIn(t, 0.075, 0.3),
  easeOutElastic: (t) => atEdge(t) ? t : elasticOut(t, 0.075, 0.3),
  easeInOutElastic(t) {
    const s = 0.1125;
    const p = 0.45;
    return atEdge(t) ? t : t < 0.5 ? 0.5 * elasticIn(t * 2, s, p) : 0.5 + 0.5 * elasticOut(t * 2 - 1, s, p);
  },
  easeInBack(t) {
    const s = 1.70158;
    return t * t * ((s + 1) * t - s);
  },
  easeOutBack(t) {
    const s = 1.70158;
    return (t -= 1) * t * ((s + 1) * t + s) + 1;
  },
  easeInOutBack(t) {
    let s = 1.70158;
    if ((t /= 0.5) < 1) {
      return 0.5 * (t * t * (((s *= 1.525) + 1) * t - s));
    }
    return 0.5 * ((t -= 2) * t * (((s *= 1.525) + 1) * t + s) + 2);
  },
  easeInBounce: (t) => 1 - effects.easeOutBounce(1 - t),
  easeOutBounce(t) {
    const m = 7.5625;
    const d = 2.75;
    if (t < 1 / d) {
      return m * t * t;
    }
    if (t < 2 / d) {
      return m * (t -= 1.5 / d) * t + 0.75;
    }
    if (t < 2.5 / d) {
      return m * (t -= 2.25 / d) * t + 0.9375;
    }
    return m * (t -= 2.625 / d) * t + 0.984375;
  },
  easeInOutBounce: (t) => t < 0.5 ? effects.easeInBounce(t * 2) * 0.5 : effects.easeOutBounce(t * 2 - 1) * 0.5 + 0.5
};
function isPatternOrGradient(value) {
  if (value && typeof value === "object") {
    const type = value.toString();
    return type === "[object CanvasPattern]" || type === "[object CanvasGradient]";
  }
  return false;
}
function color(value) {
  return isPatternOrGradient(value) ? value : new Color(value);
}
function getHoverColor(value) {
  return isPatternOrGradient(value) ? value : new Color(value).saturate(0.5).darken(0.1).hexString();
}
var numbers = [
  "x",
  "y",
  "borderWidth",
  "radius",
  "tension"
];
var colors = [
  "color",
  "borderColor",
  "backgroundColor"
];
function applyAnimationsDefaults(defaults2) {
  defaults2.set("animation", {
    delay: void 0,
    duration: 1e3,
    easing: "easeOutQuart",
    fn: void 0,
    from: void 0,
    loop: void 0,
    to: void 0,
    type: void 0
  });
  defaults2.describe("animation", {
    _fallback: false,
    _indexable: false,
    _scriptable: (name) => name !== "onProgress" && name !== "onComplete" && name !== "fn"
  });
  defaults2.set("animations", {
    colors: {
      type: "color",
      properties: colors
    },
    numbers: {
      type: "number",
      properties: numbers
    }
  });
  defaults2.describe("animations", {
    _fallback: "animation"
  });
  defaults2.set("transitions", {
    active: {
      animation: {
        duration: 400
      }
    },
    resize: {
      animation: {
        duration: 0
      }
    },
    show: {
      animations: {
        colors: {
          from: "transparent"
        },
        visible: {
          type: "boolean",
          duration: 0
        }
      }
    },
    hide: {
      animations: {
        colors: {
          to: "transparent"
        },
        visible: {
          type: "boolean",
          easing: "linear",
          fn: (v) => v | 0
        }
      }
    }
  });
}
function applyLayoutsDefaults(defaults2) {
  defaults2.set("layout", {
    autoPadding: true,
    padding: {
      top: 0,
      right: 0,
      bottom: 0,
      left: 0
    }
  });
}
var intlCache = /* @__PURE__ */ new Map();
function getNumberFormat(locale, options) {
  options = options || {};
  const cacheKey = locale + JSON.stringify(options);
  let formatter = intlCache.get(cacheKey);
  if (!formatter) {
    formatter = new Intl.NumberFormat(locale, options);
    intlCache.set(cacheKey, formatter);
  }
  return formatter;
}
function formatNumber(num, locale, options) {
  return getNumberFormat(locale, options).format(num);
}
var formatters = {
  values(value) {
    return isArray(value) ? value : "" + value;
  },
  numeric(tickValue, index2, ticks) {
    if (tickValue === 0) {
      return "0";
    }
    const locale = this.chart.options.locale;
    let notation;
    let delta = tickValue;
    if (ticks.length > 1) {
      const maxTick = Math.max(Math.abs(ticks[0].value), Math.abs(ticks[ticks.length - 1].value));
      if (maxTick < 1e-4 || maxTick > 1e15) {
        notation = "scientific";
      }
      delta = calculateDelta(tickValue, ticks);
    }
    const logDelta = log10(Math.abs(delta));
    const numDecimal = isNaN(logDelta) ? 1 : Math.max(Math.min(-1 * Math.floor(logDelta), 20), 0);
    const options = {
      notation,
      minimumFractionDigits: numDecimal,
      maximumFractionDigits: numDecimal
    };
    Object.assign(options, this.options.ticks.format);
    return formatNumber(tickValue, locale, options);
  },
  logarithmic(tickValue, index2, ticks) {
    if (tickValue === 0) {
      return "0";
    }
    const remain = ticks[index2].significand || tickValue / Math.pow(10, Math.floor(log10(tickValue)));
    if ([
      1,
      2,
      3,
      5,
      10,
      15
    ].includes(remain) || index2 > 0.8 * ticks.length) {
      return formatters.numeric.call(this, tickValue, index2, ticks);
    }
    return "";
  }
};
function calculateDelta(tickValue, ticks) {
  let delta = ticks.length > 3 ? ticks[2].value - ticks[1].value : ticks[1].value - ticks[0].value;
  if (Math.abs(delta) >= 1 && tickValue !== Math.floor(tickValue)) {
    delta = tickValue - Math.floor(tickValue);
  }
  return delta;
}
var Ticks = {
  formatters
};
function applyScaleDefaults(defaults2) {
  defaults2.set("scale", {
    display: true,
    offset: false,
    reverse: false,
    beginAtZero: false,
    bounds: "ticks",
    clip: true,
    grace: 0,
    grid: {
      display: true,
      lineWidth: 1,
      drawOnChartArea: true,
      drawTicks: true,
      tickLength: 8,
      tickWidth: (_ctx, options) => options.lineWidth,
      tickColor: (_ctx, options) => options.color,
      offset: false
    },
    border: {
      display: true,
      dash: [],
      dashOffset: 0,
      width: 1
    },
    title: {
      display: false,
      text: "",
      padding: {
        top: 4,
        bottom: 4
      }
    },
    ticks: {
      minRotation: 0,
      maxRotation: 50,
      mirror: false,
      textStrokeWidth: 0,
      textStrokeColor: "",
      padding: 3,
      display: true,
      autoSkip: true,
      autoSkipPadding: 3,
      labelOffset: 0,
      callback: Ticks.formatters.values,
      minor: {},
      major: {},
      align: "center",
      crossAlign: "near",
      showLabelBackdrop: false,
      backdropColor: "rgba(255, 255, 255, 0.75)",
      backdropPadding: 2
    }
  });
  defaults2.route("scale.ticks", "color", "", "color");
  defaults2.route("scale.grid", "color", "", "borderColor");
  defaults2.route("scale.border", "color", "", "borderColor");
  defaults2.route("scale.title", "color", "", "color");
  defaults2.describe("scale", {
    _fallback: false,
    _scriptable: (name) => !name.startsWith("before") && !name.startsWith("after") && name !== "callback" && name !== "parser",
    _indexable: (name) => name !== "borderDash" && name !== "tickBorderDash" && name !== "dash"
  });
  defaults2.describe("scales", {
    _fallback: "scale"
  });
  defaults2.describe("scale.ticks", {
    _scriptable: (name) => name !== "backdropPadding" && name !== "callback",
    _indexable: (name) => name !== "backdropPadding"
  });
}
var overrides = /* @__PURE__ */ Object.create(null);
var descriptors = /* @__PURE__ */ Object.create(null);
function getScope$1(node, key) {
  if (!key) {
    return node;
  }
  const keys = key.split(".");
  for (let i = 0, n = keys.length; i < n; ++i) {
    const k = keys[i];
    node = node[k] || (node[k] = /* @__PURE__ */ Object.create(null));
  }
  return node;
}
function set(root, scope, values) {
  if (typeof scope === "string") {
    return merge(getScope$1(root, scope), values);
  }
  return merge(getScope$1(root, ""), scope);
}
var Defaults = class {
  constructor(_descriptors2, _appliers) {
    this.animation = void 0;
    this.backgroundColor = "rgba(0,0,0,0.1)";
    this.borderColor = "rgba(0,0,0,0.1)";
    this.color = "#666";
    this.datasets = {};
    this.devicePixelRatio = (context) => context.chart.platform.getDevicePixelRatio();
    this.elements = {};
    this.events = [
      "mousemove",
      "mouseout",
      "click",
      "touchstart",
      "touchmove"
    ];
    this.font = {
      family: "'Helvetica Neue', 'Helvetica', 'Arial', sans-serif",
      size: 12,
      style: "normal",
      lineHeight: 1.2,
      weight: null
    };
    this.hover = {};
    this.hoverBackgroundColor = (ctx, options) => getHoverColor(options.backgroundColor);
    this.hoverBorderColor = (ctx, options) => getHoverColor(options.borderColor);
    this.hoverColor = (ctx, options) => getHoverColor(options.color);
    this.indexAxis = "x";
    this.interaction = {
      mode: "nearest",
      intersect: true,
      includeInvisible: false
    };
    this.maintainAspectRatio = true;
    this.onHover = null;
    this.onClick = null;
    this.parsing = true;
    this.plugins = {};
    this.responsive = true;
    this.scale = void 0;
    this.scales = {};
    this.showLine = true;
    this.drawActiveElementsOnTop = true;
    this.describe(_descriptors2);
    this.apply(_appliers);
  }
  set(scope, values) {
    return set(this, scope, values);
  }
  get(scope) {
    return getScope$1(this, scope);
  }
  describe(scope, values) {
    return set(descriptors, scope, values);
  }
  override(scope, values) {
    return set(overrides, scope, values);
  }
  route(scope, name, targetScope, targetName) {
    const scopeObject = getScope$1(this, scope);
    const targetScopeObject = getScope$1(this, targetScope);
    const privateName = "_" + name;
    Object.defineProperties(scopeObject, {
      [privateName]: {
        value: scopeObject[name],
        writable: true
      },
      [name]: {
        enumerable: true,
        get() {
          const local = this[privateName];
          const target = targetScopeObject[targetName];
          if (isObject(local)) {
            return Object.assign({}, target, local);
          }
          return valueOrDefault(local, target);
        },
        set(value) {
          this[privateName] = value;
        }
      }
    });
  }
  apply(appliers) {
    appliers.forEach((apply) => apply(this));
  }
};
var defaults = /* @__PURE__ */ new Defaults({
  _scriptable: (name) => !name.startsWith("on"),
  _indexable: (name) => name !== "events",
  hover: {
    _fallback: "interaction"
  },
  interaction: {
    _scriptable: false,
    _indexable: false
  }
}, [
  applyAnimationsDefaults,
  applyLayoutsDefaults,
  applyScaleDefaults
]);
function toFontString(font) {
  if (!font || isNullOrUndef(font.size) || isNullOrUndef(font.family)) {
    return null;
  }
  return (font.style ? font.style + " " : "") + (font.weight ? font.weight + " " : "") + font.size + "px " + font.family;
}
function _measureText(ctx, data, gc, longest, string) {
  let textWidth = data[string];
  if (!textWidth) {
    textWidth = data[string] = ctx.measureText(string).width;
    gc.push(string);
  }
  if (textWidth > longest) {
    longest = textWidth;
  }
  return longest;
}
function _longestText(ctx, font, arrayOfThings, cache) {
  cache = cache || {};
  let data = cache.data = cache.data || {};
  let gc = cache.garbageCollect = cache.garbageCollect || [];
  if (cache.font !== font) {
    data = cache.data = {};
    gc = cache.garbageCollect = [];
    cache.font = font;
  }
  ctx.save();
  ctx.font = font;
  let longest = 0;
  const ilen = arrayOfThings.length;
  let i, j, jlen, thing, nestedThing;
  for (i = 0; i < ilen; i++) {
    thing = arrayOfThings[i];
    if (thing !== void 0 && thing !== null && !isArray(thing)) {
      longest = _measureText(ctx, data, gc, longest, thing);
    } else if (isArray(thing)) {
      for (j = 0, jlen = thing.length; j < jlen; j++) {
        nestedThing = thing[j];
        if (nestedThing !== void 0 && nestedThing !== null && !isArray(nestedThing)) {
          longest = _measureText(ctx, data, gc, longest, nestedThing);
        }
      }
    }
  }
  ctx.restore();
  const gcLen = gc.length / 2;
  if (gcLen > arrayOfThings.length) {
    for (i = 0; i < gcLen; i++) {
      delete data[gc[i]];
    }
    gc.splice(0, gcLen);
  }
  return longest;
}
function _alignPixel(chart, pixel, width) {
  const devicePixelRatio = chart.currentDevicePixelRatio;
  const halfWidth = width !== 0 ? Math.max(width / 2, 0.5) : 0;
  return Math.round((pixel - halfWidth) * devicePixelRatio) / devicePixelRatio + halfWidth;
}
function clearCanvas(canvas, ctx) {
  if (!ctx && !canvas) {
    return;
  }
  ctx = ctx || canvas.getContext("2d");
  ctx.save();
  ctx.resetTransform();
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  ctx.restore();
}
function drawPoint(ctx, options, x, y) {
  drawPointLegend(ctx, options, x, y, null);
}
function drawPointLegend(ctx, options, x, y, w) {
  let type, xOffset, yOffset, size, cornerRadius, width, xOffsetW, yOffsetW;
  const style = options.pointStyle;
  const rotation = options.rotation;
  const radius = options.radius;
  let rad = (rotation || 0) * RAD_PER_DEG;
  if (style && typeof style === "object") {
    type = style.toString();
    if (type === "[object HTMLImageElement]" || type === "[object HTMLCanvasElement]") {
      ctx.save();
      ctx.translate(x, y);
      ctx.rotate(rad);
      ctx.drawImage(style, -style.width / 2, -style.height / 2, style.width, style.height);
      ctx.restore();
      return;
    }
  }
  if (isNaN(radius) || radius <= 0) {
    return;
  }
  ctx.beginPath();
  switch (style) {
    default:
      if (w) {
        ctx.ellipse(x, y, w / 2, radius, 0, 0, TAU);
      } else {
        ctx.arc(x, y, radius, 0, TAU);
      }
      ctx.closePath();
      break;
    case "triangle":
      width = w ? w / 2 : radius;
      ctx.moveTo(x + Math.sin(rad) * width, y - Math.cos(rad) * radius);
      rad += TWO_THIRDS_PI;
      ctx.lineTo(x + Math.sin(rad) * width, y - Math.cos(rad) * radius);
      rad += TWO_THIRDS_PI;
      ctx.lineTo(x + Math.sin(rad) * width, y - Math.cos(rad) * radius);
      ctx.closePath();
      break;
    case "rectRounded":
      cornerRadius = radius * 0.516;
      size = radius - cornerRadius;
      xOffset = Math.cos(rad + QUARTER_PI) * size;
      xOffsetW = Math.cos(rad + QUARTER_PI) * (w ? w / 2 - cornerRadius : size);
      yOffset = Math.sin(rad + QUARTER_PI) * size;
      yOffsetW = Math.sin(rad + QUARTER_PI) * (w ? w / 2 - cornerRadius : size);
      ctx.arc(x - xOffsetW, y - yOffset, cornerRadius, rad - PI, rad - HALF_PI);
      ctx.arc(x + yOffsetW, y - xOffset, cornerRadius, rad - HALF_PI, rad);
      ctx.arc(x + xOffsetW, y + yOffset, cornerRadius, rad, rad + HALF_PI);
      ctx.arc(x - yOffsetW, y + xOffset, cornerRadius, rad + HALF_PI, rad + PI);
      ctx.closePath();
      break;
    case "rect":
      if (!rotation) {
        size = Math.SQRT1_2 * radius;
        width = w ? w / 2 : size;
        ctx.rect(x - width, y - size, 2 * width, 2 * size);
        break;
      }
      rad += QUARTER_PI;
    case "rectRot":
      xOffsetW = Math.cos(rad) * (w ? w / 2 : radius);
      xOffset = Math.cos(rad) * radius;
      yOffset = Math.sin(rad) * radius;
      yOffsetW = Math.sin(rad) * (w ? w / 2 : radius);
      ctx.moveTo(x - xOffsetW, y - yOffset);
      ctx.lineTo(x + yOffsetW, y - xOffset);
      ctx.lineTo(x + xOffsetW, y + yOffset);
      ctx.lineTo(x - yOffsetW, y + xOffset);
      ctx.closePath();
      break;
    case "crossRot":
      rad += QUARTER_PI;
    case "cross":
      xOffsetW = Math.cos(rad) * (w ? w / 2 : radius);
      xOffset = Math.cos(rad) * radius;
      yOffset = Math.sin(rad) * radius;
      yOffsetW = Math.sin(rad) * (w ? w / 2 : radius);
      ctx.moveTo(x - xOffsetW, y - yOffset);
      ctx.lineTo(x + xOffsetW, y + yOffset);
      ctx.moveTo(x + yOffsetW, y - xOffset);
      ctx.lineTo(x - yOffsetW, y + xOffset);
      break;
    case "star":
      xOffsetW = Math.cos(rad) * (w ? w / 2 : radius);
      xOffset = Math.cos(rad) * radius;
      yOffset = Math.sin(rad) * radius;
      yOffsetW = Math.sin(rad) * (w ? w / 2 : radius);
      ctx.moveTo(x - xOffsetW, y - yOffset);
      ctx.lineTo(x + xOffsetW, y + yOffset);
      ctx.moveTo(x + yOffsetW, y - xOffset);
      ctx.lineTo(x - yOffsetW, y + xOffset);
      rad += QUARTER_PI;
      xOffsetW = Math.cos(rad) * (w ? w / 2 : radius);
      xOffset = Math.cos(rad) * radius;
      yOffset = Math.sin(rad) * radius;
      yOffsetW = Math.sin(rad) * (w ? w / 2 : radius);
      ctx.moveTo(x - xOffsetW, y - yOffset);
      ctx.lineTo(x + xOffsetW, y + yOffset);
      ctx.moveTo(x + yOffsetW, y - xOffset);
      ctx.lineTo(x - yOffsetW, y + xOffset);
      break;
    case "line":
      xOffset = w ? w / 2 : Math.cos(rad) * radius;
      yOffset = Math.sin(rad) * radius;
      ctx.moveTo(x - xOffset, y - yOffset);
      ctx.lineTo(x + xOffset, y + yOffset);
      break;
    case "dash":
      ctx.moveTo(x, y);
      ctx.lineTo(x + Math.cos(rad) * (w ? w / 2 : radius), y + Math.sin(rad) * radius);
      break;
    case false:
      ctx.closePath();
      break;
  }
  ctx.fill();
  if (options.borderWidth > 0) {
    ctx.stroke();
  }
}
function _isPointInArea(point, area, margin) {
  margin = margin || 0.5;
  return !area || point && point.x > area.left - margin && point.x < area.right + margin && point.y > area.top - margin && point.y < area.bottom + margin;
}
function clipArea(ctx, area) {
  ctx.save();
  ctx.beginPath();
  ctx.rect(area.left, area.top, area.right - area.left, area.bottom - area.top);
  ctx.clip();
}
function unclipArea(ctx) {
  ctx.restore();
}
function _steppedLineTo(ctx, previous, target, flip, mode) {
  if (!previous) {
    return ctx.lineTo(target.x, target.y);
  }
  if (mode === "middle") {
    const midpoint = (previous.x + target.x) / 2;
    ctx.lineTo(midpoint, previous.y);
    ctx.lineTo(midpoint, target.y);
  } else if (mode === "after" !== !!flip) {
    ctx.lineTo(previous.x, target.y);
  } else {
    ctx.lineTo(target.x, previous.y);
  }
  ctx.lineTo(target.x, target.y);
}
function _bezierCurveTo(ctx, previous, target, flip) {
  if (!previous) {
    return ctx.lineTo(target.x, target.y);
  }
  ctx.bezierCurveTo(flip ? previous.cp1x : previous.cp2x, flip ? previous.cp1y : previous.cp2y, flip ? target.cp2x : target.cp1x, flip ? target.cp2y : target.cp1y, target.x, target.y);
}
function setRenderOpts(ctx, opts) {
  if (opts.translation) {
    ctx.translate(opts.translation[0], opts.translation[1]);
  }
  if (!isNullOrUndef(opts.rotation)) {
    ctx.rotate(opts.rotation);
  }
  if (opts.color) {
    ctx.fillStyle = opts.color;
  }
  if (opts.textAlign) {
    ctx.textAlign = opts.textAlign;
  }
  if (opts.textBaseline) {
    ctx.textBaseline = opts.textBaseline;
  }
}
function decorateText(ctx, x, y, line, opts) {
  if (opts.strikethrough || opts.underline) {
    const metrics = ctx.measureText(line);
    const left = x - metrics.actualBoundingBoxLeft;
    const right = x + metrics.actualBoundingBoxRight;
    const top = y - metrics.actualBoundingBoxAscent;
    const bottom = y + metrics.actualBoundingBoxDescent;
    const yDecoration = opts.strikethrough ? (top + bottom) / 2 : bottom;
    ctx.strokeStyle = ctx.fillStyle;
    ctx.beginPath();
    ctx.lineWidth = opts.decorationWidth || 2;
    ctx.moveTo(left, yDecoration);
    ctx.lineTo(right, yDecoration);
    ctx.stroke();
  }
}
function drawBackdrop(ctx, opts) {
  const oldColor = ctx.fillStyle;
  ctx.fillStyle = opts.color;
  ctx.fillRect(opts.left, opts.top, opts.width, opts.height);
  ctx.fillStyle = oldColor;
}
function renderText(ctx, text, x, y, font, opts = {}) {
  const lines = isArray(text) ? text : [
    text
  ];
  const stroke = opts.strokeWidth > 0 && opts.strokeColor !== "";
  let i, line;
  ctx.save();
  ctx.font = font.string;
  setRenderOpts(ctx, opts);
  for (i = 0; i < lines.length; ++i) {
    line = lines[i];
    if (opts.backdrop) {
      drawBackdrop(ctx, opts.backdrop);
    }
    if (stroke) {
      if (opts.strokeColor) {
        ctx.strokeStyle = opts.strokeColor;
      }
      if (!isNullOrUndef(opts.strokeWidth)) {
        ctx.lineWidth = opts.strokeWidth;
      }
      ctx.strokeText(line, x, y, opts.maxWidth);
    }
    ctx.fillText(line, x, y, opts.maxWidth);
    decorateText(ctx, x, y, line, opts);
    y += Number(font.lineHeight);
  }
  ctx.restore();
}
function addRoundedRectPath(ctx, rect) {
  const { x, y, w, h, radius } = rect;
  ctx.arc(x + radius.topLeft, y + radius.topLeft, radius.topLeft, 1.5 * PI, PI, true);
  ctx.lineTo(x, y + h - radius.bottomLeft);
  ctx.arc(x + radius.bottomLeft, y + h - radius.bottomLeft, radius.bottomLeft, PI, HALF_PI, true);
  ctx.lineTo(x + w - radius.bottomRight, y + h);
  ctx.arc(x + w - radius.bottomRight, y + h - radius.bottomRight, radius.bottomRight, HALF_PI, 0, true);
  ctx.lineTo(x + w, y + radius.topRight);
  ctx.arc(x + w - radius.topRight, y + radius.topRight, radius.topRight, 0, -HALF_PI, true);
  ctx.lineTo(x + radius.topLeft, y);
}
var LINE_HEIGHT = /^(normal|(\d+(?:\.\d+)?)(px|em|%)?)$/;
var FONT_STYLE = /^(normal|italic|initial|inherit|unset|(oblique( -?[0-9]?[0-9]deg)?))$/;
function toLineHeight(value, size) {
  const matches = ("" + value).match(LINE_HEIGHT);
  if (!matches || matches[1] === "normal") {
    return size * 1.2;
  }
  value = +matches[2];
  switch (matches[3]) {
    case "px":
      return value;
    case "%":
      value /= 100;
      break;
  }
  return size * value;
}
var numberOrZero = (v) => +v || 0;
function _readValueToProps(value, props) {
  const ret = {};
  const objProps = isObject(props);
  const keys = objProps ? Object.keys(props) : props;
  const read = isObject(value) ? objProps ? (prop) => valueOrDefault(value[prop], value[props[prop]]) : (prop) => value[prop] : () => value;
  for (const prop of keys) {
    ret[prop] = numberOrZero(read(prop));
  }
  return ret;
}
function toTRBL(value) {
  return _readValueToProps(value, {
    top: "y",
    right: "x",
    bottom: "y",
    left: "x"
  });
}
function toTRBLCorners(value) {
  return _readValueToProps(value, [
    "topLeft",
    "topRight",
    "bottomLeft",
    "bottomRight"
  ]);
}
function toPadding(value) {
  const obj = toTRBL(value);
  obj.width = obj.left + obj.right;
  obj.height = obj.top + obj.bottom;
  return obj;
}
function toFont(options, fallback) {
  options = options || {};
  fallback = fallback || defaults.font;
  let size = valueOrDefault(options.size, fallback.size);
  if (typeof size === "string") {
    size = parseInt(size, 10);
  }
  let style = valueOrDefault(options.style, fallback.style);
  if (style && !("" + style).match(FONT_STYLE)) {
    console.warn('Invalid font style specified: "' + style + '"');
    style = void 0;
  }
  const font = {
    family: valueOrDefault(options.family, fallback.family),
    lineHeight: toLineHeight(valueOrDefault(options.lineHeight, fallback.lineHeight), size),
    size,
    style,
    weight: valueOrDefault(options.weight, fallback.weight),
    string: ""
  };
  font.string = toFontString(font);
  return font;
}
function resolve(inputs, context, index2, info) {
  let cacheable = true;
  let i, ilen, value;
  for (i = 0, ilen = inputs.length; i < ilen; ++i) {
    value = inputs[i];
    if (value === void 0) {
      continue;
    }
    if (context !== void 0 && typeof value === "function") {
      value = value(context);
      cacheable = false;
    }
    if (index2 !== void 0 && isArray(value)) {
      value = value[index2 % value.length];
      cacheable = false;
    }
    if (value !== void 0) {
      if (info && !cacheable) {
        info.cacheable = false;
      }
      return value;
    }
  }
}
function _addGrace(minmax, grace, beginAtZero) {
  const { min, max } = minmax;
  const change = toDimension(grace, (max - min) / 2);
  const keepZero = (value, add) => beginAtZero && value === 0 ? 0 : value + add;
  return {
    min: keepZero(min, -Math.abs(change)),
    max: keepZero(max, change)
  };
}
function createContext(parentContext, context) {
  return Object.assign(Object.create(parentContext), context);
}
function _createResolver(scopes, prefixes = [
  ""
], rootScopes, fallback, getTarget = () => scopes[0]) {
  const finalRootScopes = rootScopes || scopes;
  if (typeof fallback === "undefined") {
    fallback = _resolve("_fallback", scopes);
  }
  const cache = {
    [Symbol.toStringTag]: "Object",
    _cacheable: true,
    _scopes: scopes,
    _rootScopes: finalRootScopes,
    _fallback: fallback,
    _getTarget: getTarget,
    override: (scope) => _createResolver([
      scope,
      ...scopes
    ], prefixes, finalRootScopes, fallback)
  };
  return new Proxy(cache, {
    /**
    * A trap for the delete operator.
    */
    deleteProperty(target, prop) {
      delete target[prop];
      delete target._keys;
      delete scopes[0][prop];
      return true;
    },
    /**
    * A trap for getting property values.
    */
    get(target, prop) {
      return _cached(target, prop, () => _resolveWithPrefixes(prop, prefixes, scopes, target));
    },
    /**
    * A trap for Object.getOwnPropertyDescriptor.
    * Also used by Object.hasOwnProperty.
    */
    getOwnPropertyDescriptor(target, prop) {
      return Reflect.getOwnPropertyDescriptor(target._scopes[0], prop);
    },
    /**
    * A trap for Object.getPrototypeOf.
    */
    getPrototypeOf() {
      return Reflect.getPrototypeOf(scopes[0]);
    },
    /**
    * A trap for the in operator.
    */
    has(target, prop) {
      return getKeysFromAllScopes(target).includes(prop);
    },
    /**
    * A trap for Object.getOwnPropertyNames and Object.getOwnPropertySymbols.
    */
    ownKeys(target) {
      return getKeysFromAllScopes(target);
    },
    /**
    * A trap for setting property values.
    */
    set(target, prop, value) {
      const storage = target._storage || (target._storage = getTarget());
      target[prop] = storage[prop] = value;
      delete target._keys;
      return true;
    }
  });
}
function _attachContext(proxy, context, subProxy, descriptorDefaults) {
  const cache = {
    _cacheable: false,
    _proxy: proxy,
    _context: context,
    _subProxy: subProxy,
    _stack: /* @__PURE__ */ new Set(),
    _descriptors: _descriptors(proxy, descriptorDefaults),
    setContext: (ctx) => _attachContext(proxy, ctx, subProxy, descriptorDefaults),
    override: (scope) => _attachContext(proxy.override(scope), context, subProxy, descriptorDefaults)
  };
  return new Proxy(cache, {
    /**
    * A trap for the delete operator.
    */
    deleteProperty(target, prop) {
      delete target[prop];
      delete proxy[prop];
      return true;
    },
    /**
    * A trap for getting property values.
    */
    get(target, prop, receiver) {
      return _cached(target, prop, () => _resolveWithContext(target, prop, receiver));
    },
    /**
    * A trap for Object.getOwnPropertyDescriptor.
    * Also used by Object.hasOwnProperty.
    */
    getOwnPropertyDescriptor(target, prop) {
      return target._descriptors.allKeys ? Reflect.has(proxy, prop) ? {
        enumerable: true,
        configurable: true
      } : void 0 : Reflect.getOwnPropertyDescriptor(proxy, prop);
    },
    /**
    * A trap for Object.getPrototypeOf.
    */
    getPrototypeOf() {
      return Reflect.getPrototypeOf(proxy);
    },
    /**
    * A trap for the in operator.
    */
    has(target, prop) {
      return Reflect.has(proxy, prop);
    },
    /**
    * A trap for Object.getOwnPropertyNames and Object.getOwnPropertySymbols.
    */
    ownKeys() {
      return Reflect.ownKeys(proxy);
    },
    /**
    * A trap for setting property values.
    */
    set(target, prop, value) {
      proxy[prop] = value;
      delete target[prop];
      return true;
    }
  });
}
function _descriptors(proxy, defaults2 = {
  scriptable: true,
  indexable: true
}) {
  const { _scriptable = defaults2.scriptable, _indexable = defaults2.indexable, _allKeys = defaults2.allKeys } = proxy;
  return {
    allKeys: _allKeys,
    scriptable: _scriptable,
    indexable: _indexable,
    isScriptable: isFunction(_scriptable) ? _scriptable : () => _scriptable,
    isIndexable: isFunction(_indexable) ? _indexable : () => _indexable
  };
}
var readKey = (prefix, name) => prefix ? prefix + _capitalize(name) : name;
var needsSubResolver = (prop, value) => isObject(value) && prop !== "adapters" && (Object.getPrototypeOf(value) === null || value.constructor === Object);
function _cached(target, prop, resolve2) {
  if (Object.prototype.hasOwnProperty.call(target, prop) || prop === "constructor") {
    return target[prop];
  }
  const value = resolve2();
  target[prop] = value;
  return value;
}
function _resolveWithContext(target, prop, receiver) {
  const { _proxy, _context, _subProxy, _descriptors: descriptors2 } = target;
  let value = _proxy[prop];
  if (isFunction(value) && descriptors2.isScriptable(prop)) {
    value = _resolveScriptable(prop, value, target, receiver);
  }
  if (isArray(value) && value.length) {
    value = _resolveArray(prop, value, target, descriptors2.isIndexable);
  }
  if (needsSubResolver(prop, value)) {
    value = _attachContext(value, _context, _subProxy && _subProxy[prop], descriptors2);
  }
  return value;
}
function _resolveScriptable(prop, getValue, target, receiver) {
  const { _proxy, _context, _subProxy, _stack } = target;
  if (_stack.has(prop)) {
    throw new Error("Recursion detected: " + Array.from(_stack).join("->") + "->" + prop);
  }
  _stack.add(prop);
  let value = getValue(_context, _subProxy || receiver);
  _stack.delete(prop);
  if (needsSubResolver(prop, value)) {
    value = createSubResolver(_proxy._scopes, _proxy, prop, value);
  }
  return value;
}
function _resolveArray(prop, value, target, isIndexable) {
  const { _proxy, _context, _subProxy, _descriptors: descriptors2 } = target;
  if (typeof _context.index !== "undefined" && isIndexable(prop)) {
    return value[_context.index % value.length];
  } else if (isObject(value[0])) {
    const arr = value;
    const scopes = _proxy._scopes.filter((s) => s !== arr);
    value = [];
    for (const item of arr) {
      const resolver = createSubResolver(scopes, _proxy, prop, item);
      value.push(_attachContext(resolver, _context, _subProxy && _subProxy[prop], descriptors2));
    }
  }
  return value;
}
function resolveFallback(fallback, prop, value) {
  return isFunction(fallback) ? fallback(prop, value) : fallback;
}
var getScope = (key, parent) => key === true ? parent : typeof key === "string" ? resolveObjectKey(parent, key) : void 0;
function addScopes(set2, parentScopes, key, parentFallback, value) {
  for (const parent of parentScopes) {
    const scope = getScope(key, parent);
    if (scope) {
      set2.add(scope);
      const fallback = resolveFallback(scope._fallback, key, value);
      if (typeof fallback !== "undefined" && fallback !== key && fallback !== parentFallback) {
        return fallback;
      }
    } else if (scope === false && typeof parentFallback !== "undefined" && key !== parentFallback) {
      return null;
    }
  }
  return false;
}
function createSubResolver(parentScopes, resolver, prop, value) {
  const rootScopes = resolver._rootScopes;
  const fallback = resolveFallback(resolver._fallback, prop, value);
  const allScopes = [
    ...parentScopes,
    ...rootScopes
  ];
  const set2 = /* @__PURE__ */ new Set();
  set2.add(value);
  let key = addScopesFromKey(set2, allScopes, prop, fallback || prop, value);
  if (key === null) {
    return false;
  }
  if (typeof fallback !== "undefined" && fallback !== prop) {
    key = addScopesFromKey(set2, allScopes, fallback, key, value);
    if (key === null) {
      return false;
    }
  }
  return _createResolver(Array.from(set2), [
    ""
  ], rootScopes, fallback, () => subGetTarget(resolver, prop, value));
}
function addScopesFromKey(set2, allScopes, key, fallback, item) {
  while (key) {
    key = addScopes(set2, allScopes, key, fallback, item);
  }
  return key;
}
function subGetTarget(resolver, prop, value) {
  const parent = resolver._getTarget();
  if (!(prop in parent)) {
    parent[prop] = {};
  }
  const target = parent[prop];
  if (isArray(target) && isObject(value)) {
    return value;
  }
  return target || {};
}
function _resolveWithPrefixes(prop, prefixes, scopes, proxy) {
  let value;
  for (const prefix of prefixes) {
    value = _resolve(readKey(prefix, prop), scopes);
    if (typeof value !== "undefined") {
      return needsSubResolver(prop, value) ? createSubResolver(scopes, proxy, prop, value) : value;
    }
  }
}
function _resolve(key, scopes) {
  for (const scope of scopes) {
    if (!scope) {
      continue;
    }
    const value = scope[key];
    if (typeof value !== "undefined") {
      return value;
    }
  }
}
function getKeysFromAllScopes(target) {
  let keys = target._keys;
  if (!keys) {
    keys = target._keys = resolveKeysFromAllScopes(target._scopes);
  }
  return keys;
}
function resolveKeysFromAllScopes(scopes) {
  const set2 = /* @__PURE__ */ new Set();
  for (const scope of scopes) {
    for (const key of Object.keys(scope).filter((k) => !k.startsWith("_"))) {
      set2.add(key);
    }
  }
  return Array.from(set2);
}
function _parseObjectDataRadialScale(meta, data, start, count) {
  const { iScale } = meta;
  const { key = "r" } = this._parsing;
  const parsed = new Array(count);
  let i, ilen, index2, item;
  for (i = 0, ilen = count; i < ilen; ++i) {
    index2 = i + start;
    item = data[index2];
    parsed[i] = {
      r: iScale.parse(resolveObjectKey(item, key), index2)
    };
  }
  return parsed;
}
var EPSILON = Number.EPSILON || 1e-14;
var getPoint = (points, i) => i < points.length && !points[i].skip && points[i];
var getValueAxis = (indexAxis) => indexAxis === "x" ? "y" : "x";
function splineCurve(firstPoint, middlePoint, afterPoint, t) {
  const previous = firstPoint.skip ? middlePoint : firstPoint;
  const current = middlePoint;
  const next = afterPoint.skip ? middlePoint : afterPoint;
  const d01 = distanceBetweenPoints(current, previous);
  const d12 = distanceBetweenPoints(next, current);
  let s01 = d01 / (d01 + d12);
  let s12 = d12 / (d01 + d12);
  s01 = isNaN(s01) ? 0 : s01;
  s12 = isNaN(s12) ? 0 : s12;
  const fa = t * s01;
  const fb = t * s12;
  return {
    previous: {
      x: current.x - fa * (next.x - previous.x),
      y: current.y - fa * (next.y - previous.y)
    },
    next: {
      x: current.x + fb * (next.x - previous.x),
      y: current.y + fb * (next.y - previous.y)
    }
  };
}
function monotoneAdjust(points, deltaK, mK) {
  const pointsLen = points.length;
  let alphaK, betaK, tauK, squaredMagnitude, pointCurrent;
  let pointAfter = getPoint(points, 0);
  for (let i = 0; i < pointsLen - 1; ++i) {
    pointCurrent = pointAfter;
    pointAfter = getPoint(points, i + 1);
    if (!pointCurrent || !pointAfter) {
      continue;
    }
    if (almostEquals(deltaK[i], 0, EPSILON)) {
      mK[i] = mK[i + 1] = 0;
      continue;
    }
    alphaK = mK[i] / deltaK[i];
    betaK = mK[i + 1] / deltaK[i];
    squaredMagnitude = Math.pow(alphaK, 2) + Math.pow(betaK, 2);
    if (squaredMagnitude <= 9) {
      continue;
    }
    tauK = 3 / Math.sqrt(squaredMagnitude);
    mK[i] = alphaK * tauK * deltaK[i];
    mK[i + 1] = betaK * tauK * deltaK[i];
  }
}
function monotoneCompute(points, mK, indexAxis = "x") {
  const valueAxis = getValueAxis(indexAxis);
  const pointsLen = points.length;
  let delta, pointBefore, pointCurrent;
  let pointAfter = getPoint(points, 0);
  for (let i = 0; i < pointsLen; ++i) {
    pointBefore = pointCurrent;
    pointCurrent = pointAfter;
    pointAfter = getPoint(points, i + 1);
    if (!pointCurrent) {
      continue;
    }
    const iPixel = pointCurrent[indexAxis];
    const vPixel = pointCurrent[valueAxis];
    if (pointBefore) {
      delta = (iPixel - pointBefore[indexAxis]) / 3;
      pointCurrent[`cp1${indexAxis}`] = iPixel - delta;
      pointCurrent[`cp1${valueAxis}`] = vPixel - delta * mK[i];
    }
    if (pointAfter) {
      delta = (pointAfter[indexAxis] - iPixel) / 3;
      pointCurrent[`cp2${indexAxis}`] = iPixel + delta;
      pointCurrent[`cp2${valueAxis}`] = vPixel + delta * mK[i];
    }
  }
}
function splineCurveMonotone(points, indexAxis = "x") {
  const valueAxis = getValueAxis(indexAxis);
  const pointsLen = points.length;
  const deltaK = Array(pointsLen).fill(0);
  const mK = Array(pointsLen);
  let i, pointBefore, pointCurrent;
  let pointAfter = getPoint(points, 0);
  for (i = 0; i < pointsLen; ++i) {
    pointBefore = pointCurrent;
    pointCurrent = pointAfter;
    pointAfter = getPoint(points, i + 1);
    if (!pointCurrent) {
      continue;
    }
    if (pointAfter) {
      const slopeDelta = pointAfter[indexAxis] - pointCurrent[indexAxis];
      deltaK[i] = slopeDelta !== 0 ? (pointAfter[valueAxis] - pointCurrent[valueAxis]) / slopeDelta : 0;
    }
    mK[i] = !pointBefore ? deltaK[i] : !pointAfter ? deltaK[i - 1] : sign(deltaK[i - 1]) !== sign(deltaK[i]) ? 0 : (deltaK[i - 1] + deltaK[i]) / 2;
  }
  monotoneAdjust(points, deltaK, mK);
  monotoneCompute(points, mK, indexAxis);
}
function capControlPoint(pt, min, max) {
  return Math.max(Math.min(pt, max), min);
}
function capBezierPoints(points, area) {
  let i, ilen, point, inArea, inAreaPrev;
  let inAreaNext = _isPointInArea(points[0], area);
  for (i = 0, ilen = points.length; i < ilen; ++i) {
    inAreaPrev = inArea;
    inArea = inAreaNext;
    inAreaNext = i < ilen - 1 && _isPointInArea(points[i + 1], area);
    if (!inArea) {
      continue;
    }
    point = points[i];
    if (inAreaPrev) {
      point.cp1x = capControlPoint(point.cp1x, area.left, area.right);
      point.cp1y = capControlPoint(point.cp1y, area.top, area.bottom);
    }
    if (inAreaNext) {
      point.cp2x = capControlPoint(point.cp2x, area.left, area.right);
      point.cp2y = capControlPoint(point.cp2y, area.top, area.bottom);
    }
  }
}
function _updateBezierControlPoints(points, options, area, loop, indexAxis) {
  let i, ilen, point, controlPoints;
  if (options.spanGaps) {
    points = points.filter((pt) => !pt.skip);
  }
  if (options.cubicInterpolationMode === "monotone") {
    splineCurveMonotone(points, indexAxis);
  } else {
    let prev = loop ? points[points.length - 1] : points[0];
    for (i = 0, ilen = points.length; i < ilen; ++i) {
      point = points[i];
      controlPoints = splineCurve(prev, point, points[Math.min(i + 1, ilen - (loop ? 0 : 1)) % ilen], options.tension);
      point.cp1x = controlPoints.previous.x;
      point.cp1y = controlPoints.previous.y;
      point.cp2x = controlPoints.next.x;
      point.cp2y = controlPoints.next.y;
      prev = point;
    }
  }
  if (options.capBezierPoints) {
    capBezierPoints(points, area);
  }
}
function _isDomSupported() {
  return typeof window !== "undefined" && typeof document !== "undefined";
}
function _getParentNode(domNode) {
  let parent = domNode.parentNode;
  if (parent && parent.toString() === "[object ShadowRoot]") {
    parent = parent.host;
  }
  return parent;
}
function parseMaxStyle(styleValue, node, parentProperty) {
  let valueInPixels;
  if (typeof styleValue === "string") {
    valueInPixels = parseInt(styleValue, 10);
    if (styleValue.indexOf("%") !== -1) {
      valueInPixels = valueInPixels / 100 * node.parentNode[parentProperty];
    }
  } else {
    valueInPixels = styleValue;
  }
  return valueInPixels;
}
var getComputedStyle = (element) => element.ownerDocument.defaultView.getComputedStyle(element, null);
function getStyle(el, property) {
  return getComputedStyle(el).getPropertyValue(property);
}
var positions = [
  "top",
  "right",
  "bottom",
  "left"
];
function getPositionedStyle(styles, style, suffix) {
  const result = {};
  suffix = suffix ? "-" + suffix : "";
  for (let i = 0; i < 4; i++) {
    const pos = positions[i];
    result[pos] = parseFloat(styles[style + "-" + pos + suffix]) || 0;
  }
  result.width = result.left + result.right;
  result.height = result.top + result.bottom;
  return result;
}
var useOffsetPos = (x, y, target) => (x > 0 || y > 0) && (!target || !target.shadowRoot);
function getCanvasPosition(e, canvas) {
  const touches = e.touches;
  const source = touches && touches.length ? touches[0] : e;
  const { offsetX, offsetY } = source;
  let box = false;
  let x, y;
  if (useOffsetPos(offsetX, offsetY, e.target)) {
    x = offsetX;
    y = offsetY;
  } else {
    const rect = canvas.getBoundingClientRect();
    x = source.clientX - rect.left;
    y = source.clientY - rect.top;
    box = true;
  }
  return {
    x,
    y,
    box
  };
}
function getRelativePosition(event, chart) {
  if ("native" in event) {
    return event;
  }
  const { canvas, currentDevicePixelRatio } = chart;
  const style = getComputedStyle(canvas);
  const borderBox = style.boxSizing === "border-box";
  const paddings = getPositionedStyle(style, "padding");
  const borders = getPositionedStyle(style, "border", "width");
  const { x, y, box } = getCanvasPosition(event, canvas);
  const xOffset = paddings.left + (box && borders.left);
  const yOffset = paddings.top + (box && borders.top);
  let { width, height } = chart;
  if (borderBox) {
    width -= paddings.width + borders.width;
    height -= paddings.height + borders.height;
  }
  return {
    x: Math.round((x - xOffset) / width * canvas.width / currentDevicePixelRatio),
    y: Math.round((y - yOffset) / height * canvas.height / currentDevicePixelRatio)
  };
}
function getContainerSize(canvas, width, height) {
  let maxWidth, maxHeight;
  if (width === void 0 || height === void 0) {
    const container = canvas && _getParentNode(canvas);
    if (!container) {
      width = canvas.clientWidth;
      height = canvas.clientHeight;
    } else {
      const rect = container.getBoundingClientRect();
      const containerStyle = getComputedStyle(container);
      const containerBorder = getPositionedStyle(containerStyle, "border", "width");
      const containerPadding = getPositionedStyle(containerStyle, "padding");
      width = rect.width - containerPadding.width - containerBorder.width;
      height = rect.height - containerPadding.height - containerBorder.height;
      maxWidth = parseMaxStyle(containerStyle.maxWidth, container, "clientWidth");
      maxHeight = parseMaxStyle(containerStyle.maxHeight, container, "clientHeight");
    }
  }
  return {
    width,
    height,
    maxWidth: maxWidth || INFINITY,
    maxHeight: maxHeight || INFINITY
  };
}
var round1 = (v) => Math.round(v * 10) / 10;
function getMaximumSize(canvas, bbWidth, bbHeight, aspectRatio) {
  const style = getComputedStyle(canvas);
  const margins = getPositionedStyle(style, "margin");
  const maxWidth = parseMaxStyle(style.maxWidth, canvas, "clientWidth") || INFINITY;
  const maxHeight = parseMaxStyle(style.maxHeight, canvas, "clientHeight") || INFINITY;
  const containerSize = getContainerSize(canvas, bbWidth, bbHeight);
  let { width, height } = containerSize;
  if (style.boxSizing === "content-box") {
    const borders = getPositionedStyle(style, "border", "width");
    const paddings = getPositionedStyle(style, "padding");
    width -= paddings.width + borders.width;
    height -= paddings.height + borders.height;
  }
  width = Math.max(0, width - margins.width);
  height = Math.max(0, aspectRatio ? width / aspectRatio : height - margins.height);
  width = round1(Math.min(width, maxWidth, containerSize.maxWidth));
  height = round1(Math.min(height, maxHeight, containerSize.maxHeight));
  if (width && !height) {
    height = round1(width / 2);
  }
  const maintainHeight = bbWidth !== void 0 || bbHeight !== void 0;
  if (maintainHeight && aspectRatio && containerSize.height && height > containerSize.height) {
    height = containerSize.height;
    width = round1(Math.floor(height * aspectRatio));
  }
  return {
    width,
    height
  };
}
function retinaScale(chart, forceRatio, forceStyle) {
  const pixelRatio = forceRatio || 1;
  const deviceHeight = Math.floor(chart.height * pixelRatio);
  const deviceWidth = Math.floor(chart.width * pixelRatio);
  chart.height = Math.floor(chart.height);
  chart.width = Math.floor(chart.width);
  const canvas = chart.canvas;
  if (canvas.style && (forceStyle || !canvas.style.height && !canvas.style.width)) {
    canvas.style.height = `${chart.height}px`;
    canvas.style.width = `${chart.width}px`;
  }
  if (chart.currentDevicePixelRatio !== pixelRatio || canvas.height !== deviceHeight || canvas.width !== deviceWidth) {
    chart.currentDevicePixelRatio = pixelRatio;
    canvas.height = deviceHeight;
    canvas.width = deviceWidth;
    chart.ctx.setTransform(pixelRatio, 0, 0, pixelRatio, 0, 0);
    return true;
  }
  return false;
}
var supportsEventListenerOptions = function() {
  let passiveSupported = false;
  try {
    const options = {
      get passive() {
        passiveSupported = true;
        return false;
      }
    };
    if (_isDomSupported()) {
      window.addEventListener("test", null, options);
      window.removeEventListener("test", null, options);
    }
  } catch (e) {
  }
  return passiveSupported;
}();
function readUsedSize(element, property) {
  const value = getStyle(element, property);
  const matches = value && value.match(/^(\d+)(\.\d+)?px$/);
  return matches ? +matches[1] : void 0;
}
function _pointInLine(p1, p2, t, mode) {
  return {
    x: p1.x + t * (p2.x - p1.x),
    y: p1.y + t * (p2.y - p1.y)
  };
}
function _steppedInterpolation(p1, p2, t, mode) {
  return {
    x: p1.x + t * (p2.x - p1.x),
    y: mode === "middle" ? t < 0.5 ? p1.y : p2.y : mode === "after" ? t < 1 ? p1.y : p2.y : t > 0 ? p2.y : p1.y
  };
}
function _bezierInterpolation(p1, p2, t, mode) {
  const cp1 = {
    x: p1.cp2x,
    y: p1.cp2y
  };
  const cp2 = {
    x: p2.cp1x,
    y: p2.cp1y
  };
  const a = _pointInLine(p1, cp1, t);
  const b = _pointInLine(cp1, cp2, t);
  const c = _pointInLine(cp2, p2, t);
  const d = _pointInLine(a, b, t);
  const e = _pointInLine(b, c, t);
  return _pointInLine(d, e, t);
}
var getRightToLeftAdapter = function(rectX, width) {
  return {
    x(x) {
      return rectX + rectX + width - x;
    },
    setWidth(w) {
      width = w;
    },
    textAlign(align) {
      if (align === "center") {
        return align;
      }
      return align === "right" ? "left" : "right";
    },
    xPlus(x, value) {
      return x - value;
    },
    leftForLtr(x, itemWidth) {
      return x - itemWidth;
    }
  };
};
var getLeftToRightAdapter = function() {
  return {
    x(x) {
      return x;
    },
    setWidth(w) {
    },
    textAlign(align) {
      return align;
    },
    xPlus(x, value) {
      return x + value;
    },
    leftForLtr(x, _itemWidth) {
      return x;
    }
  };
};
function getRtlAdapter(rtl, rectX, width) {
  return rtl ? getRightToLeftAdapter(rectX, width) : getLeftToRightAdapter();
}
function overrideTextDirection(ctx, direction) {
  let style, original;
  if (direction === "ltr" || direction === "rtl") {
    style = ctx.canvas.style;
    original = [
      style.getPropertyValue("direction"),
      style.getPropertyPriority("direction")
    ];
    style.setProperty("direction", direction, "important");
    ctx.prevTextDirection = original;
  }
}
function restoreTextDirection(ctx, original) {
  if (original !== void 0) {
    delete ctx.prevTextDirection;
    ctx.canvas.style.setProperty("direction", original[0], original[1]);
  }
}
function propertyFn(property) {
  if (property === "angle") {
    return {
      between: _angleBetween,
      compare: _angleDiff,
      normalize: _normalizeAngle
    };
  }
  return {
    between: _isBetween,
    compare: (a, b) => a - b,
    normalize: (x) => x
  };
}
function normalizeSegment({ start, end, count, loop, style }) {
  return {
    start: start % count,
    end: end % count,
    loop: loop && (end - start + 1) % count === 0,
    style
  };
}
function getSegment(segment, points, bounds) {
  const { property, start: startBound, end: endBound } = bounds;
  const { between, normalize } = propertyFn(property);
  const count = points.length;
  let { start, end, loop } = segment;
  let i, ilen;
  if (loop) {
    start += count;
    end += count;
    for (i = 0, ilen = count; i < ilen; ++i) {
      if (!between(normalize(points[start % count][property]), startBound, endBound)) {
        break;
      }
      start--;
      end--;
    }
    start %= count;
    end %= count;
  }
  if (end < start) {
    end += count;
  }
  return {
    start,
    end,
    loop,
    style: segment.style
  };
}
function _boundSegment(segment, points, bounds) {
  if (!bounds) {
    return [
      segment
    ];
  }
  const { property, start: startBound, end: endBound } = bounds;
  const count = points.length;
  const { compare, between, normalize } = propertyFn(property);
  const { start, end, loop, style } = getSegment(segment, points, bounds);
  const result = [];
  let inside = false;
  let subStart = null;
  let value, point, prevValue;
  const startIsBefore = () => between(startBound, prevValue, value) && compare(startBound, prevValue) !== 0;
  const endIsBefore = () => compare(endBound, value) === 0 || between(endBound, prevValue, value);
  const shouldStart = () => inside || startIsBefore();
  const shouldStop = () => !inside || endIsBefore();
  for (let i = start, prev = start; i <= end; ++i) {
    point = points[i % count];
    if (point.skip) {
      continue;
    }
    value = normalize(point[property]);
    if (value === prevValue) {
      continue;
    }
    inside = between(value, startBound, endBound);
    if (subStart === null && shouldStart()) {
      subStart = compare(value, startBound) === 0 ? i : prev;
    }
    if (subStart !== null && shouldStop()) {
      result.push(normalizeSegment({
        start: subStart,
        end: i,
        loop,
        count,
        style
      }));
      subStart = null;
    }
    prev = i;
    prevValue = value;
  }
  if (subStart !== null) {
    result.push(normalizeSegment({
      start: subStart,
      end,
      loop,
      count,
      style
    }));
  }
  return result;
}
function _boundSegments(line, bounds) {
  const result = [];
  const segments = line.segments;
  for (let i = 0; i < segments.length; i++) {
    const sub = _boundSegment(segments[i], line.points, bounds);
    if (sub.length) {
      result.push(...sub);
    }
  }
  return result;
}
function findStartAndEnd(points, count, loop, spanGaps) {
  let start = 0;
  let end = count - 1;
  if (loop && !spanGaps) {
    while (start < count && !points[start].skip) {
      start++;
    }
  }
  while (start < count && points[start].skip) {
    start++;
  }
  start %= count;
  if (loop) {
    end += start;
  }
  while (end > start && points[end % count].skip) {
    end--;
  }
  end %= count;
  return {
    start,
    end
  };
}
function solidSegments(points, start, max, loop) {
  const count = points.length;
  const result = [];
  let last = start;
  let prev = points[start];
  let end;
  for (end = start + 1; end <= max; ++end) {
    const cur = points[end % count];
    if (cur.skip || cur.stop) {
      if (!prev.skip) {
        loop = false;
        result.push({
          start: start % count,
          end: (end - 1) % count,
          loop
        });
        start = last = cur.stop ? end : null;
      }
    } else {
      last = end;
      if (prev.skip) {
        start = end;
      }
    }
    prev = cur;
  }
  if (last !== null) {
    result.push({
      start: start % count,
      end: last % count,
      loop
    });
  }
  return result;
}
function _computeSegments(line, segmentOptions) {
  const points = line.points;
  const spanGaps = line.options.spanGaps;
  const count = points.length;
  if (!count) {
    return [];
  }
  const loop = !!line._loop;
  const { start, end } = findStartAndEnd(points, count, loop, spanGaps);
  if (spanGaps === true) {
    return splitByStyles(line, [
      {
        start,
        end,
        loop
      }
    ], points, segmentOptions);
  }
  const max = end < start ? end + count : end;
  const completeLoop = !!line._fullLoop && start === 0 && end === count - 1;
  return splitByStyles(line, solidSegments(points, start, max, completeLoop), points, segmentOptions);
}
function splitByStyles(line, segments, points, segmentOptions) {
  if (!segmentOptions || !segmentOptions.setContext || !points) {
    return segments;
  }
  return doSplitByStyles(line, segments, points, segmentOptions);
}
function doSplitByStyles(line, segments, points, segmentOptions) {
  const chartContext = line._chart.getContext();
  const baseStyle = readStyle(line.options);
  const { _datasetIndex: datasetIndex, options: { spanGaps } } = line;
  const count = points.length;
  const result = [];
  let prevStyle = baseStyle;
  let start = segments[0].start;
  let i = start;
  function addStyle(s, e, l, st) {
    const dir = spanGaps ? -1 : 1;
    if (s === e) {
      return;
    }
    s += count;
    while (points[s % count].skip) {
      s -= dir;
    }
    while (points[e % count].skip) {
      e += dir;
    }
    if (s % count !== e % count) {
      result.push({
        start: s % count,
        end: e % count,
        loop: l,
        style: st
      });
      prevStyle = st;
      start = e % count;
    }
  }
  for (const segment of segments) {
    start = spanGaps ? start : segment.start;
    let prev = points[start % count];
    let style;
    for (i = start + 1; i <= segment.end; i++) {
      const pt = points[i % count];
      style = readStyle(segmentOptions.setContext(createContext(chartContext, {
        type: "segment",
        p0: prev,
        p1: pt,
        p0DataIndex: (i - 1) % count,
        p1DataIndex: i % count,
        datasetIndex
      })));
      if (styleChanged(style, prevStyle)) {
        addStyle(start, i - 1, segment.loop, prevStyle);
      }
      prev = pt;
      prevStyle = style;
    }
    if (start < i - 1) {
      addStyle(start, i - 1, segment.loop, prevStyle);
    }
  }
  return result;
}
function readStyle(options) {
  return {
    backgroundColor: options.backgroundColor,
    borderCapStyle: options.borderCapStyle,
    borderDash: options.borderDash,
    borderDashOffset: options.borderDashOffset,
    borderJoinStyle: options.borderJoinStyle,
    borderWidth: options.borderWidth,
    borderColor: options.borderColor
  };
}
function styleChanged(style, prevStyle) {
  if (!prevStyle) {
    return false;
  }
  const cache = [];
  const replacer = function(key, value) {
    if (!isPatternOrGradient(value)) {
      return value;
    }
    if (!cache.includes(value)) {
      cache.push(value);
    }
    return cache.indexOf(value);
  };
  return JSON.stringify(style, replacer) !== JSON.stringify(prevStyle, replacer);
}

// node_modules/chart.js/dist/chart.js
var Animator = class {
  constructor() {
    this._request = null;
    this._charts = /* @__PURE__ */ new Map();
    this._running = false;
    this._lastDate = void 0;
  }
  _notify(chart, anims, date, type) {
    const callbacks = anims.listeners[type];
    const numSteps = anims.duration;
    callbacks.forEach((fn) => fn({
      chart,
      initial: anims.initial,
      numSteps,
      currentStep: Math.min(date - anims.start, numSteps)
    }));
  }
  _refresh() {
    if (this._request) {
      return;
    }
    this._running = true;
    this._request = requestAnimFrame.call(window, () => {
      this._update();
      this._request = null;
      if (this._running) {
        this._refresh();
      }
    });
  }
  _update(date = Date.now()) {
    let remaining = 0;
    this._charts.forEach((anims, chart) => {
      if (!anims.running || !anims.items.length) {
        return;
      }
      const items = anims.items;
      let i = items.length - 1;
      let draw3 = false;
      let item;
      for (; i >= 0; --i) {
        item = items[i];
        if (item._active) {
          if (item._total > anims.duration) {
            anims.duration = item._total;
          }
          item.tick(date);
          draw3 = true;
        } else {
          items[i] = items[items.length - 1];
          items.pop();
        }
      }
      if (draw3) {
        chart.draw();
        this._notify(chart, anims, date, "progress");
      }
      if (!items.length) {
        anims.running = false;
        this._notify(chart, anims, date, "complete");
        anims.initial = false;
      }
      remaining += items.length;
    });
    this._lastDate = date;
    if (remaining === 0) {
      this._running = false;
    }
  }
  _getAnims(chart) {
    const charts = this._charts;
    let anims = charts.get(chart);
    if (!anims) {
      anims = {
        running: false,
        initial: true,
        items: [],
        listeners: {
          complete: [],
          progress: []
        }
      };
      charts.set(chart, anims);
    }
    return anims;
  }
  listen(chart, event, cb) {
    this._getAnims(chart).listeners[event].push(cb);
  }
  add(chart, items) {
    if (!items || !items.length) {
      return;
    }
    this._getAnims(chart).items.push(...items);
  }
  has(chart) {
    return this._getAnims(chart).items.length > 0;
  }
  start(chart) {
    const anims = this._charts.get(chart);
    if (!anims) {
      return;
    }
    anims.running = true;
    anims.start = Date.now();
    anims.duration = anims.items.reduce((acc, cur) => Math.max(acc, cur._duration), 0);
    this._refresh();
  }
  running(chart) {
    if (!this._running) {
      return false;
    }
    const anims = this._charts.get(chart);
    if (!anims || !anims.running || !anims.items.length) {
      return false;
    }
    return true;
  }
  stop(chart) {
    const anims = this._charts.get(chart);
    if (!anims || !anims.items.length) {
      return;
    }
    const items = anims.items;
    let i = items.length - 1;
    for (; i >= 0; --i) {
      items[i].cancel();
    }
    anims.items = [];
    this._notify(chart, anims, Date.now(), "complete");
  }
  remove(chart) {
    return this._charts.delete(chart);
  }
};
var animator = /* @__PURE__ */ new Animator();
var transparent = "transparent";
var interpolators = {
  boolean(from2, to2, factor) {
    return factor > 0.5 ? to2 : from2;
  },
  color(from2, to2, factor) {
    const c0 = color(from2 || transparent);
    const c1 = c0.valid && color(to2 || transparent);
    return c1 && c1.valid ? c1.mix(c0, factor).hexString() : to2;
  },
  number(from2, to2, factor) {
    return from2 + (to2 - from2) * factor;
  }
};
var Animation = class {
  constructor(cfg, target, prop, to2) {
    const currentValue = target[prop];
    to2 = resolve([
      cfg.to,
      to2,
      currentValue,
      cfg.from
    ]);
    const from2 = resolve([
      cfg.from,
      currentValue,
      to2
    ]);
    this._active = true;
    this._fn = cfg.fn || interpolators[cfg.type || typeof from2];
    this._easing = effects[cfg.easing] || effects.linear;
    this._start = Math.floor(Date.now() + (cfg.delay || 0));
    this._duration = this._total = Math.floor(cfg.duration);
    this._loop = !!cfg.loop;
    this._target = target;
    this._prop = prop;
    this._from = from2;
    this._to = to2;
    this._promises = void 0;
  }
  active() {
    return this._active;
  }
  update(cfg, to2, date) {
    if (this._active) {
      this._notify(false);
      const currentValue = this._target[this._prop];
      const elapsed = date - this._start;
      const remain = this._duration - elapsed;
      this._start = date;
      this._duration = Math.floor(Math.max(remain, cfg.duration));
      this._total += elapsed;
      this._loop = !!cfg.loop;
      this._to = resolve([
        cfg.to,
        to2,
        currentValue,
        cfg.from
      ]);
      this._from = resolve([
        cfg.from,
        currentValue,
        to2
      ]);
    }
  }
  cancel() {
    if (this._active) {
      this.tick(Date.now());
      this._active = false;
      this._notify(false);
    }
  }
  tick(date) {
    const elapsed = date - this._start;
    const duration = this._duration;
    const prop = this._prop;
    const from2 = this._from;
    const loop = this._loop;
    const to2 = this._to;
    let factor;
    this._active = from2 !== to2 && (loop || elapsed < duration);
    if (!this._active) {
      this._target[prop] = to2;
      this._notify(true);
      return;
    }
    if (elapsed < 0) {
      this._target[prop] = from2;
      return;
    }
    factor = elapsed / duration % 2;
    factor = loop && factor > 1 ? 2 - factor : factor;
    factor = this._easing(Math.min(1, Math.max(0, factor)));
    this._target[prop] = this._fn(from2, to2, factor);
  }
  wait() {
    const promises = this._promises || (this._promises = []);
    return new Promise((res, rej) => {
      promises.push({
        res,
        rej
      });
    });
  }
  _notify(resolved) {
    const method = resolved ? "res" : "rej";
    const promises = this._promises || [];
    for (let i = 0; i < promises.length; i++) {
      promises[i][method]();
    }
  }
};
var Animations = class {
  constructor(chart, config) {
    this._chart = chart;
    this._properties = /* @__PURE__ */ new Map();
    this.configure(config);
  }
  configure(config) {
    if (!isObject(config)) {
      return;
    }
    const animationOptions = Object.keys(defaults.animation);
    const animatedProps = this._properties;
    Object.getOwnPropertyNames(config).forEach((key) => {
      const cfg = config[key];
      if (!isObject(cfg)) {
        return;
      }
      const resolved = {};
      for (const option of animationOptions) {
        resolved[option] = cfg[option];
      }
      (isArray(cfg.properties) && cfg.properties || [
        key
      ]).forEach((prop) => {
        if (prop === key || !animatedProps.has(prop)) {
          animatedProps.set(prop, resolved);
        }
      });
    });
  }
  _animateOptions(target, values) {
    const newOptions = values.options;
    const options = resolveTargetOptions(target, newOptions);
    if (!options) {
      return [];
    }
    const animations = this._createAnimations(options, newOptions);
    if (newOptions.$shared) {
      awaitAll(target.options.$animations, newOptions).then(() => {
        target.options = newOptions;
      }, () => {
      });
    }
    return animations;
  }
  _createAnimations(target, values) {
    const animatedProps = this._properties;
    const animations = [];
    const running = target.$animations || (target.$animations = {});
    const props = Object.keys(values);
    const date = Date.now();
    let i;
    for (i = props.length - 1; i >= 0; --i) {
      const prop = props[i];
      if (prop.charAt(0) === "$") {
        continue;
      }
      if (prop === "options") {
        animations.push(...this._animateOptions(target, values));
        continue;
      }
      const value = values[prop];
      let animation = running[prop];
      const cfg = animatedProps.get(prop);
      if (animation) {
        if (cfg && animation.active()) {
          animation.update(cfg, value, date);
          continue;
        } else {
          animation.cancel();
        }
      }
      if (!cfg || !cfg.duration) {
        target[prop] = value;
        continue;
      }
      running[prop] = animation = new Animation(cfg, target, prop, value);
      animations.push(animation);
    }
    return animations;
  }
  update(target, values) {
    if (this._properties.size === 0) {
      Object.assign(target, values);
      return;
    }
    const animations = this._createAnimations(target, values);
    if (animations.length) {
      animator.add(this._chart, animations);
      return true;
    }
  }
};
function awaitAll(animations, properties) {
  const running = [];
  const keys = Object.keys(properties);
  for (let i = 0; i < keys.length; i++) {
    const anim = animations[keys[i]];
    if (anim && anim.active()) {
      running.push(anim.wait());
    }
  }
  return Promise.all(running);
}
function resolveTargetOptions(target, newOptions) {
  if (!newOptions) {
    return;
  }
  let options = target.options;
  if (!options) {
    target.options = newOptions;
    return;
  }
  if (options.$shared) {
    target.options = options = Object.assign({}, options, {
      $shared: false,
      $animations: {}
    });
  }
  return options;
}
function scaleClip(scale, allowedOverflow) {
  const opts = scale && scale.options || {};
  const reverse = opts.reverse;
  const min = opts.min === void 0 ? allowedOverflow : 0;
  const max = opts.max === void 0 ? allowedOverflow : 0;
  return {
    start: reverse ? max : min,
    end: reverse ? min : max
  };
}
function defaultClip(xScale, yScale, allowedOverflow) {
  if (allowedOverflow === false) {
    return false;
  }
  const x = scaleClip(xScale, allowedOverflow);
  const y = scaleClip(yScale, allowedOverflow);
  return {
    top: y.end,
    right: x.end,
    bottom: y.start,
    left: x.start
  };
}
function toClip(value) {
  let t, r, b, l;
  if (isObject(value)) {
    t = value.top;
    r = value.right;
    b = value.bottom;
    l = value.left;
  } else {
    t = r = b = l = value;
  }
  return {
    top: t,
    right: r,
    bottom: b,
    left: l,
    disabled: value === false
  };
}
function getSortedDatasetIndices(chart, filterVisible) {
  const keys = [];
  const metasets = chart._getSortedDatasetMetas(filterVisible);
  let i, ilen;
  for (i = 0, ilen = metasets.length; i < ilen; ++i) {
    keys.push(metasets[i].index);
  }
  return keys;
}
function applyStack(stack, value, dsIndex, options = {}) {
  const keys = stack.keys;
  const singleMode = options.mode === "single";
  let i, ilen, datasetIndex, otherValue;
  if (value === null) {
    return;
  }
  for (i = 0, ilen = keys.length; i < ilen; ++i) {
    datasetIndex = +keys[i];
    if (datasetIndex === dsIndex) {
      if (options.all) {
        continue;
      }
      break;
    }
    otherValue = stack.values[datasetIndex];
    if (isNumberFinite(otherValue) && (singleMode || value === 0 || sign(value) === sign(otherValue))) {
      value += otherValue;
    }
  }
  return value;
}
function convertObjectDataToArray(data, meta) {
  const { iScale, vScale } = meta;
  const iAxisKey = iScale.axis === "x" ? "x" : "y";
  const vAxisKey = vScale.axis === "x" ? "x" : "y";
  const keys = Object.keys(data);
  const adata = new Array(keys.length);
  let i, ilen, key;
  for (i = 0, ilen = keys.length; i < ilen; ++i) {
    key = keys[i];
    adata[i] = {
      [iAxisKey]: key,
      [vAxisKey]: data[key]
    };
  }
  return adata;
}
function isStacked(scale, meta) {
  const stacked = scale && scale.options.stacked;
  return stacked || stacked === void 0 && meta.stack !== void 0;
}
function getStackKey(indexScale, valueScale, meta) {
  return `${indexScale.id}.${valueScale.id}.${meta.stack || meta.type}`;
}
function getUserBounds(scale) {
  const { min, max, minDefined, maxDefined } = scale.getUserBounds();
  return {
    min: minDefined ? min : Number.NEGATIVE_INFINITY,
    max: maxDefined ? max : Number.POSITIVE_INFINITY
  };
}
function getOrCreateStack(stacks, stackKey, indexValue) {
  const subStack = stacks[stackKey] || (stacks[stackKey] = {});
  return subStack[indexValue] || (subStack[indexValue] = {});
}
function getLastIndexInStack(stack, vScale, positive, type) {
  for (const meta of vScale.getMatchingVisibleMetas(type).reverse()) {
    const value = stack[meta.index];
    if (positive && value > 0 || !positive && value < 0) {
      return meta.index;
    }
  }
  return null;
}
function updateStacks(controller, parsed) {
  const { chart, _cachedMeta: meta } = controller;
  const stacks = chart._stacks || (chart._stacks = {});
  const { iScale, vScale, index: datasetIndex } = meta;
  const iAxis = iScale.axis;
  const vAxis = vScale.axis;
  const key = getStackKey(iScale, vScale, meta);
  const ilen = parsed.length;
  let stack;
  for (let i = 0; i < ilen; ++i) {
    const item = parsed[i];
    const { [iAxis]: index2, [vAxis]: value } = item;
    const itemStacks = item._stacks || (item._stacks = {});
    stack = itemStacks[vAxis] = getOrCreateStack(stacks, key, index2);
    stack[datasetIndex] = value;
    stack._top = getLastIndexInStack(stack, vScale, true, meta.type);
    stack._bottom = getLastIndexInStack(stack, vScale, false, meta.type);
    const visualValues = stack._visualValues || (stack._visualValues = {});
    visualValues[datasetIndex] = value;
  }
}
function getFirstScaleId(chart, axis) {
  const scales2 = chart.scales;
  return Object.keys(scales2).filter((key) => scales2[key].axis === axis).shift();
}
function createDatasetContext(parent, index2) {
  return createContext(parent, {
    active: false,
    dataset: void 0,
    datasetIndex: index2,
    index: index2,
    mode: "default",
    type: "dataset"
  });
}
function createDataContext(parent, index2, element) {
  return createContext(parent, {
    active: false,
    dataIndex: index2,
    parsed: void 0,
    raw: void 0,
    element,
    index: index2,
    mode: "default",
    type: "data"
  });
}
function clearStacks(meta, items) {
  const datasetIndex = meta.controller.index;
  const axis = meta.vScale && meta.vScale.axis;
  if (!axis) {
    return;
  }
  items = items || meta._parsed;
  for (const parsed of items) {
    const stacks = parsed._stacks;
    if (!stacks || stacks[axis] === void 0 || stacks[axis][datasetIndex] === void 0) {
      return;
    }
    delete stacks[axis][datasetIndex];
    if (stacks[axis]._visualValues !== void 0 && stacks[axis]._visualValues[datasetIndex] !== void 0) {
      delete stacks[axis]._visualValues[datasetIndex];
    }
  }
}
var isDirectUpdateMode = (mode) => mode === "reset" || mode === "none";
var cloneIfNotShared = (cached, shared) => shared ? cached : Object.assign({}, cached);
var createStack = (canStack, meta, chart) => canStack && !meta.hidden && meta._stacked && {
  keys: getSortedDatasetIndices(chart, true),
  values: null
};
var DatasetController = class {
  constructor(chart, datasetIndex) {
    this.chart = chart;
    this._ctx = chart.ctx;
    this.index = datasetIndex;
    this._cachedDataOpts = {};
    this._cachedMeta = this.getMeta();
    this._type = this._cachedMeta.type;
    this.options = void 0;
    this._parsing = false;
    this._data = void 0;
    this._objectData = void 0;
    this._sharedOptions = void 0;
    this._drawStart = void 0;
    this._drawCount = void 0;
    this.enableOptionSharing = false;
    this.supportsDecimation = false;
    this.$context = void 0;
    this._syncList = [];
    this.datasetElementType = new.target.datasetElementType;
    this.dataElementType = new.target.dataElementType;
    this.initialize();
  }
  initialize() {
    const meta = this._cachedMeta;
    this.configure();
    this.linkScales();
    meta._stacked = isStacked(meta.vScale, meta);
    this.addElements();
    if (this.options.fill && !this.chart.isPluginEnabled("filler")) {
      console.warn("Tried to use the 'fill' option without the 'Filler' plugin enabled. Please import and register the 'Filler' plugin and make sure it is not disabled in the options");
    }
  }
  updateIndex(datasetIndex) {
    if (this.index !== datasetIndex) {
      clearStacks(this._cachedMeta);
    }
    this.index = datasetIndex;
  }
  linkScales() {
    const chart = this.chart;
    const meta = this._cachedMeta;
    const dataset = this.getDataset();
    const chooseId = (axis, x, y, r) => axis === "x" ? x : axis === "r" ? r : y;
    const xid = meta.xAxisID = valueOrDefault(dataset.xAxisID, getFirstScaleId(chart, "x"));
    const yid = meta.yAxisID = valueOrDefault(dataset.yAxisID, getFirstScaleId(chart, "y"));
    const rid = meta.rAxisID = valueOrDefault(dataset.rAxisID, getFirstScaleId(chart, "r"));
    const indexAxis = meta.indexAxis;
    const iid = meta.iAxisID = chooseId(indexAxis, xid, yid, rid);
    const vid = meta.vAxisID = chooseId(indexAxis, yid, xid, rid);
    meta.xScale = this.getScaleForId(xid);
    meta.yScale = this.getScaleForId(yid);
    meta.rScale = this.getScaleForId(rid);
    meta.iScale = this.getScaleForId(iid);
    meta.vScale = this.getScaleForId(vid);
  }
  getDataset() {
    return this.chart.data.datasets[this.index];
  }
  getMeta() {
    return this.chart.getDatasetMeta(this.index);
  }
  getScaleForId(scaleID) {
    return this.chart.scales[scaleID];
  }
  _getOtherScale(scale) {
    const meta = this._cachedMeta;
    return scale === meta.iScale ? meta.vScale : meta.iScale;
  }
  reset() {
    this._update("reset");
  }
  _destroy() {
    const meta = this._cachedMeta;
    if (this._data) {
      unlistenArrayEvents(this._data, this);
    }
    if (meta._stacked) {
      clearStacks(meta);
    }
  }
  _dataCheck() {
    const dataset = this.getDataset();
    const data = dataset.data || (dataset.data = []);
    const _data = this._data;
    if (isObject(data)) {
      const meta = this._cachedMeta;
      this._data = convertObjectDataToArray(data, meta);
    } else if (_data !== data) {
      if (_data) {
        unlistenArrayEvents(_data, this);
        const meta = this._cachedMeta;
        clearStacks(meta);
        meta._parsed = [];
      }
      if (data && Object.isExtensible(data)) {
        listenArrayEvents(data, this);
      }
      this._syncList = [];
      this._data = data;
    }
  }
  addElements() {
    const meta = this._cachedMeta;
    this._dataCheck();
    if (this.datasetElementType) {
      meta.dataset = new this.datasetElementType();
    }
  }
  buildOrUpdateElements(resetNewElements) {
    const meta = this._cachedMeta;
    const dataset = this.getDataset();
    let stackChanged = false;
    this._dataCheck();
    const oldStacked = meta._stacked;
    meta._stacked = isStacked(meta.vScale, meta);
    if (meta.stack !== dataset.stack) {
      stackChanged = true;
      clearStacks(meta);
      meta.stack = dataset.stack;
    }
    this._resyncElements(resetNewElements);
    if (stackChanged || oldStacked !== meta._stacked) {
      updateStacks(this, meta._parsed);
    }
  }
  configure() {
    const config = this.chart.config;
    const scopeKeys = config.datasetScopeKeys(this._type);
    const scopes = config.getOptionScopes(this.getDataset(), scopeKeys, true);
    this.options = config.createResolver(scopes, this.getContext());
    this._parsing = this.options.parsing;
    this._cachedDataOpts = {};
  }
  parse(start, count) {
    const { _cachedMeta: meta, _data: data } = this;
    const { iScale, _stacked } = meta;
    const iAxis = iScale.axis;
    let sorted = start === 0 && count === data.length ? true : meta._sorted;
    let prev = start > 0 && meta._parsed[start - 1];
    let i, cur, parsed;
    if (this._parsing === false) {
      meta._parsed = data;
      meta._sorted = true;
      parsed = data;
    } else {
      if (isArray(data[start])) {
        parsed = this.parseArrayData(meta, data, start, count);
      } else if (isObject(data[start])) {
        parsed = this.parseObjectData(meta, data, start, count);
      } else {
        parsed = this.parsePrimitiveData(meta, data, start, count);
      }
      const isNotInOrderComparedToPrev = () => cur[iAxis] === null || prev && cur[iAxis] < prev[iAxis];
      for (i = 0; i < count; ++i) {
        meta._parsed[i + start] = cur = parsed[i];
        if (sorted) {
          if (isNotInOrderComparedToPrev()) {
            sorted = false;
          }
          prev = cur;
        }
      }
      meta._sorted = sorted;
    }
    if (_stacked) {
      updateStacks(this, parsed);
    }
  }
  parsePrimitiveData(meta, data, start, count) {
    const { iScale, vScale } = meta;
    const iAxis = iScale.axis;
    const vAxis = vScale.axis;
    const labels = iScale.getLabels();
    const singleScale = iScale === vScale;
    const parsed = new Array(count);
    let i, ilen, index2;
    for (i = 0, ilen = count; i < ilen; ++i) {
      index2 = i + start;
      parsed[i] = {
        [iAxis]: singleScale || iScale.parse(labels[index2], index2),
        [vAxis]: vScale.parse(data[index2], index2)
      };
    }
    return parsed;
  }
  parseArrayData(meta, data, start, count) {
    const { xScale, yScale } = meta;
    const parsed = new Array(count);
    let i, ilen, index2, item;
    for (i = 0, ilen = count; i < ilen; ++i) {
      index2 = i + start;
      item = data[index2];
      parsed[i] = {
        x: xScale.parse(item[0], index2),
        y: yScale.parse(item[1], index2)
      };
    }
    return parsed;
  }
  parseObjectData(meta, data, start, count) {
    const { xScale, yScale } = meta;
    const { xAxisKey = "x", yAxisKey = "y" } = this._parsing;
    const parsed = new Array(count);
    let i, ilen, index2, item;
    for (i = 0, ilen = count; i < ilen; ++i) {
      index2 = i + start;
      item = data[index2];
      parsed[i] = {
        x: xScale.parse(resolveObjectKey(item, xAxisKey), index2),
        y: yScale.parse(resolveObjectKey(item, yAxisKey), index2)
      };
    }
    return parsed;
  }
  getParsed(index2) {
    return this._cachedMeta._parsed[index2];
  }
  getDataElement(index2) {
    return this._cachedMeta.data[index2];
  }
  applyStack(scale, parsed, mode) {
    const chart = this.chart;
    const meta = this._cachedMeta;
    const value = parsed[scale.axis];
    const stack = {
      keys: getSortedDatasetIndices(chart, true),
      values: parsed._stacks[scale.axis]._visualValues
    };
    return applyStack(stack, value, meta.index, {
      mode
    });
  }
  updateRangeFromParsed(range, scale, parsed, stack) {
    const parsedValue = parsed[scale.axis];
    let value = parsedValue === null ? NaN : parsedValue;
    const values = stack && parsed._stacks[scale.axis];
    if (stack && values) {
      stack.values = values;
      value = applyStack(stack, parsedValue, this._cachedMeta.index);
    }
    range.min = Math.min(range.min, value);
    range.max = Math.max(range.max, value);
  }
  getMinMax(scale, canStack) {
    const meta = this._cachedMeta;
    const _parsed = meta._parsed;
    const sorted = meta._sorted && scale === meta.iScale;
    const ilen = _parsed.length;
    const otherScale = this._getOtherScale(scale);
    const stack = createStack(canStack, meta, this.chart);
    const range = {
      min: Number.POSITIVE_INFINITY,
      max: Number.NEGATIVE_INFINITY
    };
    const { min: otherMin, max: otherMax } = getUserBounds(otherScale);
    let i, parsed;
    function _skip() {
      parsed = _parsed[i];
      const otherValue = parsed[otherScale.axis];
      return !isNumberFinite(parsed[scale.axis]) || otherMin > otherValue || otherMax < otherValue;
    }
    for (i = 0; i < ilen; ++i) {
      if (_skip()) {
        continue;
      }
      this.updateRangeFromParsed(range, scale, parsed, stack);
      if (sorted) {
        break;
      }
    }
    if (sorted) {
      for (i = ilen - 1; i >= 0; --i) {
        if (_skip()) {
          continue;
        }
        this.updateRangeFromParsed(range, scale, parsed, stack);
        break;
      }
    }
    return range;
  }
  getAllParsedValues(scale) {
    const parsed = this._cachedMeta._parsed;
    const values = [];
    let i, ilen, value;
    for (i = 0, ilen = parsed.length; i < ilen; ++i) {
      value = parsed[i][scale.axis];
      if (isNumberFinite(value)) {
        values.push(value);
      }
    }
    return values;
  }
  getMaxOverflow() {
    return false;
  }
  getLabelAndValue(index2) {
    const meta = this._cachedMeta;
    const iScale = meta.iScale;
    const vScale = meta.vScale;
    const parsed = this.getParsed(index2);
    return {
      label: iScale ? "" + iScale.getLabelForValue(parsed[iScale.axis]) : "",
      value: vScale ? "" + vScale.getLabelForValue(parsed[vScale.axis]) : ""
    };
  }
  _update(mode) {
    const meta = this._cachedMeta;
    this.update(mode || "default");
    meta._clip = toClip(valueOrDefault(this.options.clip, defaultClip(meta.xScale, meta.yScale, this.getMaxOverflow())));
  }
  update(mode) {
  }
  draw() {
    const ctx = this._ctx;
    const chart = this.chart;
    const meta = this._cachedMeta;
    const elements2 = meta.data || [];
    const area = chart.chartArea;
    const active = [];
    const start = this._drawStart || 0;
    const count = this._drawCount || elements2.length - start;
    const drawActiveElementsOnTop = this.options.drawActiveElementsOnTop;
    let i;
    if (meta.dataset) {
      meta.dataset.draw(ctx, area, start, count);
    }
    for (i = start; i < start + count; ++i) {
      const element = elements2[i];
      if (element.hidden) {
        continue;
      }
      if (element.active && drawActiveElementsOnTop) {
        active.push(element);
      } else {
        element.draw(ctx, area);
      }
    }
    for (i = 0; i < active.length; ++i) {
      active[i].draw(ctx, area);
    }
  }
  getStyle(index2, active) {
    const mode = active ? "active" : "default";
    return index2 === void 0 && this._cachedMeta.dataset ? this.resolveDatasetElementOptions(mode) : this.resolveDataElementOptions(index2 || 0, mode);
  }
  getContext(index2, active, mode) {
    const dataset = this.getDataset();
    let context;
    if (index2 >= 0 && index2 < this._cachedMeta.data.length) {
      const element = this._cachedMeta.data[index2];
      context = element.$context || (element.$context = createDataContext(this.getContext(), index2, element));
      context.parsed = this.getParsed(index2);
      context.raw = dataset.data[index2];
      context.index = context.dataIndex = index2;
    } else {
      context = this.$context || (this.$context = createDatasetContext(this.chart.getContext(), this.index));
      context.dataset = dataset;
      context.index = context.datasetIndex = this.index;
    }
    context.active = !!active;
    context.mode = mode;
    return context;
  }
  resolveDatasetElementOptions(mode) {
    return this._resolveElementOptions(this.datasetElementType.id, mode);
  }
  resolveDataElementOptions(index2, mode) {
    return this._resolveElementOptions(this.dataElementType.id, mode, index2);
  }
  _resolveElementOptions(elementType, mode = "default", index2) {
    const active = mode === "active";
    const cache = this._cachedDataOpts;
    const cacheKey = elementType + "-" + mode;
    const cached = cache[cacheKey];
    const sharing = this.enableOptionSharing && defined(index2);
    if (cached) {
      return cloneIfNotShared(cached, sharing);
    }
    const config = this.chart.config;
    const scopeKeys = config.datasetElementScopeKeys(this._type, elementType);
    const prefixes = active ? [
      `${elementType}Hover`,
      "hover",
      elementType,
      ""
    ] : [
      elementType,
      ""
    ];
    const scopes = config.getOptionScopes(this.getDataset(), scopeKeys);
    const names2 = Object.keys(defaults.elements[elementType]);
    const context = () => this.getContext(index2, active, mode);
    const values = config.resolveNamedOptions(scopes, names2, context, prefixes);
    if (values.$shared) {
      values.$shared = sharing;
      cache[cacheKey] = Object.freeze(cloneIfNotShared(values, sharing));
    }
    return values;
  }
  _resolveAnimations(index2, transition, active) {
    const chart = this.chart;
    const cache = this._cachedDataOpts;
    const cacheKey = `animation-${transition}`;
    const cached = cache[cacheKey];
    if (cached) {
      return cached;
    }
    let options;
    if (chart.options.animation !== false) {
      const config = this.chart.config;
      const scopeKeys = config.datasetAnimationScopeKeys(this._type, transition);
      const scopes = config.getOptionScopes(this.getDataset(), scopeKeys);
      options = config.createResolver(scopes, this.getContext(index2, active, transition));
    }
    const animations = new Animations(chart, options && options.animations);
    if (options && options._cacheable) {
      cache[cacheKey] = Object.freeze(animations);
    }
    return animations;
  }
  getSharedOptions(options) {
    if (!options.$shared) {
      return;
    }
    return this._sharedOptions || (this._sharedOptions = Object.assign({}, options));
  }
  includeOptions(mode, sharedOptions) {
    return !sharedOptions || isDirectUpdateMode(mode) || this.chart._animationsDisabled;
  }
  _getSharedOptions(start, mode) {
    const firstOpts = this.resolveDataElementOptions(start, mode);
    const previouslySharedOptions = this._sharedOptions;
    const sharedOptions = this.getSharedOptions(firstOpts);
    const includeOptions = this.includeOptions(mode, sharedOptions) || sharedOptions !== previouslySharedOptions;
    this.updateSharedOptions(sharedOptions, mode, firstOpts);
    return {
      sharedOptions,
      includeOptions
    };
  }
  updateElement(element, index2, properties, mode) {
    if (isDirectUpdateMode(mode)) {
      Object.assign(element, properties);
    } else {
      this._resolveAnimations(index2, mode).update(element, properties);
    }
  }
  updateSharedOptions(sharedOptions, mode, newOptions) {
    if (sharedOptions && !isDirectUpdateMode(mode)) {
      this._resolveAnimations(void 0, mode).update(sharedOptions, newOptions);
    }
  }
  _setStyle(element, index2, mode, active) {
    element.active = active;
    const options = this.getStyle(index2, active);
    this._resolveAnimations(index2, mode, active).update(element, {
      options: !active && this.getSharedOptions(options) || options
    });
  }
  removeHoverStyle(element, datasetIndex, index2) {
    this._setStyle(element, index2, "active", false);
  }
  setHoverStyle(element, datasetIndex, index2) {
    this._setStyle(element, index2, "active", true);
  }
  _removeDatasetHoverStyle() {
    const element = this._cachedMeta.dataset;
    if (element) {
      this._setStyle(element, void 0, "active", false);
    }
  }
  _setDatasetHoverStyle() {
    const element = this._cachedMeta.dataset;
    if (element) {
      this._setStyle(element, void 0, "active", true);
    }
  }
  _resyncElements(resetNewElements) {
    const data = this._data;
    const elements2 = this._cachedMeta.data;
    for (const [method, arg1, arg2] of this._syncList) {
      this[method](arg1, arg2);
    }
    this._syncList = [];
    const numMeta = elements2.length;
    const numData = data.length;
    const count = Math.min(numData, numMeta);
    if (count) {
      this.parse(0, count);
    }
    if (numData > numMeta) {
      this._insertElements(numMeta, numData - numMeta, resetNewElements);
    } else if (numData < numMeta) {
      this._removeElements(numData, numMeta - numData);
    }
  }
  _insertElements(start, count, resetNewElements = true) {
    const meta = this._cachedMeta;
    const data = meta.data;
    const end = start + count;
    let i;
    const move = (arr) => {
      arr.length += count;
      for (i = arr.length - 1; i >= end; i--) {
        arr[i] = arr[i - count];
      }
    };
    move(data);
    for (i = start; i < end; ++i) {
      data[i] = new this.dataElementType();
    }
    if (this._parsing) {
      move(meta._parsed);
    }
    this.parse(start, count);
    if (resetNewElements) {
      this.updateElements(data, start, count, "reset");
    }
  }
  updateElements(element, start, count, mode) {
  }
  _removeElements(start, count) {
    const meta = this._cachedMeta;
    if (this._parsing) {
      const removed = meta._parsed.splice(start, count);
      if (meta._stacked) {
        clearStacks(meta, removed);
      }
    }
    meta.data.splice(start, count);
  }
  _sync(args) {
    if (this._parsing) {
      this._syncList.push(args);
    } else {
      const [method, arg1, arg2] = args;
      this[method](arg1, arg2);
    }
    this.chart._dataChanges.push([
      this.index,
      ...args
    ]);
  }
  _onDataPush() {
    const count = arguments.length;
    this._sync([
      "_insertElements",
      this.getDataset().data.length - count,
      count
    ]);
  }
  _onDataPop() {
    this._sync([
      "_removeElements",
      this._cachedMeta.data.length - 1,
      1
    ]);
  }
  _onDataShift() {
    this._sync([
      "_removeElements",
      0,
      1
    ]);
  }
  _onDataSplice(start, count) {
    if (count) {
      this._sync([
        "_removeElements",
        start,
        count
      ]);
    }
    const newCount = arguments.length - 2;
    if (newCount) {
      this._sync([
        "_insertElements",
        start,
        newCount
      ]);
    }
  }
  _onDataUnshift() {
    this._sync([
      "_insertElements",
      0,
      arguments.length
    ]);
  }
};
__publicField(DatasetController, "defaults", {});
__publicField(DatasetController, "datasetElementType", null);
__publicField(DatasetController, "dataElementType", null);
function getAllScaleValues(scale, type) {
  if (!scale._cache.$bar) {
    const visibleMetas = scale.getMatchingVisibleMetas(type);
    let values = [];
    for (let i = 0, ilen = visibleMetas.length; i < ilen; i++) {
      values = values.concat(visibleMetas[i].controller.getAllParsedValues(scale));
    }
    scale._cache.$bar = _arrayUnique(values.sort((a, b) => a - b));
  }
  return scale._cache.$bar;
}
function computeMinSampleSize(meta) {
  const scale = meta.iScale;
  const values = getAllScaleValues(scale, meta.type);
  let min = scale._length;
  let i, ilen, curr, prev;
  const updateMinAndPrev = () => {
    if (curr === 32767 || curr === -32768) {
      return;
    }
    if (defined(prev)) {
      min = Math.min(min, Math.abs(curr - prev) || min);
    }
    prev = curr;
  };
  for (i = 0, ilen = values.length; i < ilen; ++i) {
    curr = scale.getPixelForValue(values[i]);
    updateMinAndPrev();
  }
  prev = void 0;
  for (i = 0, ilen = scale.ticks.length; i < ilen; ++i) {
    curr = scale.getPixelForTick(i);
    updateMinAndPrev();
  }
  return min;
}
function computeFitCategoryTraits(index2, ruler, options, stackCount) {
  const thickness = options.barThickness;
  let size, ratio;
  if (isNullOrUndef(thickness)) {
    size = ruler.min * options.categoryPercentage;
    ratio = options.barPercentage;
  } else {
    size = thickness * stackCount;
    ratio = 1;
  }
  return {
    chunk: size / stackCount,
    ratio,
    start: ruler.pixels[index2] - size / 2
  };
}
function computeFlexCategoryTraits(index2, ruler, options, stackCount) {
  const pixels = ruler.pixels;
  const curr = pixels[index2];
  let prev = index2 > 0 ? pixels[index2 - 1] : null;
  let next = index2 < pixels.length - 1 ? pixels[index2 + 1] : null;
  const percent = options.categoryPercentage;
  if (prev === null) {
    prev = curr - (next === null ? ruler.end - ruler.start : next - curr);
  }
  if (next === null) {
    next = curr + curr - prev;
  }
  const start = curr - (curr - Math.min(prev, next)) / 2 * percent;
  const size = Math.abs(next - prev) / 2 * percent;
  return {
    chunk: size / stackCount,
    ratio: options.barPercentage,
    start
  };
}
function parseFloatBar(entry, item, vScale, i) {
  const startValue = vScale.parse(entry[0], i);
  const endValue = vScale.parse(entry[1], i);
  const min = Math.min(startValue, endValue);
  const max = Math.max(startValue, endValue);
  let barStart = min;
  let barEnd = max;
  if (Math.abs(min) > Math.abs(max)) {
    barStart = max;
    barEnd = min;
  }
  item[vScale.axis] = barEnd;
  item._custom = {
    barStart,
    barEnd,
    start: startValue,
    end: endValue,
    min,
    max
  };
}
function parseValue(entry, item, vScale, i) {
  if (isArray(entry)) {
    parseFloatBar(entry, item, vScale, i);
  } else {
    item[vScale.axis] = vScale.parse(entry, i);
  }
  return item;
}
function parseArrayOrPrimitive(meta, data, start, count) {
  const iScale = meta.iScale;
  const vScale = meta.vScale;
  const labels = iScale.getLabels();
  const singleScale = iScale === vScale;
  const parsed = [];
  let i, ilen, item, entry;
  for (i = start, ilen = start + count; i < ilen; ++i) {
    entry = data[i];
    item = {};
    item[iScale.axis] = singleScale || iScale.parse(labels[i], i);
    parsed.push(parseValue(entry, item, vScale, i));
  }
  return parsed;
}
function isFloatBar(custom) {
  return custom && custom.barStart !== void 0 && custom.barEnd !== void 0;
}
function barSign(size, vScale, actualBase) {
  if (size !== 0) {
    return sign(size);
  }
  return (vScale.isHorizontal() ? 1 : -1) * (vScale.min >= actualBase ? 1 : -1);
}
function borderProps(properties) {
  let reverse, start, end, top, bottom;
  if (properties.horizontal) {
    reverse = properties.base > properties.x;
    start = "left";
    end = "right";
  } else {
    reverse = properties.base < properties.y;
    start = "bottom";
    end = "top";
  }
  if (reverse) {
    top = "end";
    bottom = "start";
  } else {
    top = "start";
    bottom = "end";
  }
  return {
    start,
    end,
    reverse,
    top,
    bottom
  };
}
function setBorderSkipped(properties, options, stack, index2) {
  let edge = options.borderSkipped;
  const res = {};
  if (!edge) {
    properties.borderSkipped = res;
    return;
  }
  if (edge === true) {
    properties.borderSkipped = {
      top: true,
      right: true,
      bottom: true,
      left: true
    };
    return;
  }
  const { start, end, reverse, top, bottom } = borderProps(properties);
  if (edge === "middle" && stack) {
    properties.enableBorderRadius = true;
    if ((stack._top || 0) === index2) {
      edge = top;
    } else if ((stack._bottom || 0) === index2) {
      edge = bottom;
    } else {
      res[parseEdge(bottom, start, end, reverse)] = true;
      edge = top;
    }
  }
  res[parseEdge(edge, start, end, reverse)] = true;
  properties.borderSkipped = res;
}
function parseEdge(edge, a, b, reverse) {
  if (reverse) {
    edge = swap(edge, a, b);
    edge = startEnd(edge, b, a);
  } else {
    edge = startEnd(edge, a, b);
  }
  return edge;
}
function swap(orig, v1, v2) {
  return orig === v1 ? v2 : orig === v2 ? v1 : orig;
}
function startEnd(v, start, end) {
  return v === "start" ? start : v === "end" ? end : v;
}
function setInflateAmount(properties, { inflateAmount }, ratio) {
  properties.inflateAmount = inflateAmount === "auto" ? ratio === 1 ? 0.33 : 0 : inflateAmount;
}
var BarController = class extends DatasetController {
  parsePrimitiveData(meta, data, start, count) {
    return parseArrayOrPrimitive(meta, data, start, count);
  }
  parseArrayData(meta, data, start, count) {
    return parseArrayOrPrimitive(meta, data, start, count);
  }
  parseObjectData(meta, data, start, count) {
    const { iScale, vScale } = meta;
    const { xAxisKey = "x", yAxisKey = "y" } = this._parsing;
    const iAxisKey = iScale.axis === "x" ? xAxisKey : yAxisKey;
    const vAxisKey = vScale.axis === "x" ? xAxisKey : yAxisKey;
    const parsed = [];
    let i, ilen, item, obj;
    for (i = start, ilen = start + count; i < ilen; ++i) {
      obj = data[i];
      item = {};
      item[iScale.axis] = iScale.parse(resolveObjectKey(obj, iAxisKey), i);
      parsed.push(parseValue(resolveObjectKey(obj, vAxisKey), item, vScale, i));
    }
    return parsed;
  }
  updateRangeFromParsed(range, scale, parsed, stack) {
    super.updateRangeFromParsed(range, scale, parsed, stack);
    const custom = parsed._custom;
    if (custom && scale === this._cachedMeta.vScale) {
      range.min = Math.min(range.min, custom.min);
      range.max = Math.max(range.max, custom.max);
    }
  }
  getMaxOverflow() {
    return 0;
  }
  getLabelAndValue(index2) {
    const meta = this._cachedMeta;
    const { iScale, vScale } = meta;
    const parsed = this.getParsed(index2);
    const custom = parsed._custom;
    const value = isFloatBar(custom) ? "[" + custom.start + ", " + custom.end + "]" : "" + vScale.getLabelForValue(parsed[vScale.axis]);
    return {
      label: "" + iScale.getLabelForValue(parsed[iScale.axis]),
      value
    };
  }
  initialize() {
    this.enableOptionSharing = true;
    super.initialize();
    const meta = this._cachedMeta;
    meta.stack = this.getDataset().stack;
  }
  update(mode) {
    const meta = this._cachedMeta;
    this.updateElements(meta.data, 0, meta.data.length, mode);
  }
  updateElements(bars, start, count, mode) {
    const reset = mode === "reset";
    const { index: index2, _cachedMeta: { vScale } } = this;
    const base = vScale.getBasePixel();
    const horizontal = vScale.isHorizontal();
    const ruler = this._getRuler();
    const { sharedOptions, includeOptions } = this._getSharedOptions(start, mode);
    for (let i = start; i < start + count; i++) {
      const parsed = this.getParsed(i);
      const vpixels = reset || isNullOrUndef(parsed[vScale.axis]) ? {
        base,
        head: base
      } : this._calculateBarValuePixels(i);
      const ipixels = this._calculateBarIndexPixels(i, ruler);
      const stack = (parsed._stacks || {})[vScale.axis];
      const properties = {
        horizontal,
        base: vpixels.base,
        enableBorderRadius: !stack || isFloatBar(parsed._custom) || index2 === stack._top || index2 === stack._bottom,
        x: horizontal ? vpixels.head : ipixels.center,
        y: horizontal ? ipixels.center : vpixels.head,
        height: horizontal ? ipixels.size : Math.abs(vpixels.size),
        width: horizontal ? Math.abs(vpixels.size) : ipixels.size
      };
      if (includeOptions) {
        properties.options = sharedOptions || this.resolveDataElementOptions(i, bars[i].active ? "active" : mode);
      }
      const options = properties.options || bars[i].options;
      setBorderSkipped(properties, options, stack, index2);
      setInflateAmount(properties, options, ruler.ratio);
      this.updateElement(bars[i], i, properties, mode);
    }
  }
  _getStacks(last, dataIndex) {
    const { iScale } = this._cachedMeta;
    const metasets = iScale.getMatchingVisibleMetas(this._type).filter((meta) => meta.controller.options.grouped);
    const stacked = iScale.options.stacked;
    const stacks = [];
    const currentParsed = this._cachedMeta.controller.getParsed(dataIndex);
    const iScaleValue = currentParsed && currentParsed[iScale.axis];
    const skipNull = (meta) => {
      const parsed = meta._parsed.find((item) => item[iScale.axis] === iScaleValue);
      const val = parsed && parsed[meta.vScale.axis];
      if (isNullOrUndef(val) || isNaN(val)) {
        return true;
      }
    };
    for (const meta of metasets) {
      if (dataIndex !== void 0 && skipNull(meta)) {
        continue;
      }
      if (stacked === false || stacks.indexOf(meta.stack) === -1 || stacked === void 0 && meta.stack === void 0) {
        stacks.push(meta.stack);
      }
      if (meta.index === last) {
        break;
      }
    }
    if (!stacks.length) {
      stacks.push(void 0);
    }
    return stacks;
  }
  _getStackCount(index2) {
    return this._getStacks(void 0, index2).length;
  }
  _getStackIndex(datasetIndex, name, dataIndex) {
    const stacks = this._getStacks(datasetIndex, dataIndex);
    const index2 = name !== void 0 ? stacks.indexOf(name) : -1;
    return index2 === -1 ? stacks.length - 1 : index2;
  }
  _getRuler() {
    const opts = this.options;
    const meta = this._cachedMeta;
    const iScale = meta.iScale;
    const pixels = [];
    let i, ilen;
    for (i = 0, ilen = meta.data.length; i < ilen; ++i) {
      pixels.push(iScale.getPixelForValue(this.getParsed(i)[iScale.axis], i));
    }
    const barThickness = opts.barThickness;
    const min = barThickness || computeMinSampleSize(meta);
    return {
      min,
      pixels,
      start: iScale._startPixel,
      end: iScale._endPixel,
      stackCount: this._getStackCount(),
      scale: iScale,
      grouped: opts.grouped,
      ratio: barThickness ? 1 : opts.categoryPercentage * opts.barPercentage
    };
  }
  _calculateBarValuePixels(index2) {
    const { _cachedMeta: { vScale, _stacked, index: datasetIndex }, options: { base: baseValue, minBarLength } } = this;
    const actualBase = baseValue || 0;
    const parsed = this.getParsed(index2);
    const custom = parsed._custom;
    const floating = isFloatBar(custom);
    let value = parsed[vScale.axis];
    let start = 0;
    let length = _stacked ? this.applyStack(vScale, parsed, _stacked) : value;
    let head, size;
    if (length !== value) {
      start = length - value;
      length = value;
    }
    if (floating) {
      value = custom.barStart;
      length = custom.barEnd - custom.barStart;
      if (value !== 0 && sign(value) !== sign(custom.barEnd)) {
        start = 0;
      }
      start += value;
    }
    const startValue = !isNullOrUndef(baseValue) && !floating ? baseValue : start;
    let base = vScale.getPixelForValue(startValue);
    if (this.chart.getDataVisibility(index2)) {
      head = vScale.getPixelForValue(start + length);
    } else {
      head = base;
    }
    size = head - base;
    if (Math.abs(size) < minBarLength) {
      size = barSign(size, vScale, actualBase) * minBarLength;
      if (value === actualBase) {
        base -= size / 2;
      }
      const startPixel = vScale.getPixelForDecimal(0);
      const endPixel = vScale.getPixelForDecimal(1);
      const min = Math.min(startPixel, endPixel);
      const max = Math.max(startPixel, endPixel);
      base = Math.max(Math.min(base, max), min);
      head = base + size;
      if (_stacked && !floating) {
        parsed._stacks[vScale.axis]._visualValues[datasetIndex] = vScale.getValueForPixel(head) - vScale.getValueForPixel(base);
      }
    }
    if (base === vScale.getPixelForValue(actualBase)) {
      const halfGrid = sign(size) * vScale.getLineWidthForValue(actualBase) / 2;
      base += halfGrid;
      size -= halfGrid;
    }
    return {
      size,
      base,
      head,
      center: head + size / 2
    };
  }
  _calculateBarIndexPixels(index2, ruler) {
    const scale = ruler.scale;
    const options = this.options;
    const skipNull = options.skipNull;
    const maxBarThickness = valueOrDefault(options.maxBarThickness, Infinity);
    let center, size;
    if (ruler.grouped) {
      const stackCount = skipNull ? this._getStackCount(index2) : ruler.stackCount;
      const range = options.barThickness === "flex" ? computeFlexCategoryTraits(index2, ruler, options, stackCount) : computeFitCategoryTraits(index2, ruler, options, stackCount);
      const stackIndex = this._getStackIndex(this.index, this._cachedMeta.stack, skipNull ? index2 : void 0);
      center = range.start + range.chunk * stackIndex + range.chunk / 2;
      size = Math.min(maxBarThickness, range.chunk * range.ratio);
    } else {
      center = scale.getPixelForValue(this.getParsed(index2)[scale.axis], index2);
      size = Math.min(maxBarThickness, ruler.min * ruler.ratio);
    }
    return {
      base: center - size / 2,
      head: center + size / 2,
      center,
      size
    };
  }
  draw() {
    const meta = this._cachedMeta;
    const vScale = meta.vScale;
    const rects = meta.data;
    const ilen = rects.length;
    let i = 0;
    for (; i < ilen; ++i) {
      if (this.getParsed(i)[vScale.axis] !== null && !rects[i].hidden) {
        rects[i].draw(this._ctx);
      }
    }
  }
};
__publicField(BarController, "id", "bar");
__publicField(BarController, "defaults", {
  datasetElementType: false,
  dataElementType: "bar",
  categoryPercentage: 0.8,
  barPercentage: 0.9,
  grouped: true,
  animations: {
    numbers: {
      type: "number",
      properties: [
        "x",
        "y",
        "base",
        "width",
        "height"
      ]
    }
  }
});
__publicField(BarController, "overrides", {
  scales: {
    _index_: {
      type: "category",
      offset: true,
      grid: {
        offset: true
      }
    },
    _value_: {
      type: "linear",
      beginAtZero: true
    }
  }
});
var BubbleController = class extends DatasetController {
  initialize() {
    this.enableOptionSharing = true;
    super.initialize();
  }
  parsePrimitiveData(meta, data, start, count) {
    const parsed = super.parsePrimitiveData(meta, data, start, count);
    for (let i = 0; i < parsed.length; i++) {
      parsed[i]._custom = this.resolveDataElementOptions(i + start).radius;
    }
    return parsed;
  }
  parseArrayData(meta, data, start, count) {
    const parsed = super.parseArrayData(meta, data, start, count);
    for (let i = 0; i < parsed.length; i++) {
      const item = data[start + i];
      parsed[i]._custom = valueOrDefault(item[2], this.resolveDataElementOptions(i + start).radius);
    }
    return parsed;
  }
  parseObjectData(meta, data, start, count) {
    const parsed = super.parseObjectData(meta, data, start, count);
    for (let i = 0; i < parsed.length; i++) {
      const item = data[start + i];
      parsed[i]._custom = valueOrDefault(item && item.r && +item.r, this.resolveDataElementOptions(i + start).radius);
    }
    return parsed;
  }
  getMaxOverflow() {
    const data = this._cachedMeta.data;
    let max = 0;
    for (let i = data.length - 1; i >= 0; --i) {
      max = Math.max(max, data[i].size(this.resolveDataElementOptions(i)) / 2);
    }
    return max > 0 && max;
  }
  getLabelAndValue(index2) {
    const meta = this._cachedMeta;
    const labels = this.chart.data.labels || [];
    const { xScale, yScale } = meta;
    const parsed = this.getParsed(index2);
    const x = xScale.getLabelForValue(parsed.x);
    const y = yScale.getLabelForValue(parsed.y);
    const r = parsed._custom;
    return {
      label: labels[index2] || "",
      value: "(" + x + ", " + y + (r ? ", " + r : "") + ")"
    };
  }
  update(mode) {
    const points = this._cachedMeta.data;
    this.updateElements(points, 0, points.length, mode);
  }
  updateElements(points, start, count, mode) {
    const reset = mode === "reset";
    const { iScale, vScale } = this._cachedMeta;
    const { sharedOptions, includeOptions } = this._getSharedOptions(start, mode);
    const iAxis = iScale.axis;
    const vAxis = vScale.axis;
    for (let i = start; i < start + count; i++) {
      const point = points[i];
      const parsed = !reset && this.getParsed(i);
      const properties = {};
      const iPixel = properties[iAxis] = reset ? iScale.getPixelForDecimal(0.5) : iScale.getPixelForValue(parsed[iAxis]);
      const vPixel = properties[vAxis] = reset ? vScale.getBasePixel() : vScale.getPixelForValue(parsed[vAxis]);
      properties.skip = isNaN(iPixel) || isNaN(vPixel);
      if (includeOptions) {
        properties.options = sharedOptions || this.resolveDataElementOptions(i, point.active ? "active" : mode);
        if (reset) {
          properties.options.radius = 0;
        }
      }
      this.updateElement(point, i, properties, mode);
    }
  }
  resolveDataElementOptions(index2, mode) {
    const parsed = this.getParsed(index2);
    let values = super.resolveDataElementOptions(index2, mode);
    if (values.$shared) {
      values = Object.assign({}, values, {
        $shared: false
      });
    }
    const radius = values.radius;
    if (mode !== "active") {
      values.radius = 0;
    }
    values.radius += valueOrDefault(parsed && parsed._custom, radius);
    return values;
  }
};
__publicField(BubbleController, "id", "bubble");
__publicField(BubbleController, "defaults", {
  datasetElementType: false,
  dataElementType: "point",
  animations: {
    numbers: {
      type: "number",
      properties: [
        "x",
        "y",
        "borderWidth",
        "radius"
      ]
    }
  }
});
__publicField(BubbleController, "overrides", {
  scales: {
    x: {
      type: "linear"
    },
    y: {
      type: "linear"
    }
  }
});
function getRatioAndOffset(rotation, circumference, cutout) {
  let ratioX = 1;
  let ratioY = 1;
  let offsetX = 0;
  let offsetY = 0;
  if (circumference < TAU) {
    const startAngle = rotation;
    const endAngle = startAngle + circumference;
    const startX = Math.cos(startAngle);
    const startY = Math.sin(startAngle);
    const endX = Math.cos(endAngle);
    const endY = Math.sin(endAngle);
    const calcMax = (angle, a, b) => _angleBetween(angle, startAngle, endAngle, true) ? 1 : Math.max(a, a * cutout, b, b * cutout);
    const calcMin = (angle, a, b) => _angleBetween(angle, startAngle, endAngle, true) ? -1 : Math.min(a, a * cutout, b, b * cutout);
    const maxX = calcMax(0, startX, endX);
    const maxY = calcMax(HALF_PI, startY, endY);
    const minX = calcMin(PI, startX, endX);
    const minY = calcMin(PI + HALF_PI, startY, endY);
    ratioX = (maxX - minX) / 2;
    ratioY = (maxY - minY) / 2;
    offsetX = -(maxX + minX) / 2;
    offsetY = -(maxY + minY) / 2;
  }
  return {
    ratioX,
    ratioY,
    offsetX,
    offsetY
  };
}
var DoughnutController = class extends DatasetController {
  constructor(chart, datasetIndex) {
    super(chart, datasetIndex);
    this.enableOptionSharing = true;
    this.innerRadius = void 0;
    this.outerRadius = void 0;
    this.offsetX = void 0;
    this.offsetY = void 0;
  }
  linkScales() {
  }
  parse(start, count) {
    const data = this.getDataset().data;
    const meta = this._cachedMeta;
    if (this._parsing === false) {
      meta._parsed = data;
    } else {
      let getter = (i2) => +data[i2];
      if (isObject(data[start])) {
        const { key = "value" } = this._parsing;
        getter = (i2) => +resolveObjectKey(data[i2], key);
      }
      let i, ilen;
      for (i = start, ilen = start + count; i < ilen; ++i) {
        meta._parsed[i] = getter(i);
      }
    }
  }
  _getRotation() {
    return toRadians(this.options.rotation - 90);
  }
  _getCircumference() {
    return toRadians(this.options.circumference);
  }
  _getRotationExtents() {
    let min = TAU;
    let max = -TAU;
    for (let i = 0; i < this.chart.data.datasets.length; ++i) {
      if (this.chart.isDatasetVisible(i) && this.chart.getDatasetMeta(i).type === this._type) {
        const controller = this.chart.getDatasetMeta(i).controller;
        const rotation = controller._getRotation();
        const circumference = controller._getCircumference();
        min = Math.min(min, rotation);
        max = Math.max(max, rotation + circumference);
      }
    }
    return {
      rotation: min,
      circumference: max - min
    };
  }
  update(mode) {
    const chart = this.chart;
    const { chartArea } = chart;
    const meta = this._cachedMeta;
    const arcs = meta.data;
    const spacing = this.getMaxBorderWidth() + this.getMaxOffset(arcs) + this.options.spacing;
    const maxSize = Math.max((Math.min(chartArea.width, chartArea.height) - spacing) / 2, 0);
    const cutout = Math.min(toPercentage(this.options.cutout, maxSize), 1);
    const chartWeight = this._getRingWeight(this.index);
    const { circumference, rotation } = this._getRotationExtents();
    const { ratioX, ratioY, offsetX, offsetY } = getRatioAndOffset(rotation, circumference, cutout);
    const maxWidth = (chartArea.width - spacing) / ratioX;
    const maxHeight = (chartArea.height - spacing) / ratioY;
    const maxRadius = Math.max(Math.min(maxWidth, maxHeight) / 2, 0);
    const outerRadius = toDimension(this.options.radius, maxRadius);
    const innerRadius = Math.max(outerRadius * cutout, 0);
    const radiusLength = (outerRadius - innerRadius) / this._getVisibleDatasetWeightTotal();
    this.offsetX = offsetX * outerRadius;
    this.offsetY = offsetY * outerRadius;
    meta.total = this.calculateTotal();
    this.outerRadius = outerRadius - radiusLength * this._getRingWeightOffset(this.index);
    this.innerRadius = Math.max(this.outerRadius - radiusLength * chartWeight, 0);
    this.updateElements(arcs, 0, arcs.length, mode);
  }
  _circumference(i, reset) {
    const opts = this.options;
    const meta = this._cachedMeta;
    const circumference = this._getCircumference();
    if (reset && opts.animation.animateRotate || !this.chart.getDataVisibility(i) || meta._parsed[i] === null || meta.data[i].hidden) {
      return 0;
    }
    return this.calculateCircumference(meta._parsed[i] * circumference / TAU);
  }
  updateElements(arcs, start, count, mode) {
    const reset = mode === "reset";
    const chart = this.chart;
    const chartArea = chart.chartArea;
    const opts = chart.options;
    const animationOpts = opts.animation;
    const centerX = (chartArea.left + chartArea.right) / 2;
    const centerY = (chartArea.top + chartArea.bottom) / 2;
    const animateScale = reset && animationOpts.animateScale;
    const innerRadius = animateScale ? 0 : this.innerRadius;
    const outerRadius = animateScale ? 0 : this.outerRadius;
    const { sharedOptions, includeOptions } = this._getSharedOptions(start, mode);
    let startAngle = this._getRotation();
    let i;
    for (i = 0; i < start; ++i) {
      startAngle += this._circumference(i, reset);
    }
    for (i = start; i < start + count; ++i) {
      const circumference = this._circumference(i, reset);
      const arc = arcs[i];
      const properties = {
        x: centerX + this.offsetX,
        y: centerY + this.offsetY,
        startAngle,
        endAngle: startAngle + circumference,
        circumference,
        outerRadius,
        innerRadius
      };
      if (includeOptions) {
        properties.options = sharedOptions || this.resolveDataElementOptions(i, arc.active ? "active" : mode);
      }
      startAngle += circumference;
      this.updateElement(arc, i, properties, mode);
    }
  }
  calculateTotal() {
    const meta = this._cachedMeta;
    const metaData = meta.data;
    let total = 0;
    let i;
    for (i = 0; i < metaData.length; i++) {
      const value = meta._parsed[i];
      if (value !== null && !isNaN(value) && this.chart.getDataVisibility(i) && !metaData[i].hidden) {
        total += Math.abs(value);
      }
    }
    return total;
  }
  calculateCircumference(value) {
    const total = this._cachedMeta.total;
    if (total > 0 && !isNaN(value)) {
      return TAU * (Math.abs(value) / total);
    }
    return 0;
  }
  getLabelAndValue(index2) {
    const meta = this._cachedMeta;
    const chart = this.chart;
    const labels = chart.data.labels || [];
    const value = formatNumber(meta._parsed[index2], chart.options.locale);
    return {
      label: labels[index2] || "",
      value
    };
  }
  getMaxBorderWidth(arcs) {
    let max = 0;
    const chart = this.chart;
    let i, ilen, meta, controller, options;
    if (!arcs) {
      for (i = 0, ilen = chart.data.datasets.length; i < ilen; ++i) {
        if (chart.isDatasetVisible(i)) {
          meta = chart.getDatasetMeta(i);
          arcs = meta.data;
          controller = meta.controller;
          break;
        }
      }
    }
    if (!arcs) {
      return 0;
    }
    for (i = 0, ilen = arcs.length; i < ilen; ++i) {
      options = controller.resolveDataElementOptions(i);
      if (options.borderAlign !== "inner") {
        max = Math.max(max, options.borderWidth || 0, options.hoverBorderWidth || 0);
      }
    }
    return max;
  }
  getMaxOffset(arcs) {
    let max = 0;
    for (let i = 0, ilen = arcs.length; i < ilen; ++i) {
      const options = this.resolveDataElementOptions(i);
      max = Math.max(max, options.offset || 0, options.hoverOffset || 0);
    }
    return max;
  }
  _getRingWeightOffset(datasetIndex) {
    let ringWeightOffset = 0;
    for (let i = 0; i < datasetIndex; ++i) {
      if (this.chart.isDatasetVisible(i)) {
        ringWeightOffset += this._getRingWeight(i);
      }
    }
    return ringWeightOffset;
  }
  _getRingWeight(datasetIndex) {
    return Math.max(valueOrDefault(this.chart.data.datasets[datasetIndex].weight, 1), 0);
  }
  _getVisibleDatasetWeightTotal() {
    return this._getRingWeightOffset(this.chart.data.datasets.length) || 1;
  }
};
__publicField(DoughnutController, "id", "doughnut");
__publicField(DoughnutController, "defaults", {
  datasetElementType: false,
  dataElementType: "arc",
  animation: {
    animateRotate: true,
    animateScale: false
  },
  animations: {
    numbers: {
      type: "number",
      properties: [
        "circumference",
        "endAngle",
        "innerRadius",
        "outerRadius",
        "startAngle",
        "x",
        "y",
        "offset",
        "borderWidth",
        "spacing"
      ]
    }
  },
  cutout: "50%",
  rotation: 0,
  circumference: 360,
  radius: "100%",
  spacing: 0,
  indexAxis: "r"
});
__publicField(DoughnutController, "descriptors", {
  _scriptable: (name) => name !== "spacing",
  _indexable: (name) => name !== "spacing" && !name.startsWith("borderDash") && !name.startsWith("hoverBorderDash")
});
__publicField(DoughnutController, "overrides", {
  aspectRatio: 1,
  plugins: {
    legend: {
      labels: {
        generateLabels(chart) {
          const data = chart.data;
          if (data.labels.length && data.datasets.length) {
            const { labels: { pointStyle, color: color2 } } = chart.legend.options;
            return data.labels.map((label, i) => {
              const meta = chart.getDatasetMeta(0);
              const style = meta.controller.getStyle(i);
              return {
                text: label,
                fillStyle: style.backgroundColor,
                strokeStyle: style.borderColor,
                fontColor: color2,
                lineWidth: style.borderWidth,
                pointStyle,
                hidden: !chart.getDataVisibility(i),
                index: i
              };
            });
          }
          return [];
        }
      },
      onClick(e, legendItem, legend) {
        legend.chart.toggleDataVisibility(legendItem.index);
        legend.chart.update();
      }
    }
  }
});
var LineController = class extends DatasetController {
  initialize() {
    this.enableOptionSharing = true;
    this.supportsDecimation = true;
    super.initialize();
  }
  update(mode) {
    const meta = this._cachedMeta;
    const { dataset: line, data: points = [], _dataset } = meta;
    const animationsDisabled = this.chart._animationsDisabled;
    let { start, count } = _getStartAndCountOfVisiblePoints(meta, points, animationsDisabled);
    this._drawStart = start;
    this._drawCount = count;
    if (_scaleRangesChanged(meta)) {
      start = 0;
      count = points.length;
    }
    line._chart = this.chart;
    line._datasetIndex = this.index;
    line._decimated = !!_dataset._decimated;
    line.points = points;
    const options = this.resolveDatasetElementOptions(mode);
    if (!this.options.showLine) {
      options.borderWidth = 0;
    }
    options.segment = this.options.segment;
    this.updateElement(line, void 0, {
      animated: !animationsDisabled,
      options
    }, mode);
    this.updateElements(points, start, count, mode);
  }
  updateElements(points, start, count, mode) {
    const reset = mode === "reset";
    const { iScale, vScale, _stacked, _dataset } = this._cachedMeta;
    const { sharedOptions, includeOptions } = this._getSharedOptions(start, mode);
    const iAxis = iScale.axis;
    const vAxis = vScale.axis;
    const { spanGaps, segment } = this.options;
    const maxGapLength = isNumber(spanGaps) ? spanGaps : Number.POSITIVE_INFINITY;
    const directUpdate = this.chart._animationsDisabled || reset || mode === "none";
    const end = start + count;
    const pointsCount = points.length;
    let prevParsed = start > 0 && this.getParsed(start - 1);
    for (let i = 0; i < pointsCount; ++i) {
      const point = points[i];
      const properties = directUpdate ? point : {};
      if (i < start || i >= end) {
        properties.skip = true;
        continue;
      }
      const parsed = this.getParsed(i);
      const nullData = isNullOrUndef(parsed[vAxis]);
      const iPixel = properties[iAxis] = iScale.getPixelForValue(parsed[iAxis], i);
      const vPixel = properties[vAxis] = reset || nullData ? vScale.getBasePixel() : vScale.getPixelForValue(_stacked ? this.applyStack(vScale, parsed, _stacked) : parsed[vAxis], i);
      properties.skip = isNaN(iPixel) || isNaN(vPixel) || nullData;
      properties.stop = i > 0 && Math.abs(parsed[iAxis] - prevParsed[iAxis]) > maxGapLength;
      if (segment) {
        properties.parsed = parsed;
        properties.raw = _dataset.data[i];
      }
      if (includeOptions) {
        properties.options = sharedOptions || this.resolveDataElementOptions(i, point.active ? "active" : mode);
      }
      if (!directUpdate) {
        this.updateElement(point, i, properties, mode);
      }
      prevParsed = parsed;
    }
  }
  getMaxOverflow() {
    const meta = this._cachedMeta;
    const dataset = meta.dataset;
    const border = dataset.options && dataset.options.borderWidth || 0;
    const data = meta.data || [];
    if (!data.length) {
      return border;
    }
    const firstPoint = data[0].size(this.resolveDataElementOptions(0));
    const lastPoint = data[data.length - 1].size(this.resolveDataElementOptions(data.length - 1));
    return Math.max(border, firstPoint, lastPoint) / 2;
  }
  draw() {
    const meta = this._cachedMeta;
    meta.dataset.updateControlPoints(this.chart.chartArea, meta.iScale.axis);
    super.draw();
  }
};
__publicField(LineController, "id", "line");
__publicField(LineController, "defaults", {
  datasetElementType: "line",
  dataElementType: "point",
  showLine: true,
  spanGaps: false
});
__publicField(LineController, "overrides", {
  scales: {
    _index_: {
      type: "category"
    },
    _value_: {
      type: "linear"
    }
  }
});
var PolarAreaController = class extends DatasetController {
  constructor(chart, datasetIndex) {
    super(chart, datasetIndex);
    this.innerRadius = void 0;
    this.outerRadius = void 0;
  }
  getLabelAndValue(index2) {
    const meta = this._cachedMeta;
    const chart = this.chart;
    const labels = chart.data.labels || [];
    const value = formatNumber(meta._parsed[index2].r, chart.options.locale);
    return {
      label: labels[index2] || "",
      value
    };
  }
  parseObjectData(meta, data, start, count) {
    return _parseObjectDataRadialScale.bind(this)(meta, data, start, count);
  }
  update(mode) {
    const arcs = this._cachedMeta.data;
    this._updateRadius();
    this.updateElements(arcs, 0, arcs.length, mode);
  }
  getMinMax() {
    const meta = this._cachedMeta;
    const range = {
      min: Number.POSITIVE_INFINITY,
      max: Number.NEGATIVE_INFINITY
    };
    meta.data.forEach((element, index2) => {
      const parsed = this.getParsed(index2).r;
      if (!isNaN(parsed) && this.chart.getDataVisibility(index2)) {
        if (parsed < range.min) {
          range.min = parsed;
        }
        if (parsed > range.max) {
          range.max = parsed;
        }
      }
    });
    return range;
  }
  _updateRadius() {
    const chart = this.chart;
    const chartArea = chart.chartArea;
    const opts = chart.options;
    const minSize = Math.min(chartArea.right - chartArea.left, chartArea.bottom - chartArea.top);
    const outerRadius = Math.max(minSize / 2, 0);
    const innerRadius = Math.max(opts.cutoutPercentage ? outerRadius / 100 * opts.cutoutPercentage : 1, 0);
    const radiusLength = (outerRadius - innerRadius) / chart.getVisibleDatasetCount();
    this.outerRadius = outerRadius - radiusLength * this.index;
    this.innerRadius = this.outerRadius - radiusLength;
  }
  updateElements(arcs, start, count, mode) {
    const reset = mode === "reset";
    const chart = this.chart;
    const opts = chart.options;
    const animationOpts = opts.animation;
    const scale = this._cachedMeta.rScale;
    const centerX = scale.xCenter;
    const centerY = scale.yCenter;
    const datasetStartAngle = scale.getIndexAngle(0) - 0.5 * PI;
    let angle = datasetStartAngle;
    let i;
    const defaultAngle = 360 / this.countVisibleElements();
    for (i = 0; i < start; ++i) {
      angle += this._computeAngle(i, mode, defaultAngle);
    }
    for (i = start; i < start + count; i++) {
      const arc = arcs[i];
      let startAngle = angle;
      let endAngle = angle + this._computeAngle(i, mode, defaultAngle);
      let outerRadius = chart.getDataVisibility(i) ? scale.getDistanceFromCenterForValue(this.getParsed(i).r) : 0;
      angle = endAngle;
      if (reset) {
        if (animationOpts.animateScale) {
          outerRadius = 0;
        }
        if (animationOpts.animateRotate) {
          startAngle = endAngle = datasetStartAngle;
        }
      }
      const properties = {
        x: centerX,
        y: centerY,
        innerRadius: 0,
        outerRadius,
        startAngle,
        endAngle,
        options: this.resolveDataElementOptions(i, arc.active ? "active" : mode)
      };
      this.updateElement(arc, i, properties, mode);
    }
  }
  countVisibleElements() {
    const meta = this._cachedMeta;
    let count = 0;
    meta.data.forEach((element, index2) => {
      if (!isNaN(this.getParsed(index2).r) && this.chart.getDataVisibility(index2)) {
        count++;
      }
    });
    return count;
  }
  _computeAngle(index2, mode, defaultAngle) {
    return this.chart.getDataVisibility(index2) ? toRadians(this.resolveDataElementOptions(index2, mode).angle || defaultAngle) : 0;
  }
};
__publicField(PolarAreaController, "id", "polarArea");
__publicField(PolarAreaController, "defaults", {
  dataElementType: "arc",
  animation: {
    animateRotate: true,
    animateScale: true
  },
  animations: {
    numbers: {
      type: "number",
      properties: [
        "x",
        "y",
        "startAngle",
        "endAngle",
        "innerRadius",
        "outerRadius"
      ]
    }
  },
  indexAxis: "r",
  startAngle: 0
});
__publicField(PolarAreaController, "overrides", {
  aspectRatio: 1,
  plugins: {
    legend: {
      labels: {
        generateLabels(chart) {
          const data = chart.data;
          if (data.labels.length && data.datasets.length) {
            const { labels: { pointStyle, color: color2 } } = chart.legend.options;
            return data.labels.map((label, i) => {
              const meta = chart.getDatasetMeta(0);
              const style = meta.controller.getStyle(i);
              return {
                text: label,
                fillStyle: style.backgroundColor,
                strokeStyle: style.borderColor,
                fontColor: color2,
                lineWidth: style.borderWidth,
                pointStyle,
                hidden: !chart.getDataVisibility(i),
                index: i
              };
            });
          }
          return [];
        }
      },
      onClick(e, legendItem, legend) {
        legend.chart.toggleDataVisibility(legendItem.index);
        legend.chart.update();
      }
    }
  },
  scales: {
    r: {
      type: "radialLinear",
      angleLines: {
        display: false
      },
      beginAtZero: true,
      grid: {
        circular: true
      },
      pointLabels: {
        display: false
      },
      startAngle: 0
    }
  }
});
var PieController = class extends DoughnutController {
};
__publicField(PieController, "id", "pie");
__publicField(PieController, "defaults", {
  cutout: 0,
  rotation: 0,
  circumference: 360,
  radius: "100%"
});
var RadarController = class extends DatasetController {
  getLabelAndValue(index2) {
    const vScale = this._cachedMeta.vScale;
    const parsed = this.getParsed(index2);
    return {
      label: vScale.getLabels()[index2],
      value: "" + vScale.getLabelForValue(parsed[vScale.axis])
    };
  }
  parseObjectData(meta, data, start, count) {
    return _parseObjectDataRadialScale.bind(this)(meta, data, start, count);
  }
  update(mode) {
    const meta = this._cachedMeta;
    const line = meta.dataset;
    const points = meta.data || [];
    const labels = meta.iScale.getLabels();
    line.points = points;
    if (mode !== "resize") {
      const options = this.resolveDatasetElementOptions(mode);
      if (!this.options.showLine) {
        options.borderWidth = 0;
      }
      const properties = {
        _loop: true,
        _fullLoop: labels.length === points.length,
        options
      };
      this.updateElement(line, void 0, properties, mode);
    }
    this.updateElements(points, 0, points.length, mode);
  }
  updateElements(points, start, count, mode) {
    const scale = this._cachedMeta.rScale;
    const reset = mode === "reset";
    for (let i = start; i < start + count; i++) {
      const point = points[i];
      const options = this.resolveDataElementOptions(i, point.active ? "active" : mode);
      const pointPosition = scale.getPointPositionForValue(i, this.getParsed(i).r);
      const x = reset ? scale.xCenter : pointPosition.x;
      const y = reset ? scale.yCenter : pointPosition.y;
      const properties = {
        x,
        y,
        angle: pointPosition.angle,
        skip: isNaN(x) || isNaN(y),
        options
      };
      this.updateElement(point, i, properties, mode);
    }
  }
};
__publicField(RadarController, "id", "radar");
__publicField(RadarController, "defaults", {
  datasetElementType: "line",
  dataElementType: "point",
  indexAxis: "r",
  showLine: true,
  elements: {
    line: {
      fill: "start"
    }
  }
});
__publicField(RadarController, "overrides", {
  aspectRatio: 1,
  scales: {
    r: {
      type: "radialLinear"
    }
  }
});
var ScatterController = class extends DatasetController {
  getLabelAndValue(index2) {
    const meta = this._cachedMeta;
    const labels = this.chart.data.labels || [];
    const { xScale, yScale } = meta;
    const parsed = this.getParsed(index2);
    const x = xScale.getLabelForValue(parsed.x);
    const y = yScale.getLabelForValue(parsed.y);
    return {
      label: labels[index2] || "",
      value: "(" + x + ", " + y + ")"
    };
  }
  update(mode) {
    const meta = this._cachedMeta;
    const { data: points = [] } = meta;
    const animationsDisabled = this.chart._animationsDisabled;
    let { start, count } = _getStartAndCountOfVisiblePoints(meta, points, animationsDisabled);
    this._drawStart = start;
    this._drawCount = count;
    if (_scaleRangesChanged(meta)) {
      start = 0;
      count = points.length;
    }
    if (this.options.showLine) {
      if (!this.datasetElementType) {
        this.addElements();
      }
      const { dataset: line, _dataset } = meta;
      line._chart = this.chart;
      line._datasetIndex = this.index;
      line._decimated = !!_dataset._decimated;
      line.points = points;
      const options = this.resolveDatasetElementOptions(mode);
      options.segment = this.options.segment;
      this.updateElement(line, void 0, {
        animated: !animationsDisabled,
        options
      }, mode);
    } else if (this.datasetElementType) {
      delete meta.dataset;
      this.datasetElementType = false;
    }
    this.updateElements(points, start, count, mode);
  }
  addElements() {
    const { showLine } = this.options;
    if (!this.datasetElementType && showLine) {
      this.datasetElementType = this.chart.registry.getElement("line");
    }
    super.addElements();
  }
  updateElements(points, start, count, mode) {
    const reset = mode === "reset";
    const { iScale, vScale, _stacked, _dataset } = this._cachedMeta;
    const firstOpts = this.resolveDataElementOptions(start, mode);
    const sharedOptions = this.getSharedOptions(firstOpts);
    const includeOptions = this.includeOptions(mode, sharedOptions);
    const iAxis = iScale.axis;
    const vAxis = vScale.axis;
    const { spanGaps, segment } = this.options;
    const maxGapLength = isNumber(spanGaps) ? spanGaps : Number.POSITIVE_INFINITY;
    const directUpdate = this.chart._animationsDisabled || reset || mode === "none";
    let prevParsed = start > 0 && this.getParsed(start - 1);
    for (let i = start; i < start + count; ++i) {
      const point = points[i];
      const parsed = this.getParsed(i);
      const properties = directUpdate ? point : {};
      const nullData = isNullOrUndef(parsed[vAxis]);
      const iPixel = properties[iAxis] = iScale.getPixelForValue(parsed[iAxis], i);
      const vPixel = properties[vAxis] = reset || nullData ? vScale.getBasePixel() : vScale.getPixelForValue(_stacked ? this.applyStack(vScale, parsed, _stacked) : parsed[vAxis], i);
      properties.skip = isNaN(iPixel) || isNaN(vPixel) || nullData;
      properties.stop = i > 0 && Math.abs(parsed[iAxis] - prevParsed[iAxis]) > maxGapLength;
      if (segment) {
        properties.parsed = parsed;
        properties.raw = _dataset.data[i];
      }
      if (includeOptions) {
        properties.options = sharedOptions || this.resolveDataElementOptions(i, point.active ? "active" : mode);
      }
      if (!directUpdate) {
        this.updateElement(point, i, properties, mode);
      }
      prevParsed = parsed;
    }
    this.updateSharedOptions(sharedOptions, mode, firstOpts);
  }
  getMaxOverflow() {
    const meta = this._cachedMeta;
    const data = meta.data || [];
    if (!this.options.showLine) {
      let max = 0;
      for (let i = data.length - 1; i >= 0; --i) {
        max = Math.max(max, data[i].size(this.resolveDataElementOptions(i)) / 2);
      }
      return max > 0 && max;
    }
    const dataset = meta.dataset;
    const border = dataset.options && dataset.options.borderWidth || 0;
    if (!data.length) {
      return border;
    }
    const firstPoint = data[0].size(this.resolveDataElementOptions(0));
    const lastPoint = data[data.length - 1].size(this.resolveDataElementOptions(data.length - 1));
    return Math.max(border, firstPoint, lastPoint) / 2;
  }
};
__publicField(ScatterController, "id", "scatter");
__publicField(ScatterController, "defaults", {
  datasetElementType: false,
  dataElementType: "point",
  showLine: false,
  fill: false
});
__publicField(ScatterController, "overrides", {
  interaction: {
    mode: "point"
  },
  scales: {
    x: {
      type: "linear"
    },
    y: {
      type: "linear"
    }
  }
});
var controllers = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  BarController,
  BubbleController,
  DoughnutController,
  LineController,
  PieController,
  PolarAreaController,
  RadarController,
  ScatterController
});
function abstract() {
  throw new Error("This method is not implemented: Check that a complete date adapter is provided.");
}
var DateAdapterBase = class {
  constructor(options) {
    __publicField(this, "options");
    this.options = options || {};
  }
  /**
  * Override default date adapter methods.
  * Accepts type parameter to define options type.
  * @example
  * Chart._adapters._date.override<{myAdapterOption: string}>({
  *   init() {
  *     console.log(this.options.myAdapterOption);
  *   }
  * })
  */
  static override(members) {
    Object.assign(DateAdapterBase.prototype, members);
  }
  // eslint-disable-next-line @typescript-eslint/no-empty-function
  init() {
  }
  formats() {
    return abstract();
  }
  parse() {
    return abstract();
  }
  format() {
    return abstract();
  }
  add() {
    return abstract();
  }
  diff() {
    return abstract();
  }
  startOf() {
    return abstract();
  }
  endOf() {
    return abstract();
  }
};
var adapters = {
  _date: DateAdapterBase
};
function binarySearch(metaset, axis, value, intersect) {
  const { controller, data, _sorted } = metaset;
  const iScale = controller._cachedMeta.iScale;
  if (iScale && axis === iScale.axis && axis !== "r" && _sorted && data.length) {
    const lookupMethod = iScale._reversePixels ? _rlookupByKey : _lookupByKey;
    if (!intersect) {
      return lookupMethod(data, axis, value);
    } else if (controller._sharedOptions) {
      const el = data[0];
      const range = typeof el.getRange === "function" && el.getRange(axis);
      if (range) {
        const start = lookupMethod(data, axis, value - range);
        const end = lookupMethod(data, axis, value + range);
        return {
          lo: start.lo,
          hi: end.hi
        };
      }
    }
  }
  return {
    lo: 0,
    hi: data.length - 1
  };
}
function evaluateInteractionItems(chart, axis, position, handler, intersect) {
  const metasets = chart.getSortedVisibleDatasetMetas();
  const value = position[axis];
  for (let i = 0, ilen = metasets.length; i < ilen; ++i) {
    const { index: index2, data } = metasets[i];
    const { lo, hi } = binarySearch(metasets[i], axis, value, intersect);
    for (let j = lo; j <= hi; ++j) {
      const element = data[j];
      if (!element.skip) {
        handler(element, index2, j);
      }
    }
  }
}
function getDistanceMetricForAxis(axis) {
  const useX = axis.indexOf("x") !== -1;
  const useY = axis.indexOf("y") !== -1;
  return function(pt1, pt2) {
    const deltaX = useX ? Math.abs(pt1.x - pt2.x) : 0;
    const deltaY = useY ? Math.abs(pt1.y - pt2.y) : 0;
    return Math.sqrt(Math.pow(deltaX, 2) + Math.pow(deltaY, 2));
  };
}
function getIntersectItems(chart, position, axis, useFinalPosition, includeInvisible) {
  const items = [];
  if (!includeInvisible && !chart.isPointInArea(position)) {
    return items;
  }
  const evaluationFunc = function(element, datasetIndex, index2) {
    if (!includeInvisible && !_isPointInArea(element, chart.chartArea, 0)) {
      return;
    }
    if (element.inRange(position.x, position.y, useFinalPosition)) {
      items.push({
        element,
        datasetIndex,
        index: index2
      });
    }
  };
  evaluateInteractionItems(chart, axis, position, evaluationFunc, true);
  return items;
}
function getNearestRadialItems(chart, position, axis, useFinalPosition) {
  let items = [];
  function evaluationFunc(element, datasetIndex, index2) {
    const { startAngle, endAngle } = element.getProps([
      "startAngle",
      "endAngle"
    ], useFinalPosition);
    const { angle } = getAngleFromPoint(element, {
      x: position.x,
      y: position.y
    });
    if (_angleBetween(angle, startAngle, endAngle)) {
      items.push({
        element,
        datasetIndex,
        index: index2
      });
    }
  }
  evaluateInteractionItems(chart, axis, position, evaluationFunc);
  return items;
}
function getNearestCartesianItems(chart, position, axis, intersect, useFinalPosition, includeInvisible) {
  let items = [];
  const distanceMetric = getDistanceMetricForAxis(axis);
  let minDistance = Number.POSITIVE_INFINITY;
  function evaluationFunc(element, datasetIndex, index2) {
    const inRange2 = element.inRange(position.x, position.y, useFinalPosition);
    if (intersect && !inRange2) {
      return;
    }
    const center = element.getCenterPoint(useFinalPosition);
    const pointInArea = !!includeInvisible || chart.isPointInArea(center);
    if (!pointInArea && !inRange2) {
      return;
    }
    const distance = distanceMetric(position, center);
    if (distance < minDistance) {
      items = [
        {
          element,
          datasetIndex,
          index: index2
        }
      ];
      minDistance = distance;
    } else if (distance === minDistance) {
      items.push({
        element,
        datasetIndex,
        index: index2
      });
    }
  }
  evaluateInteractionItems(chart, axis, position, evaluationFunc);
  return items;
}
function getNearestItems(chart, position, axis, intersect, useFinalPosition, includeInvisible) {
  if (!includeInvisible && !chart.isPointInArea(position)) {
    return [];
  }
  return axis === "r" && !intersect ? getNearestRadialItems(chart, position, axis, useFinalPosition) : getNearestCartesianItems(chart, position, axis, intersect, useFinalPosition, includeInvisible);
}
function getAxisItems(chart, position, axis, intersect, useFinalPosition) {
  const items = [];
  const rangeMethod = axis === "x" ? "inXRange" : "inYRange";
  let intersectsItem = false;
  evaluateInteractionItems(chart, axis, position, (element, datasetIndex, index2) => {
    if (element[rangeMethod] && element[rangeMethod](position[axis], useFinalPosition)) {
      items.push({
        element,
        datasetIndex,
        index: index2
      });
      intersectsItem = intersectsItem || element.inRange(position.x, position.y, useFinalPosition);
    }
  });
  if (intersect && !intersectsItem) {
    return [];
  }
  return items;
}
var Interaction = {
  evaluateInteractionItems,
  modes: {
    index(chart, e, options, useFinalPosition) {
      const position = getRelativePosition(e, chart);
      const axis = options.axis || "x";
      const includeInvisible = options.includeInvisible || false;
      const items = options.intersect ? getIntersectItems(chart, position, axis, useFinalPosition, includeInvisible) : getNearestItems(chart, position, axis, false, useFinalPosition, includeInvisible);
      const elements2 = [];
      if (!items.length) {
        return [];
      }
      chart.getSortedVisibleDatasetMetas().forEach((meta) => {
        const index2 = items[0].index;
        const element = meta.data[index2];
        if (element && !element.skip) {
          elements2.push({
            element,
            datasetIndex: meta.index,
            index: index2
          });
        }
      });
      return elements2;
    },
    dataset(chart, e, options, useFinalPosition) {
      const position = getRelativePosition(e, chart);
      const axis = options.axis || "xy";
      const includeInvisible = options.includeInvisible || false;
      let items = options.intersect ? getIntersectItems(chart, position, axis, useFinalPosition, includeInvisible) : getNearestItems(chart, position, axis, false, useFinalPosition, includeInvisible);
      if (items.length > 0) {
        const datasetIndex = items[0].datasetIndex;
        const data = chart.getDatasetMeta(datasetIndex).data;
        items = [];
        for (let i = 0; i < data.length; ++i) {
          items.push({
            element: data[i],
            datasetIndex,
            index: i
          });
        }
      }
      return items;
    },
    point(chart, e, options, useFinalPosition) {
      const position = getRelativePosition(e, chart);
      const axis = options.axis || "xy";
      const includeInvisible = options.includeInvisible || false;
      return getIntersectItems(chart, position, axis, useFinalPosition, includeInvisible);
    },
    nearest(chart, e, options, useFinalPosition) {
      const position = getRelativePosition(e, chart);
      const axis = options.axis || "xy";
      const includeInvisible = options.includeInvisible || false;
      return getNearestItems(chart, position, axis, options.intersect, useFinalPosition, includeInvisible);
    },
    x(chart, e, options, useFinalPosition) {
      const position = getRelativePosition(e, chart);
      return getAxisItems(chart, position, "x", options.intersect, useFinalPosition);
    },
    y(chart, e, options, useFinalPosition) {
      const position = getRelativePosition(e, chart);
      return getAxisItems(chart, position, "y", options.intersect, useFinalPosition);
    }
  }
};
var STATIC_POSITIONS = [
  "left",
  "top",
  "right",
  "bottom"
];
function filterByPosition(array, position) {
  return array.filter((v) => v.pos === position);
}
function filterDynamicPositionByAxis(array, axis) {
  return array.filter((v) => STATIC_POSITIONS.indexOf(v.pos) === -1 && v.box.axis === axis);
}
function sortByWeight(array, reverse) {
  return array.sort((a, b) => {
    const v0 = reverse ? b : a;
    const v1 = reverse ? a : b;
    return v0.weight === v1.weight ? v0.index - v1.index : v0.weight - v1.weight;
  });
}
function wrapBoxes(boxes) {
  const layoutBoxes = [];
  let i, ilen, box, pos, stack, stackWeight;
  for (i = 0, ilen = (boxes || []).length; i < ilen; ++i) {
    box = boxes[i];
    ({ position: pos, options: { stack, stackWeight = 1 } } = box);
    layoutBoxes.push({
      index: i,
      box,
      pos,
      horizontal: box.isHorizontal(),
      weight: box.weight,
      stack: stack && pos + stack,
      stackWeight
    });
  }
  return layoutBoxes;
}
function buildStacks(layouts2) {
  const stacks = {};
  for (const wrap of layouts2) {
    const { stack, pos, stackWeight } = wrap;
    if (!stack || !STATIC_POSITIONS.includes(pos)) {
      continue;
    }
    const _stack = stacks[stack] || (stacks[stack] = {
      count: 0,
      placed: 0,
      weight: 0,
      size: 0
    });
    _stack.count++;
    _stack.weight += stackWeight;
  }
  return stacks;
}
function setLayoutDims(layouts2, params) {
  const stacks = buildStacks(layouts2);
  const { vBoxMaxWidth, hBoxMaxHeight } = params;
  let i, ilen, layout;
  for (i = 0, ilen = layouts2.length; i < ilen; ++i) {
    layout = layouts2[i];
    const { fullSize } = layout.box;
    const stack = stacks[layout.stack];
    const factor = stack && layout.stackWeight / stack.weight;
    if (layout.horizontal) {
      layout.width = factor ? factor * vBoxMaxWidth : fullSize && params.availableWidth;
      layout.height = hBoxMaxHeight;
    } else {
      layout.width = vBoxMaxWidth;
      layout.height = factor ? factor * hBoxMaxHeight : fullSize && params.availableHeight;
    }
  }
  return stacks;
}
function buildLayoutBoxes(boxes) {
  const layoutBoxes = wrapBoxes(boxes);
  const fullSize = sortByWeight(layoutBoxes.filter((wrap) => wrap.box.fullSize), true);
  const left = sortByWeight(filterByPosition(layoutBoxes, "left"), true);
  const right = sortByWeight(filterByPosition(layoutBoxes, "right"));
  const top = sortByWeight(filterByPosition(layoutBoxes, "top"), true);
  const bottom = sortByWeight(filterByPosition(layoutBoxes, "bottom"));
  const centerHorizontal = filterDynamicPositionByAxis(layoutBoxes, "x");
  const centerVertical = filterDynamicPositionByAxis(layoutBoxes, "y");
  return {
    fullSize,
    leftAndTop: left.concat(top),
    rightAndBottom: right.concat(centerVertical).concat(bottom).concat(centerHorizontal),
    chartArea: filterByPosition(layoutBoxes, "chartArea"),
    vertical: left.concat(right).concat(centerVertical),
    horizontal: top.concat(bottom).concat(centerHorizontal)
  };
}
function getCombinedMax(maxPadding, chartArea, a, b) {
  return Math.max(maxPadding[a], chartArea[a]) + Math.max(maxPadding[b], chartArea[b]);
}
function updateMaxPadding(maxPadding, boxPadding) {
  maxPadding.top = Math.max(maxPadding.top, boxPadding.top);
  maxPadding.left = Math.max(maxPadding.left, boxPadding.left);
  maxPadding.bottom = Math.max(maxPadding.bottom, boxPadding.bottom);
  maxPadding.right = Math.max(maxPadding.right, boxPadding.right);
}
function updateDims(chartArea, params, layout, stacks) {
  const { pos, box } = layout;
  const maxPadding = chartArea.maxPadding;
  if (!isObject(pos)) {
    if (layout.size) {
      chartArea[pos] -= layout.size;
    }
    const stack = stacks[layout.stack] || {
      size: 0,
      count: 1
    };
    stack.size = Math.max(stack.size, layout.horizontal ? box.height : box.width);
    layout.size = stack.size / stack.count;
    chartArea[pos] += layout.size;
  }
  if (box.getPadding) {
    updateMaxPadding(maxPadding, box.getPadding());
  }
  const newWidth = Math.max(0, params.outerWidth - getCombinedMax(maxPadding, chartArea, "left", "right"));
  const newHeight = Math.max(0, params.outerHeight - getCombinedMax(maxPadding, chartArea, "top", "bottom"));
  const widthChanged = newWidth !== chartArea.w;
  const heightChanged = newHeight !== chartArea.h;
  chartArea.w = newWidth;
  chartArea.h = newHeight;
  return layout.horizontal ? {
    same: widthChanged,
    other: heightChanged
  } : {
    same: heightChanged,
    other: widthChanged
  };
}
function handleMaxPadding(chartArea) {
  const maxPadding = chartArea.maxPadding;
  function updatePos(pos) {
    const change = Math.max(maxPadding[pos] - chartArea[pos], 0);
    chartArea[pos] += change;
    return change;
  }
  chartArea.y += updatePos("top");
  chartArea.x += updatePos("left");
  updatePos("right");
  updatePos("bottom");
}
function getMargins(horizontal, chartArea) {
  const maxPadding = chartArea.maxPadding;
  function marginForPositions(positions2) {
    const margin = {
      left: 0,
      top: 0,
      right: 0,
      bottom: 0
    };
    positions2.forEach((pos) => {
      margin[pos] = Math.max(chartArea[pos], maxPadding[pos]);
    });
    return margin;
  }
  return horizontal ? marginForPositions([
    "left",
    "right"
  ]) : marginForPositions([
    "top",
    "bottom"
  ]);
}
function fitBoxes(boxes, chartArea, params, stacks) {
  const refitBoxes = [];
  let i, ilen, layout, box, refit, changed;
  for (i = 0, ilen = boxes.length, refit = 0; i < ilen; ++i) {
    layout = boxes[i];
    box = layout.box;
    box.update(layout.width || chartArea.w, layout.height || chartArea.h, getMargins(layout.horizontal, chartArea));
    const { same, other } = updateDims(chartArea, params, layout, stacks);
    refit |= same && refitBoxes.length;
    changed = changed || other;
    if (!box.fullSize) {
      refitBoxes.push(layout);
    }
  }
  return refit && fitBoxes(refitBoxes, chartArea, params, stacks) || changed;
}
function setBoxDims(box, left, top, width, height) {
  box.top = top;
  box.left = left;
  box.right = left + width;
  box.bottom = top + height;
  box.width = width;
  box.height = height;
}
function placeBoxes(boxes, chartArea, params, stacks) {
  const userPadding = params.padding;
  let { x, y } = chartArea;
  for (const layout of boxes) {
    const box = layout.box;
    const stack = stacks[layout.stack] || {
      count: 1,
      placed: 0,
      weight: 1
    };
    const weight = layout.stackWeight / stack.weight || 1;
    if (layout.horizontal) {
      const width = chartArea.w * weight;
      const height = stack.size || box.height;
      if (defined(stack.start)) {
        y = stack.start;
      }
      if (box.fullSize) {
        setBoxDims(box, userPadding.left, y, params.outerWidth - userPadding.right - userPadding.left, height);
      } else {
        setBoxDims(box, chartArea.left + stack.placed, y, width, height);
      }
      stack.start = y;
      stack.placed += width;
      y = box.bottom;
    } else {
      const height = chartArea.h * weight;
      const width = stack.size || box.width;
      if (defined(stack.start)) {
        x = stack.start;
      }
      if (box.fullSize) {
        setBoxDims(box, x, userPadding.top, width, params.outerHeight - userPadding.bottom - userPadding.top);
      } else {
        setBoxDims(box, x, chartArea.top + stack.placed, width, height);
      }
      stack.start = x;
      stack.placed += height;
      x = box.right;
    }
  }
  chartArea.x = x;
  chartArea.y = y;
}
var layouts = {
  addBox(chart, item) {
    if (!chart.boxes) {
      chart.boxes = [];
    }
    item.fullSize = item.fullSize || false;
    item.position = item.position || "top";
    item.weight = item.weight || 0;
    item._layers = item._layers || function() {
      return [
        {
          z: 0,
          draw(chartArea) {
            item.draw(chartArea);
          }
        }
      ];
    };
    chart.boxes.push(item);
  },
  removeBox(chart, layoutItem) {
    const index2 = chart.boxes ? chart.boxes.indexOf(layoutItem) : -1;
    if (index2 !== -1) {
      chart.boxes.splice(index2, 1);
    }
  },
  configure(chart, item, options) {
    item.fullSize = options.fullSize;
    item.position = options.position;
    item.weight = options.weight;
  },
  update(chart, width, height, minPadding) {
    if (!chart) {
      return;
    }
    const padding = toPadding(chart.options.layout.padding);
    const availableWidth = Math.max(width - padding.width, 0);
    const availableHeight = Math.max(height - padding.height, 0);
    const boxes = buildLayoutBoxes(chart.boxes);
    const verticalBoxes = boxes.vertical;
    const horizontalBoxes = boxes.horizontal;
    each(chart.boxes, (box) => {
      if (typeof box.beforeLayout === "function") {
        box.beforeLayout();
      }
    });
    const visibleVerticalBoxCount = verticalBoxes.reduce((total, wrap) => wrap.box.options && wrap.box.options.display === false ? total : total + 1, 0) || 1;
    const params = Object.freeze({
      outerWidth: width,
      outerHeight: height,
      padding,
      availableWidth,
      availableHeight,
      vBoxMaxWidth: availableWidth / 2 / visibleVerticalBoxCount,
      hBoxMaxHeight: availableHeight / 2
    });
    const maxPadding = Object.assign({}, padding);
    updateMaxPadding(maxPadding, toPadding(minPadding));
    const chartArea = Object.assign({
      maxPadding,
      w: availableWidth,
      h: availableHeight,
      x: padding.left,
      y: padding.top
    }, padding);
    const stacks = setLayoutDims(verticalBoxes.concat(horizontalBoxes), params);
    fitBoxes(boxes.fullSize, chartArea, params, stacks);
    fitBoxes(verticalBoxes, chartArea, params, stacks);
    if (fitBoxes(horizontalBoxes, chartArea, params, stacks)) {
      fitBoxes(verticalBoxes, chartArea, params, stacks);
    }
    handleMaxPadding(chartArea);
    placeBoxes(boxes.leftAndTop, chartArea, params, stacks);
    chartArea.x += chartArea.w;
    chartArea.y += chartArea.h;
    placeBoxes(boxes.rightAndBottom, chartArea, params, stacks);
    chart.chartArea = {
      left: chartArea.left,
      top: chartArea.top,
      right: chartArea.left + chartArea.w,
      bottom: chartArea.top + chartArea.h,
      height: chartArea.h,
      width: chartArea.w
    };
    each(boxes.chartArea, (layout) => {
      const box = layout.box;
      Object.assign(box, chart.chartArea);
      box.update(chartArea.w, chartArea.h, {
        left: 0,
        top: 0,
        right: 0,
        bottom: 0
      });
    });
  }
};
var BasePlatform = class {
  acquireContext(canvas, aspectRatio) {
  }
  releaseContext(context) {
    return false;
  }
  addEventListener(chart, type, listener) {
  }
  removeEventListener(chart, type, listener) {
  }
  getDevicePixelRatio() {
    return 1;
  }
  getMaximumSize(element, width, height, aspectRatio) {
    width = Math.max(0, width || element.width);
    height = height || element.height;
    return {
      width,
      height: Math.max(0, aspectRatio ? Math.floor(width / aspectRatio) : height)
    };
  }
  isAttached(canvas) {
    return true;
  }
  updateConfig(config) {
  }
};
var BasicPlatform = class extends BasePlatform {
  acquireContext(item) {
    return item && item.getContext && item.getContext("2d") || null;
  }
  updateConfig(config) {
    config.options.animation = false;
  }
};
var EXPANDO_KEY = "$chartjs";
var EVENT_TYPES = {
  touchstart: "mousedown",
  touchmove: "mousemove",
  touchend: "mouseup",
  pointerenter: "mouseenter",
  pointerdown: "mousedown",
  pointermove: "mousemove",
  pointerup: "mouseup",
  pointerleave: "mouseout",
  pointerout: "mouseout"
};
var isNullOrEmpty = (value) => value === null || value === "";
function initCanvas(canvas, aspectRatio) {
  const style = canvas.style;
  const renderHeight = canvas.getAttribute("height");
  const renderWidth = canvas.getAttribute("width");
  canvas[EXPANDO_KEY] = {
    initial: {
      height: renderHeight,
      width: renderWidth,
      style: {
        display: style.display,
        height: style.height,
        width: style.width
      }
    }
  };
  style.display = style.display || "block";
  style.boxSizing = style.boxSizing || "border-box";
  if (isNullOrEmpty(renderWidth)) {
    const displayWidth = readUsedSize(canvas, "width");
    if (displayWidth !== void 0) {
      canvas.width = displayWidth;
    }
  }
  if (isNullOrEmpty(renderHeight)) {
    if (canvas.style.height === "") {
      canvas.height = canvas.width / (aspectRatio || 2);
    } else {
      const displayHeight = readUsedSize(canvas, "height");
      if (displayHeight !== void 0) {
        canvas.height = displayHeight;
      }
    }
  }
  return canvas;
}
var eventListenerOptions = supportsEventListenerOptions ? {
  passive: true
} : false;
function addListener(node, type, listener) {
  if (node) {
    node.addEventListener(type, listener, eventListenerOptions);
  }
}
function removeListener(chart, type, listener) {
  if (chart && chart.canvas) {
    chart.canvas.removeEventListener(type, listener, eventListenerOptions);
  }
}
function fromNativeEvent(event, chart) {
  const type = EVENT_TYPES[event.type] || event.type;
  const { x, y } = getRelativePosition(event, chart);
  return {
    type,
    chart,
    native: event,
    x: x !== void 0 ? x : null,
    y: y !== void 0 ? y : null
  };
}
function nodeListContains(nodeList, canvas) {
  for (const node of nodeList) {
    if (node === canvas || node.contains(canvas)) {
      return true;
    }
  }
}
function createAttachObserver(chart, type, listener) {
  const canvas = chart.canvas;
  const observer = new MutationObserver((entries) => {
    let trigger = false;
    for (const entry of entries) {
      trigger = trigger || nodeListContains(entry.addedNodes, canvas);
      trigger = trigger && !nodeListContains(entry.removedNodes, canvas);
    }
    if (trigger) {
      listener();
    }
  });
  observer.observe(document, {
    childList: true,
    subtree: true
  });
  return observer;
}
function createDetachObserver(chart, type, listener) {
  const canvas = chart.canvas;
  const observer = new MutationObserver((entries) => {
    let trigger = false;
    for (const entry of entries) {
      trigger = trigger || nodeListContains(entry.removedNodes, canvas);
      trigger = trigger && !nodeListContains(entry.addedNodes, canvas);
    }
    if (trigger) {
      listener();
    }
  });
  observer.observe(document, {
    childList: true,
    subtree: true
  });
  return observer;
}
var drpListeningCharts = /* @__PURE__ */ new Map();
var oldDevicePixelRatio = 0;
function onWindowResize() {
  const dpr = window.devicePixelRatio;
  if (dpr === oldDevicePixelRatio) {
    return;
  }
  oldDevicePixelRatio = dpr;
  drpListeningCharts.forEach((resize, chart) => {
    if (chart.currentDevicePixelRatio !== dpr) {
      resize();
    }
  });
}
function listenDevicePixelRatioChanges(chart, resize) {
  if (!drpListeningCharts.size) {
    window.addEventListener("resize", onWindowResize);
  }
  drpListeningCharts.set(chart, resize);
}
function unlistenDevicePixelRatioChanges(chart) {
  drpListeningCharts.delete(chart);
  if (!drpListeningCharts.size) {
    window.removeEventListener("resize", onWindowResize);
  }
}
function createResizeObserver(chart, type, listener) {
  const canvas = chart.canvas;
  const container = canvas && _getParentNode(canvas);
  if (!container) {
    return;
  }
  const resize = throttled((width, height) => {
    const w = container.clientWidth;
    listener(width, height);
    if (w < container.clientWidth) {
      listener();
    }
  }, window);
  const observer = new ResizeObserver((entries) => {
    const entry = entries[0];
    const width = entry.contentRect.width;
    const height = entry.contentRect.height;
    if (width === 0 && height === 0) {
      return;
    }
    resize(width, height);
  });
  observer.observe(container);
  listenDevicePixelRatioChanges(chart, resize);
  return observer;
}
function releaseObserver(chart, type, observer) {
  if (observer) {
    observer.disconnect();
  }
  if (type === "resize") {
    unlistenDevicePixelRatioChanges(chart);
  }
}
function createProxyAndListen(chart, type, listener) {
  const canvas = chart.canvas;
  const proxy = throttled((event) => {
    if (chart.ctx !== null) {
      listener(fromNativeEvent(event, chart));
    }
  }, chart);
  addListener(canvas, type, proxy);
  return proxy;
}
var DomPlatform = class extends BasePlatform {
  acquireContext(canvas, aspectRatio) {
    const context = canvas && canvas.getContext && canvas.getContext("2d");
    if (context && context.canvas === canvas) {
      initCanvas(canvas, aspectRatio);
      return context;
    }
    return null;
  }
  releaseContext(context) {
    const canvas = context.canvas;
    if (!canvas[EXPANDO_KEY]) {
      return false;
    }
    const initial = canvas[EXPANDO_KEY].initial;
    [
      "height",
      "width"
    ].forEach((prop) => {
      const value = initial[prop];
      if (isNullOrUndef(value)) {
        canvas.removeAttribute(prop);
      } else {
        canvas.setAttribute(prop, value);
      }
    });
    const style = initial.style || {};
    Object.keys(style).forEach((key) => {
      canvas.style[key] = style[key];
    });
    canvas.width = canvas.width;
    delete canvas[EXPANDO_KEY];
    return true;
  }
  addEventListener(chart, type, listener) {
    this.removeEventListener(chart, type);
    const proxies = chart.$proxies || (chart.$proxies = {});
    const handlers = {
      attach: createAttachObserver,
      detach: createDetachObserver,
      resize: createResizeObserver
    };
    const handler = handlers[type] || createProxyAndListen;
    proxies[type] = handler(chart, type, listener);
  }
  removeEventListener(chart, type) {
    const proxies = chart.$proxies || (chart.$proxies = {});
    const proxy = proxies[type];
    if (!proxy) {
      return;
    }
    const handlers = {
      attach: releaseObserver,
      detach: releaseObserver,
      resize: releaseObserver
    };
    const handler = handlers[type] || removeListener;
    handler(chart, type, proxy);
    proxies[type] = void 0;
  }
  getDevicePixelRatio() {
    return window.devicePixelRatio;
  }
  getMaximumSize(canvas, width, height, aspectRatio) {
    return getMaximumSize(canvas, width, height, aspectRatio);
  }
  isAttached(canvas) {
    const container = canvas && _getParentNode(canvas);
    return !!(container && container.isConnected);
  }
};
function _detectPlatform(canvas) {
  if (!_isDomSupported() || typeof OffscreenCanvas !== "undefined" && canvas instanceof OffscreenCanvas) {
    return BasicPlatform;
  }
  return DomPlatform;
}
var Element = class {
  constructor() {
    __publicField(this, "x");
    __publicField(this, "y");
    __publicField(this, "active", false);
    __publicField(this, "options");
    __publicField(this, "$animations");
  }
  tooltipPosition(useFinalPosition) {
    const { x, y } = this.getProps([
      "x",
      "y"
    ], useFinalPosition);
    return {
      x,
      y
    };
  }
  hasValue() {
    return isNumber(this.x) && isNumber(this.y);
  }
  getProps(props, final) {
    const anims = this.$animations;
    if (!final || !anims) {
      return this;
    }
    const ret = {};
    props.forEach((prop) => {
      ret[prop] = anims[prop] && anims[prop].active() ? anims[prop]._to : this[prop];
    });
    return ret;
  }
};
__publicField(Element, "defaults", {});
__publicField(Element, "defaultRoutes");
function autoSkip(scale, ticks) {
  const tickOpts = scale.options.ticks;
  const determinedMaxTicks = determineMaxTicks(scale);
  const ticksLimit = Math.min(tickOpts.maxTicksLimit || determinedMaxTicks, determinedMaxTicks);
  const majorIndices = tickOpts.major.enabled ? getMajorIndices(ticks) : [];
  const numMajorIndices = majorIndices.length;
  const first = majorIndices[0];
  const last = majorIndices[numMajorIndices - 1];
  const newTicks = [];
  if (numMajorIndices > ticksLimit) {
    skipMajors(ticks, newTicks, majorIndices, numMajorIndices / ticksLimit);
    return newTicks;
  }
  const spacing = calculateSpacing(majorIndices, ticks, ticksLimit);
  if (numMajorIndices > 0) {
    let i, ilen;
    const avgMajorSpacing = numMajorIndices > 1 ? Math.round((last - first) / (numMajorIndices - 1)) : null;
    skip(ticks, newTicks, spacing, isNullOrUndef(avgMajorSpacing) ? 0 : first - avgMajorSpacing, first);
    for (i = 0, ilen = numMajorIndices - 1; i < ilen; i++) {
      skip(ticks, newTicks, spacing, majorIndices[i], majorIndices[i + 1]);
    }
    skip(ticks, newTicks, spacing, last, isNullOrUndef(avgMajorSpacing) ? ticks.length : last + avgMajorSpacing);
    return newTicks;
  }
  skip(ticks, newTicks, spacing);
  return newTicks;
}
function determineMaxTicks(scale) {
  const offset = scale.options.offset;
  const tickLength = scale._tickSize();
  const maxScale = scale._length / tickLength + (offset ? 0 : 1);
  const maxChart = scale._maxLength / tickLength;
  return Math.floor(Math.min(maxScale, maxChart));
}
function calculateSpacing(majorIndices, ticks, ticksLimit) {
  const evenMajorSpacing = getEvenSpacing(majorIndices);
  const spacing = ticks.length / ticksLimit;
  if (!evenMajorSpacing) {
    return Math.max(spacing, 1);
  }
  const factors = _factorize(evenMajorSpacing);
  for (let i = 0, ilen = factors.length - 1; i < ilen; i++) {
    const factor = factors[i];
    if (factor > spacing) {
      return factor;
    }
  }
  return Math.max(spacing, 1);
}
function getMajorIndices(ticks) {
  const result = [];
  let i, ilen;
  for (i = 0, ilen = ticks.length; i < ilen; i++) {
    if (ticks[i].major) {
      result.push(i);
    }
  }
  return result;
}
function skipMajors(ticks, newTicks, majorIndices, spacing) {
  let count = 0;
  let next = majorIndices[0];
  let i;
  spacing = Math.ceil(spacing);
  for (i = 0; i < ticks.length; i++) {
    if (i === next) {
      newTicks.push(ticks[i]);
      count++;
      next = majorIndices[count * spacing];
    }
  }
}
function skip(ticks, newTicks, spacing, majorStart, majorEnd) {
  const start = valueOrDefault(majorStart, 0);
  const end = Math.min(valueOrDefault(majorEnd, ticks.length), ticks.length);
  let count = 0;
  let length, i, next;
  spacing = Math.ceil(spacing);
  if (majorEnd) {
    length = majorEnd - majorStart;
    spacing = length / Math.floor(length / spacing);
  }
  next = start;
  while (next < 0) {
    count++;
    next = Math.round(start + count * spacing);
  }
  for (i = Math.max(start, 0); i < end; i++) {
    if (i === next) {
      newTicks.push(ticks[i]);
      count++;
      next = Math.round(start + count * spacing);
    }
  }
}
function getEvenSpacing(arr) {
  const len = arr.length;
  let i, diff;
  if (len < 2) {
    return false;
  }
  for (diff = arr[0], i = 1; i < len; ++i) {
    if (arr[i] - arr[i - 1] !== diff) {
      return false;
    }
  }
  return diff;
}
var reverseAlign = (align) => align === "left" ? "right" : align === "right" ? "left" : align;
var offsetFromEdge = (scale, edge, offset) => edge === "top" || edge === "left" ? scale[edge] + offset : scale[edge] - offset;
var getTicksLimit = (ticksLength, maxTicksLimit) => Math.min(maxTicksLimit || ticksLength, ticksLength);
function sample(arr, numItems) {
  const result = [];
  const increment = arr.length / numItems;
  const len = arr.length;
  let i = 0;
  for (; i < len; i += increment) {
    result.push(arr[Math.floor(i)]);
  }
  return result;
}
function getPixelForGridLine(scale, index2, offsetGridLines) {
  const length = scale.ticks.length;
  const validIndex2 = Math.min(index2, length - 1);
  const start = scale._startPixel;
  const end = scale._endPixel;
  const epsilon = 1e-6;
  let lineValue = scale.getPixelForTick(validIndex2);
  let offset;
  if (offsetGridLines) {
    if (length === 1) {
      offset = Math.max(lineValue - start, end - lineValue);
    } else if (index2 === 0) {
      offset = (scale.getPixelForTick(1) - lineValue) / 2;
    } else {
      offset = (lineValue - scale.getPixelForTick(validIndex2 - 1)) / 2;
    }
    lineValue += validIndex2 < index2 ? offset : -offset;
    if (lineValue < start - epsilon || lineValue > end + epsilon) {
      return;
    }
  }
  return lineValue;
}
function garbageCollect(caches, length) {
  each(caches, (cache) => {
    const gc = cache.gc;
    const gcLen = gc.length / 2;
    let i;
    if (gcLen > length) {
      for (i = 0; i < gcLen; ++i) {
        delete cache.data[gc[i]];
      }
      gc.splice(0, gcLen);
    }
  });
}
function getTickMarkLength(options) {
  return options.drawTicks ? options.tickLength : 0;
}
function getTitleHeight(options, fallback) {
  if (!options.display) {
    return 0;
  }
  const font = toFont(options.font, fallback);
  const padding = toPadding(options.padding);
  const lines = isArray(options.text) ? options.text.length : 1;
  return lines * font.lineHeight + padding.height;
}
function createScaleContext(parent, scale) {
  return createContext(parent, {
    scale,
    type: "scale"
  });
}
function createTickContext(parent, index2, tick) {
  return createContext(parent, {
    tick,
    index: index2,
    type: "tick"
  });
}
function titleAlign(align, position, reverse) {
  let ret = _toLeftRightCenter(align);
  if (reverse && position !== "right" || !reverse && position === "right") {
    ret = reverseAlign(ret);
  }
  return ret;
}
function titleArgs(scale, offset, position, align) {
  const { top, left, bottom, right, chart } = scale;
  const { chartArea, scales: scales2 } = chart;
  let rotation = 0;
  let maxWidth, titleX, titleY;
  const height = bottom - top;
  const width = right - left;
  if (scale.isHorizontal()) {
    titleX = _alignStartEnd(align, left, right);
    if (isObject(position)) {
      const positionAxisID = Object.keys(position)[0];
      const value = position[positionAxisID];
      titleY = scales2[positionAxisID].getPixelForValue(value) + height - offset;
    } else if (position === "center") {
      titleY = (chartArea.bottom + chartArea.top) / 2 + height - offset;
    } else {
      titleY = offsetFromEdge(scale, position, offset);
    }
    maxWidth = right - left;
  } else {
    if (isObject(position)) {
      const positionAxisID = Object.keys(position)[0];
      const value = position[positionAxisID];
      titleX = scales2[positionAxisID].getPixelForValue(value) - width + offset;
    } else if (position === "center") {
      titleX = (chartArea.left + chartArea.right) / 2 - width + offset;
    } else {
      titleX = offsetFromEdge(scale, position, offset);
    }
    titleY = _alignStartEnd(align, bottom, top);
    rotation = position === "left" ? -HALF_PI : HALF_PI;
  }
  return {
    titleX,
    titleY,
    maxWidth,
    rotation
  };
}
var Scale = class extends Element {
  constructor(cfg) {
    super();
    this.id = cfg.id;
    this.type = cfg.type;
    this.options = void 0;
    this.ctx = cfg.ctx;
    this.chart = cfg.chart;
    this.top = void 0;
    this.bottom = void 0;
    this.left = void 0;
    this.right = void 0;
    this.width = void 0;
    this.height = void 0;
    this._margins = {
      left: 0,
      right: 0,
      top: 0,
      bottom: 0
    };
    this.maxWidth = void 0;
    this.maxHeight = void 0;
    this.paddingTop = void 0;
    this.paddingBottom = void 0;
    this.paddingLeft = void 0;
    this.paddingRight = void 0;
    this.axis = void 0;
    this.labelRotation = void 0;
    this.min = void 0;
    this.max = void 0;
    this._range = void 0;
    this.ticks = [];
    this._gridLineItems = null;
    this._labelItems = null;
    this._labelSizes = null;
    this._length = 0;
    this._maxLength = 0;
    this._longestTextCache = {};
    this._startPixel = void 0;
    this._endPixel = void 0;
    this._reversePixels = false;
    this._userMax = void 0;
    this._userMin = void 0;
    this._suggestedMax = void 0;
    this._suggestedMin = void 0;
    this._ticksLength = 0;
    this._borderValue = 0;
    this._cache = {};
    this._dataLimitsCached = false;
    this.$context = void 0;
  }
  init(options) {
    this.options = options.setContext(this.getContext());
    this.axis = options.axis;
    this._userMin = this.parse(options.min);
    this._userMax = this.parse(options.max);
    this._suggestedMin = this.parse(options.suggestedMin);
    this._suggestedMax = this.parse(options.suggestedMax);
  }
  parse(raw, index2) {
    return raw;
  }
  getUserBounds() {
    let { _userMin, _userMax, _suggestedMin, _suggestedMax } = this;
    _userMin = finiteOrDefault(_userMin, Number.POSITIVE_INFINITY);
    _userMax = finiteOrDefault(_userMax, Number.NEGATIVE_INFINITY);
    _suggestedMin = finiteOrDefault(_suggestedMin, Number.POSITIVE_INFINITY);
    _suggestedMax = finiteOrDefault(_suggestedMax, Number.NEGATIVE_INFINITY);
    return {
      min: finiteOrDefault(_userMin, _suggestedMin),
      max: finiteOrDefault(_userMax, _suggestedMax),
      minDefined: isNumberFinite(_userMin),
      maxDefined: isNumberFinite(_userMax)
    };
  }
  getMinMax(canStack) {
    let { min, max, minDefined, maxDefined } = this.getUserBounds();
    let range;
    if (minDefined && maxDefined) {
      return {
        min,
        max
      };
    }
    const metas = this.getMatchingVisibleMetas();
    for (let i = 0, ilen = metas.length; i < ilen; ++i) {
      range = metas[i].controller.getMinMax(this, canStack);
      if (!minDefined) {
        min = Math.min(min, range.min);
      }
      if (!maxDefined) {
        max = Math.max(max, range.max);
      }
    }
    min = maxDefined && min > max ? max : min;
    max = minDefined && min > max ? min : max;
    return {
      min: finiteOrDefault(min, finiteOrDefault(max, min)),
      max: finiteOrDefault(max, finiteOrDefault(min, max))
    };
  }
  getPadding() {
    return {
      left: this.paddingLeft || 0,
      top: this.paddingTop || 0,
      right: this.paddingRight || 0,
      bottom: this.paddingBottom || 0
    };
  }
  getTicks() {
    return this.ticks;
  }
  getLabels() {
    const data = this.chart.data;
    return this.options.labels || (this.isHorizontal() ? data.xLabels : data.yLabels) || data.labels || [];
  }
  getLabelItems(chartArea = this.chart.chartArea) {
    const items = this._labelItems || (this._labelItems = this._computeLabelItems(chartArea));
    return items;
  }
  beforeLayout() {
    this._cache = {};
    this._dataLimitsCached = false;
  }
  beforeUpdate() {
    callback(this.options.beforeUpdate, [
      this
    ]);
  }
  update(maxWidth, maxHeight, margins) {
    const { beginAtZero, grace, ticks: tickOpts } = this.options;
    const sampleSize = tickOpts.sampleSize;
    this.beforeUpdate();
    this.maxWidth = maxWidth;
    this.maxHeight = maxHeight;
    this._margins = margins = Object.assign({
      left: 0,
      right: 0,
      top: 0,
      bottom: 0
    }, margins);
    this.ticks = null;
    this._labelSizes = null;
    this._gridLineItems = null;
    this._labelItems = null;
    this.beforeSetDimensions();
    this.setDimensions();
    this.afterSetDimensions();
    this._maxLength = this.isHorizontal() ? this.width + margins.left + margins.right : this.height + margins.top + margins.bottom;
    if (!this._dataLimitsCached) {
      this.beforeDataLimits();
      this.determineDataLimits();
      this.afterDataLimits();
      this._range = _addGrace(this, grace, beginAtZero);
      this._dataLimitsCached = true;
    }
    this.beforeBuildTicks();
    this.ticks = this.buildTicks() || [];
    this.afterBuildTicks();
    const samplingEnabled = sampleSize < this.ticks.length;
    this._convertTicksToLabels(samplingEnabled ? sample(this.ticks, sampleSize) : this.ticks);
    this.configure();
    this.beforeCalculateLabelRotation();
    this.calculateLabelRotation();
    this.afterCalculateLabelRotation();
    if (tickOpts.display && (tickOpts.autoSkip || tickOpts.source === "auto")) {
      this.ticks = autoSkip(this, this.ticks);
      this._labelSizes = null;
      this.afterAutoSkip();
    }
    if (samplingEnabled) {
      this._convertTicksToLabels(this.ticks);
    }
    this.beforeFit();
    this.fit();
    this.afterFit();
    this.afterUpdate();
  }
  configure() {
    let reversePixels = this.options.reverse;
    let startPixel, endPixel;
    if (this.isHorizontal()) {
      startPixel = this.left;
      endPixel = this.right;
    } else {
      startPixel = this.top;
      endPixel = this.bottom;
      reversePixels = !reversePixels;
    }
    this._startPixel = startPixel;
    this._endPixel = endPixel;
    this._reversePixels = reversePixels;
    this._length = endPixel - startPixel;
    this._alignToPixels = this.options.alignToPixels;
  }
  afterUpdate() {
    callback(this.options.afterUpdate, [
      this
    ]);
  }
  beforeSetDimensions() {
    callback(this.options.beforeSetDimensions, [
      this
    ]);
  }
  setDimensions() {
    if (this.isHorizontal()) {
      this.width = this.maxWidth;
      this.left = 0;
      this.right = this.width;
    } else {
      this.height = this.maxHeight;
      this.top = 0;
      this.bottom = this.height;
    }
    this.paddingLeft = 0;
    this.paddingTop = 0;
    this.paddingRight = 0;
    this.paddingBottom = 0;
  }
  afterSetDimensions() {
    callback(this.options.afterSetDimensions, [
      this
    ]);
  }
  _callHooks(name) {
    this.chart.notifyPlugins(name, this.getContext());
    callback(this.options[name], [
      this
    ]);
  }
  beforeDataLimits() {
    this._callHooks("beforeDataLimits");
  }
  determineDataLimits() {
  }
  afterDataLimits() {
    this._callHooks("afterDataLimits");
  }
  beforeBuildTicks() {
    this._callHooks("beforeBuildTicks");
  }
  buildTicks() {
    return [];
  }
  afterBuildTicks() {
    this._callHooks("afterBuildTicks");
  }
  beforeTickToLabelConversion() {
    callback(this.options.beforeTickToLabelConversion, [
      this
    ]);
  }
  generateTickLabels(ticks) {
    const tickOpts = this.options.ticks;
    let i, ilen, tick;
    for (i = 0, ilen = ticks.length; i < ilen; i++) {
      tick = ticks[i];
      tick.label = callback(tickOpts.callback, [
        tick.value,
        i,
        ticks
      ], this);
    }
  }
  afterTickToLabelConversion() {
    callback(this.options.afterTickToLabelConversion, [
      this
    ]);
  }
  beforeCalculateLabelRotation() {
    callback(this.options.beforeCalculateLabelRotation, [
      this
    ]);
  }
  calculateLabelRotation() {
    const options = this.options;
    const tickOpts = options.ticks;
    const numTicks = getTicksLimit(this.ticks.length, options.ticks.maxTicksLimit);
    const minRotation = tickOpts.minRotation || 0;
    const maxRotation = tickOpts.maxRotation;
    let labelRotation = minRotation;
    let tickWidth, maxHeight, maxLabelDiagonal;
    if (!this._isVisible() || !tickOpts.display || minRotation >= maxRotation || numTicks <= 1 || !this.isHorizontal()) {
      this.labelRotation = minRotation;
      return;
    }
    const labelSizes = this._getLabelSizes();
    const maxLabelWidth = labelSizes.widest.width;
    const maxLabelHeight = labelSizes.highest.height;
    const maxWidth = _limitValue(this.chart.width - maxLabelWidth, 0, this.maxWidth);
    tickWidth = options.offset ? this.maxWidth / numTicks : maxWidth / (numTicks - 1);
    if (maxLabelWidth + 6 > tickWidth) {
      tickWidth = maxWidth / (numTicks - (options.offset ? 0.5 : 1));
      maxHeight = this.maxHeight - getTickMarkLength(options.grid) - tickOpts.padding - getTitleHeight(options.title, this.chart.options.font);
      maxLabelDiagonal = Math.sqrt(maxLabelWidth * maxLabelWidth + maxLabelHeight * maxLabelHeight);
      labelRotation = toDegrees(Math.min(Math.asin(_limitValue((labelSizes.highest.height + 6) / tickWidth, -1, 1)), Math.asin(_limitValue(maxHeight / maxLabelDiagonal, -1, 1)) - Math.asin(_limitValue(maxLabelHeight / maxLabelDiagonal, -1, 1))));
      labelRotation = Math.max(minRotation, Math.min(maxRotation, labelRotation));
    }
    this.labelRotation = labelRotation;
  }
  afterCalculateLabelRotation() {
    callback(this.options.afterCalculateLabelRotation, [
      this
    ]);
  }
  afterAutoSkip() {
  }
  beforeFit() {
    callback(this.options.beforeFit, [
      this
    ]);
  }
  fit() {
    const minSize = {
      width: 0,
      height: 0
    };
    const { chart, options: { ticks: tickOpts, title: titleOpts, grid: gridOpts } } = this;
    const display = this._isVisible();
    const isHorizontal = this.isHorizontal();
    if (display) {
      const titleHeight = getTitleHeight(titleOpts, chart.options.font);
      if (isHorizontal) {
        minSize.width = this.maxWidth;
        minSize.height = getTickMarkLength(gridOpts) + titleHeight;
      } else {
        minSize.height = this.maxHeight;
        minSize.width = getTickMarkLength(gridOpts) + titleHeight;
      }
      if (tickOpts.display && this.ticks.length) {
        const { first, last, widest, highest } = this._getLabelSizes();
        const tickPadding = tickOpts.padding * 2;
        const angleRadians = toRadians(this.labelRotation);
        const cos = Math.cos(angleRadians);
        const sin = Math.sin(angleRadians);
        if (isHorizontal) {
          const labelHeight = tickOpts.mirror ? 0 : sin * widest.width + cos * highest.height;
          minSize.height = Math.min(this.maxHeight, minSize.height + labelHeight + tickPadding);
        } else {
          const labelWidth = tickOpts.mirror ? 0 : cos * widest.width + sin * highest.height;
          minSize.width = Math.min(this.maxWidth, minSize.width + labelWidth + tickPadding);
        }
        this._calculatePadding(first, last, sin, cos);
      }
    }
    this._handleMargins();
    if (isHorizontal) {
      this.width = this._length = chart.width - this._margins.left - this._margins.right;
      this.height = minSize.height;
    } else {
      this.width = minSize.width;
      this.height = this._length = chart.height - this._margins.top - this._margins.bottom;
    }
  }
  _calculatePadding(first, last, sin, cos) {
    const { ticks: { align, padding }, position } = this.options;
    const isRotated = this.labelRotation !== 0;
    const labelsBelowTicks = position !== "top" && this.axis === "x";
    if (this.isHorizontal()) {
      const offsetLeft = this.getPixelForTick(0) - this.left;
      const offsetRight = this.right - this.getPixelForTick(this.ticks.length - 1);
      let paddingLeft = 0;
      let paddingRight = 0;
      if (isRotated) {
        if (labelsBelowTicks) {
          paddingLeft = cos * first.width;
          paddingRight = sin * last.height;
        } else {
          paddingLeft = sin * first.height;
          paddingRight = cos * last.width;
        }
      } else if (align === "start") {
        paddingRight = last.width;
      } else if (align === "end") {
        paddingLeft = first.width;
      } else if (align !== "inner") {
        paddingLeft = first.width / 2;
        paddingRight = last.width / 2;
      }
      this.paddingLeft = Math.max((paddingLeft - offsetLeft + padding) * this.width / (this.width - offsetLeft), 0);
      this.paddingRight = Math.max((paddingRight - offsetRight + padding) * this.width / (this.width - offsetRight), 0);
    } else {
      let paddingTop = last.height / 2;
      let paddingBottom = first.height / 2;
      if (align === "start") {
        paddingTop = 0;
        paddingBottom = first.height;
      } else if (align === "end") {
        paddingTop = last.height;
        paddingBottom = 0;
      }
      this.paddingTop = paddingTop + padding;
      this.paddingBottom = paddingBottom + padding;
    }
  }
  _handleMargins() {
    if (this._margins) {
      this._margins.left = Math.max(this.paddingLeft, this._margins.left);
      this._margins.top = Math.max(this.paddingTop, this._margins.top);
      this._margins.right = Math.max(this.paddingRight, this._margins.right);
      this._margins.bottom = Math.max(this.paddingBottom, this._margins.bottom);
    }
  }
  afterFit() {
    callback(this.options.afterFit, [
      this
    ]);
  }
  isHorizontal() {
    const { axis, position } = this.options;
    return position === "top" || position === "bottom" || axis === "x";
  }
  isFullSize() {
    return this.options.fullSize;
  }
  _convertTicksToLabels(ticks) {
    this.beforeTickToLabelConversion();
    this.generateTickLabels(ticks);
    let i, ilen;
    for (i = 0, ilen = ticks.length; i < ilen; i++) {
      if (isNullOrUndef(ticks[i].label)) {
        ticks.splice(i, 1);
        ilen--;
        i--;
      }
    }
    this.afterTickToLabelConversion();
  }
  _getLabelSizes() {
    let labelSizes = this._labelSizes;
    if (!labelSizes) {
      const sampleSize = this.options.ticks.sampleSize;
      let ticks = this.ticks;
      if (sampleSize < ticks.length) {
        ticks = sample(ticks, sampleSize);
      }
      this._labelSizes = labelSizes = this._computeLabelSizes(ticks, ticks.length, this.options.ticks.maxTicksLimit);
    }
    return labelSizes;
  }
  _computeLabelSizes(ticks, length, maxTicksLimit) {
    const { ctx, _longestTextCache: caches } = this;
    const widths = [];
    const heights = [];
    const increment = Math.floor(length / getTicksLimit(length, maxTicksLimit));
    let widestLabelSize = 0;
    let highestLabelSize = 0;
    let i, j, jlen, label, tickFont, fontString2, cache, lineHeight, width, height, nestedLabel;
    for (i = 0; i < length; i += increment) {
      label = ticks[i].label;
      tickFont = this._resolveTickFontOptions(i);
      ctx.font = fontString2 = tickFont.string;
      cache = caches[fontString2] = caches[fontString2] || {
        data: {},
        gc: []
      };
      lineHeight = tickFont.lineHeight;
      width = height = 0;
      if (!isNullOrUndef(label) && !isArray(label)) {
        width = _measureText(ctx, cache.data, cache.gc, width, label);
        height = lineHeight;
      } else if (isArray(label)) {
        for (j = 0, jlen = label.length; j < jlen; ++j) {
          nestedLabel = label[j];
          if (!isNullOrUndef(nestedLabel) && !isArray(nestedLabel)) {
            width = _measureText(ctx, cache.data, cache.gc, width, nestedLabel);
            height += lineHeight;
          }
        }
      }
      widths.push(width);
      heights.push(height);
      widestLabelSize = Math.max(width, widestLabelSize);
      highestLabelSize = Math.max(height, highestLabelSize);
    }
    garbageCollect(caches, length);
    const widest = widths.indexOf(widestLabelSize);
    const highest = heights.indexOf(highestLabelSize);
    const valueAt = (idx) => ({
      width: widths[idx] || 0,
      height: heights[idx] || 0
    });
    return {
      first: valueAt(0),
      last: valueAt(length - 1),
      widest: valueAt(widest),
      highest: valueAt(highest),
      widths,
      heights
    };
  }
  getLabelForValue(value) {
    return value;
  }
  getPixelForValue(value, index2) {
    return NaN;
  }
  getValueForPixel(pixel) {
  }
  getPixelForTick(index2) {
    const ticks = this.ticks;
    if (index2 < 0 || index2 > ticks.length - 1) {
      return null;
    }
    return this.getPixelForValue(ticks[index2].value);
  }
  getPixelForDecimal(decimal) {
    if (this._reversePixels) {
      decimal = 1 - decimal;
    }
    const pixel = this._startPixel + decimal * this._length;
    return _int16Range(this._alignToPixels ? _alignPixel(this.chart, pixel, 0) : pixel);
  }
  getDecimalForPixel(pixel) {
    const decimal = (pixel - this._startPixel) / this._length;
    return this._reversePixels ? 1 - decimal : decimal;
  }
  getBasePixel() {
    return this.getPixelForValue(this.getBaseValue());
  }
  getBaseValue() {
    const { min, max } = this;
    return min < 0 && max < 0 ? max : min > 0 && max > 0 ? min : 0;
  }
  getContext(index2) {
    const ticks = this.ticks || [];
    if (index2 >= 0 && index2 < ticks.length) {
      const tick = ticks[index2];
      return tick.$context || (tick.$context = createTickContext(this.getContext(), index2, tick));
    }
    return this.$context || (this.$context = createScaleContext(this.chart.getContext(), this));
  }
  _tickSize() {
    const optionTicks = this.options.ticks;
    const rot = toRadians(this.labelRotation);
    const cos = Math.abs(Math.cos(rot));
    const sin = Math.abs(Math.sin(rot));
    const labelSizes = this._getLabelSizes();
    const padding = optionTicks.autoSkipPadding || 0;
    const w = labelSizes ? labelSizes.widest.width + padding : 0;
    const h = labelSizes ? labelSizes.highest.height + padding : 0;
    return this.isHorizontal() ? h * cos > w * sin ? w / cos : h / sin : h * sin < w * cos ? h / cos : w / sin;
  }
  _isVisible() {
    const display = this.options.display;
    if (display !== "auto") {
      return !!display;
    }
    return this.getMatchingVisibleMetas().length > 0;
  }
  _computeGridLineItems(chartArea) {
    const axis = this.axis;
    const chart = this.chart;
    const options = this.options;
    const { grid, position, border } = options;
    const offset = grid.offset;
    const isHorizontal = this.isHorizontal();
    const ticks = this.ticks;
    const ticksLength = ticks.length + (offset ? 1 : 0);
    const tl = getTickMarkLength(grid);
    const items = [];
    const borderOpts = border.setContext(this.getContext());
    const axisWidth = borderOpts.display ? borderOpts.width : 0;
    const axisHalfWidth = axisWidth / 2;
    const alignBorderValue = function(pixel) {
      return _alignPixel(chart, pixel, axisWidth);
    };
    let borderValue, i, lineValue, alignedLineValue;
    let tx1, ty1, tx2, ty2, x1, y1, x2, y2;
    if (position === "top") {
      borderValue = alignBorderValue(this.bottom);
      ty1 = this.bottom - tl;
      ty2 = borderValue - axisHalfWidth;
      y1 = alignBorderValue(chartArea.top) + axisHalfWidth;
      y2 = chartArea.bottom;
    } else if (position === "bottom") {
      borderValue = alignBorderValue(this.top);
      y1 = chartArea.top;
      y2 = alignBorderValue(chartArea.bottom) - axisHalfWidth;
      ty1 = borderValue + axisHalfWidth;
      ty2 = this.top + tl;
    } else if (position === "left") {
      borderValue = alignBorderValue(this.right);
      tx1 = this.right - tl;
      tx2 = borderValue - axisHalfWidth;
      x1 = alignBorderValue(chartArea.left) + axisHalfWidth;
      x2 = chartArea.right;
    } else if (position === "right") {
      borderValue = alignBorderValue(this.left);
      x1 = chartArea.left;
      x2 = alignBorderValue(chartArea.right) - axisHalfWidth;
      tx1 = borderValue + axisHalfWidth;
      tx2 = this.left + tl;
    } else if (axis === "x") {
      if (position === "center") {
        borderValue = alignBorderValue((chartArea.top + chartArea.bottom) / 2 + 0.5);
      } else if (isObject(position)) {
        const positionAxisID = Object.keys(position)[0];
        const value = position[positionAxisID];
        borderValue = alignBorderValue(this.chart.scales[positionAxisID].getPixelForValue(value));
      }
      y1 = chartArea.top;
      y2 = chartArea.bottom;
      ty1 = borderValue + axisHalfWidth;
      ty2 = ty1 + tl;
    } else if (axis === "y") {
      if (position === "center") {
        borderValue = alignBorderValue((chartArea.left + chartArea.right) / 2);
      } else if (isObject(position)) {
        const positionAxisID = Object.keys(position)[0];
        const value = position[positionAxisID];
        borderValue = alignBorderValue(this.chart.scales[positionAxisID].getPixelForValue(value));
      }
      tx1 = borderValue - axisHalfWidth;
      tx2 = tx1 - tl;
      x1 = chartArea.left;
      x2 = chartArea.right;
    }
    const limit = valueOrDefault(options.ticks.maxTicksLimit, ticksLength);
    const step = Math.max(1, Math.ceil(ticksLength / limit));
    for (i = 0; i < ticksLength; i += step) {
      const context = this.getContext(i);
      const optsAtIndex = grid.setContext(context);
      const optsAtIndexBorder = border.setContext(context);
      const lineWidth = optsAtIndex.lineWidth;
      const lineColor = optsAtIndex.color;
      const borderDash = optsAtIndexBorder.dash || [];
      const borderDashOffset = optsAtIndexBorder.dashOffset;
      const tickWidth = optsAtIndex.tickWidth;
      const tickColor = optsAtIndex.tickColor;
      const tickBorderDash = optsAtIndex.tickBorderDash || [];
      const tickBorderDashOffset = optsAtIndex.tickBorderDashOffset;
      lineValue = getPixelForGridLine(this, i, offset);
      if (lineValue === void 0) {
        continue;
      }
      alignedLineValue = _alignPixel(chart, lineValue, lineWidth);
      if (isHorizontal) {
        tx1 = tx2 = x1 = x2 = alignedLineValue;
      } else {
        ty1 = ty2 = y1 = y2 = alignedLineValue;
      }
      items.push({
        tx1,
        ty1,
        tx2,
        ty2,
        x1,
        y1,
        x2,
        y2,
        width: lineWidth,
        color: lineColor,
        borderDash,
        borderDashOffset,
        tickWidth,
        tickColor,
        tickBorderDash,
        tickBorderDashOffset
      });
    }
    this._ticksLength = ticksLength;
    this._borderValue = borderValue;
    return items;
  }
  _computeLabelItems(chartArea) {
    const axis = this.axis;
    const options = this.options;
    const { position, ticks: optionTicks } = options;
    const isHorizontal = this.isHorizontal();
    const ticks = this.ticks;
    const { align, crossAlign, padding, mirror } = optionTicks;
    const tl = getTickMarkLength(options.grid);
    const tickAndPadding = tl + padding;
    const hTickAndPadding = mirror ? -padding : tickAndPadding;
    const rotation = -toRadians(this.labelRotation);
    const items = [];
    let i, ilen, tick, label, x, y, textAlign, pixel, font, lineHeight, lineCount, textOffset;
    let textBaseline = "middle";
    if (position === "top") {
      y = this.bottom - hTickAndPadding;
      textAlign = this._getXAxisLabelAlignment();
    } else if (position === "bottom") {
      y = this.top + hTickAndPadding;
      textAlign = this._getXAxisLabelAlignment();
    } else if (position === "left") {
      const ret = this._getYAxisLabelAlignment(tl);
      textAlign = ret.textAlign;
      x = ret.x;
    } else if (position === "right") {
      const ret = this._getYAxisLabelAlignment(tl);
      textAlign = ret.textAlign;
      x = ret.x;
    } else if (axis === "x") {
      if (position === "center") {
        y = (chartArea.top + chartArea.bottom) / 2 + tickAndPadding;
      } else if (isObject(position)) {
        const positionAxisID = Object.keys(position)[0];
        const value = position[positionAxisID];
        y = this.chart.scales[positionAxisID].getPixelForValue(value) + tickAndPadding;
      }
      textAlign = this._getXAxisLabelAlignment();
    } else if (axis === "y") {
      if (position === "center") {
        x = (chartArea.left + chartArea.right) / 2 - tickAndPadding;
      } else if (isObject(position)) {
        const positionAxisID = Object.keys(position)[0];
        const value = position[positionAxisID];
        x = this.chart.scales[positionAxisID].getPixelForValue(value);
      }
      textAlign = this._getYAxisLabelAlignment(tl).textAlign;
    }
    if (axis === "y") {
      if (align === "start") {
        textBaseline = "top";
      } else if (align === "end") {
        textBaseline = "bottom";
      }
    }
    const labelSizes = this._getLabelSizes();
    for (i = 0, ilen = ticks.length; i < ilen; ++i) {
      tick = ticks[i];
      label = tick.label;
      const optsAtIndex = optionTicks.setContext(this.getContext(i));
      pixel = this.getPixelForTick(i) + optionTicks.labelOffset;
      font = this._resolveTickFontOptions(i);
      lineHeight = font.lineHeight;
      lineCount = isArray(label) ? label.length : 1;
      const halfCount = lineCount / 2;
      const color2 = optsAtIndex.color;
      const strokeColor = optsAtIndex.textStrokeColor;
      const strokeWidth = optsAtIndex.textStrokeWidth;
      let tickTextAlign = textAlign;
      if (isHorizontal) {
        x = pixel;
        if (textAlign === "inner") {
          if (i === ilen - 1) {
            tickTextAlign = !this.options.reverse ? "right" : "left";
          } else if (i === 0) {
            tickTextAlign = !this.options.reverse ? "left" : "right";
          } else {
            tickTextAlign = "center";
          }
        }
        if (position === "top") {
          if (crossAlign === "near" || rotation !== 0) {
            textOffset = -lineCount * lineHeight + lineHeight / 2;
          } else if (crossAlign === "center") {
            textOffset = -labelSizes.highest.height / 2 - halfCount * lineHeight + lineHeight;
          } else {
            textOffset = -labelSizes.highest.height + lineHeight / 2;
          }
        } else {
          if (crossAlign === "near" || rotation !== 0) {
            textOffset = lineHeight / 2;
          } else if (crossAlign === "center") {
            textOffset = labelSizes.highest.height / 2 - halfCount * lineHeight;
          } else {
            textOffset = labelSizes.highest.height - lineCount * lineHeight;
          }
        }
        if (mirror) {
          textOffset *= -1;
        }
        if (rotation !== 0 && !optsAtIndex.showLabelBackdrop) {
          x += lineHeight / 2 * Math.sin(rotation);
        }
      } else {
        y = pixel;
        textOffset = (1 - lineCount) * lineHeight / 2;
      }
      let backdrop;
      if (optsAtIndex.showLabelBackdrop) {
        const labelPadding = toPadding(optsAtIndex.backdropPadding);
        const height = labelSizes.heights[i];
        const width = labelSizes.widths[i];
        let top = textOffset - labelPadding.top;
        let left = 0 - labelPadding.left;
        switch (textBaseline) {
          case "middle":
            top -= height / 2;
            break;
          case "bottom":
            top -= height;
            break;
        }
        switch (textAlign) {
          case "center":
            left -= width / 2;
            break;
          case "right":
            left -= width;
            break;
          case "inner":
            if (i === ilen - 1) {
              left -= width;
            } else if (i > 0) {
              left -= width / 2;
            }
            break;
        }
        backdrop = {
          left,
          top,
          width: width + labelPadding.width,
          height: height + labelPadding.height,
          color: optsAtIndex.backdropColor
        };
      }
      items.push({
        label,
        font,
        textOffset,
        options: {
          rotation,
          color: color2,
          strokeColor,
          strokeWidth,
          textAlign: tickTextAlign,
          textBaseline,
          translation: [
            x,
            y
          ],
          backdrop
        }
      });
    }
    return items;
  }
  _getXAxisLabelAlignment() {
    const { position, ticks } = this.options;
    const rotation = -toRadians(this.labelRotation);
    if (rotation) {
      return position === "top" ? "left" : "right";
    }
    let align = "center";
    if (ticks.align === "start") {
      align = "left";
    } else if (ticks.align === "end") {
      align = "right";
    } else if (ticks.align === "inner") {
      align = "inner";
    }
    return align;
  }
  _getYAxisLabelAlignment(tl) {
    const { position, ticks: { crossAlign, mirror, padding } } = this.options;
    const labelSizes = this._getLabelSizes();
    const tickAndPadding = tl + padding;
    const widest = labelSizes.widest.width;
    let textAlign;
    let x;
    if (position === "left") {
      if (mirror) {
        x = this.right + padding;
        if (crossAlign === "near") {
          textAlign = "left";
        } else if (crossAlign === "center") {
          textAlign = "center";
          x += widest / 2;
        } else {
          textAlign = "right";
          x += widest;
        }
      } else {
        x = this.right - tickAndPadding;
        if (crossAlign === "near") {
          textAlign = "right";
        } else if (crossAlign === "center") {
          textAlign = "center";
          x -= widest / 2;
        } else {
          textAlign = "left";
          x = this.left;
        }
      }
    } else if (position === "right") {
      if (mirror) {
        x = this.left + padding;
        if (crossAlign === "near") {
          textAlign = "right";
        } else if (crossAlign === "center") {
          textAlign = "center";
          x -= widest / 2;
        } else {
          textAlign = "left";
          x -= widest;
        }
      } else {
        x = this.left + tickAndPadding;
        if (crossAlign === "near") {
          textAlign = "left";
        } else if (crossAlign === "center") {
          textAlign = "center";
          x += widest / 2;
        } else {
          textAlign = "right";
          x = this.right;
        }
      }
    } else {
      textAlign = "right";
    }
    return {
      textAlign,
      x
    };
  }
  _computeLabelArea() {
    if (this.options.ticks.mirror) {
      return;
    }
    const chart = this.chart;
    const position = this.options.position;
    if (position === "left" || position === "right") {
      return {
        top: 0,
        left: this.left,
        bottom: chart.height,
        right: this.right
      };
    }
    if (position === "top" || position === "bottom") {
      return {
        top: this.top,
        left: 0,
        bottom: this.bottom,
        right: chart.width
      };
    }
  }
  drawBackground() {
    const { ctx, options: { backgroundColor }, left, top, width, height } = this;
    if (backgroundColor) {
      ctx.save();
      ctx.fillStyle = backgroundColor;
      ctx.fillRect(left, top, width, height);
      ctx.restore();
    }
  }
  getLineWidthForValue(value) {
    const grid = this.options.grid;
    if (!this._isVisible() || !grid.display) {
      return 0;
    }
    const ticks = this.ticks;
    const index2 = ticks.findIndex((t) => t.value === value);
    if (index2 >= 0) {
      const opts = grid.setContext(this.getContext(index2));
      return opts.lineWidth;
    }
    return 0;
  }
  drawGrid(chartArea) {
    const grid = this.options.grid;
    const ctx = this.ctx;
    const items = this._gridLineItems || (this._gridLineItems = this._computeGridLineItems(chartArea));
    let i, ilen;
    const drawLine = (p1, p2, style) => {
      if (!style.width || !style.color) {
        return;
      }
      ctx.save();
      ctx.lineWidth = style.width;
      ctx.strokeStyle = style.color;
      ctx.setLineDash(style.borderDash || []);
      ctx.lineDashOffset = style.borderDashOffset;
      ctx.beginPath();
      ctx.moveTo(p1.x, p1.y);
      ctx.lineTo(p2.x, p2.y);
      ctx.stroke();
      ctx.restore();
    };
    if (grid.display) {
      for (i = 0, ilen = items.length; i < ilen; ++i) {
        const item = items[i];
        if (grid.drawOnChartArea) {
          drawLine({
            x: item.x1,
            y: item.y1
          }, {
            x: item.x2,
            y: item.y2
          }, item);
        }
        if (grid.drawTicks) {
          drawLine({
            x: item.tx1,
            y: item.ty1
          }, {
            x: item.tx2,
            y: item.ty2
          }, {
            color: item.tickColor,
            width: item.tickWidth,
            borderDash: item.tickBorderDash,
            borderDashOffset: item.tickBorderDashOffset
          });
        }
      }
    }
  }
  drawBorder() {
    const { chart, ctx, options: { border, grid } } = this;
    const borderOpts = border.setContext(this.getContext());
    const axisWidth = border.display ? borderOpts.width : 0;
    if (!axisWidth) {
      return;
    }
    const lastLineWidth = grid.setContext(this.getContext(0)).lineWidth;
    const borderValue = this._borderValue;
    let x1, x2, y1, y2;
    if (this.isHorizontal()) {
      x1 = _alignPixel(chart, this.left, axisWidth) - axisWidth / 2;
      x2 = _alignPixel(chart, this.right, lastLineWidth) + lastLineWidth / 2;
      y1 = y2 = borderValue;
    } else {
      y1 = _alignPixel(chart, this.top, axisWidth) - axisWidth / 2;
      y2 = _alignPixel(chart, this.bottom, lastLineWidth) + lastLineWidth / 2;
      x1 = x2 = borderValue;
    }
    ctx.save();
    ctx.lineWidth = borderOpts.width;
    ctx.strokeStyle = borderOpts.color;
    ctx.beginPath();
    ctx.moveTo(x1, y1);
    ctx.lineTo(x2, y2);
    ctx.stroke();
    ctx.restore();
  }
  drawLabels(chartArea) {
    const optionTicks = this.options.ticks;
    if (!optionTicks.display) {
      return;
    }
    const ctx = this.ctx;
    const area = this._computeLabelArea();
    if (area) {
      clipArea(ctx, area);
    }
    const items = this.getLabelItems(chartArea);
    for (const item of items) {
      const renderTextOptions = item.options;
      const tickFont = item.font;
      const label = item.label;
      const y = item.textOffset;
      renderText(ctx, label, 0, y, tickFont, renderTextOptions);
    }
    if (area) {
      unclipArea(ctx);
    }
  }
  drawTitle() {
    const { ctx, options: { position, title, reverse } } = this;
    if (!title.display) {
      return;
    }
    const font = toFont(title.font);
    const padding = toPadding(title.padding);
    const align = title.align;
    let offset = font.lineHeight / 2;
    if (position === "bottom" || position === "center" || isObject(position)) {
      offset += padding.bottom;
      if (isArray(title.text)) {
        offset += font.lineHeight * (title.text.length - 1);
      }
    } else {
      offset += padding.top;
    }
    const { titleX, titleY, maxWidth, rotation } = titleArgs(this, offset, position, align);
    renderText(ctx, title.text, 0, 0, font, {
      color: title.color,
      maxWidth,
      rotation,
      textAlign: titleAlign(align, position, reverse),
      textBaseline: "middle",
      translation: [
        titleX,
        titleY
      ]
    });
  }
  draw(chartArea) {
    if (!this._isVisible()) {
      return;
    }
    this.drawBackground();
    this.drawGrid(chartArea);
    this.drawBorder();
    this.drawTitle();
    this.drawLabels(chartArea);
  }
  _layers() {
    const opts = this.options;
    const tz = opts.ticks && opts.ticks.z || 0;
    const gz = valueOrDefault(opts.grid && opts.grid.z, -1);
    const bz = valueOrDefault(opts.border && opts.border.z, 0);
    if (!this._isVisible() || this.draw !== Scale.prototype.draw) {
      return [
        {
          z: tz,
          draw: (chartArea) => {
            this.draw(chartArea);
          }
        }
      ];
    }
    return [
      {
        z: gz,
        draw: (chartArea) => {
          this.drawBackground();
          this.drawGrid(chartArea);
          this.drawTitle();
        }
      },
      {
        z: bz,
        draw: () => {
          this.drawBorder();
        }
      },
      {
        z: tz,
        draw: (chartArea) => {
          this.drawLabels(chartArea);
        }
      }
    ];
  }
  getMatchingVisibleMetas(type) {
    const metas = this.chart.getSortedVisibleDatasetMetas();
    const axisID = this.axis + "AxisID";
    const result = [];
    let i, ilen;
    for (i = 0, ilen = metas.length; i < ilen; ++i) {
      const meta = metas[i];
      if (meta[axisID] === this.id && (!type || meta.type === type)) {
        result.push(meta);
      }
    }
    return result;
  }
  _resolveTickFontOptions(index2) {
    const opts = this.options.ticks.setContext(this.getContext(index2));
    return toFont(opts.font);
  }
  _maxDigits() {
    const fontSize = this._resolveTickFontOptions(0).lineHeight;
    return (this.isHorizontal() ? this.width : this.height) / fontSize;
  }
};
var TypedRegistry = class {
  constructor(type, scope, override) {
    this.type = type;
    this.scope = scope;
    this.override = override;
    this.items = /* @__PURE__ */ Object.create(null);
  }
  isForType(type) {
    return Object.prototype.isPrototypeOf.call(this.type.prototype, type.prototype);
  }
  register(item) {
    const proto = Object.getPrototypeOf(item);
    let parentScope;
    if (isIChartComponent(proto)) {
      parentScope = this.register(proto);
    }
    const items = this.items;
    const id = item.id;
    const scope = this.scope + "." + id;
    if (!id) {
      throw new Error("class does not have id: " + item);
    }
    if (id in items) {
      return scope;
    }
    items[id] = item;
    registerDefaults(item, scope, parentScope);
    if (this.override) {
      defaults.override(item.id, item.overrides);
    }
    return scope;
  }
  get(id) {
    return this.items[id];
  }
  unregister(item) {
    const items = this.items;
    const id = item.id;
    const scope = this.scope;
    if (id in items) {
      delete items[id];
    }
    if (scope && id in defaults[scope]) {
      delete defaults[scope][id];
      if (this.override) {
        delete overrides[id];
      }
    }
  }
};
function registerDefaults(item, scope, parentScope) {
  const itemDefaults = merge(/* @__PURE__ */ Object.create(null), [
    parentScope ? defaults.get(parentScope) : {},
    defaults.get(scope),
    item.defaults
  ]);
  defaults.set(scope, itemDefaults);
  if (item.defaultRoutes) {
    routeDefaults(scope, item.defaultRoutes);
  }
  if (item.descriptors) {
    defaults.describe(scope, item.descriptors);
  }
}
function routeDefaults(scope, routes) {
  Object.keys(routes).forEach((property) => {
    const propertyParts = property.split(".");
    const sourceName = propertyParts.pop();
    const sourceScope = [
      scope
    ].concat(propertyParts).join(".");
    const parts = routes[property].split(".");
    const targetName = parts.pop();
    const targetScope = parts.join(".");
    defaults.route(sourceScope, sourceName, targetScope, targetName);
  });
}
function isIChartComponent(proto) {
  return "id" in proto && "defaults" in proto;
}
var Registry = class {
  constructor() {
    this.controllers = new TypedRegistry(DatasetController, "datasets", true);
    this.elements = new TypedRegistry(Element, "elements");
    this.plugins = new TypedRegistry(Object, "plugins");
    this.scales = new TypedRegistry(Scale, "scales");
    this._typedRegistries = [
      this.controllers,
      this.scales,
      this.elements
    ];
  }
  add(...args) {
    this._each("register", args);
  }
  remove(...args) {
    this._each("unregister", args);
  }
  addControllers(...args) {
    this._each("register", args, this.controllers);
  }
  addElements(...args) {
    this._each("register", args, this.elements);
  }
  addPlugins(...args) {
    this._each("register", args, this.plugins);
  }
  addScales(...args) {
    this._each("register", args, this.scales);
  }
  getController(id) {
    return this._get(id, this.controllers, "controller");
  }
  getElement(id) {
    return this._get(id, this.elements, "element");
  }
  getPlugin(id) {
    return this._get(id, this.plugins, "plugin");
  }
  getScale(id) {
    return this._get(id, this.scales, "scale");
  }
  removeControllers(...args) {
    this._each("unregister", args, this.controllers);
  }
  removeElements(...args) {
    this._each("unregister", args, this.elements);
  }
  removePlugins(...args) {
    this._each("unregister", args, this.plugins);
  }
  removeScales(...args) {
    this._each("unregister", args, this.scales);
  }
  _each(method, args, typedRegistry) {
    [
      ...args
    ].forEach((arg) => {
      const reg = typedRegistry || this._getRegistryForType(arg);
      if (typedRegistry || reg.isForType(arg) || reg === this.plugins && arg.id) {
        this._exec(method, reg, arg);
      } else {
        each(arg, (item) => {
          const itemReg = typedRegistry || this._getRegistryForType(item);
          this._exec(method, itemReg, item);
        });
      }
    });
  }
  _exec(method, registry2, component) {
    const camelMethod = _capitalize(method);
    callback(component["before" + camelMethod], [], component);
    registry2[method](component);
    callback(component["after" + camelMethod], [], component);
  }
  _getRegistryForType(type) {
    for (let i = 0; i < this._typedRegistries.length; i++) {
      const reg = this._typedRegistries[i];
      if (reg.isForType(type)) {
        return reg;
      }
    }
    return this.plugins;
  }
  _get(id, typedRegistry, type) {
    const item = typedRegistry.get(id);
    if (item === void 0) {
      throw new Error('"' + id + '" is not a registered ' + type + ".");
    }
    return item;
  }
};
var registry = /* @__PURE__ */ new Registry();
var PluginService = class {
  constructor() {
    this._init = [];
  }
  notify(chart, hook, args, filter) {
    if (hook === "beforeInit") {
      this._init = this._createDescriptors(chart, true);
      this._notify(this._init, chart, "install");
    }
    const descriptors2 = filter ? this._descriptors(chart).filter(filter) : this._descriptors(chart);
    const result = this._notify(descriptors2, chart, hook, args);
    if (hook === "afterDestroy") {
      this._notify(descriptors2, chart, "stop");
      this._notify(this._init, chart, "uninstall");
    }
    return result;
  }
  _notify(descriptors2, chart, hook, args) {
    args = args || {};
    for (const descriptor of descriptors2) {
      const plugin2 = descriptor.plugin;
      const method = plugin2[hook];
      const params = [
        chart,
        args,
        descriptor.options
      ];
      if (callback(method, params, plugin2) === false && args.cancelable) {
        return false;
      }
    }
    return true;
  }
  invalidate() {
    if (!isNullOrUndef(this._cache)) {
      this._oldCache = this._cache;
      this._cache = void 0;
    }
  }
  _descriptors(chart) {
    if (this._cache) {
      return this._cache;
    }
    const descriptors2 = this._cache = this._createDescriptors(chart);
    this._notifyStateChanges(chart);
    return descriptors2;
  }
  _createDescriptors(chart, all) {
    const config = chart && chart.config;
    const options = valueOrDefault(config.options && config.options.plugins, {});
    const plugins2 = allPlugins(config);
    return options === false && !all ? [] : createDescriptors(chart, plugins2, options, all);
  }
  _notifyStateChanges(chart) {
    const previousDescriptors = this._oldCache || [];
    const descriptors2 = this._cache;
    const diff = (a, b) => a.filter((x) => !b.some((y) => x.plugin.id === y.plugin.id));
    this._notify(diff(previousDescriptors, descriptors2), chart, "stop");
    this._notify(diff(descriptors2, previousDescriptors), chart, "start");
  }
};
function allPlugins(config) {
  const localIds = {};
  const plugins2 = [];
  const keys = Object.keys(registry.plugins.items);
  for (let i = 0; i < keys.length; i++) {
    plugins2.push(registry.getPlugin(keys[i]));
  }
  const local = config.plugins || [];
  for (let i = 0; i < local.length; i++) {
    const plugin2 = local[i];
    if (plugins2.indexOf(plugin2) === -1) {
      plugins2.push(plugin2);
      localIds[plugin2.id] = true;
    }
  }
  return {
    plugins: plugins2,
    localIds
  };
}
function getOpts(options, all) {
  if (!all && options === false) {
    return null;
  }
  if (options === true) {
    return {};
  }
  return options;
}
function createDescriptors(chart, { plugins: plugins2, localIds }, options, all) {
  const result = [];
  const context = chart.getContext();
  for (const plugin2 of plugins2) {
    const id = plugin2.id;
    const opts = getOpts(options[id], all);
    if (opts === null) {
      continue;
    }
    result.push({
      plugin: plugin2,
      options: pluginOpts(chart.config, {
        plugin: plugin2,
        local: localIds[id]
      }, opts, context)
    });
  }
  return result;
}
function pluginOpts(config, { plugin: plugin2, local }, opts, context) {
  const keys = config.pluginScopeKeys(plugin2);
  const scopes = config.getOptionScopes(opts, keys);
  if (local && plugin2.defaults) {
    scopes.push(plugin2.defaults);
  }
  return config.createResolver(scopes, context, [
    ""
  ], {
    scriptable: false,
    indexable: false,
    allKeys: true
  });
}
function getIndexAxis(type, options) {
  const datasetDefaults = defaults.datasets[type] || {};
  const datasetOptions = (options.datasets || {})[type] || {};
  return datasetOptions.indexAxis || options.indexAxis || datasetDefaults.indexAxis || "x";
}
function getAxisFromDefaultScaleID(id, indexAxis) {
  let axis = id;
  if (id === "_index_") {
    axis = indexAxis;
  } else if (id === "_value_") {
    axis = indexAxis === "x" ? "y" : "x";
  }
  return axis;
}
function getDefaultScaleIDFromAxis(axis, indexAxis) {
  return axis === indexAxis ? "_index_" : "_value_";
}
function idMatchesAxis(id) {
  if (id === "x" || id === "y" || id === "r") {
    return id;
  }
}
function axisFromPosition(position) {
  if (position === "top" || position === "bottom") {
    return "x";
  }
  if (position === "left" || position === "right") {
    return "y";
  }
}
function determineAxis(id, ...scaleOptions) {
  if (idMatchesAxis(id)) {
    return id;
  }
  for (const opts of scaleOptions) {
    const axis = opts.axis || axisFromPosition(opts.position) || id.length > 1 && idMatchesAxis(id[0].toLowerCase());
    if (axis) {
      return axis;
    }
  }
  throw new Error(`Cannot determine type of '${id}' axis. Please provide 'axis' or 'position' option.`);
}
function getAxisFromDataset(id, axis, dataset) {
  if (dataset[axis + "AxisID"] === id) {
    return {
      axis
    };
  }
}
function retrieveAxisFromDatasets(id, config) {
  if (config.data && config.data.datasets) {
    const boundDs = config.data.datasets.filter((d) => d.xAxisID === id || d.yAxisID === id);
    if (boundDs.length) {
      return getAxisFromDataset(id, "x", boundDs[0]) || getAxisFromDataset(id, "y", boundDs[0]);
    }
  }
  return {};
}
function mergeScaleConfig(config, options) {
  const chartDefaults = overrides[config.type] || {
    scales: {}
  };
  const configScales = options.scales || {};
  const chartIndexAxis = getIndexAxis(config.type, options);
  const scales2 = /* @__PURE__ */ Object.create(null);
  Object.keys(configScales).forEach((id) => {
    const scaleConf = configScales[id];
    if (!isObject(scaleConf)) {
      return console.error(`Invalid scale configuration for scale: ${id}`);
    }
    if (scaleConf._proxy) {
      return console.warn(`Ignoring resolver passed as options for scale: ${id}`);
    }
    const axis = determineAxis(id, scaleConf, retrieveAxisFromDatasets(id, config), defaults.scales[scaleConf.type]);
    const defaultId = getDefaultScaleIDFromAxis(axis, chartIndexAxis);
    const defaultScaleOptions = chartDefaults.scales || {};
    scales2[id] = mergeIf(/* @__PURE__ */ Object.create(null), [
      {
        axis
      },
      scaleConf,
      defaultScaleOptions[axis],
      defaultScaleOptions[defaultId]
    ]);
  });
  config.data.datasets.forEach((dataset) => {
    const type = dataset.type || config.type;
    const indexAxis = dataset.indexAxis || getIndexAxis(type, options);
    const datasetDefaults = overrides[type] || {};
    const defaultScaleOptions = datasetDefaults.scales || {};
    Object.keys(defaultScaleOptions).forEach((defaultID) => {
      const axis = getAxisFromDefaultScaleID(defaultID, indexAxis);
      const id = dataset[axis + "AxisID"] || axis;
      scales2[id] = scales2[id] || /* @__PURE__ */ Object.create(null);
      mergeIf(scales2[id], [
        {
          axis
        },
        configScales[id],
        defaultScaleOptions[defaultID]
      ]);
    });
  });
  Object.keys(scales2).forEach((key) => {
    const scale = scales2[key];
    mergeIf(scale, [
      defaults.scales[scale.type],
      defaults.scale
    ]);
  });
  return scales2;
}
function initOptions(config) {
  const options = config.options || (config.options = {});
  options.plugins = valueOrDefault(options.plugins, {});
  options.scales = mergeScaleConfig(config, options);
}
function initData(data) {
  data = data || {};
  data.datasets = data.datasets || [];
  data.labels = data.labels || [];
  return data;
}
function initConfig(config) {
  config = config || {};
  config.data = initData(config.data);
  initOptions(config);
  return config;
}
var keyCache = /* @__PURE__ */ new Map();
var keysCached = /* @__PURE__ */ new Set();
function cachedKeys(cacheKey, generate) {
  let keys = keyCache.get(cacheKey);
  if (!keys) {
    keys = generate();
    keyCache.set(cacheKey, keys);
    keysCached.add(keys);
  }
  return keys;
}
var addIfFound = (set2, obj, key) => {
  const opts = resolveObjectKey(obj, key);
  if (opts !== void 0) {
    set2.add(opts);
  }
};
var Config = class {
  constructor(config) {
    this._config = initConfig(config);
    this._scopeCache = /* @__PURE__ */ new Map();
    this._resolverCache = /* @__PURE__ */ new Map();
  }
  get platform() {
    return this._config.platform;
  }
  get type() {
    return this._config.type;
  }
  set type(type) {
    this._config.type = type;
  }
  get data() {
    return this._config.data;
  }
  set data(data) {
    this._config.data = initData(data);
  }
  get options() {
    return this._config.options;
  }
  set options(options) {
    this._config.options = options;
  }
  get plugins() {
    return this._config.plugins;
  }
  update() {
    const config = this._config;
    this.clearCache();
    initOptions(config);
  }
  clearCache() {
    this._scopeCache.clear();
    this._resolverCache.clear();
  }
  datasetScopeKeys(datasetType) {
    return cachedKeys(datasetType, () => [
      [
        `datasets.${datasetType}`,
        ""
      ]
    ]);
  }
  datasetAnimationScopeKeys(datasetType, transition) {
    return cachedKeys(`${datasetType}.transition.${transition}`, () => [
      [
        `datasets.${datasetType}.transitions.${transition}`,
        `transitions.${transition}`
      ],
      [
        `datasets.${datasetType}`,
        ""
      ]
    ]);
  }
  datasetElementScopeKeys(datasetType, elementType) {
    return cachedKeys(`${datasetType}-${elementType}`, () => [
      [
        `datasets.${datasetType}.elements.${elementType}`,
        `datasets.${datasetType}`,
        `elements.${elementType}`,
        ""
      ]
    ]);
  }
  pluginScopeKeys(plugin2) {
    const id = plugin2.id;
    const type = this.type;
    return cachedKeys(`${type}-plugin-${id}`, () => [
      [
        `plugins.${id}`,
        ...plugin2.additionalOptionScopes || []
      ]
    ]);
  }
  _cachedScopes(mainScope, resetCache) {
    const _scopeCache = this._scopeCache;
    let cache = _scopeCache.get(mainScope);
    if (!cache || resetCache) {
      cache = /* @__PURE__ */ new Map();
      _scopeCache.set(mainScope, cache);
    }
    return cache;
  }
  getOptionScopes(mainScope, keyLists, resetCache) {
    const { options, type } = this;
    const cache = this._cachedScopes(mainScope, resetCache);
    const cached = cache.get(keyLists);
    if (cached) {
      return cached;
    }
    const scopes = /* @__PURE__ */ new Set();
    keyLists.forEach((keys) => {
      if (mainScope) {
        scopes.add(mainScope);
        keys.forEach((key) => addIfFound(scopes, mainScope, key));
      }
      keys.forEach((key) => addIfFound(scopes, options, key));
      keys.forEach((key) => addIfFound(scopes, overrides[type] || {}, key));
      keys.forEach((key) => addIfFound(scopes, defaults, key));
      keys.forEach((key) => addIfFound(scopes, descriptors, key));
    });
    const array = Array.from(scopes);
    if (array.length === 0) {
      array.push(/* @__PURE__ */ Object.create(null));
    }
    if (keysCached.has(keyLists)) {
      cache.set(keyLists, array);
    }
    return array;
  }
  chartOptionScopes() {
    const { options, type } = this;
    return [
      options,
      overrides[type] || {},
      defaults.datasets[type] || {},
      {
        type
      },
      defaults,
      descriptors
    ];
  }
  resolveNamedOptions(scopes, names2, context, prefixes = [
    ""
  ]) {
    const result = {
      $shared: true
    };
    const { resolver, subPrefixes } = getResolver(this._resolverCache, scopes, prefixes);
    let options = resolver;
    if (needContext(resolver, names2)) {
      result.$shared = false;
      context = isFunction(context) ? context() : context;
      const subResolver = this.createResolver(scopes, context, subPrefixes);
      options = _attachContext(resolver, context, subResolver);
    }
    for (const prop of names2) {
      result[prop] = options[prop];
    }
    return result;
  }
  createResolver(scopes, context, prefixes = [
    ""
  ], descriptorDefaults) {
    const { resolver } = getResolver(this._resolverCache, scopes, prefixes);
    return isObject(context) ? _attachContext(resolver, context, void 0, descriptorDefaults) : resolver;
  }
};
function getResolver(resolverCache, scopes, prefixes) {
  let cache = resolverCache.get(scopes);
  if (!cache) {
    cache = /* @__PURE__ */ new Map();
    resolverCache.set(scopes, cache);
  }
  const cacheKey = prefixes.join();
  let cached = cache.get(cacheKey);
  if (!cached) {
    const resolver = _createResolver(scopes, prefixes);
    cached = {
      resolver,
      subPrefixes: prefixes.filter((p) => !p.toLowerCase().includes("hover"))
    };
    cache.set(cacheKey, cached);
  }
  return cached;
}
var hasFunction = (value) => isObject(value) && Object.getOwnPropertyNames(value).some((key) => isFunction(value[key]));
function needContext(proxy, names2) {
  const { isScriptable, isIndexable } = _descriptors(proxy);
  for (const prop of names2) {
    const scriptable = isScriptable(prop);
    const indexable = isIndexable(prop);
    const value = (indexable || scriptable) && proxy[prop];
    if (scriptable && (isFunction(value) || hasFunction(value)) || indexable && isArray(value)) {
      return true;
    }
  }
  return false;
}
var version = "4.4.4";
var KNOWN_POSITIONS = [
  "top",
  "bottom",
  "left",
  "right",
  "chartArea"
];
function positionIsHorizontal(position, axis) {
  return position === "top" || position === "bottom" || KNOWN_POSITIONS.indexOf(position) === -1 && axis === "x";
}
function compare2Level(l1, l2) {
  return function(a, b) {
    return a[l1] === b[l1] ? a[l2] - b[l2] : a[l1] - b[l1];
  };
}
function onAnimationsComplete(context) {
  const chart = context.chart;
  const animationOptions = chart.options.animation;
  chart.notifyPlugins("afterRender");
  callback(animationOptions && animationOptions.onComplete, [
    context
  ], chart);
}
function onAnimationProgress(context) {
  const chart = context.chart;
  const animationOptions = chart.options.animation;
  callback(animationOptions && animationOptions.onProgress, [
    context
  ], chart);
}
function getCanvas(item) {
  if (_isDomSupported() && typeof item === "string") {
    item = document.getElementById(item);
  } else if (item && item.length) {
    item = item[0];
  }
  if (item && item.canvas) {
    item = item.canvas;
  }
  return item;
}
var instances = {};
var getChart = (key) => {
  const canvas = getCanvas(key);
  return Object.values(instances).filter((c) => c.canvas === canvas).pop();
};
function moveNumericKeys(obj, start, move) {
  const keys = Object.keys(obj);
  for (const key of keys) {
    const intKey = +key;
    if (intKey >= start) {
      const value = obj[key];
      delete obj[key];
      if (move > 0 || intKey > start) {
        obj[intKey + move] = value;
      }
    }
  }
}
function determineLastEvent(e, lastEvent, inChartArea, isClick) {
  if (!inChartArea || e.type === "mouseout") {
    return null;
  }
  if (isClick) {
    return lastEvent;
  }
  return e;
}
function getSizeForArea(scale, chartArea, field) {
  return scale.options.clip ? scale[field] : chartArea[field];
}
function getDatasetArea(meta, chartArea) {
  const { xScale, yScale } = meta;
  if (xScale && yScale) {
    return {
      left: getSizeForArea(xScale, chartArea, "left"),
      right: getSizeForArea(xScale, chartArea, "right"),
      top: getSizeForArea(yScale, chartArea, "top"),
      bottom: getSizeForArea(yScale, chartArea, "bottom")
    };
  }
  return chartArea;
}
var Chart = class {
  static register(...items) {
    registry.add(...items);
    invalidatePlugins();
  }
  static unregister(...items) {
    registry.remove(...items);
    invalidatePlugins();
  }
  constructor(item, userConfig) {
    const config = this.config = new Config(userConfig);
    const initialCanvas = getCanvas(item);
    const existingChart = getChart(initialCanvas);
    if (existingChart) {
      throw new Error("Canvas is already in use. Chart with ID '" + existingChart.id + "' must be destroyed before the canvas with ID '" + existingChart.canvas.id + "' can be reused.");
    }
    const options = config.createResolver(config.chartOptionScopes(), this.getContext());
    this.platform = new (config.platform || _detectPlatform(initialCanvas))();
    this.platform.updateConfig(config);
    const context = this.platform.acquireContext(initialCanvas, options.aspectRatio);
    const canvas = context && context.canvas;
    const height = canvas && canvas.height;
    const width = canvas && canvas.width;
    this.id = uid();
    this.ctx = context;
    this.canvas = canvas;
    this.width = width;
    this.height = height;
    this._options = options;
    this._aspectRatio = this.aspectRatio;
    this._layers = [];
    this._metasets = [];
    this._stacks = void 0;
    this.boxes = [];
    this.currentDevicePixelRatio = void 0;
    this.chartArea = void 0;
    this._active = [];
    this._lastEvent = void 0;
    this._listeners = {};
    this._responsiveListeners = void 0;
    this._sortedMetasets = [];
    this.scales = {};
    this._plugins = new PluginService();
    this.$proxies = {};
    this._hiddenIndices = {};
    this.attached = false;
    this._animationsDisabled = void 0;
    this.$context = void 0;
    this._doResize = debounce((mode) => this.update(mode), options.resizeDelay || 0);
    this._dataChanges = [];
    instances[this.id] = this;
    if (!context || !canvas) {
      console.error("Failed to create chart: can't acquire context from the given item");
      return;
    }
    animator.listen(this, "complete", onAnimationsComplete);
    animator.listen(this, "progress", onAnimationProgress);
    this._initialize();
    if (this.attached) {
      this.update();
    }
  }
  get aspectRatio() {
    const { options: { aspectRatio, maintainAspectRatio }, width, height, _aspectRatio } = this;
    if (!isNullOrUndef(aspectRatio)) {
      return aspectRatio;
    }
    if (maintainAspectRatio && _aspectRatio) {
      return _aspectRatio;
    }
    return height ? width / height : null;
  }
  get data() {
    return this.config.data;
  }
  set data(data) {
    this.config.data = data;
  }
  get options() {
    return this._options;
  }
  set options(options) {
    this.config.options = options;
  }
  get registry() {
    return registry;
  }
  _initialize() {
    this.notifyPlugins("beforeInit");
    if (this.options.responsive) {
      this.resize();
    } else {
      retinaScale(this, this.options.devicePixelRatio);
    }
    this.bindEvents();
    this.notifyPlugins("afterInit");
    return this;
  }
  clear() {
    clearCanvas(this.canvas, this.ctx);
    return this;
  }
  stop() {
    animator.stop(this);
    return this;
  }
  resize(width, height) {
    if (!animator.running(this)) {
      this._resize(width, height);
    } else {
      this._resizeBeforeDraw = {
        width,
        height
      };
    }
  }
  _resize(width, height) {
    const options = this.options;
    const canvas = this.canvas;
    const aspectRatio = options.maintainAspectRatio && this.aspectRatio;
    const newSize = this.platform.getMaximumSize(canvas, width, height, aspectRatio);
    const newRatio = options.devicePixelRatio || this.platform.getDevicePixelRatio();
    const mode = this.width ? "resize" : "attach";
    this.width = newSize.width;
    this.height = newSize.height;
    this._aspectRatio = this.aspectRatio;
    if (!retinaScale(this, newRatio, true)) {
      return;
    }
    this.notifyPlugins("resize", {
      size: newSize
    });
    callback(options.onResize, [
      this,
      newSize
    ], this);
    if (this.attached) {
      if (this._doResize(mode)) {
        this.render();
      }
    }
  }
  ensureScalesHaveIDs() {
    const options = this.options;
    const scalesOptions = options.scales || {};
    each(scalesOptions, (axisOptions, axisID) => {
      axisOptions.id = axisID;
    });
  }
  buildOrUpdateScales() {
    const options = this.options;
    const scaleOpts = options.scales;
    const scales2 = this.scales;
    const updated = Object.keys(scales2).reduce((obj, id) => {
      obj[id] = false;
      return obj;
    }, {});
    let items = [];
    if (scaleOpts) {
      items = items.concat(Object.keys(scaleOpts).map((id) => {
        const scaleOptions = scaleOpts[id];
        const axis = determineAxis(id, scaleOptions);
        const isRadial = axis === "r";
        const isHorizontal = axis === "x";
        return {
          options: scaleOptions,
          dposition: isRadial ? "chartArea" : isHorizontal ? "bottom" : "left",
          dtype: isRadial ? "radialLinear" : isHorizontal ? "category" : "linear"
        };
      }));
    }
    each(items, (item) => {
      const scaleOptions = item.options;
      const id = scaleOptions.id;
      const axis = determineAxis(id, scaleOptions);
      const scaleType = valueOrDefault(scaleOptions.type, item.dtype);
      if (scaleOptions.position === void 0 || positionIsHorizontal(scaleOptions.position, axis) !== positionIsHorizontal(item.dposition)) {
        scaleOptions.position = item.dposition;
      }
      updated[id] = true;
      let scale = null;
      if (id in scales2 && scales2[id].type === scaleType) {
        scale = scales2[id];
      } else {
        const scaleClass = registry.getScale(scaleType);
        scale = new scaleClass({
          id,
          type: scaleType,
          ctx: this.ctx,
          chart: this
        });
        scales2[scale.id] = scale;
      }
      scale.init(scaleOptions, options);
    });
    each(updated, (hasUpdated, id) => {
      if (!hasUpdated) {
        delete scales2[id];
      }
    });
    each(scales2, (scale) => {
      layouts.configure(this, scale, scale.options);
      layouts.addBox(this, scale);
    });
  }
  _updateMetasets() {
    const metasets = this._metasets;
    const numData = this.data.datasets.length;
    const numMeta = metasets.length;
    metasets.sort((a, b) => a.index - b.index);
    if (numMeta > numData) {
      for (let i = numData; i < numMeta; ++i) {
        this._destroyDatasetMeta(i);
      }
      metasets.splice(numData, numMeta - numData);
    }
    this._sortedMetasets = metasets.slice(0).sort(compare2Level("order", "index"));
  }
  _removeUnreferencedMetasets() {
    const { _metasets: metasets, data: { datasets } } = this;
    if (metasets.length > datasets.length) {
      delete this._stacks;
    }
    metasets.forEach((meta, index2) => {
      if (datasets.filter((x) => x === meta._dataset).length === 0) {
        this._destroyDatasetMeta(index2);
      }
    });
  }
  buildOrUpdateControllers() {
    const newControllers = [];
    const datasets = this.data.datasets;
    let i, ilen;
    this._removeUnreferencedMetasets();
    for (i = 0, ilen = datasets.length; i < ilen; i++) {
      const dataset = datasets[i];
      let meta = this.getDatasetMeta(i);
      const type = dataset.type || this.config.type;
      if (meta.type && meta.type !== type) {
        this._destroyDatasetMeta(i);
        meta = this.getDatasetMeta(i);
      }
      meta.type = type;
      meta.indexAxis = dataset.indexAxis || getIndexAxis(type, this.options);
      meta.order = dataset.order || 0;
      meta.index = i;
      meta.label = "" + dataset.label;
      meta.visible = this.isDatasetVisible(i);
      if (meta.controller) {
        meta.controller.updateIndex(i);
        meta.controller.linkScales();
      } else {
        const ControllerClass = registry.getController(type);
        const { datasetElementType, dataElementType } = defaults.datasets[type];
        Object.assign(ControllerClass, {
          dataElementType: registry.getElement(dataElementType),
          datasetElementType: datasetElementType && registry.getElement(datasetElementType)
        });
        meta.controller = new ControllerClass(this, i);
        newControllers.push(meta.controller);
      }
    }
    this._updateMetasets();
    return newControllers;
  }
  _resetElements() {
    each(this.data.datasets, (dataset, datasetIndex) => {
      this.getDatasetMeta(datasetIndex).controller.reset();
    }, this);
  }
  reset() {
    this._resetElements();
    this.notifyPlugins("reset");
  }
  update(mode) {
    const config = this.config;
    config.update();
    const options = this._options = config.createResolver(config.chartOptionScopes(), this.getContext());
    const animsDisabled = this._animationsDisabled = !options.animation;
    this._updateScales();
    this._checkEventBindings();
    this._updateHiddenIndices();
    this._plugins.invalidate();
    if (this.notifyPlugins("beforeUpdate", {
      mode,
      cancelable: true
    }) === false) {
      return;
    }
    const newControllers = this.buildOrUpdateControllers();
    this.notifyPlugins("beforeElementsUpdate");
    let minPadding = 0;
    for (let i = 0, ilen = this.data.datasets.length; i < ilen; i++) {
      const { controller } = this.getDatasetMeta(i);
      const reset = !animsDisabled && newControllers.indexOf(controller) === -1;
      controller.buildOrUpdateElements(reset);
      minPadding = Math.max(+controller.getMaxOverflow(), minPadding);
    }
    minPadding = this._minPadding = options.layout.autoPadding ? minPadding : 0;
    this._updateLayout(minPadding);
    if (!animsDisabled) {
      each(newControllers, (controller) => {
        controller.reset();
      });
    }
    this._updateDatasets(mode);
    this.notifyPlugins("afterUpdate", {
      mode
    });
    this._layers.sort(compare2Level("z", "_idx"));
    const { _active, _lastEvent } = this;
    if (_lastEvent) {
      this._eventHandler(_lastEvent, true);
    } else if (_active.length) {
      this._updateHoverStyles(_active, _active, true);
    }
    this.render();
  }
  _updateScales() {
    each(this.scales, (scale) => {
      layouts.removeBox(this, scale);
    });
    this.ensureScalesHaveIDs();
    this.buildOrUpdateScales();
  }
  _checkEventBindings() {
    const options = this.options;
    const existingEvents = new Set(Object.keys(this._listeners));
    const newEvents = new Set(options.events);
    if (!setsEqual(existingEvents, newEvents) || !!this._responsiveListeners !== options.responsive) {
      this.unbindEvents();
      this.bindEvents();
    }
  }
  _updateHiddenIndices() {
    const { _hiddenIndices } = this;
    const changes = this._getUniformDataChanges() || [];
    for (const { method, start, count } of changes) {
      const move = method === "_removeElements" ? -count : count;
      moveNumericKeys(_hiddenIndices, start, move);
    }
  }
  _getUniformDataChanges() {
    const _dataChanges = this._dataChanges;
    if (!_dataChanges || !_dataChanges.length) {
      return;
    }
    this._dataChanges = [];
    const datasetCount = this.data.datasets.length;
    const makeSet = (idx) => new Set(_dataChanges.filter((c) => c[0] === idx).map((c, i) => i + "," + c.splice(1).join(",")));
    const changeSet = makeSet(0);
    for (let i = 1; i < datasetCount; i++) {
      if (!setsEqual(changeSet, makeSet(i))) {
        return;
      }
    }
    return Array.from(changeSet).map((c) => c.split(",")).map((a) => ({
      method: a[1],
      start: +a[2],
      count: +a[3]
    }));
  }
  _updateLayout(minPadding) {
    if (this.notifyPlugins("beforeLayout", {
      cancelable: true
    }) === false) {
      return;
    }
    layouts.update(this, this.width, this.height, minPadding);
    const area = this.chartArea;
    const noArea = area.width <= 0 || area.height <= 0;
    this._layers = [];
    each(this.boxes, (box) => {
      if (noArea && box.position === "chartArea") {
        return;
      }
      if (box.configure) {
        box.configure();
      }
      this._layers.push(...box._layers());
    }, this);
    this._layers.forEach((item, index2) => {
      item._idx = index2;
    });
    this.notifyPlugins("afterLayout");
  }
  _updateDatasets(mode) {
    if (this.notifyPlugins("beforeDatasetsUpdate", {
      mode,
      cancelable: true
    }) === false) {
      return;
    }
    for (let i = 0, ilen = this.data.datasets.length; i < ilen; ++i) {
      this.getDatasetMeta(i).controller.configure();
    }
    for (let i = 0, ilen = this.data.datasets.length; i < ilen; ++i) {
      this._updateDataset(i, isFunction(mode) ? mode({
        datasetIndex: i
      }) : mode);
    }
    this.notifyPlugins("afterDatasetsUpdate", {
      mode
    });
  }
  _updateDataset(index2, mode) {
    const meta = this.getDatasetMeta(index2);
    const args = {
      meta,
      index: index2,
      mode,
      cancelable: true
    };
    if (this.notifyPlugins("beforeDatasetUpdate", args) === false) {
      return;
    }
    meta.controller._update(mode);
    args.cancelable = false;
    this.notifyPlugins("afterDatasetUpdate", args);
  }
  render() {
    if (this.notifyPlugins("beforeRender", {
      cancelable: true
    }) === false) {
      return;
    }
    if (animator.has(this)) {
      if (this.attached && !animator.running(this)) {
        animator.start(this);
      }
    } else {
      this.draw();
      onAnimationsComplete({
        chart: this
      });
    }
  }
  draw() {
    let i;
    if (this._resizeBeforeDraw) {
      const { width, height } = this._resizeBeforeDraw;
      this._resizeBeforeDraw = null;
      this._resize(width, height);
    }
    this.clear();
    if (this.width <= 0 || this.height <= 0) {
      return;
    }
    if (this.notifyPlugins("beforeDraw", {
      cancelable: true
    }) === false) {
      return;
    }
    const layers = this._layers;
    for (i = 0; i < layers.length && layers[i].z <= 0; ++i) {
      layers[i].draw(this.chartArea);
    }
    this._drawDatasets();
    for (; i < layers.length; ++i) {
      layers[i].draw(this.chartArea);
    }
    this.notifyPlugins("afterDraw");
  }
  _getSortedDatasetMetas(filterVisible) {
    const metasets = this._sortedMetasets;
    const result = [];
    let i, ilen;
    for (i = 0, ilen = metasets.length; i < ilen; ++i) {
      const meta = metasets[i];
      if (!filterVisible || meta.visible) {
        result.push(meta);
      }
    }
    return result;
  }
  getSortedVisibleDatasetMetas() {
    return this._getSortedDatasetMetas(true);
  }
  _drawDatasets() {
    if (this.notifyPlugins("beforeDatasetsDraw", {
      cancelable: true
    }) === false) {
      return;
    }
    const metasets = this.getSortedVisibleDatasetMetas();
    for (let i = metasets.length - 1; i >= 0; --i) {
      this._drawDataset(metasets[i]);
    }
    this.notifyPlugins("afterDatasetsDraw");
  }
  _drawDataset(meta) {
    const ctx = this.ctx;
    const clip = meta._clip;
    const useClip = !clip.disabled;
    const area = getDatasetArea(meta, this.chartArea);
    const args = {
      meta,
      index: meta.index,
      cancelable: true
    };
    if (this.notifyPlugins("beforeDatasetDraw", args) === false) {
      return;
    }
    if (useClip) {
      clipArea(ctx, {
        left: clip.left === false ? 0 : area.left - clip.left,
        right: clip.right === false ? this.width : area.right + clip.right,
        top: clip.top === false ? 0 : area.top - clip.top,
        bottom: clip.bottom === false ? this.height : area.bottom + clip.bottom
      });
    }
    meta.controller.draw();
    if (useClip) {
      unclipArea(ctx);
    }
    args.cancelable = false;
    this.notifyPlugins("afterDatasetDraw", args);
  }
  isPointInArea(point) {
    return _isPointInArea(point, this.chartArea, this._minPadding);
  }
  getElementsAtEventForMode(e, mode, options, useFinalPosition) {
    const method = Interaction.modes[mode];
    if (typeof method === "function") {
      return method(this, e, options, useFinalPosition);
    }
    return [];
  }
  getDatasetMeta(datasetIndex) {
    const dataset = this.data.datasets[datasetIndex];
    const metasets = this._metasets;
    let meta = metasets.filter((x) => x && x._dataset === dataset).pop();
    if (!meta) {
      meta = {
        type: null,
        data: [],
        dataset: null,
        controller: null,
        hidden: null,
        xAxisID: null,
        yAxisID: null,
        order: dataset && dataset.order || 0,
        index: datasetIndex,
        _dataset: dataset,
        _parsed: [],
        _sorted: false
      };
      metasets.push(meta);
    }
    return meta;
  }
  getContext() {
    return this.$context || (this.$context = createContext(null, {
      chart: this,
      type: "chart"
    }));
  }
  getVisibleDatasetCount() {
    return this.getSortedVisibleDatasetMetas().length;
  }
  isDatasetVisible(datasetIndex) {
    const dataset = this.data.datasets[datasetIndex];
    if (!dataset) {
      return false;
    }
    const meta = this.getDatasetMeta(datasetIndex);
    return typeof meta.hidden === "boolean" ? !meta.hidden : !dataset.hidden;
  }
  setDatasetVisibility(datasetIndex, visible) {
    const meta = this.getDatasetMeta(datasetIndex);
    meta.hidden = !visible;
  }
  toggleDataVisibility(index2) {
    this._hiddenIndices[index2] = !this._hiddenIndices[index2];
  }
  getDataVisibility(index2) {
    return !this._hiddenIndices[index2];
  }
  _updateVisibility(datasetIndex, dataIndex, visible) {
    const mode = visible ? "show" : "hide";
    const meta = this.getDatasetMeta(datasetIndex);
    const anims = meta.controller._resolveAnimations(void 0, mode);
    if (defined(dataIndex)) {
      meta.data[dataIndex].hidden = !visible;
      this.update();
    } else {
      this.setDatasetVisibility(datasetIndex, visible);
      anims.update(meta, {
        visible
      });
      this.update((ctx) => ctx.datasetIndex === datasetIndex ? mode : void 0);
    }
  }
  hide(datasetIndex, dataIndex) {
    this._updateVisibility(datasetIndex, dataIndex, false);
  }
  show(datasetIndex, dataIndex) {
    this._updateVisibility(datasetIndex, dataIndex, true);
  }
  _destroyDatasetMeta(datasetIndex) {
    const meta = this._metasets[datasetIndex];
    if (meta && meta.controller) {
      meta.controller._destroy();
    }
    delete this._metasets[datasetIndex];
  }
  _stop() {
    let i, ilen;
    this.stop();
    animator.remove(this);
    for (i = 0, ilen = this.data.datasets.length; i < ilen; ++i) {
      this._destroyDatasetMeta(i);
    }
  }
  destroy() {
    this.notifyPlugins("beforeDestroy");
    const { canvas, ctx } = this;
    this._stop();
    this.config.clearCache();
    if (canvas) {
      this.unbindEvents();
      clearCanvas(canvas, ctx);
      this.platform.releaseContext(ctx);
      this.canvas = null;
      this.ctx = null;
    }
    delete instances[this.id];
    this.notifyPlugins("afterDestroy");
  }
  toBase64Image(...args) {
    return this.canvas.toDataURL(...args);
  }
  bindEvents() {
    this.bindUserEvents();
    if (this.options.responsive) {
      this.bindResponsiveEvents();
    } else {
      this.attached = true;
    }
  }
  bindUserEvents() {
    const listeners = this._listeners;
    const platform = this.platform;
    const _add = (type, listener2) => {
      platform.addEventListener(this, type, listener2);
      listeners[type] = listener2;
    };
    const listener = (e, x, y) => {
      e.offsetX = x;
      e.offsetY = y;
      this._eventHandler(e);
    };
    each(this.options.events, (type) => _add(type, listener));
  }
  bindResponsiveEvents() {
    if (!this._responsiveListeners) {
      this._responsiveListeners = {};
    }
    const listeners = this._responsiveListeners;
    const platform = this.platform;
    const _add = (type, listener2) => {
      platform.addEventListener(this, type, listener2);
      listeners[type] = listener2;
    };
    const _remove = (type, listener2) => {
      if (listeners[type]) {
        platform.removeEventListener(this, type, listener2);
        delete listeners[type];
      }
    };
    const listener = (width, height) => {
      if (this.canvas) {
        this.resize(width, height);
      }
    };
    let detached;
    const attached = () => {
      _remove("attach", attached);
      this.attached = true;
      this.resize();
      _add("resize", listener);
      _add("detach", detached);
    };
    detached = () => {
      this.attached = false;
      _remove("resize", listener);
      this._stop();
      this._resize(0, 0);
      _add("attach", attached);
    };
    if (platform.isAttached(this.canvas)) {
      attached();
    } else {
      detached();
    }
  }
  unbindEvents() {
    each(this._listeners, (listener, type) => {
      this.platform.removeEventListener(this, type, listener);
    });
    this._listeners = {};
    each(this._responsiveListeners, (listener, type) => {
      this.platform.removeEventListener(this, type, listener);
    });
    this._responsiveListeners = void 0;
  }
  updateHoverStyle(items, mode, enabled) {
    const prefix = enabled ? "set" : "remove";
    let meta, item, i, ilen;
    if (mode === "dataset") {
      meta = this.getDatasetMeta(items[0].datasetIndex);
      meta.controller["_" + prefix + "DatasetHoverStyle"]();
    }
    for (i = 0, ilen = items.length; i < ilen; ++i) {
      item = items[i];
      const controller = item && this.getDatasetMeta(item.datasetIndex).controller;
      if (controller) {
        controller[prefix + "HoverStyle"](item.element, item.datasetIndex, item.index);
      }
    }
  }
  getActiveElements() {
    return this._active || [];
  }
  setActiveElements(activeElements) {
    const lastActive = this._active || [];
    const active = activeElements.map(({ datasetIndex, index: index2 }) => {
      const meta = this.getDatasetMeta(datasetIndex);
      if (!meta) {
        throw new Error("No dataset found at index " + datasetIndex);
      }
      return {
        datasetIndex,
        element: meta.data[index2],
        index: index2
      };
    });
    const changed = !_elementsEqual(active, lastActive);
    if (changed) {
      this._active = active;
      this._lastEvent = null;
      this._updateHoverStyles(active, lastActive);
    }
  }
  notifyPlugins(hook, args, filter) {
    return this._plugins.notify(this, hook, args, filter);
  }
  isPluginEnabled(pluginId) {
    return this._plugins._cache.filter((p) => p.plugin.id === pluginId).length === 1;
  }
  _updateHoverStyles(active, lastActive, replay) {
    const hoverOptions = this.options.hover;
    const diff = (a, b) => a.filter((x) => !b.some((y) => x.datasetIndex === y.datasetIndex && x.index === y.index));
    const deactivated = diff(lastActive, active);
    const activated = replay ? active : diff(active, lastActive);
    if (deactivated.length) {
      this.updateHoverStyle(deactivated, hoverOptions.mode, false);
    }
    if (activated.length && hoverOptions.mode) {
      this.updateHoverStyle(activated, hoverOptions.mode, true);
    }
  }
  _eventHandler(e, replay) {
    const args = {
      event: e,
      replay,
      cancelable: true,
      inChartArea: this.isPointInArea(e)
    };
    const eventFilter = (plugin2) => (plugin2.options.events || this.options.events).includes(e.native.type);
    if (this.notifyPlugins("beforeEvent", args, eventFilter) === false) {
      return;
    }
    const changed = this._handleEvent(e, replay, args.inChartArea);
    args.cancelable = false;
    this.notifyPlugins("afterEvent", args, eventFilter);
    if (changed || args.changed) {
      this.render();
    }
    return this;
  }
  _handleEvent(e, replay, inChartArea) {
    const { _active: lastActive = [], options } = this;
    const useFinalPosition = replay;
    const active = this._getActiveElements(e, lastActive, inChartArea, useFinalPosition);
    const isClick = _isClickEvent(e);
    const lastEvent = determineLastEvent(e, this._lastEvent, inChartArea, isClick);
    if (inChartArea) {
      this._lastEvent = null;
      callback(options.onHover, [
        e,
        active,
        this
      ], this);
      if (isClick) {
        callback(options.onClick, [
          e,
          active,
          this
        ], this);
      }
    }
    const changed = !_elementsEqual(active, lastActive);
    if (changed || replay) {
      this._active = active;
      this._updateHoverStyles(active, lastActive, replay);
    }
    this._lastEvent = lastEvent;
    return changed;
  }
  _getActiveElements(e, lastActive, inChartArea, useFinalPosition) {
    if (e.type === "mouseout") {
      return [];
    }
    if (!inChartArea) {
      return lastActive;
    }
    const hoverOptions = this.options.hover;
    return this.getElementsAtEventForMode(e, hoverOptions.mode, hoverOptions, useFinalPosition);
  }
};
__publicField(Chart, "defaults", defaults);
__publicField(Chart, "instances", instances);
__publicField(Chart, "overrides", overrides);
__publicField(Chart, "registry", registry);
__publicField(Chart, "version", version);
__publicField(Chart, "getChart", getChart);
function invalidatePlugins() {
  return each(Chart.instances, (chart) => chart._plugins.invalidate());
}
function clipArc(ctx, element, endAngle) {
  const { startAngle, pixelMargin, x, y, outerRadius, innerRadius } = element;
  let angleMargin = pixelMargin / outerRadius;
  ctx.beginPath();
  ctx.arc(x, y, outerRadius, startAngle - angleMargin, endAngle + angleMargin);
  if (innerRadius > pixelMargin) {
    angleMargin = pixelMargin / innerRadius;
    ctx.arc(x, y, innerRadius, endAngle + angleMargin, startAngle - angleMargin, true);
  } else {
    ctx.arc(x, y, pixelMargin, endAngle + HALF_PI, startAngle - HALF_PI);
  }
  ctx.closePath();
  ctx.clip();
}
function toRadiusCorners(value) {
  return _readValueToProps(value, [
    "outerStart",
    "outerEnd",
    "innerStart",
    "innerEnd"
  ]);
}
function parseBorderRadius$1(arc, innerRadius, outerRadius, angleDelta) {
  const o = toRadiusCorners(arc.options.borderRadius);
  const halfThickness = (outerRadius - innerRadius) / 2;
  const innerLimit = Math.min(halfThickness, angleDelta * innerRadius / 2);
  const computeOuterLimit = (val) => {
    const outerArcLimit = (outerRadius - Math.min(halfThickness, val)) * angleDelta / 2;
    return _limitValue(val, 0, Math.min(halfThickness, outerArcLimit));
  };
  return {
    outerStart: computeOuterLimit(o.outerStart),
    outerEnd: computeOuterLimit(o.outerEnd),
    innerStart: _limitValue(o.innerStart, 0, innerLimit),
    innerEnd: _limitValue(o.innerEnd, 0, innerLimit)
  };
}
function rThetaToXY(r, theta, x, y) {
  return {
    x: x + r * Math.cos(theta),
    y: y + r * Math.sin(theta)
  };
}
function pathArc(ctx, element, offset, spacing, end, circular) {
  const { x, y, startAngle: start, pixelMargin, innerRadius: innerR } = element;
  const outerRadius = Math.max(element.outerRadius + spacing + offset - pixelMargin, 0);
  const innerRadius = innerR > 0 ? innerR + spacing + offset + pixelMargin : 0;
  let spacingOffset = 0;
  const alpha2 = end - start;
  if (spacing) {
    const noSpacingInnerRadius = innerR > 0 ? innerR - spacing : 0;
    const noSpacingOuterRadius = outerRadius > 0 ? outerRadius - spacing : 0;
    const avNogSpacingRadius = (noSpacingInnerRadius + noSpacingOuterRadius) / 2;
    const adjustedAngle = avNogSpacingRadius !== 0 ? alpha2 * avNogSpacingRadius / (avNogSpacingRadius + spacing) : alpha2;
    spacingOffset = (alpha2 - adjustedAngle) / 2;
  }
  const beta = Math.max(1e-3, alpha2 * outerRadius - offset / PI) / outerRadius;
  const angleOffset = (alpha2 - beta) / 2;
  const startAngle = start + angleOffset + spacingOffset;
  const endAngle = end - angleOffset - spacingOffset;
  const { outerStart, outerEnd, innerStart, innerEnd } = parseBorderRadius$1(element, innerRadius, outerRadius, endAngle - startAngle);
  const outerStartAdjustedRadius = outerRadius - outerStart;
  const outerEndAdjustedRadius = outerRadius - outerEnd;
  const outerStartAdjustedAngle = startAngle + outerStart / outerStartAdjustedRadius;
  const outerEndAdjustedAngle = endAngle - outerEnd / outerEndAdjustedRadius;
  const innerStartAdjustedRadius = innerRadius + innerStart;
  const innerEndAdjustedRadius = innerRadius + innerEnd;
  const innerStartAdjustedAngle = startAngle + innerStart / innerStartAdjustedRadius;
  const innerEndAdjustedAngle = endAngle - innerEnd / innerEndAdjustedRadius;
  ctx.beginPath();
  if (circular) {
    const outerMidAdjustedAngle = (outerStartAdjustedAngle + outerEndAdjustedAngle) / 2;
    ctx.arc(x, y, outerRadius, outerStartAdjustedAngle, outerMidAdjustedAngle);
    ctx.arc(x, y, outerRadius, outerMidAdjustedAngle, outerEndAdjustedAngle);
    if (outerEnd > 0) {
      const pCenter = rThetaToXY(outerEndAdjustedRadius, outerEndAdjustedAngle, x, y);
      ctx.arc(pCenter.x, pCenter.y, outerEnd, outerEndAdjustedAngle, endAngle + HALF_PI);
    }
    const p4 = rThetaToXY(innerEndAdjustedRadius, endAngle, x, y);
    ctx.lineTo(p4.x, p4.y);
    if (innerEnd > 0) {
      const pCenter = rThetaToXY(innerEndAdjustedRadius, innerEndAdjustedAngle, x, y);
      ctx.arc(pCenter.x, pCenter.y, innerEnd, endAngle + HALF_PI, innerEndAdjustedAngle + Math.PI);
    }
    const innerMidAdjustedAngle = (endAngle - innerEnd / innerRadius + (startAngle + innerStart / innerRadius)) / 2;
    ctx.arc(x, y, innerRadius, endAngle - innerEnd / innerRadius, innerMidAdjustedAngle, true);
    ctx.arc(x, y, innerRadius, innerMidAdjustedAngle, startAngle + innerStart / innerRadius, true);
    if (innerStart > 0) {
      const pCenter = rThetaToXY(innerStartAdjustedRadius, innerStartAdjustedAngle, x, y);
      ctx.arc(pCenter.x, pCenter.y, innerStart, innerStartAdjustedAngle + Math.PI, startAngle - HALF_PI);
    }
    const p8 = rThetaToXY(outerStartAdjustedRadius, startAngle, x, y);
    ctx.lineTo(p8.x, p8.y);
    if (outerStart > 0) {
      const pCenter = rThetaToXY(outerStartAdjustedRadius, outerStartAdjustedAngle, x, y);
      ctx.arc(pCenter.x, pCenter.y, outerStart, startAngle - HALF_PI, outerStartAdjustedAngle);
    }
  } else {
    ctx.moveTo(x, y);
    const outerStartX = Math.cos(outerStartAdjustedAngle) * outerRadius + x;
    const outerStartY = Math.sin(outerStartAdjustedAngle) * outerRadius + y;
    ctx.lineTo(outerStartX, outerStartY);
    const outerEndX = Math.cos(outerEndAdjustedAngle) * outerRadius + x;
    const outerEndY = Math.sin(outerEndAdjustedAngle) * outerRadius + y;
    ctx.lineTo(outerEndX, outerEndY);
  }
  ctx.closePath();
}
function drawArc(ctx, element, offset, spacing, circular) {
  const { fullCircles, startAngle, circumference } = element;
  let endAngle = element.endAngle;
  if (fullCircles) {
    pathArc(ctx, element, offset, spacing, endAngle, circular);
    for (let i = 0; i < fullCircles; ++i) {
      ctx.fill();
    }
    if (!isNaN(circumference)) {
      endAngle = startAngle + (circumference % TAU || TAU);
    }
  }
  pathArc(ctx, element, offset, spacing, endAngle, circular);
  ctx.fill();
  return endAngle;
}
function drawBorder(ctx, element, offset, spacing, circular) {
  const { fullCircles, startAngle, circumference, options } = element;
  const { borderWidth, borderJoinStyle, borderDash, borderDashOffset } = options;
  const inner = options.borderAlign === "inner";
  if (!borderWidth) {
    return;
  }
  ctx.setLineDash(borderDash || []);
  ctx.lineDashOffset = borderDashOffset;
  if (inner) {
    ctx.lineWidth = borderWidth * 2;
    ctx.lineJoin = borderJoinStyle || "round";
  } else {
    ctx.lineWidth = borderWidth;
    ctx.lineJoin = borderJoinStyle || "bevel";
  }
  let endAngle = element.endAngle;
  if (fullCircles) {
    pathArc(ctx, element, offset, spacing, endAngle, circular);
    for (let i = 0; i < fullCircles; ++i) {
      ctx.stroke();
    }
    if (!isNaN(circumference)) {
      endAngle = startAngle + (circumference % TAU || TAU);
    }
  }
  if (inner) {
    clipArc(ctx, element, endAngle);
  }
  if (!fullCircles) {
    pathArc(ctx, element, offset, spacing, endAngle, circular);
    ctx.stroke();
  }
}
var ArcElement = class extends Element {
  constructor(cfg) {
    super();
    __publicField(this, "circumference");
    __publicField(this, "endAngle");
    __publicField(this, "fullCircles");
    __publicField(this, "innerRadius");
    __publicField(this, "outerRadius");
    __publicField(this, "pixelMargin");
    __publicField(this, "startAngle");
    this.options = void 0;
    this.circumference = void 0;
    this.startAngle = void 0;
    this.endAngle = void 0;
    this.innerRadius = void 0;
    this.outerRadius = void 0;
    this.pixelMargin = 0;
    this.fullCircles = 0;
    if (cfg) {
      Object.assign(this, cfg);
    }
  }
  inRange(chartX, chartY, useFinalPosition) {
    const point = this.getProps([
      "x",
      "y"
    ], useFinalPosition);
    const { angle, distance } = getAngleFromPoint(point, {
      x: chartX,
      y: chartY
    });
    const { startAngle, endAngle, innerRadius, outerRadius, circumference } = this.getProps([
      "startAngle",
      "endAngle",
      "innerRadius",
      "outerRadius",
      "circumference"
    ], useFinalPosition);
    const rAdjust = (this.options.spacing + this.options.borderWidth) / 2;
    const _circumference = valueOrDefault(circumference, endAngle - startAngle);
    const nonZeroBetween = _angleBetween(angle, startAngle, endAngle) && startAngle !== endAngle;
    const betweenAngles = _circumference >= TAU || nonZeroBetween;
    const withinRadius = _isBetween(distance, innerRadius + rAdjust, outerRadius + rAdjust);
    return betweenAngles && withinRadius;
  }
  getCenterPoint(useFinalPosition) {
    const { x, y, startAngle, endAngle, innerRadius, outerRadius } = this.getProps([
      "x",
      "y",
      "startAngle",
      "endAngle",
      "innerRadius",
      "outerRadius"
    ], useFinalPosition);
    const { offset, spacing } = this.options;
    const halfAngle = (startAngle + endAngle) / 2;
    const halfRadius = (innerRadius + outerRadius + spacing + offset) / 2;
    return {
      x: x + Math.cos(halfAngle) * halfRadius,
      y: y + Math.sin(halfAngle) * halfRadius
    };
  }
  tooltipPosition(useFinalPosition) {
    return this.getCenterPoint(useFinalPosition);
  }
  draw(ctx) {
    const { options, circumference } = this;
    const offset = (options.offset || 0) / 4;
    const spacing = (options.spacing || 0) / 2;
    const circular = options.circular;
    this.pixelMargin = options.borderAlign === "inner" ? 0.33 : 0;
    this.fullCircles = circumference > TAU ? Math.floor(circumference / TAU) : 0;
    if (circumference === 0 || this.innerRadius < 0 || this.outerRadius < 0) {
      return;
    }
    ctx.save();
    const halfAngle = (this.startAngle + this.endAngle) / 2;
    ctx.translate(Math.cos(halfAngle) * offset, Math.sin(halfAngle) * offset);
    const fix = 1 - Math.sin(Math.min(PI, circumference || 0));
    const radiusOffset = offset * fix;
    ctx.fillStyle = options.backgroundColor;
    ctx.strokeStyle = options.borderColor;
    drawArc(ctx, this, radiusOffset, spacing, circular);
    drawBorder(ctx, this, radiusOffset, spacing, circular);
    ctx.restore();
  }
};
__publicField(ArcElement, "id", "arc");
__publicField(ArcElement, "defaults", {
  borderAlign: "center",
  borderColor: "#fff",
  borderDash: [],
  borderDashOffset: 0,
  borderJoinStyle: void 0,
  borderRadius: 0,
  borderWidth: 2,
  offset: 0,
  spacing: 0,
  angle: void 0,
  circular: true
});
__publicField(ArcElement, "defaultRoutes", {
  backgroundColor: "backgroundColor"
});
__publicField(ArcElement, "descriptors", {
  _scriptable: true,
  _indexable: (name) => name !== "borderDash"
});
function setStyle(ctx, options, style = options) {
  ctx.lineCap = valueOrDefault(style.borderCapStyle, options.borderCapStyle);
  ctx.setLineDash(valueOrDefault(style.borderDash, options.borderDash));
  ctx.lineDashOffset = valueOrDefault(style.borderDashOffset, options.borderDashOffset);
  ctx.lineJoin = valueOrDefault(style.borderJoinStyle, options.borderJoinStyle);
  ctx.lineWidth = valueOrDefault(style.borderWidth, options.borderWidth);
  ctx.strokeStyle = valueOrDefault(style.borderColor, options.borderColor);
}
function lineTo(ctx, previous, target) {
  ctx.lineTo(target.x, target.y);
}
function getLineMethod(options) {
  if (options.stepped) {
    return _steppedLineTo;
  }
  if (options.tension || options.cubicInterpolationMode === "monotone") {
    return _bezierCurveTo;
  }
  return lineTo;
}
function pathVars(points, segment, params = {}) {
  const count = points.length;
  const { start: paramsStart = 0, end: paramsEnd = count - 1 } = params;
  const { start: segmentStart, end: segmentEnd } = segment;
  const start = Math.max(paramsStart, segmentStart);
  const end = Math.min(paramsEnd, segmentEnd);
  const outside = paramsStart < segmentStart && paramsEnd < segmentStart || paramsStart > segmentEnd && paramsEnd > segmentEnd;
  return {
    count,
    start,
    loop: segment.loop,
    ilen: end < start && !outside ? count + end - start : end - start
  };
}
function pathSegment(ctx, line, segment, params) {
  const { points, options } = line;
  const { count, start, loop, ilen } = pathVars(points, segment, params);
  const lineMethod = getLineMethod(options);
  let { move = true, reverse } = params || {};
  let i, point, prev;
  for (i = 0; i <= ilen; ++i) {
    point = points[(start + (reverse ? ilen - i : i)) % count];
    if (point.skip) {
      continue;
    } else if (move) {
      ctx.moveTo(point.x, point.y);
      move = false;
    } else {
      lineMethod(ctx, prev, point, reverse, options.stepped);
    }
    prev = point;
  }
  if (loop) {
    point = points[(start + (reverse ? ilen : 0)) % count];
    lineMethod(ctx, prev, point, reverse, options.stepped);
  }
  return !!loop;
}
function fastPathSegment(ctx, line, segment, params) {
  const points = line.points;
  const { count, start, ilen } = pathVars(points, segment, params);
  const { move = true, reverse } = params || {};
  let avgX = 0;
  let countX = 0;
  let i, point, prevX, minY, maxY, lastY;
  const pointIndex = (index2) => (start + (reverse ? ilen - index2 : index2)) % count;
  const drawX = () => {
    if (minY !== maxY) {
      ctx.lineTo(avgX, maxY);
      ctx.lineTo(avgX, minY);
      ctx.lineTo(avgX, lastY);
    }
  };
  if (move) {
    point = points[pointIndex(0)];
    ctx.moveTo(point.x, point.y);
  }
  for (i = 0; i <= ilen; ++i) {
    point = points[pointIndex(i)];
    if (point.skip) {
      continue;
    }
    const x = point.x;
    const y = point.y;
    const truncX = x | 0;
    if (truncX === prevX) {
      if (y < minY) {
        minY = y;
      } else if (y > maxY) {
        maxY = y;
      }
      avgX = (countX * avgX + x) / ++countX;
    } else {
      drawX();
      ctx.lineTo(x, y);
      prevX = truncX;
      countX = 0;
      minY = maxY = y;
    }
    lastY = y;
  }
  drawX();
}
function _getSegmentMethod(line) {
  const opts = line.options;
  const borderDash = opts.borderDash && opts.borderDash.length;
  const useFastPath = !line._decimated && !line._loop && !opts.tension && opts.cubicInterpolationMode !== "monotone" && !opts.stepped && !borderDash;
  return useFastPath ? fastPathSegment : pathSegment;
}
function _getInterpolationMethod(options) {
  if (options.stepped) {
    return _steppedInterpolation;
  }
  if (options.tension || options.cubicInterpolationMode === "monotone") {
    return _bezierInterpolation;
  }
  return _pointInLine;
}
function strokePathWithCache(ctx, line, start, count) {
  let path = line._path;
  if (!path) {
    path = line._path = new Path2D();
    if (line.path(path, start, count)) {
      path.closePath();
    }
  }
  setStyle(ctx, line.options);
  ctx.stroke(path);
}
function strokePathDirect(ctx, line, start, count) {
  const { segments, options } = line;
  const segmentMethod = _getSegmentMethod(line);
  for (const segment of segments) {
    setStyle(ctx, options, segment.style);
    ctx.beginPath();
    if (segmentMethod(ctx, line, segment, {
      start,
      end: start + count - 1
    })) {
      ctx.closePath();
    }
    ctx.stroke();
  }
}
var usePath2D = typeof Path2D === "function";
function draw(ctx, line, start, count) {
  if (usePath2D && !line.options.segment) {
    strokePathWithCache(ctx, line, start, count);
  } else {
    strokePathDirect(ctx, line, start, count);
  }
}
var LineElement = class extends Element {
  constructor(cfg) {
    super();
    this.animated = true;
    this.options = void 0;
    this._chart = void 0;
    this._loop = void 0;
    this._fullLoop = void 0;
    this._path = void 0;
    this._points = void 0;
    this._segments = void 0;
    this._decimated = false;
    this._pointsUpdated = false;
    this._datasetIndex = void 0;
    if (cfg) {
      Object.assign(this, cfg);
    }
  }
  updateControlPoints(chartArea, indexAxis) {
    const options = this.options;
    if ((options.tension || options.cubicInterpolationMode === "monotone") && !options.stepped && !this._pointsUpdated) {
      const loop = options.spanGaps ? this._loop : this._fullLoop;
      _updateBezierControlPoints(this._points, options, chartArea, loop, indexAxis);
      this._pointsUpdated = true;
    }
  }
  set points(points) {
    this._points = points;
    delete this._segments;
    delete this._path;
    this._pointsUpdated = false;
  }
  get points() {
    return this._points;
  }
  get segments() {
    return this._segments || (this._segments = _computeSegments(this, this.options.segment));
  }
  first() {
    const segments = this.segments;
    const points = this.points;
    return segments.length && points[segments[0].start];
  }
  last() {
    const segments = this.segments;
    const points = this.points;
    const count = segments.length;
    return count && points[segments[count - 1].end];
  }
  interpolate(point, property) {
    const options = this.options;
    const value = point[property];
    const points = this.points;
    const segments = _boundSegments(this, {
      property,
      start: value,
      end: value
    });
    if (!segments.length) {
      return;
    }
    const result = [];
    const _interpolate = _getInterpolationMethod(options);
    let i, ilen;
    for (i = 0, ilen = segments.length; i < ilen; ++i) {
      const { start, end } = segments[i];
      const p1 = points[start];
      const p2 = points[end];
      if (p1 === p2) {
        result.push(p1);
        continue;
      }
      const t = Math.abs((value - p1[property]) / (p2[property] - p1[property]));
      const interpolated = _interpolate(p1, p2, t, options.stepped);
      interpolated[property] = point[property];
      result.push(interpolated);
    }
    return result.length === 1 ? result[0] : result;
  }
  pathSegment(ctx, segment, params) {
    const segmentMethod = _getSegmentMethod(this);
    return segmentMethod(ctx, this, segment, params);
  }
  path(ctx, start, count) {
    const segments = this.segments;
    const segmentMethod = _getSegmentMethod(this);
    let loop = this._loop;
    start = start || 0;
    count = count || this.points.length - start;
    for (const segment of segments) {
      loop &= segmentMethod(ctx, this, segment, {
        start,
        end: start + count - 1
      });
    }
    return !!loop;
  }
  draw(ctx, chartArea, start, count) {
    const options = this.options || {};
    const points = this.points || [];
    if (points.length && options.borderWidth) {
      ctx.save();
      draw(ctx, this, start, count);
      ctx.restore();
    }
    if (this.animated) {
      this._pointsUpdated = false;
      this._path = void 0;
    }
  }
};
__publicField(LineElement, "id", "line");
__publicField(LineElement, "defaults", {
  borderCapStyle: "butt",
  borderDash: [],
  borderDashOffset: 0,
  borderJoinStyle: "miter",
  borderWidth: 3,
  capBezierPoints: true,
  cubicInterpolationMode: "default",
  fill: false,
  spanGaps: false,
  stepped: false,
  tension: 0
});
__publicField(LineElement, "defaultRoutes", {
  backgroundColor: "backgroundColor",
  borderColor: "borderColor"
});
__publicField(LineElement, "descriptors", {
  _scriptable: true,
  _indexable: (name) => name !== "borderDash" && name !== "fill"
});
function inRange$1(el, pos, axis, useFinalPosition) {
  const options = el.options;
  const { [axis]: value } = el.getProps([
    axis
  ], useFinalPosition);
  return Math.abs(pos - value) < options.radius + options.hitRadius;
}
var PointElement = class extends Element {
  constructor(cfg) {
    super();
    __publicField(this, "parsed");
    __publicField(this, "skip");
    __publicField(this, "stop");
    this.options = void 0;
    this.parsed = void 0;
    this.skip = void 0;
    this.stop = void 0;
    if (cfg) {
      Object.assign(this, cfg);
    }
  }
  inRange(mouseX, mouseY, useFinalPosition) {
    const options = this.options;
    const { x, y } = this.getProps([
      "x",
      "y"
    ], useFinalPosition);
    return Math.pow(mouseX - x, 2) + Math.pow(mouseY - y, 2) < Math.pow(options.hitRadius + options.radius, 2);
  }
  inXRange(mouseX, useFinalPosition) {
    return inRange$1(this, mouseX, "x", useFinalPosition);
  }
  inYRange(mouseY, useFinalPosition) {
    return inRange$1(this, mouseY, "y", useFinalPosition);
  }
  getCenterPoint(useFinalPosition) {
    const { x, y } = this.getProps([
      "x",
      "y"
    ], useFinalPosition);
    return {
      x,
      y
    };
  }
  size(options) {
    options = options || this.options || {};
    let radius = options.radius || 0;
    radius = Math.max(radius, radius && options.hoverRadius || 0);
    const borderWidth = radius && options.borderWidth || 0;
    return (radius + borderWidth) * 2;
  }
  draw(ctx, area) {
    const options = this.options;
    if (this.skip || options.radius < 0.1 || !_isPointInArea(this, area, this.size(options) / 2)) {
      return;
    }
    ctx.strokeStyle = options.borderColor;
    ctx.lineWidth = options.borderWidth;
    ctx.fillStyle = options.backgroundColor;
    drawPoint(ctx, options, this.x, this.y);
  }
  getRange() {
    const options = this.options || {};
    return options.radius + options.hitRadius;
  }
};
__publicField(PointElement, "id", "point");
/**
* @type {any}
*/
__publicField(PointElement, "defaults", {
  borderWidth: 1,
  hitRadius: 1,
  hoverBorderWidth: 1,
  hoverRadius: 4,
  pointStyle: "circle",
  radius: 3,
  rotation: 0
});
/**
* @type {any}
*/
__publicField(PointElement, "defaultRoutes", {
  backgroundColor: "backgroundColor",
  borderColor: "borderColor"
});
function getBarBounds(bar, useFinalPosition) {
  const { x, y, base, width, height } = bar.getProps([
    "x",
    "y",
    "base",
    "width",
    "height"
  ], useFinalPosition);
  let left, right, top, bottom, half;
  if (bar.horizontal) {
    half = height / 2;
    left = Math.min(x, base);
    right = Math.max(x, base);
    top = y - half;
    bottom = y + half;
  } else {
    half = width / 2;
    left = x - half;
    right = x + half;
    top = Math.min(y, base);
    bottom = Math.max(y, base);
  }
  return {
    left,
    top,
    right,
    bottom
  };
}
function skipOrLimit(skip2, value, min, max) {
  return skip2 ? 0 : _limitValue(value, min, max);
}
function parseBorderWidth(bar, maxW, maxH) {
  const value = bar.options.borderWidth;
  const skip2 = bar.borderSkipped;
  const o = toTRBL(value);
  return {
    t: skipOrLimit(skip2.top, o.top, 0, maxH),
    r: skipOrLimit(skip2.right, o.right, 0, maxW),
    b: skipOrLimit(skip2.bottom, o.bottom, 0, maxH),
    l: skipOrLimit(skip2.left, o.left, 0, maxW)
  };
}
function parseBorderRadius(bar, maxW, maxH) {
  const { enableBorderRadius } = bar.getProps([
    "enableBorderRadius"
  ]);
  const value = bar.options.borderRadius;
  const o = toTRBLCorners(value);
  const maxR = Math.min(maxW, maxH);
  const skip2 = bar.borderSkipped;
  const enableBorder = enableBorderRadius || isObject(value);
  return {
    topLeft: skipOrLimit(!enableBorder || skip2.top || skip2.left, o.topLeft, 0, maxR),
    topRight: skipOrLimit(!enableBorder || skip2.top || skip2.right, o.topRight, 0, maxR),
    bottomLeft: skipOrLimit(!enableBorder || skip2.bottom || skip2.left, o.bottomLeft, 0, maxR),
    bottomRight: skipOrLimit(!enableBorder || skip2.bottom || skip2.right, o.bottomRight, 0, maxR)
  };
}
function boundingRects(bar) {
  const bounds = getBarBounds(bar);
  const width = bounds.right - bounds.left;
  const height = bounds.bottom - bounds.top;
  const border = parseBorderWidth(bar, width / 2, height / 2);
  const radius = parseBorderRadius(bar, width / 2, height / 2);
  return {
    outer: {
      x: bounds.left,
      y: bounds.top,
      w: width,
      h: height,
      radius
    },
    inner: {
      x: bounds.left + border.l,
      y: bounds.top + border.t,
      w: width - border.l - border.r,
      h: height - border.t - border.b,
      radius: {
        topLeft: Math.max(0, radius.topLeft - Math.max(border.t, border.l)),
        topRight: Math.max(0, radius.topRight - Math.max(border.t, border.r)),
        bottomLeft: Math.max(0, radius.bottomLeft - Math.max(border.b, border.l)),
        bottomRight: Math.max(0, radius.bottomRight - Math.max(border.b, border.r))
      }
    }
  };
}
function inRange(bar, x, y, useFinalPosition) {
  const skipX = x === null;
  const skipY = y === null;
  const skipBoth = skipX && skipY;
  const bounds = bar && !skipBoth && getBarBounds(bar, useFinalPosition);
  return bounds && (skipX || _isBetween(x, bounds.left, bounds.right)) && (skipY || _isBetween(y, bounds.top, bounds.bottom));
}
function hasRadius(radius) {
  return radius.topLeft || radius.topRight || radius.bottomLeft || radius.bottomRight;
}
function addNormalRectPath(ctx, rect) {
  ctx.rect(rect.x, rect.y, rect.w, rect.h);
}
function inflateRect(rect, amount, refRect = {}) {
  const x = rect.x !== refRect.x ? -amount : 0;
  const y = rect.y !== refRect.y ? -amount : 0;
  const w = (rect.x + rect.w !== refRect.x + refRect.w ? amount : 0) - x;
  const h = (rect.y + rect.h !== refRect.y + refRect.h ? amount : 0) - y;
  return {
    x: rect.x + x,
    y: rect.y + y,
    w: rect.w + w,
    h: rect.h + h,
    radius: rect.radius
  };
}
var BarElement = class extends Element {
  constructor(cfg) {
    super();
    this.options = void 0;
    this.horizontal = void 0;
    this.base = void 0;
    this.width = void 0;
    this.height = void 0;
    this.inflateAmount = void 0;
    if (cfg) {
      Object.assign(this, cfg);
    }
  }
  draw(ctx) {
    const { inflateAmount, options: { borderColor, backgroundColor } } = this;
    const { inner, outer } = boundingRects(this);
    const addRectPath = hasRadius(outer.radius) ? addRoundedRectPath : addNormalRectPath;
    ctx.save();
    if (outer.w !== inner.w || outer.h !== inner.h) {
      ctx.beginPath();
      addRectPath(ctx, inflateRect(outer, inflateAmount, inner));
      ctx.clip();
      addRectPath(ctx, inflateRect(inner, -inflateAmount, outer));
      ctx.fillStyle = borderColor;
      ctx.fill("evenodd");
    }
    ctx.beginPath();
    addRectPath(ctx, inflateRect(inner, inflateAmount));
    ctx.fillStyle = backgroundColor;
    ctx.fill();
    ctx.restore();
  }
  inRange(mouseX, mouseY, useFinalPosition) {
    return inRange(this, mouseX, mouseY, useFinalPosition);
  }
  inXRange(mouseX, useFinalPosition) {
    return inRange(this, mouseX, null, useFinalPosition);
  }
  inYRange(mouseY, useFinalPosition) {
    return inRange(this, null, mouseY, useFinalPosition);
  }
  getCenterPoint(useFinalPosition) {
    const { x, y, base, horizontal } = this.getProps([
      "x",
      "y",
      "base",
      "horizontal"
    ], useFinalPosition);
    return {
      x: horizontal ? (x + base) / 2 : x,
      y: horizontal ? y : (y + base) / 2
    };
  }
  getRange(axis) {
    return axis === "x" ? this.width / 2 : this.height / 2;
  }
};
__publicField(BarElement, "id", "bar");
__publicField(BarElement, "defaults", {
  borderSkipped: "start",
  borderWidth: 0,
  borderRadius: 0,
  inflateAmount: "auto",
  pointStyle: void 0
});
__publicField(BarElement, "defaultRoutes", {
  backgroundColor: "backgroundColor",
  borderColor: "borderColor"
});
var elements = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  ArcElement,
  BarElement,
  LineElement,
  PointElement
});
var BORDER_COLORS = [
  "rgb(54, 162, 235)",
  "rgb(255, 99, 132)",
  "rgb(255, 159, 64)",
  "rgb(255, 205, 86)",
  "rgb(75, 192, 192)",
  "rgb(153, 102, 255)",
  "rgb(201, 203, 207)"
  // grey
];
var BACKGROUND_COLORS = /* @__PURE__ */ BORDER_COLORS.map((color2) => color2.replace("rgb(", "rgba(").replace(")", ", 0.5)"));
function getBorderColor(i) {
  return BORDER_COLORS[i % BORDER_COLORS.length];
}
function getBackgroundColor(i) {
  return BACKGROUND_COLORS[i % BACKGROUND_COLORS.length];
}
function colorizeDefaultDataset(dataset, i) {
  dataset.borderColor = getBorderColor(i);
  dataset.backgroundColor = getBackgroundColor(i);
  return ++i;
}
function colorizeDoughnutDataset(dataset, i) {
  dataset.backgroundColor = dataset.data.map(() => getBorderColor(i++));
  return i;
}
function colorizePolarAreaDataset(dataset, i) {
  dataset.backgroundColor = dataset.data.map(() => getBackgroundColor(i++));
  return i;
}
function getColorizer(chart) {
  let i = 0;
  return (dataset, datasetIndex) => {
    const controller = chart.getDatasetMeta(datasetIndex).controller;
    if (controller instanceof DoughnutController) {
      i = colorizeDoughnutDataset(dataset, i);
    } else if (controller instanceof PolarAreaController) {
      i = colorizePolarAreaDataset(dataset, i);
    } else if (controller) {
      i = colorizeDefaultDataset(dataset, i);
    }
  };
}
function containsColorsDefinitions(descriptors2) {
  let k;
  for (k in descriptors2) {
    if (descriptors2[k].borderColor || descriptors2[k].backgroundColor) {
      return true;
    }
  }
  return false;
}
function containsColorsDefinition(descriptor) {
  return descriptor && (descriptor.borderColor || descriptor.backgroundColor);
}
var plugin_colors = {
  id: "colors",
  defaults: {
    enabled: true,
    forceOverride: false
  },
  beforeLayout(chart, _args, options) {
    if (!options.enabled) {
      return;
    }
    const { data: { datasets }, options: chartOptions } = chart.config;
    const { elements: elements2 } = chartOptions;
    if (!options.forceOverride && (containsColorsDefinitions(datasets) || containsColorsDefinition(chartOptions) || elements2 && containsColorsDefinitions(elements2))) {
      return;
    }
    const colorizer = getColorizer(chart);
    datasets.forEach(colorizer);
  }
};
function lttbDecimation(data, start, count, availableWidth, options) {
  const samples = options.samples || availableWidth;
  if (samples >= count) {
    return data.slice(start, start + count);
  }
  const decimated = [];
  const bucketWidth = (count - 2) / (samples - 2);
  let sampledIndex = 0;
  const endIndex = start + count - 1;
  let a = start;
  let i, maxAreaPoint, maxArea, area, nextA;
  decimated[sampledIndex++] = data[a];
  for (i = 0; i < samples - 2; i++) {
    let avgX = 0;
    let avgY = 0;
    let j;
    const avgRangeStart = Math.floor((i + 1) * bucketWidth) + 1 + start;
    const avgRangeEnd = Math.min(Math.floor((i + 2) * bucketWidth) + 1, count) + start;
    const avgRangeLength = avgRangeEnd - avgRangeStart;
    for (j = avgRangeStart; j < avgRangeEnd; j++) {
      avgX += data[j].x;
      avgY += data[j].y;
    }
    avgX /= avgRangeLength;
    avgY /= avgRangeLength;
    const rangeOffs = Math.floor(i * bucketWidth) + 1 + start;
    const rangeTo = Math.min(Math.floor((i + 1) * bucketWidth) + 1, count) + start;
    const { x: pointAx, y: pointAy } = data[a];
    maxArea = area = -1;
    for (j = rangeOffs; j < rangeTo; j++) {
      area = 0.5 * Math.abs((pointAx - avgX) * (data[j].y - pointAy) - (pointAx - data[j].x) * (avgY - pointAy));
      if (area > maxArea) {
        maxArea = area;
        maxAreaPoint = data[j];
        nextA = j;
      }
    }
    decimated[sampledIndex++] = maxAreaPoint;
    a = nextA;
  }
  decimated[sampledIndex++] = data[endIndex];
  return decimated;
}
function minMaxDecimation(data, start, count, availableWidth) {
  let avgX = 0;
  let countX = 0;
  let i, point, x, y, prevX, minIndex, maxIndex, startIndex, minY, maxY;
  const decimated = [];
  const endIndex = start + count - 1;
  const xMin = data[start].x;
  const xMax = data[endIndex].x;
  const dx = xMax - xMin;
  for (i = start; i < start + count; ++i) {
    point = data[i];
    x = (point.x - xMin) / dx * availableWidth;
    y = point.y;
    const truncX = x | 0;
    if (truncX === prevX) {
      if (y < minY) {
        minY = y;
        minIndex = i;
      } else if (y > maxY) {
        maxY = y;
        maxIndex = i;
      }
      avgX = (countX * avgX + point.x) / ++countX;
    } else {
      const lastIndex = i - 1;
      if (!isNullOrUndef(minIndex) && !isNullOrUndef(maxIndex)) {
        const intermediateIndex1 = Math.min(minIndex, maxIndex);
        const intermediateIndex2 = Math.max(minIndex, maxIndex);
        if (intermediateIndex1 !== startIndex && intermediateIndex1 !== lastIndex) {
          decimated.push({
            ...data[intermediateIndex1],
            x: avgX
          });
        }
        if (intermediateIndex2 !== startIndex && intermediateIndex2 !== lastIndex) {
          decimated.push({
            ...data[intermediateIndex2],
            x: avgX
          });
        }
      }
      if (i > 0 && lastIndex !== startIndex) {
        decimated.push(data[lastIndex]);
      }
      decimated.push(point);
      prevX = truncX;
      countX = 0;
      minY = maxY = y;
      minIndex = maxIndex = startIndex = i;
    }
  }
  return decimated;
}
function cleanDecimatedDataset(dataset) {
  if (dataset._decimated) {
    const data = dataset._data;
    delete dataset._decimated;
    delete dataset._data;
    Object.defineProperty(dataset, "data", {
      configurable: true,
      enumerable: true,
      writable: true,
      value: data
    });
  }
}
function cleanDecimatedData(chart) {
  chart.data.datasets.forEach((dataset) => {
    cleanDecimatedDataset(dataset);
  });
}
function getStartAndCountOfVisiblePointsSimplified(meta, points) {
  const pointCount = points.length;
  let start = 0;
  let count;
  const { iScale } = meta;
  const { min, max, minDefined, maxDefined } = iScale.getUserBounds();
  if (minDefined) {
    start = _limitValue(_lookupByKey(points, iScale.axis, min).lo, 0, pointCount - 1);
  }
  if (maxDefined) {
    count = _limitValue(_lookupByKey(points, iScale.axis, max).hi + 1, start, pointCount) - start;
  } else {
    count = pointCount - start;
  }
  return {
    start,
    count
  };
}
var plugin_decimation = {
  id: "decimation",
  defaults: {
    algorithm: "min-max",
    enabled: false
  },
  beforeElementsUpdate: (chart, args, options) => {
    if (!options.enabled) {
      cleanDecimatedData(chart);
      return;
    }
    const availableWidth = chart.width;
    chart.data.datasets.forEach((dataset, datasetIndex) => {
      const { _data, indexAxis } = dataset;
      const meta = chart.getDatasetMeta(datasetIndex);
      const data = _data || dataset.data;
      if (resolve([
        indexAxis,
        chart.options.indexAxis
      ]) === "y") {
        return;
      }
      if (!meta.controller.supportsDecimation) {
        return;
      }
      const xAxis = chart.scales[meta.xAxisID];
      if (xAxis.type !== "linear" && xAxis.type !== "time") {
        return;
      }
      if (chart.options.parsing) {
        return;
      }
      let { start, count } = getStartAndCountOfVisiblePointsSimplified(meta, data);
      const threshold = options.threshold || 4 * availableWidth;
      if (count <= threshold) {
        cleanDecimatedDataset(dataset);
        return;
      }
      if (isNullOrUndef(_data)) {
        dataset._data = data;
        delete dataset.data;
        Object.defineProperty(dataset, "data", {
          configurable: true,
          enumerable: true,
          get: function() {
            return this._decimated;
          },
          set: function(d) {
            this._data = d;
          }
        });
      }
      let decimated;
      switch (options.algorithm) {
        case "lttb":
          decimated = lttbDecimation(data, start, count, availableWidth, options);
          break;
        case "min-max":
          decimated = minMaxDecimation(data, start, count, availableWidth);
          break;
        default:
          throw new Error(`Unsupported decimation algorithm '${options.algorithm}'`);
      }
      dataset._decimated = decimated;
    });
  },
  destroy(chart) {
    cleanDecimatedData(chart);
  }
};
function _segments(line, target, property) {
  const segments = line.segments;
  const points = line.points;
  const tpoints = target.points;
  const parts = [];
  for (const segment of segments) {
    let { start, end } = segment;
    end = _findSegmentEnd(start, end, points);
    const bounds = _getBounds(property, points[start], points[end], segment.loop);
    if (!target.segments) {
      parts.push({
        source: segment,
        target: bounds,
        start: points[start],
        end: points[end]
      });
      continue;
    }
    const targetSegments = _boundSegments(target, bounds);
    for (const tgt of targetSegments) {
      const subBounds = _getBounds(property, tpoints[tgt.start], tpoints[tgt.end], tgt.loop);
      const fillSources = _boundSegment(segment, points, subBounds);
      for (const fillSource of fillSources) {
        parts.push({
          source: fillSource,
          target: tgt,
          start: {
            [property]: _getEdge(bounds, subBounds, "start", Math.max)
          },
          end: {
            [property]: _getEdge(bounds, subBounds, "end", Math.min)
          }
        });
      }
    }
  }
  return parts;
}
function _getBounds(property, first, last, loop) {
  if (loop) {
    return;
  }
  let start = first[property];
  let end = last[property];
  if (property === "angle") {
    start = _normalizeAngle(start);
    end = _normalizeAngle(end);
  }
  return {
    property,
    start,
    end
  };
}
function _pointsFromSegments(boundary, line) {
  const { x = null, y = null } = boundary || {};
  const linePoints = line.points;
  const points = [];
  line.segments.forEach(({ start, end }) => {
    end = _findSegmentEnd(start, end, linePoints);
    const first = linePoints[start];
    const last = linePoints[end];
    if (y !== null) {
      points.push({
        x: first.x,
        y
      });
      points.push({
        x: last.x,
        y
      });
    } else if (x !== null) {
      points.push({
        x,
        y: first.y
      });
      points.push({
        x,
        y: last.y
      });
    }
  });
  return points;
}
function _findSegmentEnd(start, end, points) {
  for (; end > start; end--) {
    const point = points[end];
    if (!isNaN(point.x) && !isNaN(point.y)) {
      break;
    }
  }
  return end;
}
function _getEdge(a, b, prop, fn) {
  if (a && b) {
    return fn(a[prop], b[prop]);
  }
  return a ? a[prop] : b ? b[prop] : 0;
}
function _createBoundaryLine(boundary, line) {
  let points = [];
  let _loop = false;
  if (isArray(boundary)) {
    _loop = true;
    points = boundary;
  } else {
    points = _pointsFromSegments(boundary, line);
  }
  return points.length ? new LineElement({
    points,
    options: {
      tension: 0
    },
    _loop,
    _fullLoop: _loop
  }) : null;
}
function _shouldApplyFill(source) {
  return source && source.fill !== false;
}
function _resolveTarget(sources, index2, propagate) {
  const source = sources[index2];
  let fill2 = source.fill;
  const visited = [
    index2
  ];
  let target;
  if (!propagate) {
    return fill2;
  }
  while (fill2 !== false && visited.indexOf(fill2) === -1) {
    if (!isNumberFinite(fill2)) {
      return fill2;
    }
    target = sources[fill2];
    if (!target) {
      return false;
    }
    if (target.visible) {
      return fill2;
    }
    visited.push(fill2);
    fill2 = target.fill;
  }
  return false;
}
function _decodeFill(line, index2, count) {
  const fill2 = parseFillOption(line);
  if (isObject(fill2)) {
    return isNaN(fill2.value) ? false : fill2;
  }
  let target = parseFloat(fill2);
  if (isNumberFinite(target) && Math.floor(target) === target) {
    return decodeTargetIndex(fill2[0], index2, target, count);
  }
  return [
    "origin",
    "start",
    "end",
    "stack",
    "shape"
  ].indexOf(fill2) >= 0 && fill2;
}
function decodeTargetIndex(firstCh, index2, target, count) {
  if (firstCh === "-" || firstCh === "+") {
    target = index2 + target;
  }
  if (target === index2 || target < 0 || target >= count) {
    return false;
  }
  return target;
}
function _getTargetPixel(fill2, scale) {
  let pixel = null;
  if (fill2 === "start") {
    pixel = scale.bottom;
  } else if (fill2 === "end") {
    pixel = scale.top;
  } else if (isObject(fill2)) {
    pixel = scale.getPixelForValue(fill2.value);
  } else if (scale.getBasePixel) {
    pixel = scale.getBasePixel();
  }
  return pixel;
}
function _getTargetValue(fill2, scale, startValue) {
  let value;
  if (fill2 === "start") {
    value = startValue;
  } else if (fill2 === "end") {
    value = scale.options.reverse ? scale.min : scale.max;
  } else if (isObject(fill2)) {
    value = fill2.value;
  } else {
    value = scale.getBaseValue();
  }
  return value;
}
function parseFillOption(line) {
  const options = line.options;
  const fillOption = options.fill;
  let fill2 = valueOrDefault(fillOption && fillOption.target, fillOption);
  if (fill2 === void 0) {
    fill2 = !!options.backgroundColor;
  }
  if (fill2 === false || fill2 === null) {
    return false;
  }
  if (fill2 === true) {
    return "origin";
  }
  return fill2;
}
function _buildStackLine(source) {
  const { scale, index: index2, line } = source;
  const points = [];
  const segments = line.segments;
  const sourcePoints = line.points;
  const linesBelow = getLinesBelow(scale, index2);
  linesBelow.push(_createBoundaryLine({
    x: null,
    y: scale.bottom
  }, line));
  for (let i = 0; i < segments.length; i++) {
    const segment = segments[i];
    for (let j = segment.start; j <= segment.end; j++) {
      addPointsBelow(points, sourcePoints[j], linesBelow);
    }
  }
  return new LineElement({
    points,
    options: {}
  });
}
function getLinesBelow(scale, index2) {
  const below = [];
  const metas = scale.getMatchingVisibleMetas("line");
  for (let i = 0; i < metas.length; i++) {
    const meta = metas[i];
    if (meta.index === index2) {
      break;
    }
    if (!meta.hidden) {
      below.unshift(meta.dataset);
    }
  }
  return below;
}
function addPointsBelow(points, sourcePoint, linesBelow) {
  const postponed = [];
  for (let j = 0; j < linesBelow.length; j++) {
    const line = linesBelow[j];
    const { first, last, point } = findPoint(line, sourcePoint, "x");
    if (!point || first && last) {
      continue;
    }
    if (first) {
      postponed.unshift(point);
    } else {
      points.push(point);
      if (!last) {
        break;
      }
    }
  }
  points.push(...postponed);
}
function findPoint(line, sourcePoint, property) {
  const point = line.interpolate(sourcePoint, property);
  if (!point) {
    return {};
  }
  const pointValue = point[property];
  const segments = line.segments;
  const linePoints = line.points;
  let first = false;
  let last = false;
  for (let i = 0; i < segments.length; i++) {
    const segment = segments[i];
    const firstValue = linePoints[segment.start][property];
    const lastValue = linePoints[segment.end][property];
    if (_isBetween(pointValue, firstValue, lastValue)) {
      first = pointValue === firstValue;
      last = pointValue === lastValue;
      break;
    }
  }
  return {
    first,
    last,
    point
  };
}
var simpleArc = class {
  constructor(opts) {
    this.x = opts.x;
    this.y = opts.y;
    this.radius = opts.radius;
  }
  pathSegment(ctx, bounds, opts) {
    const { x, y, radius } = this;
    bounds = bounds || {
      start: 0,
      end: TAU
    };
    ctx.arc(x, y, radius, bounds.end, bounds.start, true);
    return !opts.bounds;
  }
  interpolate(point) {
    const { x, y, radius } = this;
    const angle = point.angle;
    return {
      x: x + Math.cos(angle) * radius,
      y: y + Math.sin(angle) * radius,
      angle
    };
  }
};
function _getTarget(source) {
  const { chart, fill: fill2, line } = source;
  if (isNumberFinite(fill2)) {
    return getLineByIndex(chart, fill2);
  }
  if (fill2 === "stack") {
    return _buildStackLine(source);
  }
  if (fill2 === "shape") {
    return true;
  }
  const boundary = computeBoundary(source);
  if (boundary instanceof simpleArc) {
    return boundary;
  }
  return _createBoundaryLine(boundary, line);
}
function getLineByIndex(chart, index2) {
  const meta = chart.getDatasetMeta(index2);
  const visible = meta && chart.isDatasetVisible(index2);
  return visible ? meta.dataset : null;
}
function computeBoundary(source) {
  const scale = source.scale || {};
  if (scale.getPointPositionForValue) {
    return computeCircularBoundary(source);
  }
  return computeLinearBoundary(source);
}
function computeLinearBoundary(source) {
  const { scale = {}, fill: fill2 } = source;
  const pixel = _getTargetPixel(fill2, scale);
  if (isNumberFinite(pixel)) {
    const horizontal = scale.isHorizontal();
    return {
      x: horizontal ? pixel : null,
      y: horizontal ? null : pixel
    };
  }
  return null;
}
function computeCircularBoundary(source) {
  const { scale, fill: fill2 } = source;
  const options = scale.options;
  const length = scale.getLabels().length;
  const start = options.reverse ? scale.max : scale.min;
  const value = _getTargetValue(fill2, scale, start);
  const target = [];
  if (options.grid.circular) {
    const center = scale.getPointPositionForValue(0, start);
    return new simpleArc({
      x: center.x,
      y: center.y,
      radius: scale.getDistanceFromCenterForValue(value)
    });
  }
  for (let i = 0; i < length; ++i) {
    target.push(scale.getPointPositionForValue(i, value));
  }
  return target;
}
function _drawfill(ctx, source, area) {
  const target = _getTarget(source);
  const { line, scale, axis } = source;
  const lineOpts = line.options;
  const fillOption = lineOpts.fill;
  const color2 = lineOpts.backgroundColor;
  const { above = color2, below = color2 } = fillOption || {};
  if (target && line.points.length) {
    clipArea(ctx, area);
    doFill(ctx, {
      line,
      target,
      above,
      below,
      area,
      scale,
      axis
    });
    unclipArea(ctx);
  }
}
function doFill(ctx, cfg) {
  const { line, target, above, below, area, scale } = cfg;
  const property = line._loop ? "angle" : cfg.axis;
  ctx.save();
  if (property === "x" && below !== above) {
    clipVertical(ctx, target, area.top);
    fill(ctx, {
      line,
      target,
      color: above,
      scale,
      property
    });
    ctx.restore();
    ctx.save();
    clipVertical(ctx, target, area.bottom);
  }
  fill(ctx, {
    line,
    target,
    color: below,
    scale,
    property
  });
  ctx.restore();
}
function clipVertical(ctx, target, clipY) {
  const { segments, points } = target;
  let first = true;
  let lineLoop = false;
  ctx.beginPath();
  for (const segment of segments) {
    const { start, end } = segment;
    const firstPoint = points[start];
    const lastPoint = points[_findSegmentEnd(start, end, points)];
    if (first) {
      ctx.moveTo(firstPoint.x, firstPoint.y);
      first = false;
    } else {
      ctx.lineTo(firstPoint.x, clipY);
      ctx.lineTo(firstPoint.x, firstPoint.y);
    }
    lineLoop = !!target.pathSegment(ctx, segment, {
      move: lineLoop
    });
    if (lineLoop) {
      ctx.closePath();
    } else {
      ctx.lineTo(lastPoint.x, clipY);
    }
  }
  ctx.lineTo(target.first().x, clipY);
  ctx.closePath();
  ctx.clip();
}
function fill(ctx, cfg) {
  const { line, target, property, color: color2, scale } = cfg;
  const segments = _segments(line, target, property);
  for (const { source: src, target: tgt, start, end } of segments) {
    const { style: { backgroundColor = color2 } = {} } = src;
    const notShape = target !== true;
    ctx.save();
    ctx.fillStyle = backgroundColor;
    clipBounds(ctx, scale, notShape && _getBounds(property, start, end));
    ctx.beginPath();
    const lineLoop = !!line.pathSegment(ctx, src);
    let loop;
    if (notShape) {
      if (lineLoop) {
        ctx.closePath();
      } else {
        interpolatedLineTo(ctx, target, end, property);
      }
      const targetLoop = !!target.pathSegment(ctx, tgt, {
        move: lineLoop,
        reverse: true
      });
      loop = lineLoop && targetLoop;
      if (!loop) {
        interpolatedLineTo(ctx, target, start, property);
      }
    }
    ctx.closePath();
    ctx.fill(loop ? "evenodd" : "nonzero");
    ctx.restore();
  }
}
function clipBounds(ctx, scale, bounds) {
  const { top, bottom } = scale.chart.chartArea;
  const { property, start, end } = bounds || {};
  if (property === "x") {
    ctx.beginPath();
    ctx.rect(start, top, end - start, bottom - top);
    ctx.clip();
  }
}
function interpolatedLineTo(ctx, target, point, property) {
  const interpolatedPoint = target.interpolate(point, property);
  if (interpolatedPoint) {
    ctx.lineTo(interpolatedPoint.x, interpolatedPoint.y);
  }
}
var index = {
  id: "filler",
  afterDatasetsUpdate(chart, _args, options) {
    const count = (chart.data.datasets || []).length;
    const sources = [];
    let meta, i, line, source;
    for (i = 0; i < count; ++i) {
      meta = chart.getDatasetMeta(i);
      line = meta.dataset;
      source = null;
      if (line && line.options && line instanceof LineElement) {
        source = {
          visible: chart.isDatasetVisible(i),
          index: i,
          fill: _decodeFill(line, i, count),
          chart,
          axis: meta.controller.options.indexAxis,
          scale: meta.vScale,
          line
        };
      }
      meta.$filler = source;
      sources.push(source);
    }
    for (i = 0; i < count; ++i) {
      source = sources[i];
      if (!source || source.fill === false) {
        continue;
      }
      source.fill = _resolveTarget(sources, i, options.propagate);
    }
  },
  beforeDraw(chart, _args, options) {
    const draw3 = options.drawTime === "beforeDraw";
    const metasets = chart.getSortedVisibleDatasetMetas();
    const area = chart.chartArea;
    for (let i = metasets.length - 1; i >= 0; --i) {
      const source = metasets[i].$filler;
      if (!source) {
        continue;
      }
      source.line.updateControlPoints(area, source.axis);
      if (draw3 && source.fill) {
        _drawfill(chart.ctx, source, area);
      }
    }
  },
  beforeDatasetsDraw(chart, _args, options) {
    if (options.drawTime !== "beforeDatasetsDraw") {
      return;
    }
    const metasets = chart.getSortedVisibleDatasetMetas();
    for (let i = metasets.length - 1; i >= 0; --i) {
      const source = metasets[i].$filler;
      if (_shouldApplyFill(source)) {
        _drawfill(chart.ctx, source, chart.chartArea);
      }
    }
  },
  beforeDatasetDraw(chart, args, options) {
    const source = args.meta.$filler;
    if (!_shouldApplyFill(source) || options.drawTime !== "beforeDatasetDraw") {
      return;
    }
    _drawfill(chart.ctx, source, chart.chartArea);
  },
  defaults: {
    propagate: true,
    drawTime: "beforeDatasetDraw"
  }
};
var getBoxSize = (labelOpts, fontSize) => {
  let { boxHeight = fontSize, boxWidth = fontSize } = labelOpts;
  if (labelOpts.usePointStyle) {
    boxHeight = Math.min(boxHeight, fontSize);
    boxWidth = labelOpts.pointStyleWidth || Math.min(boxWidth, fontSize);
  }
  return {
    boxWidth,
    boxHeight,
    itemHeight: Math.max(fontSize, boxHeight)
  };
};
var itemsEqual = (a, b) => a !== null && b !== null && a.datasetIndex === b.datasetIndex && a.index === b.index;
var Legend = class extends Element {
  constructor(config) {
    super();
    this._added = false;
    this.legendHitBoxes = [];
    this._hoveredItem = null;
    this.doughnutMode = false;
    this.chart = config.chart;
    this.options = config.options;
    this.ctx = config.ctx;
    this.legendItems = void 0;
    this.columnSizes = void 0;
    this.lineWidths = void 0;
    this.maxHeight = void 0;
    this.maxWidth = void 0;
    this.top = void 0;
    this.bottom = void 0;
    this.left = void 0;
    this.right = void 0;
    this.height = void 0;
    this.width = void 0;
    this._margins = void 0;
    this.position = void 0;
    this.weight = void 0;
    this.fullSize = void 0;
  }
  update(maxWidth, maxHeight, margins) {
    this.maxWidth = maxWidth;
    this.maxHeight = maxHeight;
    this._margins = margins;
    this.setDimensions();
    this.buildLabels();
    this.fit();
  }
  setDimensions() {
    if (this.isHorizontal()) {
      this.width = this.maxWidth;
      this.left = this._margins.left;
      this.right = this.width;
    } else {
      this.height = this.maxHeight;
      this.top = this._margins.top;
      this.bottom = this.height;
    }
  }
  buildLabels() {
    const labelOpts = this.options.labels || {};
    let legendItems = callback(labelOpts.generateLabels, [
      this.chart
    ], this) || [];
    if (labelOpts.filter) {
      legendItems = legendItems.filter((item) => labelOpts.filter(item, this.chart.data));
    }
    if (labelOpts.sort) {
      legendItems = legendItems.sort((a, b) => labelOpts.sort(a, b, this.chart.data));
    }
    if (this.options.reverse) {
      legendItems.reverse();
    }
    this.legendItems = legendItems;
  }
  fit() {
    const { options, ctx } = this;
    if (!options.display) {
      this.width = this.height = 0;
      return;
    }
    const labelOpts = options.labels;
    const labelFont = toFont(labelOpts.font);
    const fontSize = labelFont.size;
    const titleHeight = this._computeTitleHeight();
    const { boxWidth, itemHeight } = getBoxSize(labelOpts, fontSize);
    let width, height;
    ctx.font = labelFont.string;
    if (this.isHorizontal()) {
      width = this.maxWidth;
      height = this._fitRows(titleHeight, fontSize, boxWidth, itemHeight) + 10;
    } else {
      height = this.maxHeight;
      width = this._fitCols(titleHeight, labelFont, boxWidth, itemHeight) + 10;
    }
    this.width = Math.min(width, options.maxWidth || this.maxWidth);
    this.height = Math.min(height, options.maxHeight || this.maxHeight);
  }
  _fitRows(titleHeight, fontSize, boxWidth, itemHeight) {
    const { ctx, maxWidth, options: { labels: { padding } } } = this;
    const hitboxes = this.legendHitBoxes = [];
    const lineWidths = this.lineWidths = [
      0
    ];
    const lineHeight = itemHeight + padding;
    let totalHeight = titleHeight;
    ctx.textAlign = "left";
    ctx.textBaseline = "middle";
    let row = -1;
    let top = -lineHeight;
    this.legendItems.forEach((legendItem, i) => {
      const itemWidth = boxWidth + fontSize / 2 + ctx.measureText(legendItem.text).width;
      if (i === 0 || lineWidths[lineWidths.length - 1] + itemWidth + 2 * padding > maxWidth) {
        totalHeight += lineHeight;
        lineWidths[lineWidths.length - (i > 0 ? 0 : 1)] = 0;
        top += lineHeight;
        row++;
      }
      hitboxes[i] = {
        left: 0,
        top,
        row,
        width: itemWidth,
        height: itemHeight
      };
      lineWidths[lineWidths.length - 1] += itemWidth + padding;
    });
    return totalHeight;
  }
  _fitCols(titleHeight, labelFont, boxWidth, _itemHeight) {
    const { ctx, maxHeight, options: { labels: { padding } } } = this;
    const hitboxes = this.legendHitBoxes = [];
    const columnSizes = this.columnSizes = [];
    const heightLimit = maxHeight - titleHeight;
    let totalWidth = padding;
    let currentColWidth = 0;
    let currentColHeight = 0;
    let left = 0;
    let col = 0;
    this.legendItems.forEach((legendItem, i) => {
      const { itemWidth, itemHeight } = calculateItemSize(boxWidth, labelFont, ctx, legendItem, _itemHeight);
      if (i > 0 && currentColHeight + itemHeight + 2 * padding > heightLimit) {
        totalWidth += currentColWidth + padding;
        columnSizes.push({
          width: currentColWidth,
          height: currentColHeight
        });
        left += currentColWidth + padding;
        col++;
        currentColWidth = currentColHeight = 0;
      }
      hitboxes[i] = {
        left,
        top: currentColHeight,
        col,
        width: itemWidth,
        height: itemHeight
      };
      currentColWidth = Math.max(currentColWidth, itemWidth);
      currentColHeight += itemHeight + padding;
    });
    totalWidth += currentColWidth;
    columnSizes.push({
      width: currentColWidth,
      height: currentColHeight
    });
    return totalWidth;
  }
  adjustHitBoxes() {
    if (!this.options.display) {
      return;
    }
    const titleHeight = this._computeTitleHeight();
    const { legendHitBoxes: hitboxes, options: { align, labels: { padding }, rtl } } = this;
    const rtlHelper = getRtlAdapter(rtl, this.left, this.width);
    if (this.isHorizontal()) {
      let row = 0;
      let left = _alignStartEnd(align, this.left + padding, this.right - this.lineWidths[row]);
      for (const hitbox of hitboxes) {
        if (row !== hitbox.row) {
          row = hitbox.row;
          left = _alignStartEnd(align, this.left + padding, this.right - this.lineWidths[row]);
        }
        hitbox.top += this.top + titleHeight + padding;
        hitbox.left = rtlHelper.leftForLtr(rtlHelper.x(left), hitbox.width);
        left += hitbox.width + padding;
      }
    } else {
      let col = 0;
      let top = _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - this.columnSizes[col].height);
      for (const hitbox of hitboxes) {
        if (hitbox.col !== col) {
          col = hitbox.col;
          top = _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - this.columnSizes[col].height);
        }
        hitbox.top = top;
        hitbox.left += this.left + padding;
        hitbox.left = rtlHelper.leftForLtr(rtlHelper.x(hitbox.left), hitbox.width);
        top += hitbox.height + padding;
      }
    }
  }
  isHorizontal() {
    return this.options.position === "top" || this.options.position === "bottom";
  }
  draw() {
    if (this.options.display) {
      const ctx = this.ctx;
      clipArea(ctx, this);
      this._draw();
      unclipArea(ctx);
    }
  }
  _draw() {
    const { options: opts, columnSizes, lineWidths, ctx } = this;
    const { align, labels: labelOpts } = opts;
    const defaultColor = defaults.color;
    const rtlHelper = getRtlAdapter(opts.rtl, this.left, this.width);
    const labelFont = toFont(labelOpts.font);
    const { padding } = labelOpts;
    const fontSize = labelFont.size;
    const halfFontSize = fontSize / 2;
    let cursor;
    this.drawTitle();
    ctx.textAlign = rtlHelper.textAlign("left");
    ctx.textBaseline = "middle";
    ctx.lineWidth = 0.5;
    ctx.font = labelFont.string;
    const { boxWidth, boxHeight, itemHeight } = getBoxSize(labelOpts, fontSize);
    const drawLegendBox = function(x, y, legendItem) {
      if (isNaN(boxWidth) || boxWidth <= 0 || isNaN(boxHeight) || boxHeight < 0) {
        return;
      }
      ctx.save();
      const lineWidth = valueOrDefault(legendItem.lineWidth, 1);
      ctx.fillStyle = valueOrDefault(legendItem.fillStyle, defaultColor);
      ctx.lineCap = valueOrDefault(legendItem.lineCap, "butt");
      ctx.lineDashOffset = valueOrDefault(legendItem.lineDashOffset, 0);
      ctx.lineJoin = valueOrDefault(legendItem.lineJoin, "miter");
      ctx.lineWidth = lineWidth;
      ctx.strokeStyle = valueOrDefault(legendItem.strokeStyle, defaultColor);
      ctx.setLineDash(valueOrDefault(legendItem.lineDash, []));
      if (labelOpts.usePointStyle) {
        const drawOptions = {
          radius: boxHeight * Math.SQRT2 / 2,
          pointStyle: legendItem.pointStyle,
          rotation: legendItem.rotation,
          borderWidth: lineWidth
        };
        const centerX = rtlHelper.xPlus(x, boxWidth / 2);
        const centerY = y + halfFontSize;
        drawPointLegend(ctx, drawOptions, centerX, centerY, labelOpts.pointStyleWidth && boxWidth);
      } else {
        const yBoxTop = y + Math.max((fontSize - boxHeight) / 2, 0);
        const xBoxLeft = rtlHelper.leftForLtr(x, boxWidth);
        const borderRadius = toTRBLCorners(legendItem.borderRadius);
        ctx.beginPath();
        if (Object.values(borderRadius).some((v) => v !== 0)) {
          addRoundedRectPath(ctx, {
            x: xBoxLeft,
            y: yBoxTop,
            w: boxWidth,
            h: boxHeight,
            radius: borderRadius
          });
        } else {
          ctx.rect(xBoxLeft, yBoxTop, boxWidth, boxHeight);
        }
        ctx.fill();
        if (lineWidth !== 0) {
          ctx.stroke();
        }
      }
      ctx.restore();
    };
    const fillText = function(x, y, legendItem) {
      renderText(ctx, legendItem.text, x, y + itemHeight / 2, labelFont, {
        strikethrough: legendItem.hidden,
        textAlign: rtlHelper.textAlign(legendItem.textAlign)
      });
    };
    const isHorizontal = this.isHorizontal();
    const titleHeight = this._computeTitleHeight();
    if (isHorizontal) {
      cursor = {
        x: _alignStartEnd(align, this.left + padding, this.right - lineWidths[0]),
        y: this.top + padding + titleHeight,
        line: 0
      };
    } else {
      cursor = {
        x: this.left + padding,
        y: _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - columnSizes[0].height),
        line: 0
      };
    }
    overrideTextDirection(this.ctx, opts.textDirection);
    const lineHeight = itemHeight + padding;
    this.legendItems.forEach((legendItem, i) => {
      ctx.strokeStyle = legendItem.fontColor;
      ctx.fillStyle = legendItem.fontColor;
      const textWidth = ctx.measureText(legendItem.text).width;
      const textAlign = rtlHelper.textAlign(legendItem.textAlign || (legendItem.textAlign = labelOpts.textAlign));
      const width = boxWidth + halfFontSize + textWidth;
      let x = cursor.x;
      let y = cursor.y;
      rtlHelper.setWidth(this.width);
      if (isHorizontal) {
        if (i > 0 && x + width + padding > this.right) {
          y = cursor.y += lineHeight;
          cursor.line++;
          x = cursor.x = _alignStartEnd(align, this.left + padding, this.right - lineWidths[cursor.line]);
        }
      } else if (i > 0 && y + lineHeight > this.bottom) {
        x = cursor.x = x + columnSizes[cursor.line].width + padding;
        cursor.line++;
        y = cursor.y = _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - columnSizes[cursor.line].height);
      }
      const realX = rtlHelper.x(x);
      drawLegendBox(realX, y, legendItem);
      x = _textX(textAlign, x + boxWidth + halfFontSize, isHorizontal ? x + width : this.right, opts.rtl);
      fillText(rtlHelper.x(x), y, legendItem);
      if (isHorizontal) {
        cursor.x += width + padding;
      } else if (typeof legendItem.text !== "string") {
        const fontLineHeight = labelFont.lineHeight;
        cursor.y += calculateLegendItemHeight(legendItem, fontLineHeight) + padding;
      } else {
        cursor.y += lineHeight;
      }
    });
    restoreTextDirection(this.ctx, opts.textDirection);
  }
  drawTitle() {
    const opts = this.options;
    const titleOpts = opts.title;
    const titleFont = toFont(titleOpts.font);
    const titlePadding = toPadding(titleOpts.padding);
    if (!titleOpts.display) {
      return;
    }
    const rtlHelper = getRtlAdapter(opts.rtl, this.left, this.width);
    const ctx = this.ctx;
    const position = titleOpts.position;
    const halfFontSize = titleFont.size / 2;
    const topPaddingPlusHalfFontSize = titlePadding.top + halfFontSize;
    let y;
    let left = this.left;
    let maxWidth = this.width;
    if (this.isHorizontal()) {
      maxWidth = Math.max(...this.lineWidths);
      y = this.top + topPaddingPlusHalfFontSize;
      left = _alignStartEnd(opts.align, left, this.right - maxWidth);
    } else {
      const maxHeight = this.columnSizes.reduce((acc, size) => Math.max(acc, size.height), 0);
      y = topPaddingPlusHalfFontSize + _alignStartEnd(opts.align, this.top, this.bottom - maxHeight - opts.labels.padding - this._computeTitleHeight());
    }
    const x = _alignStartEnd(position, left, left + maxWidth);
    ctx.textAlign = rtlHelper.textAlign(_toLeftRightCenter(position));
    ctx.textBaseline = "middle";
    ctx.strokeStyle = titleOpts.color;
    ctx.fillStyle = titleOpts.color;
    ctx.font = titleFont.string;
    renderText(ctx, titleOpts.text, x, y, titleFont);
  }
  _computeTitleHeight() {
    const titleOpts = this.options.title;
    const titleFont = toFont(titleOpts.font);
    const titlePadding = toPadding(titleOpts.padding);
    return titleOpts.display ? titleFont.lineHeight + titlePadding.height : 0;
  }
  _getLegendItemAt(x, y) {
    let i, hitBox, lh;
    if (_isBetween(x, this.left, this.right) && _isBetween(y, this.top, this.bottom)) {
      lh = this.legendHitBoxes;
      for (i = 0; i < lh.length; ++i) {
        hitBox = lh[i];
        if (_isBetween(x, hitBox.left, hitBox.left + hitBox.width) && _isBetween(y, hitBox.top, hitBox.top + hitBox.height)) {
          return this.legendItems[i];
        }
      }
    }
    return null;
  }
  handleEvent(e) {
    const opts = this.options;
    if (!isListened(e.type, opts)) {
      return;
    }
    const hoveredItem = this._getLegendItemAt(e.x, e.y);
    if (e.type === "mousemove" || e.type === "mouseout") {
      const previous = this._hoveredItem;
      const sameItem = itemsEqual(previous, hoveredItem);
      if (previous && !sameItem) {
        callback(opts.onLeave, [
          e,
          previous,
          this
        ], this);
      }
      this._hoveredItem = hoveredItem;
      if (hoveredItem && !sameItem) {
        callback(opts.onHover, [
          e,
          hoveredItem,
          this
        ], this);
      }
    } else if (hoveredItem) {
      callback(opts.onClick, [
        e,
        hoveredItem,
        this
      ], this);
    }
  }
};
function calculateItemSize(boxWidth, labelFont, ctx, legendItem, _itemHeight) {
  const itemWidth = calculateItemWidth(legendItem, boxWidth, labelFont, ctx);
  const itemHeight = calculateItemHeight(_itemHeight, legendItem, labelFont.lineHeight);
  return {
    itemWidth,
    itemHeight
  };
}
function calculateItemWidth(legendItem, boxWidth, labelFont, ctx) {
  let legendItemText = legendItem.text;
  if (legendItemText && typeof legendItemText !== "string") {
    legendItemText = legendItemText.reduce((a, b) => a.length > b.length ? a : b);
  }
  return boxWidth + labelFont.size / 2 + ctx.measureText(legendItemText).width;
}
function calculateItemHeight(_itemHeight, legendItem, fontLineHeight) {
  let itemHeight = _itemHeight;
  if (typeof legendItem.text !== "string") {
    itemHeight = calculateLegendItemHeight(legendItem, fontLineHeight);
  }
  return itemHeight;
}
function calculateLegendItemHeight(legendItem, fontLineHeight) {
  const labelHeight = legendItem.text ? legendItem.text.length : 0;
  return fontLineHeight * labelHeight;
}
function isListened(type, opts) {
  if ((type === "mousemove" || type === "mouseout") && (opts.onHover || opts.onLeave)) {
    return true;
  }
  if (opts.onClick && (type === "click" || type === "mouseup")) {
    return true;
  }
  return false;
}
var plugin_legend = {
  id: "legend",
  _element: Legend,
  start(chart, _args, options) {
    const legend = chart.legend = new Legend({
      ctx: chart.ctx,
      options,
      chart
    });
    layouts.configure(chart, legend, options);
    layouts.addBox(chart, legend);
  },
  stop(chart) {
    layouts.removeBox(chart, chart.legend);
    delete chart.legend;
  },
  beforeUpdate(chart, _args, options) {
    const legend = chart.legend;
    layouts.configure(chart, legend, options);
    legend.options = options;
  },
  afterUpdate(chart) {
    const legend = chart.legend;
    legend.buildLabels();
    legend.adjustHitBoxes();
  },
  afterEvent(chart, args) {
    if (!args.replay) {
      chart.legend.handleEvent(args.event);
    }
  },
  defaults: {
    display: true,
    position: "top",
    align: "center",
    fullSize: true,
    reverse: false,
    weight: 1e3,
    onClick(e, legendItem, legend) {
      const index2 = legendItem.datasetIndex;
      const ci = legend.chart;
      if (ci.isDatasetVisible(index2)) {
        ci.hide(index2);
        legendItem.hidden = true;
      } else {
        ci.show(index2);
        legendItem.hidden = false;
      }
    },
    onHover: null,
    onLeave: null,
    labels: {
      color: (ctx) => ctx.chart.options.color,
      boxWidth: 40,
      padding: 10,
      generateLabels(chart) {
        const datasets = chart.data.datasets;
        const { labels: { usePointStyle, pointStyle, textAlign, color: color2, useBorderRadius, borderRadius } } = chart.legend.options;
        return chart._getSortedDatasetMetas().map((meta) => {
          const style = meta.controller.getStyle(usePointStyle ? 0 : void 0);
          const borderWidth = toPadding(style.borderWidth);
          return {
            text: datasets[meta.index].label,
            fillStyle: style.backgroundColor,
            fontColor: color2,
            hidden: !meta.visible,
            lineCap: style.borderCapStyle,
            lineDash: style.borderDash,
            lineDashOffset: style.borderDashOffset,
            lineJoin: style.borderJoinStyle,
            lineWidth: (borderWidth.width + borderWidth.height) / 4,
            strokeStyle: style.borderColor,
            pointStyle: pointStyle || style.pointStyle,
            rotation: style.rotation,
            textAlign: textAlign || style.textAlign,
            borderRadius: useBorderRadius && (borderRadius || style.borderRadius),
            datasetIndex: meta.index
          };
        }, this);
      }
    },
    title: {
      color: (ctx) => ctx.chart.options.color,
      display: false,
      position: "center",
      text: ""
    }
  },
  descriptors: {
    _scriptable: (name) => !name.startsWith("on"),
    labels: {
      _scriptable: (name) => ![
        "generateLabels",
        "filter",
        "sort"
      ].includes(name)
    }
  }
};
var Title = class extends Element {
  constructor(config) {
    super();
    this.chart = config.chart;
    this.options = config.options;
    this.ctx = config.ctx;
    this._padding = void 0;
    this.top = void 0;
    this.bottom = void 0;
    this.left = void 0;
    this.right = void 0;
    this.width = void 0;
    this.height = void 0;
    this.position = void 0;
    this.weight = void 0;
    this.fullSize = void 0;
  }
  update(maxWidth, maxHeight) {
    const opts = this.options;
    this.left = 0;
    this.top = 0;
    if (!opts.display) {
      this.width = this.height = this.right = this.bottom = 0;
      return;
    }
    this.width = this.right = maxWidth;
    this.height = this.bottom = maxHeight;
    const lineCount = isArray(opts.text) ? opts.text.length : 1;
    this._padding = toPadding(opts.padding);
    const textSize = lineCount * toFont(opts.font).lineHeight + this._padding.height;
    if (this.isHorizontal()) {
      this.height = textSize;
    } else {
      this.width = textSize;
    }
  }
  isHorizontal() {
    const pos = this.options.position;
    return pos === "top" || pos === "bottom";
  }
  _drawArgs(offset) {
    const { top, left, bottom, right, options } = this;
    const align = options.align;
    let rotation = 0;
    let maxWidth, titleX, titleY;
    if (this.isHorizontal()) {
      titleX = _alignStartEnd(align, left, right);
      titleY = top + offset;
      maxWidth = right - left;
    } else {
      if (options.position === "left") {
        titleX = left + offset;
        titleY = _alignStartEnd(align, bottom, top);
        rotation = PI * -0.5;
      } else {
        titleX = right - offset;
        titleY = _alignStartEnd(align, top, bottom);
        rotation = PI * 0.5;
      }
      maxWidth = bottom - top;
    }
    return {
      titleX,
      titleY,
      maxWidth,
      rotation
    };
  }
  draw() {
    const ctx = this.ctx;
    const opts = this.options;
    if (!opts.display) {
      return;
    }
    const fontOpts = toFont(opts.font);
    const lineHeight = fontOpts.lineHeight;
    const offset = lineHeight / 2 + this._padding.top;
    const { titleX, titleY, maxWidth, rotation } = this._drawArgs(offset);
    renderText(ctx, opts.text, 0, 0, fontOpts, {
      color: opts.color,
      maxWidth,
      rotation,
      textAlign: _toLeftRightCenter(opts.align),
      textBaseline: "middle",
      translation: [
        titleX,
        titleY
      ]
    });
  }
};
function createTitle(chart, titleOpts) {
  const title = new Title({
    ctx: chart.ctx,
    options: titleOpts,
    chart
  });
  layouts.configure(chart, title, titleOpts);
  layouts.addBox(chart, title);
  chart.titleBlock = title;
}
var plugin_title = {
  id: "title",
  _element: Title,
  start(chart, _args, options) {
    createTitle(chart, options);
  },
  stop(chart) {
    const titleBlock = chart.titleBlock;
    layouts.removeBox(chart, titleBlock);
    delete chart.titleBlock;
  },
  beforeUpdate(chart, _args, options) {
    const title = chart.titleBlock;
    layouts.configure(chart, title, options);
    title.options = options;
  },
  defaults: {
    align: "center",
    display: false,
    font: {
      weight: "bold"
    },
    fullSize: true,
    padding: 10,
    position: "top",
    text: "",
    weight: 2e3
  },
  defaultRoutes: {
    color: "color"
  },
  descriptors: {
    _scriptable: true,
    _indexable: false
  }
};
var map2 = /* @__PURE__ */ new WeakMap();
var plugin_subtitle = {
  id: "subtitle",
  start(chart, _args, options) {
    const title = new Title({
      ctx: chart.ctx,
      options,
      chart
    });
    layouts.configure(chart, title, options);
    layouts.addBox(chart, title);
    map2.set(chart, title);
  },
  stop(chart) {
    layouts.removeBox(chart, map2.get(chart));
    map2.delete(chart);
  },
  beforeUpdate(chart, _args, options) {
    const title = map2.get(chart);
    layouts.configure(chart, title, options);
    title.options = options;
  },
  defaults: {
    align: "center",
    display: false,
    font: {
      weight: "normal"
    },
    fullSize: true,
    padding: 0,
    position: "top",
    text: "",
    weight: 1500
  },
  defaultRoutes: {
    color: "color"
  },
  descriptors: {
    _scriptable: true,
    _indexable: false
  }
};
var positioners = {
  average(items) {
    if (!items.length) {
      return false;
    }
    let i, len;
    let xSet = /* @__PURE__ */ new Set();
    let y = 0;
    let count = 0;
    for (i = 0, len = items.length; i < len; ++i) {
      const el = items[i].element;
      if (el && el.hasValue()) {
        const pos = el.tooltipPosition();
        xSet.add(pos.x);
        y += pos.y;
        ++count;
      }
    }
    if (count === 0 || xSet.size === 0) {
      return false;
    }
    const xAverage = [
      ...xSet
    ].reduce((a, b) => a + b) / xSet.size;
    return {
      x: xAverage,
      y: y / count
    };
  },
  nearest(items, eventPosition) {
    if (!items.length) {
      return false;
    }
    let x = eventPosition.x;
    let y = eventPosition.y;
    let minDistance = Number.POSITIVE_INFINITY;
    let i, len, nearestElement;
    for (i = 0, len = items.length; i < len; ++i) {
      const el = items[i].element;
      if (el && el.hasValue()) {
        const center = el.getCenterPoint();
        const d = distanceBetweenPoints(eventPosition, center);
        if (d < minDistance) {
          minDistance = d;
          nearestElement = el;
        }
      }
    }
    if (nearestElement) {
      const tp = nearestElement.tooltipPosition();
      x = tp.x;
      y = tp.y;
    }
    return {
      x,
      y
    };
  }
};
function pushOrConcat(base, toPush) {
  if (toPush) {
    if (isArray(toPush)) {
      Array.prototype.push.apply(base, toPush);
    } else {
      base.push(toPush);
    }
  }
  return base;
}
function splitNewlines(str) {
  if ((typeof str === "string" || str instanceof String) && str.indexOf("\n") > -1) {
    return str.split("\n");
  }
  return str;
}
function createTooltipItem(chart, item) {
  const { element, datasetIndex, index: index2 } = item;
  const controller = chart.getDatasetMeta(datasetIndex).controller;
  const { label, value } = controller.getLabelAndValue(index2);
  return {
    chart,
    label,
    parsed: controller.getParsed(index2),
    raw: chart.data.datasets[datasetIndex].data[index2],
    formattedValue: value,
    dataset: controller.getDataset(),
    dataIndex: index2,
    datasetIndex,
    element
  };
}
function getTooltipSize(tooltip, options) {
  const ctx = tooltip.chart.ctx;
  const { body, footer, title } = tooltip;
  const { boxWidth, boxHeight } = options;
  const bodyFont = toFont(options.bodyFont);
  const titleFont = toFont(options.titleFont);
  const footerFont = toFont(options.footerFont);
  const titleLineCount = title.length;
  const footerLineCount = footer.length;
  const bodyLineItemCount = body.length;
  const padding = toPadding(options.padding);
  let height = padding.height;
  let width = 0;
  let combinedBodyLength = body.reduce((count, bodyItem) => count + bodyItem.before.length + bodyItem.lines.length + bodyItem.after.length, 0);
  combinedBodyLength += tooltip.beforeBody.length + tooltip.afterBody.length;
  if (titleLineCount) {
    height += titleLineCount * titleFont.lineHeight + (titleLineCount - 1) * options.titleSpacing + options.titleMarginBottom;
  }
  if (combinedBodyLength) {
    const bodyLineHeight = options.displayColors ? Math.max(boxHeight, bodyFont.lineHeight) : bodyFont.lineHeight;
    height += bodyLineItemCount * bodyLineHeight + (combinedBodyLength - bodyLineItemCount) * bodyFont.lineHeight + (combinedBodyLength - 1) * options.bodySpacing;
  }
  if (footerLineCount) {
    height += options.footerMarginTop + footerLineCount * footerFont.lineHeight + (footerLineCount - 1) * options.footerSpacing;
  }
  let widthPadding = 0;
  const maxLineWidth = function(line) {
    width = Math.max(width, ctx.measureText(line).width + widthPadding);
  };
  ctx.save();
  ctx.font = titleFont.string;
  each(tooltip.title, maxLineWidth);
  ctx.font = bodyFont.string;
  each(tooltip.beforeBody.concat(tooltip.afterBody), maxLineWidth);
  widthPadding = options.displayColors ? boxWidth + 2 + options.boxPadding : 0;
  each(body, (bodyItem) => {
    each(bodyItem.before, maxLineWidth);
    each(bodyItem.lines, maxLineWidth);
    each(bodyItem.after, maxLineWidth);
  });
  widthPadding = 0;
  ctx.font = footerFont.string;
  each(tooltip.footer, maxLineWidth);
  ctx.restore();
  width += padding.width;
  return {
    width,
    height
  };
}
function determineYAlign(chart, size) {
  const { y, height } = size;
  if (y < height / 2) {
    return "top";
  } else if (y > chart.height - height / 2) {
    return "bottom";
  }
  return "center";
}
function doesNotFitWithAlign(xAlign, chart, options, size) {
  const { x, width } = size;
  const caret = options.caretSize + options.caretPadding;
  if (xAlign === "left" && x + width + caret > chart.width) {
    return true;
  }
  if (xAlign === "right" && x - width - caret < 0) {
    return true;
  }
}
function determineXAlign(chart, options, size, yAlign) {
  const { x, width } = size;
  const { width: chartWidth, chartArea: { left, right } } = chart;
  let xAlign = "center";
  if (yAlign === "center") {
    xAlign = x <= (left + right) / 2 ? "left" : "right";
  } else if (x <= width / 2) {
    xAlign = "left";
  } else if (x >= chartWidth - width / 2) {
    xAlign = "right";
  }
  if (doesNotFitWithAlign(xAlign, chart, options, size)) {
    xAlign = "center";
  }
  return xAlign;
}
function determineAlignment(chart, options, size) {
  const yAlign = size.yAlign || options.yAlign || determineYAlign(chart, size);
  return {
    xAlign: size.xAlign || options.xAlign || determineXAlign(chart, options, size, yAlign),
    yAlign
  };
}
function alignX(size, xAlign) {
  let { x, width } = size;
  if (xAlign === "right") {
    x -= width;
  } else if (xAlign === "center") {
    x -= width / 2;
  }
  return x;
}
function alignY(size, yAlign, paddingAndSize) {
  let { y, height } = size;
  if (yAlign === "top") {
    y += paddingAndSize;
  } else if (yAlign === "bottom") {
    y -= height + paddingAndSize;
  } else {
    y -= height / 2;
  }
  return y;
}
function getBackgroundPoint(options, size, alignment, chart) {
  const { caretSize, caretPadding, cornerRadius } = options;
  const { xAlign, yAlign } = alignment;
  const paddingAndSize = caretSize + caretPadding;
  const { topLeft, topRight, bottomLeft, bottomRight } = toTRBLCorners(cornerRadius);
  let x = alignX(size, xAlign);
  const y = alignY(size, yAlign, paddingAndSize);
  if (yAlign === "center") {
    if (xAlign === "left") {
      x += paddingAndSize;
    } else if (xAlign === "right") {
      x -= paddingAndSize;
    }
  } else if (xAlign === "left") {
    x -= Math.max(topLeft, bottomLeft) + caretSize;
  } else if (xAlign === "right") {
    x += Math.max(topRight, bottomRight) + caretSize;
  }
  return {
    x: _limitValue(x, 0, chart.width - size.width),
    y: _limitValue(y, 0, chart.height - size.height)
  };
}
function getAlignedX(tooltip, align, options) {
  const padding = toPadding(options.padding);
  return align === "center" ? tooltip.x + tooltip.width / 2 : align === "right" ? tooltip.x + tooltip.width - padding.right : tooltip.x + padding.left;
}
function getBeforeAfterBodyLines(callback2) {
  return pushOrConcat([], splitNewlines(callback2));
}
function createTooltipContext(parent, tooltip, tooltipItems) {
  return createContext(parent, {
    tooltip,
    tooltipItems,
    type: "tooltip"
  });
}
function overrideCallbacks(callbacks, context) {
  const override = context && context.dataset && context.dataset.tooltip && context.dataset.tooltip.callbacks;
  return override ? callbacks.override(override) : callbacks;
}
var defaultCallbacks = {
  beforeTitle: noop,
  title(tooltipItems) {
    if (tooltipItems.length > 0) {
      const item = tooltipItems[0];
      const labels = item.chart.data.labels;
      const labelCount = labels ? labels.length : 0;
      if (this && this.options && this.options.mode === "dataset") {
        return item.dataset.label || "";
      } else if (item.label) {
        return item.label;
      } else if (labelCount > 0 && item.dataIndex < labelCount) {
        return labels[item.dataIndex];
      }
    }
    return "";
  },
  afterTitle: noop,
  beforeBody: noop,
  beforeLabel: noop,
  label(tooltipItem) {
    if (this && this.options && this.options.mode === "dataset") {
      return tooltipItem.label + ": " + tooltipItem.formattedValue || tooltipItem.formattedValue;
    }
    let label = tooltipItem.dataset.label || "";
    if (label) {
      label += ": ";
    }
    const value = tooltipItem.formattedValue;
    if (!isNullOrUndef(value)) {
      label += value;
    }
    return label;
  },
  labelColor(tooltipItem) {
    const meta = tooltipItem.chart.getDatasetMeta(tooltipItem.datasetIndex);
    const options = meta.controller.getStyle(tooltipItem.dataIndex);
    return {
      borderColor: options.borderColor,
      backgroundColor: options.backgroundColor,
      borderWidth: options.borderWidth,
      borderDash: options.borderDash,
      borderDashOffset: options.borderDashOffset,
      borderRadius: 0
    };
  },
  labelTextColor() {
    return this.options.bodyColor;
  },
  labelPointStyle(tooltipItem) {
    const meta = tooltipItem.chart.getDatasetMeta(tooltipItem.datasetIndex);
    const options = meta.controller.getStyle(tooltipItem.dataIndex);
    return {
      pointStyle: options.pointStyle,
      rotation: options.rotation
    };
  },
  afterLabel: noop,
  afterBody: noop,
  beforeFooter: noop,
  footer: noop,
  afterFooter: noop
};
function invokeCallbackWithFallback(callbacks, name, ctx, arg) {
  const result = callbacks[name].call(ctx, arg);
  if (typeof result === "undefined") {
    return defaultCallbacks[name].call(ctx, arg);
  }
  return result;
}
var Tooltip = class extends Element {
  constructor(config) {
    super();
    this.opacity = 0;
    this._active = [];
    this._eventPosition = void 0;
    this._size = void 0;
    this._cachedAnimations = void 0;
    this._tooltipItems = [];
    this.$animations = void 0;
    this.$context = void 0;
    this.chart = config.chart;
    this.options = config.options;
    this.dataPoints = void 0;
    this.title = void 0;
    this.beforeBody = void 0;
    this.body = void 0;
    this.afterBody = void 0;
    this.footer = void 0;
    this.xAlign = void 0;
    this.yAlign = void 0;
    this.x = void 0;
    this.y = void 0;
    this.height = void 0;
    this.width = void 0;
    this.caretX = void 0;
    this.caretY = void 0;
    this.labelColors = void 0;
    this.labelPointStyles = void 0;
    this.labelTextColors = void 0;
  }
  initialize(options) {
    this.options = options;
    this._cachedAnimations = void 0;
    this.$context = void 0;
  }
  _resolveAnimations() {
    const cached = this._cachedAnimations;
    if (cached) {
      return cached;
    }
    const chart = this.chart;
    const options = this.options.setContext(this.getContext());
    const opts = options.enabled && chart.options.animation && options.animations;
    const animations = new Animations(this.chart, opts);
    if (opts._cacheable) {
      this._cachedAnimations = Object.freeze(animations);
    }
    return animations;
  }
  getContext() {
    return this.$context || (this.$context = createTooltipContext(this.chart.getContext(), this, this._tooltipItems));
  }
  getTitle(context, options) {
    const { callbacks } = options;
    const beforeTitle = invokeCallbackWithFallback(callbacks, "beforeTitle", this, context);
    const title = invokeCallbackWithFallback(callbacks, "title", this, context);
    const afterTitle = invokeCallbackWithFallback(callbacks, "afterTitle", this, context);
    let lines = [];
    lines = pushOrConcat(lines, splitNewlines(beforeTitle));
    lines = pushOrConcat(lines, splitNewlines(title));
    lines = pushOrConcat(lines, splitNewlines(afterTitle));
    return lines;
  }
  getBeforeBody(tooltipItems, options) {
    return getBeforeAfterBodyLines(invokeCallbackWithFallback(options.callbacks, "beforeBody", this, tooltipItems));
  }
  getBody(tooltipItems, options) {
    const { callbacks } = options;
    const bodyItems = [];
    each(tooltipItems, (context) => {
      const bodyItem = {
        before: [],
        lines: [],
        after: []
      };
      const scoped = overrideCallbacks(callbacks, context);
      pushOrConcat(bodyItem.before, splitNewlines(invokeCallbackWithFallback(scoped, "beforeLabel", this, context)));
      pushOrConcat(bodyItem.lines, invokeCallbackWithFallback(scoped, "label", this, context));
      pushOrConcat(bodyItem.after, splitNewlines(invokeCallbackWithFallback(scoped, "afterLabel", this, context)));
      bodyItems.push(bodyItem);
    });
    return bodyItems;
  }
  getAfterBody(tooltipItems, options) {
    return getBeforeAfterBodyLines(invokeCallbackWithFallback(options.callbacks, "afterBody", this, tooltipItems));
  }
  getFooter(tooltipItems, options) {
    const { callbacks } = options;
    const beforeFooter = invokeCallbackWithFallback(callbacks, "beforeFooter", this, tooltipItems);
    const footer = invokeCallbackWithFallback(callbacks, "footer", this, tooltipItems);
    const afterFooter = invokeCallbackWithFallback(callbacks, "afterFooter", this, tooltipItems);
    let lines = [];
    lines = pushOrConcat(lines, splitNewlines(beforeFooter));
    lines = pushOrConcat(lines, splitNewlines(footer));
    lines = pushOrConcat(lines, splitNewlines(afterFooter));
    return lines;
  }
  _createItems(options) {
    const active = this._active;
    const data = this.chart.data;
    const labelColors = [];
    const labelPointStyles = [];
    const labelTextColors = [];
    let tooltipItems = [];
    let i, len;
    for (i = 0, len = active.length; i < len; ++i) {
      tooltipItems.push(createTooltipItem(this.chart, active[i]));
    }
    if (options.filter) {
      tooltipItems = tooltipItems.filter((element, index2, array) => options.filter(element, index2, array, data));
    }
    if (options.itemSort) {
      tooltipItems = tooltipItems.sort((a, b) => options.itemSort(a, b, data));
    }
    each(tooltipItems, (context) => {
      const scoped = overrideCallbacks(options.callbacks, context);
      labelColors.push(invokeCallbackWithFallback(scoped, "labelColor", this, context));
      labelPointStyles.push(invokeCallbackWithFallback(scoped, "labelPointStyle", this, context));
      labelTextColors.push(invokeCallbackWithFallback(scoped, "labelTextColor", this, context));
    });
    this.labelColors = labelColors;
    this.labelPointStyles = labelPointStyles;
    this.labelTextColors = labelTextColors;
    this.dataPoints = tooltipItems;
    return tooltipItems;
  }
  update(changed, replay) {
    const options = this.options.setContext(this.getContext());
    const active = this._active;
    let properties;
    let tooltipItems = [];
    if (!active.length) {
      if (this.opacity !== 0) {
        properties = {
          opacity: 0
        };
      }
    } else {
      const position = positioners[options.position].call(this, active, this._eventPosition);
      tooltipItems = this._createItems(options);
      this.title = this.getTitle(tooltipItems, options);
      this.beforeBody = this.getBeforeBody(tooltipItems, options);
      this.body = this.getBody(tooltipItems, options);
      this.afterBody = this.getAfterBody(tooltipItems, options);
      this.footer = this.getFooter(tooltipItems, options);
      const size = this._size = getTooltipSize(this, options);
      const positionAndSize = Object.assign({}, position, size);
      const alignment = determineAlignment(this.chart, options, positionAndSize);
      const backgroundPoint = getBackgroundPoint(options, positionAndSize, alignment, this.chart);
      this.xAlign = alignment.xAlign;
      this.yAlign = alignment.yAlign;
      properties = {
        opacity: 1,
        x: backgroundPoint.x,
        y: backgroundPoint.y,
        width: size.width,
        height: size.height,
        caretX: position.x,
        caretY: position.y
      };
    }
    this._tooltipItems = tooltipItems;
    this.$context = void 0;
    if (properties) {
      this._resolveAnimations().update(this, properties);
    }
    if (changed && options.external) {
      options.external.call(this, {
        chart: this.chart,
        tooltip: this,
        replay
      });
    }
  }
  drawCaret(tooltipPoint, ctx, size, options) {
    const caretPosition = this.getCaretPosition(tooltipPoint, size, options);
    ctx.lineTo(caretPosition.x1, caretPosition.y1);
    ctx.lineTo(caretPosition.x2, caretPosition.y2);
    ctx.lineTo(caretPosition.x3, caretPosition.y3);
  }
  getCaretPosition(tooltipPoint, size, options) {
    const { xAlign, yAlign } = this;
    const { caretSize, cornerRadius } = options;
    const { topLeft, topRight, bottomLeft, bottomRight } = toTRBLCorners(cornerRadius);
    const { x: ptX, y: ptY } = tooltipPoint;
    const { width, height } = size;
    let x1, x2, x3, y1, y2, y3;
    if (yAlign === "center") {
      y2 = ptY + height / 2;
      if (xAlign === "left") {
        x1 = ptX;
        x2 = x1 - caretSize;
        y1 = y2 + caretSize;
        y3 = y2 - caretSize;
      } else {
        x1 = ptX + width;
        x2 = x1 + caretSize;
        y1 = y2 - caretSize;
        y3 = y2 + caretSize;
      }
      x3 = x1;
    } else {
      if (xAlign === "left") {
        x2 = ptX + Math.max(topLeft, bottomLeft) + caretSize;
      } else if (xAlign === "right") {
        x2 = ptX + width - Math.max(topRight, bottomRight) - caretSize;
      } else {
        x2 = this.caretX;
      }
      if (yAlign === "top") {
        y1 = ptY;
        y2 = y1 - caretSize;
        x1 = x2 - caretSize;
        x3 = x2 + caretSize;
      } else {
        y1 = ptY + height;
        y2 = y1 + caretSize;
        x1 = x2 + caretSize;
        x3 = x2 - caretSize;
      }
      y3 = y1;
    }
    return {
      x1,
      x2,
      x3,
      y1,
      y2,
      y3
    };
  }
  drawTitle(pt, ctx, options) {
    const title = this.title;
    const length = title.length;
    let titleFont, titleSpacing, i;
    if (length) {
      const rtlHelper = getRtlAdapter(options.rtl, this.x, this.width);
      pt.x = getAlignedX(this, options.titleAlign, options);
      ctx.textAlign = rtlHelper.textAlign(options.titleAlign);
      ctx.textBaseline = "middle";
      titleFont = toFont(options.titleFont);
      titleSpacing = options.titleSpacing;
      ctx.fillStyle = options.titleColor;
      ctx.font = titleFont.string;
      for (i = 0; i < length; ++i) {
        ctx.fillText(title[i], rtlHelper.x(pt.x), pt.y + titleFont.lineHeight / 2);
        pt.y += titleFont.lineHeight + titleSpacing;
        if (i + 1 === length) {
          pt.y += options.titleMarginBottom - titleSpacing;
        }
      }
    }
  }
  _drawColorBox(ctx, pt, i, rtlHelper, options) {
    const labelColor = this.labelColors[i];
    const labelPointStyle = this.labelPointStyles[i];
    const { boxHeight, boxWidth } = options;
    const bodyFont = toFont(options.bodyFont);
    const colorX = getAlignedX(this, "left", options);
    const rtlColorX = rtlHelper.x(colorX);
    const yOffSet = boxHeight < bodyFont.lineHeight ? (bodyFont.lineHeight - boxHeight) / 2 : 0;
    const colorY = pt.y + yOffSet;
    if (options.usePointStyle) {
      const drawOptions = {
        radius: Math.min(boxWidth, boxHeight) / 2,
        pointStyle: labelPointStyle.pointStyle,
        rotation: labelPointStyle.rotation,
        borderWidth: 1
      };
      const centerX = rtlHelper.leftForLtr(rtlColorX, boxWidth) + boxWidth / 2;
      const centerY = colorY + boxHeight / 2;
      ctx.strokeStyle = options.multiKeyBackground;
      ctx.fillStyle = options.multiKeyBackground;
      drawPoint(ctx, drawOptions, centerX, centerY);
      ctx.strokeStyle = labelColor.borderColor;
      ctx.fillStyle = labelColor.backgroundColor;
      drawPoint(ctx, drawOptions, centerX, centerY);
    } else {
      ctx.lineWidth = isObject(labelColor.borderWidth) ? Math.max(...Object.values(labelColor.borderWidth)) : labelColor.borderWidth || 1;
      ctx.strokeStyle = labelColor.borderColor;
      ctx.setLineDash(labelColor.borderDash || []);
      ctx.lineDashOffset = labelColor.borderDashOffset || 0;
      const outerX = rtlHelper.leftForLtr(rtlColorX, boxWidth);
      const innerX = rtlHelper.leftForLtr(rtlHelper.xPlus(rtlColorX, 1), boxWidth - 2);
      const borderRadius = toTRBLCorners(labelColor.borderRadius);
      if (Object.values(borderRadius).some((v) => v !== 0)) {
        ctx.beginPath();
        ctx.fillStyle = options.multiKeyBackground;
        addRoundedRectPath(ctx, {
          x: outerX,
          y: colorY,
          w: boxWidth,
          h: boxHeight,
          radius: borderRadius
        });
        ctx.fill();
        ctx.stroke();
        ctx.fillStyle = labelColor.backgroundColor;
        ctx.beginPath();
        addRoundedRectPath(ctx, {
          x: innerX,
          y: colorY + 1,
          w: boxWidth - 2,
          h: boxHeight - 2,
          radius: borderRadius
        });
        ctx.fill();
      } else {
        ctx.fillStyle = options.multiKeyBackground;
        ctx.fillRect(outerX, colorY, boxWidth, boxHeight);
        ctx.strokeRect(outerX, colorY, boxWidth, boxHeight);
        ctx.fillStyle = labelColor.backgroundColor;
        ctx.fillRect(innerX, colorY + 1, boxWidth - 2, boxHeight - 2);
      }
    }
    ctx.fillStyle = this.labelTextColors[i];
  }
  drawBody(pt, ctx, options) {
    const { body } = this;
    const { bodySpacing, bodyAlign, displayColors, boxHeight, boxWidth, boxPadding } = options;
    const bodyFont = toFont(options.bodyFont);
    let bodyLineHeight = bodyFont.lineHeight;
    let xLinePadding = 0;
    const rtlHelper = getRtlAdapter(options.rtl, this.x, this.width);
    const fillLineOfText = function(line) {
      ctx.fillText(line, rtlHelper.x(pt.x + xLinePadding), pt.y + bodyLineHeight / 2);
      pt.y += bodyLineHeight + bodySpacing;
    };
    const bodyAlignForCalculation = rtlHelper.textAlign(bodyAlign);
    let bodyItem, textColor, lines, i, j, ilen, jlen;
    ctx.textAlign = bodyAlign;
    ctx.textBaseline = "middle";
    ctx.font = bodyFont.string;
    pt.x = getAlignedX(this, bodyAlignForCalculation, options);
    ctx.fillStyle = options.bodyColor;
    each(this.beforeBody, fillLineOfText);
    xLinePadding = displayColors && bodyAlignForCalculation !== "right" ? bodyAlign === "center" ? boxWidth / 2 + boxPadding : boxWidth + 2 + boxPadding : 0;
    for (i = 0, ilen = body.length; i < ilen; ++i) {
      bodyItem = body[i];
      textColor = this.labelTextColors[i];
      ctx.fillStyle = textColor;
      each(bodyItem.before, fillLineOfText);
      lines = bodyItem.lines;
      if (displayColors && lines.length) {
        this._drawColorBox(ctx, pt, i, rtlHelper, options);
        bodyLineHeight = Math.max(bodyFont.lineHeight, boxHeight);
      }
      for (j = 0, jlen = lines.length; j < jlen; ++j) {
        fillLineOfText(lines[j]);
        bodyLineHeight = bodyFont.lineHeight;
      }
      each(bodyItem.after, fillLineOfText);
    }
    xLinePadding = 0;
    bodyLineHeight = bodyFont.lineHeight;
    each(this.afterBody, fillLineOfText);
    pt.y -= bodySpacing;
  }
  drawFooter(pt, ctx, options) {
    const footer = this.footer;
    const length = footer.length;
    let footerFont, i;
    if (length) {
      const rtlHelper = getRtlAdapter(options.rtl, this.x, this.width);
      pt.x = getAlignedX(this, options.footerAlign, options);
      pt.y += options.footerMarginTop;
      ctx.textAlign = rtlHelper.textAlign(options.footerAlign);
      ctx.textBaseline = "middle";
      footerFont = toFont(options.footerFont);
      ctx.fillStyle = options.footerColor;
      ctx.font = footerFont.string;
      for (i = 0; i < length; ++i) {
        ctx.fillText(footer[i], rtlHelper.x(pt.x), pt.y + footerFont.lineHeight / 2);
        pt.y += footerFont.lineHeight + options.footerSpacing;
      }
    }
  }
  drawBackground(pt, ctx, tooltipSize, options) {
    const { xAlign, yAlign } = this;
    const { x, y } = pt;
    const { width, height } = tooltipSize;
    const { topLeft, topRight, bottomLeft, bottomRight } = toTRBLCorners(options.cornerRadius);
    ctx.fillStyle = options.backgroundColor;
    ctx.strokeStyle = options.borderColor;
    ctx.lineWidth = options.borderWidth;
    ctx.beginPath();
    ctx.moveTo(x + topLeft, y);
    if (yAlign === "top") {
      this.drawCaret(pt, ctx, tooltipSize, options);
    }
    ctx.lineTo(x + width - topRight, y);
    ctx.quadraticCurveTo(x + width, y, x + width, y + topRight);
    if (yAlign === "center" && xAlign === "right") {
      this.drawCaret(pt, ctx, tooltipSize, options);
    }
    ctx.lineTo(x + width, y + height - bottomRight);
    ctx.quadraticCurveTo(x + width, y + height, x + width - bottomRight, y + height);
    if (yAlign === "bottom") {
      this.drawCaret(pt, ctx, tooltipSize, options);
    }
    ctx.lineTo(x + bottomLeft, y + height);
    ctx.quadraticCurveTo(x, y + height, x, y + height - bottomLeft);
    if (yAlign === "center" && xAlign === "left") {
      this.drawCaret(pt, ctx, tooltipSize, options);
    }
    ctx.lineTo(x, y + topLeft);
    ctx.quadraticCurveTo(x, y, x + topLeft, y);
    ctx.closePath();
    ctx.fill();
    if (options.borderWidth > 0) {
      ctx.stroke();
    }
  }
  _updateAnimationTarget(options) {
    const chart = this.chart;
    const anims = this.$animations;
    const animX = anims && anims.x;
    const animY = anims && anims.y;
    if (animX || animY) {
      const position = positioners[options.position].call(this, this._active, this._eventPosition);
      if (!position) {
        return;
      }
      const size = this._size = getTooltipSize(this, options);
      const positionAndSize = Object.assign({}, position, this._size);
      const alignment = determineAlignment(chart, options, positionAndSize);
      const point = getBackgroundPoint(options, positionAndSize, alignment, chart);
      if (animX._to !== point.x || animY._to !== point.y) {
        this.xAlign = alignment.xAlign;
        this.yAlign = alignment.yAlign;
        this.width = size.width;
        this.height = size.height;
        this.caretX = position.x;
        this.caretY = position.y;
        this._resolveAnimations().update(this, point);
      }
    }
  }
  _willRender() {
    return !!this.opacity;
  }
  draw(ctx) {
    const options = this.options.setContext(this.getContext());
    let opacity = this.opacity;
    if (!opacity) {
      return;
    }
    this._updateAnimationTarget(options);
    const tooltipSize = {
      width: this.width,
      height: this.height
    };
    const pt = {
      x: this.x,
      y: this.y
    };
    opacity = Math.abs(opacity) < 1e-3 ? 0 : opacity;
    const padding = toPadding(options.padding);
    const hasTooltipContent = this.title.length || this.beforeBody.length || this.body.length || this.afterBody.length || this.footer.length;
    if (options.enabled && hasTooltipContent) {
      ctx.save();
      ctx.globalAlpha = opacity;
      this.drawBackground(pt, ctx, tooltipSize, options);
      overrideTextDirection(ctx, options.textDirection);
      pt.y += padding.top;
      this.drawTitle(pt, ctx, options);
      this.drawBody(pt, ctx, options);
      this.drawFooter(pt, ctx, options);
      restoreTextDirection(ctx, options.textDirection);
      ctx.restore();
    }
  }
  getActiveElements() {
    return this._active || [];
  }
  setActiveElements(activeElements, eventPosition) {
    const lastActive = this._active;
    const active = activeElements.map(({ datasetIndex, index: index2 }) => {
      const meta = this.chart.getDatasetMeta(datasetIndex);
      if (!meta) {
        throw new Error("Cannot find a dataset at index " + datasetIndex);
      }
      return {
        datasetIndex,
        element: meta.data[index2],
        index: index2
      };
    });
    const changed = !_elementsEqual(lastActive, active);
    const positionChanged = this._positionChanged(active, eventPosition);
    if (changed || positionChanged) {
      this._active = active;
      this._eventPosition = eventPosition;
      this._ignoreReplayEvents = true;
      this.update(true);
    }
  }
  handleEvent(e, replay, inChartArea = true) {
    if (replay && this._ignoreReplayEvents) {
      return false;
    }
    this._ignoreReplayEvents = false;
    const options = this.options;
    const lastActive = this._active || [];
    const active = this._getActiveElements(e, lastActive, replay, inChartArea);
    const positionChanged = this._positionChanged(active, e);
    const changed = replay || !_elementsEqual(active, lastActive) || positionChanged;
    if (changed) {
      this._active = active;
      if (options.enabled || options.external) {
        this._eventPosition = {
          x: e.x,
          y: e.y
        };
        this.update(true, replay);
      }
    }
    return changed;
  }
  _getActiveElements(e, lastActive, replay, inChartArea) {
    const options = this.options;
    if (e.type === "mouseout") {
      return [];
    }
    if (!inChartArea) {
      return lastActive.filter((i) => this.chart.data.datasets[i.datasetIndex] && this.chart.getDatasetMeta(i.datasetIndex).controller.getParsed(i.index) !== void 0);
    }
    const active = this.chart.getElementsAtEventForMode(e, options.mode, options, replay);
    if (options.reverse) {
      active.reverse();
    }
    return active;
  }
  _positionChanged(active, e) {
    const { caretX, caretY, options } = this;
    const position = positioners[options.position].call(this, active, e);
    return position !== false && (caretX !== position.x || caretY !== position.y);
  }
};
__publicField(Tooltip, "positioners", positioners);
var plugin_tooltip = {
  id: "tooltip",
  _element: Tooltip,
  positioners,
  afterInit(chart, _args, options) {
    if (options) {
      chart.tooltip = new Tooltip({
        chart,
        options
      });
    }
  },
  beforeUpdate(chart, _args, options) {
    if (chart.tooltip) {
      chart.tooltip.initialize(options);
    }
  },
  reset(chart, _args, options) {
    if (chart.tooltip) {
      chart.tooltip.initialize(options);
    }
  },
  afterDraw(chart) {
    const tooltip = chart.tooltip;
    if (tooltip && tooltip._willRender()) {
      const args = {
        tooltip
      };
      if (chart.notifyPlugins("beforeTooltipDraw", {
        ...args,
        cancelable: true
      }) === false) {
        return;
      }
      tooltip.draw(chart.ctx);
      chart.notifyPlugins("afterTooltipDraw", args);
    }
  },
  afterEvent(chart, args) {
    if (chart.tooltip) {
      const useFinalPosition = args.replay;
      if (chart.tooltip.handleEvent(args.event, useFinalPosition, args.inChartArea)) {
        args.changed = true;
      }
    }
  },
  defaults: {
    enabled: true,
    external: null,
    position: "average",
    backgroundColor: "rgba(0,0,0,0.8)",
    titleColor: "#fff",
    titleFont: {
      weight: "bold"
    },
    titleSpacing: 2,
    titleMarginBottom: 6,
    titleAlign: "left",
    bodyColor: "#fff",
    bodySpacing: 2,
    bodyFont: {},
    bodyAlign: "left",
    footerColor: "#fff",
    footerSpacing: 2,
    footerMarginTop: 6,
    footerFont: {
      weight: "bold"
    },
    footerAlign: "left",
    padding: 6,
    caretPadding: 2,
    caretSize: 5,
    cornerRadius: 6,
    boxHeight: (ctx, opts) => opts.bodyFont.size,
    boxWidth: (ctx, opts) => opts.bodyFont.size,
    multiKeyBackground: "#fff",
    displayColors: true,
    boxPadding: 0,
    borderColor: "rgba(0,0,0,0)",
    borderWidth: 0,
    animation: {
      duration: 400,
      easing: "easeOutQuart"
    },
    animations: {
      numbers: {
        type: "number",
        properties: [
          "x",
          "y",
          "width",
          "height",
          "caretX",
          "caretY"
        ]
      },
      opacity: {
        easing: "linear",
        duration: 200
      }
    },
    callbacks: defaultCallbacks
  },
  defaultRoutes: {
    bodyFont: "font",
    footerFont: "font",
    titleFont: "font"
  },
  descriptors: {
    _scriptable: (name) => name !== "filter" && name !== "itemSort" && name !== "external",
    _indexable: false,
    callbacks: {
      _scriptable: false,
      _indexable: false
    },
    animation: {
      _fallback: false
    },
    animations: {
      _fallback: "animation"
    }
  },
  additionalOptionScopes: [
    "interaction"
  ]
};
var plugins = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  Colors: plugin_colors,
  Decimation: plugin_decimation,
  Filler: index,
  Legend: plugin_legend,
  SubTitle: plugin_subtitle,
  Title: plugin_title,
  Tooltip: plugin_tooltip
});
var addIfString = (labels, raw, index2, addedLabels) => {
  if (typeof raw === "string") {
    index2 = labels.push(raw) - 1;
    addedLabels.unshift({
      index: index2,
      label: raw
    });
  } else if (isNaN(raw)) {
    index2 = null;
  }
  return index2;
};
function findOrAddLabel(labels, raw, index2, addedLabels) {
  const first = labels.indexOf(raw);
  if (first === -1) {
    return addIfString(labels, raw, index2, addedLabels);
  }
  const last = labels.lastIndexOf(raw);
  return first !== last ? index2 : first;
}
var validIndex = (index2, max) => index2 === null ? null : _limitValue(Math.round(index2), 0, max);
function _getLabelForValue(value) {
  const labels = this.getLabels();
  if (value >= 0 && value < labels.length) {
    return labels[value];
  }
  return value;
}
var CategoryScale = class extends Scale {
  constructor(cfg) {
    super(cfg);
    this._startValue = void 0;
    this._valueRange = 0;
    this._addedLabels = [];
  }
  init(scaleOptions) {
    const added = this._addedLabels;
    if (added.length) {
      const labels = this.getLabels();
      for (const { index: index2, label } of added) {
        if (labels[index2] === label) {
          labels.splice(index2, 1);
        }
      }
      this._addedLabels = [];
    }
    super.init(scaleOptions);
  }
  parse(raw, index2) {
    if (isNullOrUndef(raw)) {
      return null;
    }
    const labels = this.getLabels();
    index2 = isFinite(index2) && labels[index2] === raw ? index2 : findOrAddLabel(labels, raw, valueOrDefault(index2, raw), this._addedLabels);
    return validIndex(index2, labels.length - 1);
  }
  determineDataLimits() {
    const { minDefined, maxDefined } = this.getUserBounds();
    let { min, max } = this.getMinMax(true);
    if (this.options.bounds === "ticks") {
      if (!minDefined) {
        min = 0;
      }
      if (!maxDefined) {
        max = this.getLabels().length - 1;
      }
    }
    this.min = min;
    this.max = max;
  }
  buildTicks() {
    const min = this.min;
    const max = this.max;
    const offset = this.options.offset;
    const ticks = [];
    let labels = this.getLabels();
    labels = min === 0 && max === labels.length - 1 ? labels : labels.slice(min, max + 1);
    this._valueRange = Math.max(labels.length - (offset ? 0 : 1), 1);
    this._startValue = this.min - (offset ? 0.5 : 0);
    for (let value = min; value <= max; value++) {
      ticks.push({
        value
      });
    }
    return ticks;
  }
  getLabelForValue(value) {
    return _getLabelForValue.call(this, value);
  }
  configure() {
    super.configure();
    if (!this.isHorizontal()) {
      this._reversePixels = !this._reversePixels;
    }
  }
  getPixelForValue(value) {
    if (typeof value !== "number") {
      value = this.parse(value);
    }
    return value === null ? NaN : this.getPixelForDecimal((value - this._startValue) / this._valueRange);
  }
  getPixelForTick(index2) {
    const ticks = this.ticks;
    if (index2 < 0 || index2 > ticks.length - 1) {
      return null;
    }
    return this.getPixelForValue(ticks[index2].value);
  }
  getValueForPixel(pixel) {
    return Math.round(this._startValue + this.getDecimalForPixel(pixel) * this._valueRange);
  }
  getBasePixel() {
    return this.bottom;
  }
};
__publicField(CategoryScale, "id", "category");
__publicField(CategoryScale, "defaults", {
  ticks: {
    callback: _getLabelForValue
  }
});
function generateTicks$1(generationOptions, dataRange) {
  const ticks = [];
  const MIN_SPACING = 1e-14;
  const { bounds, step, min, max, precision, count, maxTicks, maxDigits, includeBounds } = generationOptions;
  const unit = step || 1;
  const maxSpaces = maxTicks - 1;
  const { min: rmin, max: rmax } = dataRange;
  const minDefined = !isNullOrUndef(min);
  const maxDefined = !isNullOrUndef(max);
  const countDefined = !isNullOrUndef(count);
  const minSpacing = (rmax - rmin) / (maxDigits + 1);
  let spacing = niceNum((rmax - rmin) / maxSpaces / unit) * unit;
  let factor, niceMin, niceMax, numSpaces;
  if (spacing < MIN_SPACING && !minDefined && !maxDefined) {
    return [
      {
        value: rmin
      },
      {
        value: rmax
      }
    ];
  }
  numSpaces = Math.ceil(rmax / spacing) - Math.floor(rmin / spacing);
  if (numSpaces > maxSpaces) {
    spacing = niceNum(numSpaces * spacing / maxSpaces / unit) * unit;
  }
  if (!isNullOrUndef(precision)) {
    factor = Math.pow(10, precision);
    spacing = Math.ceil(spacing * factor) / factor;
  }
  if (bounds === "ticks") {
    niceMin = Math.floor(rmin / spacing) * spacing;
    niceMax = Math.ceil(rmax / spacing) * spacing;
  } else {
    niceMin = rmin;
    niceMax = rmax;
  }
  if (minDefined && maxDefined && step && almostWhole((max - min) / step, spacing / 1e3)) {
    numSpaces = Math.round(Math.min((max - min) / spacing, maxTicks));
    spacing = (max - min) / numSpaces;
    niceMin = min;
    niceMax = max;
  } else if (countDefined) {
    niceMin = minDefined ? min : niceMin;
    niceMax = maxDefined ? max : niceMax;
    numSpaces = count - 1;
    spacing = (niceMax - niceMin) / numSpaces;
  } else {
    numSpaces = (niceMax - niceMin) / spacing;
    if (almostEquals(numSpaces, Math.round(numSpaces), spacing / 1e3)) {
      numSpaces = Math.round(numSpaces);
    } else {
      numSpaces = Math.ceil(numSpaces);
    }
  }
  const decimalPlaces = Math.max(_decimalPlaces(spacing), _decimalPlaces(niceMin));
  factor = Math.pow(10, isNullOrUndef(precision) ? decimalPlaces : precision);
  niceMin = Math.round(niceMin * factor) / factor;
  niceMax = Math.round(niceMax * factor) / factor;
  let j = 0;
  if (minDefined) {
    if (includeBounds && niceMin !== min) {
      ticks.push({
        value: min
      });
      if (niceMin < min) {
        j++;
      }
      if (almostEquals(Math.round((niceMin + j * spacing) * factor) / factor, min, relativeLabelSize(min, minSpacing, generationOptions))) {
        j++;
      }
    } else if (niceMin < min) {
      j++;
    }
  }
  for (; j < numSpaces; ++j) {
    const tickValue = Math.round((niceMin + j * spacing) * factor) / factor;
    if (maxDefined && tickValue > max) {
      break;
    }
    ticks.push({
      value: tickValue
    });
  }
  if (maxDefined && includeBounds && niceMax !== max) {
    if (ticks.length && almostEquals(ticks[ticks.length - 1].value, max, relativeLabelSize(max, minSpacing, generationOptions))) {
      ticks[ticks.length - 1].value = max;
    } else {
      ticks.push({
        value: max
      });
    }
  } else if (!maxDefined || niceMax === max) {
    ticks.push({
      value: niceMax
    });
  }
  return ticks;
}
function relativeLabelSize(value, minSpacing, { horizontal, minRotation }) {
  const rad = toRadians(minRotation);
  const ratio = (horizontal ? Math.sin(rad) : Math.cos(rad)) || 1e-3;
  const length = 0.75 * minSpacing * ("" + value).length;
  return Math.min(minSpacing / ratio, length);
}
var LinearScaleBase = class extends Scale {
  constructor(cfg) {
    super(cfg);
    this.start = void 0;
    this.end = void 0;
    this._startValue = void 0;
    this._endValue = void 0;
    this._valueRange = 0;
  }
  parse(raw, index2) {
    if (isNullOrUndef(raw)) {
      return null;
    }
    if ((typeof raw === "number" || raw instanceof Number) && !isFinite(+raw)) {
      return null;
    }
    return +raw;
  }
  handleTickRangeOptions() {
    const { beginAtZero } = this.options;
    const { minDefined, maxDefined } = this.getUserBounds();
    let { min, max } = this;
    const setMin = (v) => min = minDefined ? min : v;
    const setMax = (v) => max = maxDefined ? max : v;
    if (beginAtZero) {
      const minSign = sign(min);
      const maxSign = sign(max);
      if (minSign < 0 && maxSign < 0) {
        setMax(0);
      } else if (minSign > 0 && maxSign > 0) {
        setMin(0);
      }
    }
    if (min === max) {
      let offset = max === 0 ? 1 : Math.abs(max * 0.05);
      setMax(max + offset);
      if (!beginAtZero) {
        setMin(min - offset);
      }
    }
    this.min = min;
    this.max = max;
  }
  getTickLimit() {
    const tickOpts = this.options.ticks;
    let { maxTicksLimit, stepSize } = tickOpts;
    let maxTicks;
    if (stepSize) {
      maxTicks = Math.ceil(this.max / stepSize) - Math.floor(this.min / stepSize) + 1;
      if (maxTicks > 1e3) {
        console.warn(`scales.${this.id}.ticks.stepSize: ${stepSize} would result generating up to ${maxTicks} ticks. Limiting to 1000.`);
        maxTicks = 1e3;
      }
    } else {
      maxTicks = this.computeTickLimit();
      maxTicksLimit = maxTicksLimit || 11;
    }
    if (maxTicksLimit) {
      maxTicks = Math.min(maxTicksLimit, maxTicks);
    }
    return maxTicks;
  }
  computeTickLimit() {
    return Number.POSITIVE_INFINITY;
  }
  buildTicks() {
    const opts = this.options;
    const tickOpts = opts.ticks;
    let maxTicks = this.getTickLimit();
    maxTicks = Math.max(2, maxTicks);
    const numericGeneratorOptions = {
      maxTicks,
      bounds: opts.bounds,
      min: opts.min,
      max: opts.max,
      precision: tickOpts.precision,
      step: tickOpts.stepSize,
      count: tickOpts.count,
      maxDigits: this._maxDigits(),
      horizontal: this.isHorizontal(),
      minRotation: tickOpts.minRotation || 0,
      includeBounds: tickOpts.includeBounds !== false
    };
    const dataRange = this._range || this;
    const ticks = generateTicks$1(numericGeneratorOptions, dataRange);
    if (opts.bounds === "ticks") {
      _setMinAndMaxByKey(ticks, this, "value");
    }
    if (opts.reverse) {
      ticks.reverse();
      this.start = this.max;
      this.end = this.min;
    } else {
      this.start = this.min;
      this.end = this.max;
    }
    return ticks;
  }
  configure() {
    const ticks = this.ticks;
    let start = this.min;
    let end = this.max;
    super.configure();
    if (this.options.offset && ticks.length) {
      const offset = (end - start) / Math.max(ticks.length - 1, 1) / 2;
      start -= offset;
      end += offset;
    }
    this._startValue = start;
    this._endValue = end;
    this._valueRange = end - start;
  }
  getLabelForValue(value) {
    return formatNumber(value, this.chart.options.locale, this.options.ticks.format);
  }
};
var LinearScale = class extends LinearScaleBase {
  determineDataLimits() {
    const { min, max } = this.getMinMax(true);
    this.min = isNumberFinite(min) ? min : 0;
    this.max = isNumberFinite(max) ? max : 1;
    this.handleTickRangeOptions();
  }
  computeTickLimit() {
    const horizontal = this.isHorizontal();
    const length = horizontal ? this.width : this.height;
    const minRotation = toRadians(this.options.ticks.minRotation);
    const ratio = (horizontal ? Math.sin(minRotation) : Math.cos(minRotation)) || 1e-3;
    const tickFont = this._resolveTickFontOptions(0);
    return Math.ceil(length / Math.min(40, tickFont.lineHeight / ratio));
  }
  getPixelForValue(value) {
    return value === null ? NaN : this.getPixelForDecimal((value - this._startValue) / this._valueRange);
  }
  getValueForPixel(pixel) {
    return this._startValue + this.getDecimalForPixel(pixel) * this._valueRange;
  }
};
__publicField(LinearScale, "id", "linear");
__publicField(LinearScale, "defaults", {
  ticks: {
    callback: Ticks.formatters.numeric
  }
});
var log10Floor = (v) => Math.floor(log10(v));
var changeExponent = (v, m) => Math.pow(10, log10Floor(v) + m);
function isMajor(tickVal) {
  const remain = tickVal / Math.pow(10, log10Floor(tickVal));
  return remain === 1;
}
function steps(min, max, rangeExp) {
  const rangeStep = Math.pow(10, rangeExp);
  const start = Math.floor(min / rangeStep);
  const end = Math.ceil(max / rangeStep);
  return end - start;
}
function startExp(min, max) {
  const range = max - min;
  let rangeExp = log10Floor(range);
  while (steps(min, max, rangeExp) > 10) {
    rangeExp++;
  }
  while (steps(min, max, rangeExp) < 10) {
    rangeExp--;
  }
  return Math.min(rangeExp, log10Floor(min));
}
function generateTicks(generationOptions, { min, max }) {
  min = finiteOrDefault(generationOptions.min, min);
  const ticks = [];
  const minExp = log10Floor(min);
  let exp = startExp(min, max);
  let precision = exp < 0 ? Math.pow(10, Math.abs(exp)) : 1;
  const stepSize = Math.pow(10, exp);
  const base = minExp > exp ? Math.pow(10, minExp) : 0;
  const start = Math.round((min - base) * precision) / precision;
  const offset = Math.floor((min - base) / stepSize / 10) * stepSize * 10;
  let significand = Math.floor((start - offset) / Math.pow(10, exp));
  let value = finiteOrDefault(generationOptions.min, Math.round((base + offset + significand * Math.pow(10, exp)) * precision) / precision);
  while (value < max) {
    ticks.push({
      value,
      major: isMajor(value),
      significand
    });
    if (significand >= 10) {
      significand = significand < 15 ? 15 : 20;
    } else {
      significand++;
    }
    if (significand >= 20) {
      exp++;
      significand = 2;
      precision = exp >= 0 ? 1 : precision;
    }
    value = Math.round((base + offset + significand * Math.pow(10, exp)) * precision) / precision;
  }
  const lastTick = finiteOrDefault(generationOptions.max, value);
  ticks.push({
    value: lastTick,
    major: isMajor(lastTick),
    significand
  });
  return ticks;
}
var LogarithmicScale = class extends Scale {
  constructor(cfg) {
    super(cfg);
    this.start = void 0;
    this.end = void 0;
    this._startValue = void 0;
    this._valueRange = 0;
  }
  parse(raw, index2) {
    const value = LinearScaleBase.prototype.parse.apply(this, [
      raw,
      index2
    ]);
    if (value === 0) {
      this._zero = true;
      return void 0;
    }
    return isNumberFinite(value) && value > 0 ? value : null;
  }
  determineDataLimits() {
    const { min, max } = this.getMinMax(true);
    this.min = isNumberFinite(min) ? Math.max(0, min) : null;
    this.max = isNumberFinite(max) ? Math.max(0, max) : null;
    if (this.options.beginAtZero) {
      this._zero = true;
    }
    if (this._zero && this.min !== this._suggestedMin && !isNumberFinite(this._userMin)) {
      this.min = min === changeExponent(this.min, 0) ? changeExponent(this.min, -1) : changeExponent(this.min, 0);
    }
    this.handleTickRangeOptions();
  }
  handleTickRangeOptions() {
    const { minDefined, maxDefined } = this.getUserBounds();
    let min = this.min;
    let max = this.max;
    const setMin = (v) => min = minDefined ? min : v;
    const setMax = (v) => max = maxDefined ? max : v;
    if (min === max) {
      if (min <= 0) {
        setMin(1);
        setMax(10);
      } else {
        setMin(changeExponent(min, -1));
        setMax(changeExponent(max, 1));
      }
    }
    if (min <= 0) {
      setMin(changeExponent(max, -1));
    }
    if (max <= 0) {
      setMax(changeExponent(min, 1));
    }
    this.min = min;
    this.max = max;
  }
  buildTicks() {
    const opts = this.options;
    const generationOptions = {
      min: this._userMin,
      max: this._userMax
    };
    const ticks = generateTicks(generationOptions, this);
    if (opts.bounds === "ticks") {
      _setMinAndMaxByKey(ticks, this, "value");
    }
    if (opts.reverse) {
      ticks.reverse();
      this.start = this.max;
      this.end = this.min;
    } else {
      this.start = this.min;
      this.end = this.max;
    }
    return ticks;
  }
  getLabelForValue(value) {
    return value === void 0 ? "0" : formatNumber(value, this.chart.options.locale, this.options.ticks.format);
  }
  configure() {
    const start = this.min;
    super.configure();
    this._startValue = log10(start);
    this._valueRange = log10(this.max) - log10(start);
  }
  getPixelForValue(value) {
    if (value === void 0 || value === 0) {
      value = this.min;
    }
    if (value === null || isNaN(value)) {
      return NaN;
    }
    return this.getPixelForDecimal(value === this.min ? 0 : (log10(value) - this._startValue) / this._valueRange);
  }
  getValueForPixel(pixel) {
    const decimal = this.getDecimalForPixel(pixel);
    return Math.pow(10, this._startValue + decimal * this._valueRange);
  }
};
__publicField(LogarithmicScale, "id", "logarithmic");
__publicField(LogarithmicScale, "defaults", {
  ticks: {
    callback: Ticks.formatters.logarithmic,
    major: {
      enabled: true
    }
  }
});
function getTickBackdropHeight(opts) {
  const tickOpts = opts.ticks;
  if (tickOpts.display && opts.display) {
    const padding = toPadding(tickOpts.backdropPadding);
    return valueOrDefault(tickOpts.font && tickOpts.font.size, defaults.font.size) + padding.height;
  }
  return 0;
}
function measureLabelSize(ctx, font, label) {
  label = isArray(label) ? label : [
    label
  ];
  return {
    w: _longestText(ctx, font.string, label),
    h: label.length * font.lineHeight
  };
}
function determineLimits(angle, pos, size, min, max) {
  if (angle === min || angle === max) {
    return {
      start: pos - size / 2,
      end: pos + size / 2
    };
  } else if (angle < min || angle > max) {
    return {
      start: pos - size,
      end: pos
    };
  }
  return {
    start: pos,
    end: pos + size
  };
}
function fitWithPointLabels(scale) {
  const orig = {
    l: scale.left + scale._padding.left,
    r: scale.right - scale._padding.right,
    t: scale.top + scale._padding.top,
    b: scale.bottom - scale._padding.bottom
  };
  const limits = Object.assign({}, orig);
  const labelSizes = [];
  const padding = [];
  const valueCount = scale._pointLabels.length;
  const pointLabelOpts = scale.options.pointLabels;
  const additionalAngle = pointLabelOpts.centerPointLabels ? PI / valueCount : 0;
  for (let i = 0; i < valueCount; i++) {
    const opts = pointLabelOpts.setContext(scale.getPointLabelContext(i));
    padding[i] = opts.padding;
    const pointPosition = scale.getPointPosition(i, scale.drawingArea + padding[i], additionalAngle);
    const plFont = toFont(opts.font);
    const textSize = measureLabelSize(scale.ctx, plFont, scale._pointLabels[i]);
    labelSizes[i] = textSize;
    const angleRadians = _normalizeAngle(scale.getIndexAngle(i) + additionalAngle);
    const angle = Math.round(toDegrees(angleRadians));
    const hLimits = determineLimits(angle, pointPosition.x, textSize.w, 0, 180);
    const vLimits = determineLimits(angle, pointPosition.y, textSize.h, 90, 270);
    updateLimits(limits, orig, angleRadians, hLimits, vLimits);
  }
  scale.setCenterPoint(orig.l - limits.l, limits.r - orig.r, orig.t - limits.t, limits.b - orig.b);
  scale._pointLabelItems = buildPointLabelItems(scale, labelSizes, padding);
}
function updateLimits(limits, orig, angle, hLimits, vLimits) {
  const sin = Math.abs(Math.sin(angle));
  const cos = Math.abs(Math.cos(angle));
  let x = 0;
  let y = 0;
  if (hLimits.start < orig.l) {
    x = (orig.l - hLimits.start) / sin;
    limits.l = Math.min(limits.l, orig.l - x);
  } else if (hLimits.end > orig.r) {
    x = (hLimits.end - orig.r) / sin;
    limits.r = Math.max(limits.r, orig.r + x);
  }
  if (vLimits.start < orig.t) {
    y = (orig.t - vLimits.start) / cos;
    limits.t = Math.min(limits.t, orig.t - y);
  } else if (vLimits.end > orig.b) {
    y = (vLimits.end - orig.b) / cos;
    limits.b = Math.max(limits.b, orig.b + y);
  }
}
function createPointLabelItem(scale, index2, itemOpts) {
  const outerDistance = scale.drawingArea;
  const { extra, additionalAngle, padding, size } = itemOpts;
  const pointLabelPosition = scale.getPointPosition(index2, outerDistance + extra + padding, additionalAngle);
  const angle = Math.round(toDegrees(_normalizeAngle(pointLabelPosition.angle + HALF_PI)));
  const y = yForAngle(pointLabelPosition.y, size.h, angle);
  const textAlign = getTextAlignForAngle(angle);
  const left = leftForTextAlign(pointLabelPosition.x, size.w, textAlign);
  return {
    visible: true,
    x: pointLabelPosition.x,
    y,
    textAlign,
    left,
    top: y,
    right: left + size.w,
    bottom: y + size.h
  };
}
function isNotOverlapped(item, area) {
  if (!area) {
    return true;
  }
  const { left, top, right, bottom } = item;
  const apexesInArea = _isPointInArea({
    x: left,
    y: top
  }, area) || _isPointInArea({
    x: left,
    y: bottom
  }, area) || _isPointInArea({
    x: right,
    y: top
  }, area) || _isPointInArea({
    x: right,
    y: bottom
  }, area);
  return !apexesInArea;
}
function buildPointLabelItems(scale, labelSizes, padding) {
  const items = [];
  const valueCount = scale._pointLabels.length;
  const opts = scale.options;
  const { centerPointLabels, display } = opts.pointLabels;
  const itemOpts = {
    extra: getTickBackdropHeight(opts) / 2,
    additionalAngle: centerPointLabels ? PI / valueCount : 0
  };
  let area;
  for (let i = 0; i < valueCount; i++) {
    itemOpts.padding = padding[i];
    itemOpts.size = labelSizes[i];
    const item = createPointLabelItem(scale, i, itemOpts);
    items.push(item);
    if (display === "auto") {
      item.visible = isNotOverlapped(item, area);
      if (item.visible) {
        area = item;
      }
    }
  }
  return items;
}
function getTextAlignForAngle(angle) {
  if (angle === 0 || angle === 180) {
    return "center";
  } else if (angle < 180) {
    return "left";
  }
  return "right";
}
function leftForTextAlign(x, w, align) {
  if (align === "right") {
    x -= w;
  } else if (align === "center") {
    x -= w / 2;
  }
  return x;
}
function yForAngle(y, h, angle) {
  if (angle === 90 || angle === 270) {
    y -= h / 2;
  } else if (angle > 270 || angle < 90) {
    y -= h;
  }
  return y;
}
function drawPointLabelBox(ctx, opts, item) {
  const { left, top, right, bottom } = item;
  const { backdropColor } = opts;
  if (!isNullOrUndef(backdropColor)) {
    const borderRadius = toTRBLCorners(opts.borderRadius);
    const padding = toPadding(opts.backdropPadding);
    ctx.fillStyle = backdropColor;
    const backdropLeft = left - padding.left;
    const backdropTop = top - padding.top;
    const backdropWidth = right - left + padding.width;
    const backdropHeight = bottom - top + padding.height;
    if (Object.values(borderRadius).some((v) => v !== 0)) {
      ctx.beginPath();
      addRoundedRectPath(ctx, {
        x: backdropLeft,
        y: backdropTop,
        w: backdropWidth,
        h: backdropHeight,
        radius: borderRadius
      });
      ctx.fill();
    } else {
      ctx.fillRect(backdropLeft, backdropTop, backdropWidth, backdropHeight);
    }
  }
}
function drawPointLabels(scale, labelCount) {
  const { ctx, options: { pointLabels } } = scale;
  for (let i = labelCount - 1; i >= 0; i--) {
    const item = scale._pointLabelItems[i];
    if (!item.visible) {
      continue;
    }
    const optsAtIndex = pointLabels.setContext(scale.getPointLabelContext(i));
    drawPointLabelBox(ctx, optsAtIndex, item);
    const plFont = toFont(optsAtIndex.font);
    const { x, y, textAlign } = item;
    renderText(ctx, scale._pointLabels[i], x, y + plFont.lineHeight / 2, plFont, {
      color: optsAtIndex.color,
      textAlign,
      textBaseline: "middle"
    });
  }
}
function pathRadiusLine(scale, radius, circular, labelCount) {
  const { ctx } = scale;
  if (circular) {
    ctx.arc(scale.xCenter, scale.yCenter, radius, 0, TAU);
  } else {
    let pointPosition = scale.getPointPosition(0, radius);
    ctx.moveTo(pointPosition.x, pointPosition.y);
    for (let i = 1; i < labelCount; i++) {
      pointPosition = scale.getPointPosition(i, radius);
      ctx.lineTo(pointPosition.x, pointPosition.y);
    }
  }
}
function drawRadiusLine(scale, gridLineOpts, radius, labelCount, borderOpts) {
  const ctx = scale.ctx;
  const circular = gridLineOpts.circular;
  const { color: color2, lineWidth } = gridLineOpts;
  if (!circular && !labelCount || !color2 || !lineWidth || radius < 0) {
    return;
  }
  ctx.save();
  ctx.strokeStyle = color2;
  ctx.lineWidth = lineWidth;
  ctx.setLineDash(borderOpts.dash);
  ctx.lineDashOffset = borderOpts.dashOffset;
  ctx.beginPath();
  pathRadiusLine(scale, radius, circular, labelCount);
  ctx.closePath();
  ctx.stroke();
  ctx.restore();
}
function createPointLabelContext(parent, index2, label) {
  return createContext(parent, {
    label,
    index: index2,
    type: "pointLabel"
  });
}
var RadialLinearScale = class extends LinearScaleBase {
  constructor(cfg) {
    super(cfg);
    this.xCenter = void 0;
    this.yCenter = void 0;
    this.drawingArea = void 0;
    this._pointLabels = [];
    this._pointLabelItems = [];
  }
  setDimensions() {
    const padding = this._padding = toPadding(getTickBackdropHeight(this.options) / 2);
    const w = this.width = this.maxWidth - padding.width;
    const h = this.height = this.maxHeight - padding.height;
    this.xCenter = Math.floor(this.left + w / 2 + padding.left);
    this.yCenter = Math.floor(this.top + h / 2 + padding.top);
    this.drawingArea = Math.floor(Math.min(w, h) / 2);
  }
  determineDataLimits() {
    const { min, max } = this.getMinMax(false);
    this.min = isNumberFinite(min) && !isNaN(min) ? min : 0;
    this.max = isNumberFinite(max) && !isNaN(max) ? max : 0;
    this.handleTickRangeOptions();
  }
  computeTickLimit() {
    return Math.ceil(this.drawingArea / getTickBackdropHeight(this.options));
  }
  generateTickLabels(ticks) {
    LinearScaleBase.prototype.generateTickLabels.call(this, ticks);
    this._pointLabels = this.getLabels().map((value, index2) => {
      const label = callback(this.options.pointLabels.callback, [
        value,
        index2
      ], this);
      return label || label === 0 ? label : "";
    }).filter((v, i) => this.chart.getDataVisibility(i));
  }
  fit() {
    const opts = this.options;
    if (opts.display && opts.pointLabels.display) {
      fitWithPointLabels(this);
    } else {
      this.setCenterPoint(0, 0, 0, 0);
    }
  }
  setCenterPoint(leftMovement, rightMovement, topMovement, bottomMovement) {
    this.xCenter += Math.floor((leftMovement - rightMovement) / 2);
    this.yCenter += Math.floor((topMovement - bottomMovement) / 2);
    this.drawingArea -= Math.min(this.drawingArea / 2, Math.max(leftMovement, rightMovement, topMovement, bottomMovement));
  }
  getIndexAngle(index2) {
    const angleMultiplier = TAU / (this._pointLabels.length || 1);
    const startAngle = this.options.startAngle || 0;
    return _normalizeAngle(index2 * angleMultiplier + toRadians(startAngle));
  }
  getDistanceFromCenterForValue(value) {
    if (isNullOrUndef(value)) {
      return NaN;
    }
    const scalingFactor = this.drawingArea / (this.max - this.min);
    if (this.options.reverse) {
      return (this.max - value) * scalingFactor;
    }
    return (value - this.min) * scalingFactor;
  }
  getValueForDistanceFromCenter(distance) {
    if (isNullOrUndef(distance)) {
      return NaN;
    }
    const scaledDistance = distance / (this.drawingArea / (this.max - this.min));
    return this.options.reverse ? this.max - scaledDistance : this.min + scaledDistance;
  }
  getPointLabelContext(index2) {
    const pointLabels = this._pointLabels || [];
    if (index2 >= 0 && index2 < pointLabels.length) {
      const pointLabel = pointLabels[index2];
      return createPointLabelContext(this.getContext(), index2, pointLabel);
    }
  }
  getPointPosition(index2, distanceFromCenter, additionalAngle = 0) {
    const angle = this.getIndexAngle(index2) - HALF_PI + additionalAngle;
    return {
      x: Math.cos(angle) * distanceFromCenter + this.xCenter,
      y: Math.sin(angle) * distanceFromCenter + this.yCenter,
      angle
    };
  }
  getPointPositionForValue(index2, value) {
    return this.getPointPosition(index2, this.getDistanceFromCenterForValue(value));
  }
  getBasePosition(index2) {
    return this.getPointPositionForValue(index2 || 0, this.getBaseValue());
  }
  getPointLabelPosition(index2) {
    const { left, top, right, bottom } = this._pointLabelItems[index2];
    return {
      left,
      top,
      right,
      bottom
    };
  }
  drawBackground() {
    const { backgroundColor, grid: { circular } } = this.options;
    if (backgroundColor) {
      const ctx = this.ctx;
      ctx.save();
      ctx.beginPath();
      pathRadiusLine(this, this.getDistanceFromCenterForValue(this._endValue), circular, this._pointLabels.length);
      ctx.closePath();
      ctx.fillStyle = backgroundColor;
      ctx.fill();
      ctx.restore();
    }
  }
  drawGrid() {
    const ctx = this.ctx;
    const opts = this.options;
    const { angleLines, grid, border } = opts;
    const labelCount = this._pointLabels.length;
    let i, offset, position;
    if (opts.pointLabels.display) {
      drawPointLabels(this, labelCount);
    }
    if (grid.display) {
      this.ticks.forEach((tick, index2) => {
        if (index2 !== 0 || index2 === 0 && this.min < 0) {
          offset = this.getDistanceFromCenterForValue(tick.value);
          const context = this.getContext(index2);
          const optsAtIndex = grid.setContext(context);
          const optsAtIndexBorder = border.setContext(context);
          drawRadiusLine(this, optsAtIndex, offset, labelCount, optsAtIndexBorder);
        }
      });
    }
    if (angleLines.display) {
      ctx.save();
      for (i = labelCount - 1; i >= 0; i--) {
        const optsAtIndex = angleLines.setContext(this.getPointLabelContext(i));
        const { color: color2, lineWidth } = optsAtIndex;
        if (!lineWidth || !color2) {
          continue;
        }
        ctx.lineWidth = lineWidth;
        ctx.strokeStyle = color2;
        ctx.setLineDash(optsAtIndex.borderDash);
        ctx.lineDashOffset = optsAtIndex.borderDashOffset;
        offset = this.getDistanceFromCenterForValue(opts.reverse ? this.min : this.max);
        position = this.getPointPosition(i, offset);
        ctx.beginPath();
        ctx.moveTo(this.xCenter, this.yCenter);
        ctx.lineTo(position.x, position.y);
        ctx.stroke();
      }
      ctx.restore();
    }
  }
  drawBorder() {
  }
  drawLabels() {
    const ctx = this.ctx;
    const opts = this.options;
    const tickOpts = opts.ticks;
    if (!tickOpts.display) {
      return;
    }
    const startAngle = this.getIndexAngle(0);
    let offset, width;
    ctx.save();
    ctx.translate(this.xCenter, this.yCenter);
    ctx.rotate(startAngle);
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    this.ticks.forEach((tick, index2) => {
      if (index2 === 0 && this.min >= 0 && !opts.reverse) {
        return;
      }
      const optsAtIndex = tickOpts.setContext(this.getContext(index2));
      const tickFont = toFont(optsAtIndex.font);
      offset = this.getDistanceFromCenterForValue(this.ticks[index2].value);
      if (optsAtIndex.showLabelBackdrop) {
        ctx.font = tickFont.string;
        width = ctx.measureText(tick.label).width;
        ctx.fillStyle = optsAtIndex.backdropColor;
        const padding = toPadding(optsAtIndex.backdropPadding);
        ctx.fillRect(-width / 2 - padding.left, -offset - tickFont.size / 2 - padding.top, width + padding.width, tickFont.size + padding.height);
      }
      renderText(ctx, tick.label, 0, -offset, tickFont, {
        color: optsAtIndex.color,
        strokeColor: optsAtIndex.textStrokeColor,
        strokeWidth: optsAtIndex.textStrokeWidth
      });
    });
    ctx.restore();
  }
  drawTitle() {
  }
};
__publicField(RadialLinearScale, "id", "radialLinear");
__publicField(RadialLinearScale, "defaults", {
  display: true,
  animate: true,
  position: "chartArea",
  angleLines: {
    display: true,
    lineWidth: 1,
    borderDash: [],
    borderDashOffset: 0
  },
  grid: {
    circular: false
  },
  startAngle: 0,
  ticks: {
    showLabelBackdrop: true,
    callback: Ticks.formatters.numeric
  },
  pointLabels: {
    backdropColor: void 0,
    backdropPadding: 2,
    display: true,
    font: {
      size: 10
    },
    callback(label) {
      return label;
    },
    padding: 5,
    centerPointLabels: false
  }
});
__publicField(RadialLinearScale, "defaultRoutes", {
  "angleLines.color": "borderColor",
  "pointLabels.color": "color",
  "ticks.color": "color"
});
__publicField(RadialLinearScale, "descriptors", {
  angleLines: {
    _fallback: "grid"
  }
});
var INTERVALS = {
  millisecond: {
    common: true,
    size: 1,
    steps: 1e3
  },
  second: {
    common: true,
    size: 1e3,
    steps: 60
  },
  minute: {
    common: true,
    size: 6e4,
    steps: 60
  },
  hour: {
    common: true,
    size: 36e5,
    steps: 24
  },
  day: {
    common: true,
    size: 864e5,
    steps: 30
  },
  week: {
    common: false,
    size: 6048e5,
    steps: 4
  },
  month: {
    common: true,
    size: 2628e6,
    steps: 12
  },
  quarter: {
    common: false,
    size: 7884e6,
    steps: 4
  },
  year: {
    common: true,
    size: 3154e7
  }
};
var UNITS = /* @__PURE__ */ Object.keys(INTERVALS);
function sorter(a, b) {
  return a - b;
}
function parse(scale, input) {
  if (isNullOrUndef(input)) {
    return null;
  }
  const adapter = scale._adapter;
  const { parser, round: round2, isoWeekday } = scale._parseOpts;
  let value = input;
  if (typeof parser === "function") {
    value = parser(value);
  }
  if (!isNumberFinite(value)) {
    value = typeof parser === "string" ? adapter.parse(value, parser) : adapter.parse(value);
  }
  if (value === null) {
    return null;
  }
  if (round2) {
    value = round2 === "week" && (isNumber(isoWeekday) || isoWeekday === true) ? adapter.startOf(value, "isoWeek", isoWeekday) : adapter.startOf(value, round2);
  }
  return +value;
}
function determineUnitForAutoTicks(minUnit, min, max, capacity) {
  const ilen = UNITS.length;
  for (let i = UNITS.indexOf(minUnit); i < ilen - 1; ++i) {
    const interval = INTERVALS[UNITS[i]];
    const factor = interval.steps ? interval.steps : Number.MAX_SAFE_INTEGER;
    if (interval.common && Math.ceil((max - min) / (factor * interval.size)) <= capacity) {
      return UNITS[i];
    }
  }
  return UNITS[ilen - 1];
}
function determineUnitForFormatting(scale, numTicks, minUnit, min, max) {
  for (let i = UNITS.length - 1; i >= UNITS.indexOf(minUnit); i--) {
    const unit = UNITS[i];
    if (INTERVALS[unit].common && scale._adapter.diff(max, min, unit) >= numTicks - 1) {
      return unit;
    }
  }
  return UNITS[minUnit ? UNITS.indexOf(minUnit) : 0];
}
function determineMajorUnit(unit) {
  for (let i = UNITS.indexOf(unit) + 1, ilen = UNITS.length; i < ilen; ++i) {
    if (INTERVALS[UNITS[i]].common) {
      return UNITS[i];
    }
  }
}
function addTick(ticks, time, timestamps) {
  if (!timestamps) {
    ticks[time] = true;
  } else if (timestamps.length) {
    const { lo, hi } = _lookup(timestamps, time);
    const timestamp = timestamps[lo] >= time ? timestamps[lo] : timestamps[hi];
    ticks[timestamp] = true;
  }
}
function setMajorTicks(scale, ticks, map3, majorUnit) {
  const adapter = scale._adapter;
  const first = +adapter.startOf(ticks[0].value, majorUnit);
  const last = ticks[ticks.length - 1].value;
  let major, index2;
  for (major = first; major <= last; major = +adapter.add(major, 1, majorUnit)) {
    index2 = map3[major];
    if (index2 >= 0) {
      ticks[index2].major = true;
    }
  }
  return ticks;
}
function ticksFromTimestamps(scale, values, majorUnit) {
  const ticks = [];
  const map3 = {};
  const ilen = values.length;
  let i, value;
  for (i = 0; i < ilen; ++i) {
    value = values[i];
    map3[value] = i;
    ticks.push({
      value,
      major: false
    });
  }
  return ilen === 0 || !majorUnit ? ticks : setMajorTicks(scale, ticks, map3, majorUnit);
}
var TimeScale = class extends Scale {
  constructor(props) {
    super(props);
    this._cache = {
      data: [],
      labels: [],
      all: []
    };
    this._unit = "day";
    this._majorUnit = void 0;
    this._offsets = {};
    this._normalized = false;
    this._parseOpts = void 0;
  }
  init(scaleOpts, opts = {}) {
    const time = scaleOpts.time || (scaleOpts.time = {});
    const adapter = this._adapter = new adapters._date(scaleOpts.adapters.date);
    adapter.init(opts);
    mergeIf(time.displayFormats, adapter.formats());
    this._parseOpts = {
      parser: time.parser,
      round: time.round,
      isoWeekday: time.isoWeekday
    };
    super.init(scaleOpts);
    this._normalized = opts.normalized;
  }
  parse(raw, index2) {
    if (raw === void 0) {
      return null;
    }
    return parse(this, raw);
  }
  beforeLayout() {
    super.beforeLayout();
    this._cache = {
      data: [],
      labels: [],
      all: []
    };
  }
  determineDataLimits() {
    const options = this.options;
    const adapter = this._adapter;
    const unit = options.time.unit || "day";
    let { min, max, minDefined, maxDefined } = this.getUserBounds();
    function _applyBounds(bounds) {
      if (!minDefined && !isNaN(bounds.min)) {
        min = Math.min(min, bounds.min);
      }
      if (!maxDefined && !isNaN(bounds.max)) {
        max = Math.max(max, bounds.max);
      }
    }
    if (!minDefined || !maxDefined) {
      _applyBounds(this._getLabelBounds());
      if (options.bounds !== "ticks" || options.ticks.source !== "labels") {
        _applyBounds(this.getMinMax(false));
      }
    }
    min = isNumberFinite(min) && !isNaN(min) ? min : +adapter.startOf(Date.now(), unit);
    max = isNumberFinite(max) && !isNaN(max) ? max : +adapter.endOf(Date.now(), unit) + 1;
    this.min = Math.min(min, max - 1);
    this.max = Math.max(min + 1, max);
  }
  _getLabelBounds() {
    const arr = this.getLabelTimestamps();
    let min = Number.POSITIVE_INFINITY;
    let max = Number.NEGATIVE_INFINITY;
    if (arr.length) {
      min = arr[0];
      max = arr[arr.length - 1];
    }
    return {
      min,
      max
    };
  }
  buildTicks() {
    const options = this.options;
    const timeOpts = options.time;
    const tickOpts = options.ticks;
    const timestamps = tickOpts.source === "labels" ? this.getLabelTimestamps() : this._generate();
    if (options.bounds === "ticks" && timestamps.length) {
      this.min = this._userMin || timestamps[0];
      this.max = this._userMax || timestamps[timestamps.length - 1];
    }
    const min = this.min;
    const max = this.max;
    const ticks = _filterBetween(timestamps, min, max);
    this._unit = timeOpts.unit || (tickOpts.autoSkip ? determineUnitForAutoTicks(timeOpts.minUnit, this.min, this.max, this._getLabelCapacity(min)) : determineUnitForFormatting(this, ticks.length, timeOpts.minUnit, this.min, this.max));
    this._majorUnit = !tickOpts.major.enabled || this._unit === "year" ? void 0 : determineMajorUnit(this._unit);
    this.initOffsets(timestamps);
    if (options.reverse) {
      ticks.reverse();
    }
    return ticksFromTimestamps(this, ticks, this._majorUnit);
  }
  afterAutoSkip() {
    if (this.options.offsetAfterAutoskip) {
      this.initOffsets(this.ticks.map((tick) => +tick.value));
    }
  }
  initOffsets(timestamps = []) {
    let start = 0;
    let end = 0;
    let first, last;
    if (this.options.offset && timestamps.length) {
      first = this.getDecimalForValue(timestamps[0]);
      if (timestamps.length === 1) {
        start = 1 - first;
      } else {
        start = (this.getDecimalForValue(timestamps[1]) - first) / 2;
      }
      last = this.getDecimalForValue(timestamps[timestamps.length - 1]);
      if (timestamps.length === 1) {
        end = last;
      } else {
        end = (last - this.getDecimalForValue(timestamps[timestamps.length - 2])) / 2;
      }
    }
    const limit = timestamps.length < 3 ? 0.5 : 0.25;
    start = _limitValue(start, 0, limit);
    end = _limitValue(end, 0, limit);
    this._offsets = {
      start,
      end,
      factor: 1 / (start + 1 + end)
    };
  }
  _generate() {
    const adapter = this._adapter;
    const min = this.min;
    const max = this.max;
    const options = this.options;
    const timeOpts = options.time;
    const minor = timeOpts.unit || determineUnitForAutoTicks(timeOpts.minUnit, min, max, this._getLabelCapacity(min));
    const stepSize = valueOrDefault(options.ticks.stepSize, 1);
    const weekday = minor === "week" ? timeOpts.isoWeekday : false;
    const hasWeekday = isNumber(weekday) || weekday === true;
    const ticks = {};
    let first = min;
    let time, count;
    if (hasWeekday) {
      first = +adapter.startOf(first, "isoWeek", weekday);
    }
    first = +adapter.startOf(first, hasWeekday ? "day" : minor);
    if (adapter.diff(max, min, minor) > 1e5 * stepSize) {
      throw new Error(min + " and " + max + " are too far apart with stepSize of " + stepSize + " " + minor);
    }
    const timestamps = options.ticks.source === "data" && this.getDataTimestamps();
    for (time = first, count = 0; time < max; time = +adapter.add(time, stepSize, minor), count++) {
      addTick(ticks, time, timestamps);
    }
    if (time === max || options.bounds === "ticks" || count === 1) {
      addTick(ticks, time, timestamps);
    }
    return Object.keys(ticks).sort(sorter).map((x) => +x);
  }
  getLabelForValue(value) {
    const adapter = this._adapter;
    const timeOpts = this.options.time;
    if (timeOpts.tooltipFormat) {
      return adapter.format(value, timeOpts.tooltipFormat);
    }
    return adapter.format(value, timeOpts.displayFormats.datetime);
  }
  format(value, format) {
    const options = this.options;
    const formats = options.time.displayFormats;
    const unit = this._unit;
    const fmt = format || formats[unit];
    return this._adapter.format(value, fmt);
  }
  _tickFormatFunction(time, index2, ticks, format) {
    const options = this.options;
    const formatter = options.ticks.callback;
    if (formatter) {
      return callback(formatter, [
        time,
        index2,
        ticks
      ], this);
    }
    const formats = options.time.displayFormats;
    const unit = this._unit;
    const majorUnit = this._majorUnit;
    const minorFormat = unit && formats[unit];
    const majorFormat = majorUnit && formats[majorUnit];
    const tick = ticks[index2];
    const major = majorUnit && majorFormat && tick && tick.major;
    return this._adapter.format(time, format || (major ? majorFormat : minorFormat));
  }
  generateTickLabels(ticks) {
    let i, ilen, tick;
    for (i = 0, ilen = ticks.length; i < ilen; ++i) {
      tick = ticks[i];
      tick.label = this._tickFormatFunction(tick.value, i, ticks);
    }
  }
  getDecimalForValue(value) {
    return value === null ? NaN : (value - this.min) / (this.max - this.min);
  }
  getPixelForValue(value) {
    const offsets = this._offsets;
    const pos = this.getDecimalForValue(value);
    return this.getPixelForDecimal((offsets.start + pos) * offsets.factor);
  }
  getValueForPixel(pixel) {
    const offsets = this._offsets;
    const pos = this.getDecimalForPixel(pixel) / offsets.factor - offsets.end;
    return this.min + pos * (this.max - this.min);
  }
  _getLabelSize(label) {
    const ticksOpts = this.options.ticks;
    const tickLabelWidth = this.ctx.measureText(label).width;
    const angle = toRadians(this.isHorizontal() ? ticksOpts.maxRotation : ticksOpts.minRotation);
    const cosRotation = Math.cos(angle);
    const sinRotation = Math.sin(angle);
    const tickFontSize = this._resolveTickFontOptions(0).size;
    return {
      w: tickLabelWidth * cosRotation + tickFontSize * sinRotation,
      h: tickLabelWidth * sinRotation + tickFontSize * cosRotation
    };
  }
  _getLabelCapacity(exampleTime) {
    const timeOpts = this.options.time;
    const displayFormats = timeOpts.displayFormats;
    const format = displayFormats[timeOpts.unit] || displayFormats.millisecond;
    const exampleLabel = this._tickFormatFunction(exampleTime, 0, ticksFromTimestamps(this, [
      exampleTime
    ], this._majorUnit), format);
    const size = this._getLabelSize(exampleLabel);
    const capacity = Math.floor(this.isHorizontal() ? this.width / size.w : this.height / size.h) - 1;
    return capacity > 0 ? capacity : 1;
  }
  getDataTimestamps() {
    let timestamps = this._cache.data || [];
    let i, ilen;
    if (timestamps.length) {
      return timestamps;
    }
    const metas = this.getMatchingVisibleMetas();
    if (this._normalized && metas.length) {
      return this._cache.data = metas[0].controller.getAllParsedValues(this);
    }
    for (i = 0, ilen = metas.length; i < ilen; ++i) {
      timestamps = timestamps.concat(metas[i].controller.getAllParsedValues(this));
    }
    return this._cache.data = this.normalize(timestamps);
  }
  getLabelTimestamps() {
    const timestamps = this._cache.labels || [];
    let i, ilen;
    if (timestamps.length) {
      return timestamps;
    }
    const labels = this.getLabels();
    for (i = 0, ilen = labels.length; i < ilen; ++i) {
      timestamps.push(parse(this, labels[i]));
    }
    return this._cache.labels = this._normalized ? timestamps : this.normalize(timestamps);
  }
  normalize(values) {
    return _arrayUnique(values.sort(sorter));
  }
};
__publicField(TimeScale, "id", "time");
__publicField(TimeScale, "defaults", {
  bounds: "data",
  adapters: {},
  time: {
    parser: false,
    unit: false,
    round: false,
    isoWeekday: false,
    minUnit: "millisecond",
    displayFormats: {}
  },
  ticks: {
    source: "auto",
    callback: false,
    major: {
      enabled: false
    }
  }
});
function interpolate2(table, val, reverse) {
  let lo = 0;
  let hi = table.length - 1;
  let prevSource, nextSource, prevTarget, nextTarget;
  if (reverse) {
    if (val >= table[lo].pos && val <= table[hi].pos) {
      ({ lo, hi } = _lookupByKey(table, "pos", val));
    }
    ({ pos: prevSource, time: prevTarget } = table[lo]);
    ({ pos: nextSource, time: nextTarget } = table[hi]);
  } else {
    if (val >= table[lo].time && val <= table[hi].time) {
      ({ lo, hi } = _lookupByKey(table, "time", val));
    }
    ({ time: prevSource, pos: prevTarget } = table[lo]);
    ({ time: nextSource, pos: nextTarget } = table[hi]);
  }
  const span = nextSource - prevSource;
  return span ? prevTarget + (nextTarget - prevTarget) * (val - prevSource) / span : prevTarget;
}
var TimeSeriesScale = class extends TimeScale {
  constructor(props) {
    super(props);
    this._table = [];
    this._minPos = void 0;
    this._tableRange = void 0;
  }
  initOffsets() {
    const timestamps = this._getTimestampsForTable();
    const table = this._table = this.buildLookupTable(timestamps);
    this._minPos = interpolate2(table, this.min);
    this._tableRange = interpolate2(table, this.max) - this._minPos;
    super.initOffsets(timestamps);
  }
  buildLookupTable(timestamps) {
    const { min, max } = this;
    const items = [];
    const table = [];
    let i, ilen, prev, curr, next;
    for (i = 0, ilen = timestamps.length; i < ilen; ++i) {
      curr = timestamps[i];
      if (curr >= min && curr <= max) {
        items.push(curr);
      }
    }
    if (items.length < 2) {
      return [
        {
          time: min,
          pos: 0
        },
        {
          time: max,
          pos: 1
        }
      ];
    }
    for (i = 0, ilen = items.length; i < ilen; ++i) {
      next = items[i + 1];
      prev = items[i - 1];
      curr = items[i];
      if (Math.round((next + prev) / 2) !== curr) {
        table.push({
          time: curr,
          pos: i / (ilen - 1)
        });
      }
    }
    return table;
  }
  _generate() {
    const min = this.min;
    const max = this.max;
    let timestamps = super.getDataTimestamps();
    if (!timestamps.includes(min) || !timestamps.length) {
      timestamps.splice(0, 0, min);
    }
    if (!timestamps.includes(max) || timestamps.length === 1) {
      timestamps.push(max);
    }
    return timestamps.sort((a, b) => a - b);
  }
  _getTimestampsForTable() {
    let timestamps = this._cache.all || [];
    if (timestamps.length) {
      return timestamps;
    }
    const data = this.getDataTimestamps();
    const label = this.getLabelTimestamps();
    if (data.length && label.length) {
      timestamps = this.normalize(data.concat(label));
    } else {
      timestamps = data.length ? data : label;
    }
    timestamps = this._cache.all = timestamps;
    return timestamps;
  }
  getDecimalForValue(value) {
    return (interpolate2(this._table, value) - this._minPos) / this._tableRange;
  }
  getValueForPixel(pixel) {
    const offsets = this._offsets;
    const decimal = this.getDecimalForPixel(pixel) / offsets.factor - offsets.end;
    return interpolate2(this._table, decimal * this._tableRange + this._minPos, true);
  }
};
__publicField(TimeSeriesScale, "id", "timeseries");
__publicField(TimeSeriesScale, "defaults", TimeScale.defaults);
var scales = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  CategoryScale,
  LinearScale,
  LogarithmicScale,
  RadialLinearScale,
  TimeScale,
  TimeSeriesScale
});
var registerables = [
  controllers,
  elements,
  plugins,
  scales
];

// node_modules/chartjs-plugin-zoom/dist/chartjs-plugin-zoom.esm.js
var import_hammerjs = __toESM(require_hammer());
var getModifierKey = (opts) => opts && opts.enabled && opts.modifierKey;
var keyPressed = (key, event) => key && event[key + "Key"];
var keyNotPressed = (key, event) => key && !event[key + "Key"];
function directionEnabled(mode, dir, chart) {
  if (mode === void 0) {
    return true;
  } else if (typeof mode === "string") {
    return mode.indexOf(dir) !== -1;
  } else if (typeof mode === "function") {
    return mode({ chart }).indexOf(dir) !== -1;
  }
  return false;
}
function directionsEnabled(mode, chart) {
  if (typeof mode === "function") {
    mode = mode({ chart });
  }
  if (typeof mode === "string") {
    return { x: mode.indexOf("x") !== -1, y: mode.indexOf("y") !== -1 };
  }
  return { x: false, y: false };
}
function debounce2(fn, delay) {
  let timeout;
  return function() {
    clearTimeout(timeout);
    timeout = setTimeout(fn, delay);
    return delay;
  };
}
function getScaleUnderPoint({ x, y }, chart) {
  const scales2 = chart.scales;
  const scaleIds = Object.keys(scales2);
  for (let i = 0; i < scaleIds.length; i++) {
    const scale = scales2[scaleIds[i]];
    if (y >= scale.top && y <= scale.bottom && x >= scale.left && x <= scale.right) {
      return scale;
    }
  }
  return null;
}
function getEnabledScalesByPoint(options, point, chart) {
  const { mode = "xy", scaleMode, overScaleMode } = options || {};
  const scale = getScaleUnderPoint(point, chart);
  const enabled = directionsEnabled(mode, chart);
  const scaleEnabled = directionsEnabled(scaleMode, chart);
  if (overScaleMode) {
    const overScaleEnabled = directionsEnabled(overScaleMode, chart);
    for (const axis of ["x", "y"]) {
      if (overScaleEnabled[axis]) {
        scaleEnabled[axis] = enabled[axis];
        enabled[axis] = false;
      }
    }
  }
  if (scale && scaleEnabled[scale.axis]) {
    return [scale];
  }
  const enabledScales = [];
  each(chart.scales, function(scaleItem) {
    if (enabled[scaleItem.axis]) {
      enabledScales.push(scaleItem);
    }
  });
  return enabledScales;
}
var chartStates = /* @__PURE__ */ new WeakMap();
function getState(chart) {
  let state = chartStates.get(chart);
  if (!state) {
    state = {
      originalScaleLimits: {},
      updatedScaleLimits: {},
      handlers: {},
      panDelta: {}
    };
    chartStates.set(chart, state);
  }
  return state;
}
function removeState(chart) {
  chartStates.delete(chart);
}
function zoomDelta(scale, zoom2, center) {
  const range = scale.max - scale.min;
  const newRange = range * (zoom2 - 1);
  const centerPoint = scale.isHorizontal() ? center.x : center.y;
  const minPercent = Math.max(0, Math.min(
    1,
    (scale.getValueForPixel(centerPoint) - scale.min) / range || 0
  ));
  const maxPercent = 1 - minPercent;
  return {
    min: newRange * minPercent,
    max: newRange * maxPercent
  };
}
function getLimit(state, scale, scaleLimits, prop, fallback) {
  let limit = scaleLimits[prop];
  if (limit === "original") {
    const original = state.originalScaleLimits[scale.id][prop];
    limit = valueOrDefault(original.options, original.scale);
  }
  return valueOrDefault(limit, fallback);
}
function getRange(scale, pixel0, pixel1) {
  const v0 = scale.getValueForPixel(pixel0);
  const v1 = scale.getValueForPixel(pixel1);
  return {
    min: Math.min(v0, v1),
    max: Math.max(v0, v1)
  };
}
function updateRange(scale, { min, max }, limits, zoom2 = false) {
  const state = getState(scale.chart);
  const { id, axis, options: scaleOpts } = scale;
  const scaleLimits = limits && (limits[id] || limits[axis]) || {};
  const { minRange = 0 } = scaleLimits;
  const minLimit = getLimit(state, scale, scaleLimits, "min", -Infinity);
  const maxLimit = getLimit(state, scale, scaleLimits, "max", Infinity);
  const range = zoom2 ? Math.max(max - min, minRange) : scale.max - scale.min;
  const offset = (range - max + min) / 2;
  min -= offset;
  max += offset;
  if (min < minLimit) {
    min = minLimit;
    max = Math.min(minLimit + range, maxLimit);
  } else if (max > maxLimit) {
    max = maxLimit;
    min = Math.max(maxLimit - range, minLimit);
  }
  scaleOpts.min = min;
  scaleOpts.max = max;
  state.updatedScaleLimits[scale.id] = { min, max };
  return scale.parse(min) !== scale.min || scale.parse(max) !== scale.max;
}
function zoomNumericalScale(scale, zoom2, center, limits) {
  const delta = zoomDelta(scale, zoom2, center);
  const newRange = { min: scale.min + delta.min, max: scale.max - delta.max };
  return updateRange(scale, newRange, limits, true);
}
function zoomRectNumericalScale(scale, from2, to2, limits) {
  updateRange(scale, getRange(scale, from2, to2), limits, true);
}
var integerChange = (v) => v === 0 || isNaN(v) ? 0 : v < 0 ? Math.min(Math.round(v), -1) : Math.max(Math.round(v), 1);
function existCategoryFromMaxZoom(scale) {
  const labels = scale.getLabels();
  const maxIndex = labels.length - 1;
  if (scale.min > 0) {
    scale.min -= 1;
  }
  if (scale.max < maxIndex) {
    scale.max += 1;
  }
}
function zoomCategoryScale(scale, zoom2, center, limits) {
  const delta = zoomDelta(scale, zoom2, center);
  if (scale.min === scale.max && zoom2 < 1) {
    existCategoryFromMaxZoom(scale);
  }
  const newRange = { min: scale.min + integerChange(delta.min), max: scale.max - integerChange(delta.max) };
  return updateRange(scale, newRange, limits, true);
}
function scaleLength(scale) {
  return scale.isHorizontal() ? scale.width : scale.height;
}
function panCategoryScale(scale, delta, limits) {
  const labels = scale.getLabels();
  const lastLabelIndex = labels.length - 1;
  let { min, max } = scale;
  const range = Math.max(max - min, 1);
  const stepDelta = Math.round(scaleLength(scale) / Math.max(range, 10));
  const stepSize = Math.round(Math.abs(delta / stepDelta));
  let applied;
  if (delta < -stepDelta) {
    max = Math.min(max + stepSize, lastLabelIndex);
    min = range === 1 ? max : max - range;
    applied = max === lastLabelIndex;
  } else if (delta > stepDelta) {
    min = Math.max(0, min - stepSize);
    max = range === 1 ? min : min + range;
    applied = min === 0;
  }
  return updateRange(scale, { min, max }, limits) || applied;
}
var OFFSETS = {
  second: 500,
  // 500 ms
  minute: 30 * 1e3,
  // 30 s
  hour: 30 * 60 * 1e3,
  // 30 m
  day: 12 * 60 * 60 * 1e3,
  // 12 h
  week: 3.5 * 24 * 60 * 60 * 1e3,
  // 3.5 d
  month: 15 * 24 * 60 * 60 * 1e3,
  // 15 d
  quarter: 60 * 24 * 60 * 60 * 1e3,
  // 60 d
  year: 182 * 24 * 60 * 60 * 1e3
  // 182 d
};
function panNumericalScale(scale, delta, limits, canZoom = false) {
  const { min: prevStart, max: prevEnd, options } = scale;
  const round2 = options.time && options.time.round;
  const offset = OFFSETS[round2] || 0;
  const newMin = scale.getValueForPixel(scale.getPixelForValue(prevStart + offset) - delta);
  const newMax = scale.getValueForPixel(scale.getPixelForValue(prevEnd + offset) - delta);
  const { min: minLimit = -Infinity, max: maxLimit = Infinity } = canZoom && limits && limits[scale.axis] || {};
  if (isNaN(newMin) || isNaN(newMax) || newMin < minLimit || newMax > maxLimit) {
    return true;
  }
  return updateRange(scale, { min: newMin, max: newMax }, limits, canZoom);
}
function panNonLinearScale(scale, delta, limits) {
  return panNumericalScale(scale, delta, limits, true);
}
var zoomFunctions = {
  category: zoomCategoryScale,
  default: zoomNumericalScale
};
var zoomRectFunctions = {
  default: zoomRectNumericalScale
};
var panFunctions = {
  category: panCategoryScale,
  default: panNumericalScale,
  logarithmic: panNonLinearScale,
  timeseries: panNonLinearScale
};
function shouldUpdateScaleLimits(scale, originalScaleLimits, updatedScaleLimits) {
  const { id, options: { min, max } } = scale;
  if (!originalScaleLimits[id] || !updatedScaleLimits[id]) {
    return true;
  }
  const previous = updatedScaleLimits[id];
  return previous.min !== min || previous.max !== max;
}
function removeMissingScales(limits, scales2) {
  each(limits, (opt, key) => {
    if (!scales2[key]) {
      delete limits[key];
    }
  });
}
function storeOriginalScaleLimits(chart, state) {
  const { scales: scales2 } = chart;
  const { originalScaleLimits, updatedScaleLimits } = state;
  each(scales2, function(scale) {
    if (shouldUpdateScaleLimits(scale, originalScaleLimits, updatedScaleLimits)) {
      originalScaleLimits[scale.id] = {
        min: { scale: scale.min, options: scale.options.min },
        max: { scale: scale.max, options: scale.options.max }
      };
    }
  });
  removeMissingScales(originalScaleLimits, scales2);
  removeMissingScales(updatedScaleLimits, scales2);
  return originalScaleLimits;
}
function doZoom(scale, amount, center, limits) {
  const fn = zoomFunctions[scale.type] || zoomFunctions.default;
  callback(fn, [scale, amount, center, limits]);
}
function doZoomRect(scale, amount, from2, to2, limits) {
  const fn = zoomRectFunctions[scale.type] || zoomRectFunctions.default;
  callback(fn, [scale, amount, from2, to2, limits]);
}
function getCenter(chart) {
  const ca = chart.chartArea;
  return {
    x: (ca.left + ca.right) / 2,
    y: (ca.top + ca.bottom) / 2
  };
}
function zoom(chart, amount, transition = "none") {
  const { x = 1, y = 1, focalPoint = getCenter(chart) } = typeof amount === "number" ? { x: amount, y: amount } : amount;
  const state = getState(chart);
  const { options: { limits, zoom: zoomOptions } } = state;
  storeOriginalScaleLimits(chart, state);
  const xEnabled = x !== 1;
  const yEnabled = y !== 1;
  const enabledScales = getEnabledScalesByPoint(zoomOptions, focalPoint, chart);
  each(enabledScales || chart.scales, function(scale) {
    if (scale.isHorizontal() && xEnabled) {
      doZoom(scale, x, focalPoint, limits);
    } else if (!scale.isHorizontal() && yEnabled) {
      doZoom(scale, y, focalPoint, limits);
    }
  });
  chart.update(transition);
  callback(zoomOptions.onZoom, [{ chart }]);
}
function zoomRect(chart, p0, p1, transition = "none") {
  const state = getState(chart);
  const { options: { limits, zoom: zoomOptions } } = state;
  const { mode = "xy" } = zoomOptions;
  storeOriginalScaleLimits(chart, state);
  const xEnabled = directionEnabled(mode, "x", chart);
  const yEnabled = directionEnabled(mode, "y", chart);
  each(chart.scales, function(scale) {
    if (scale.isHorizontal() && xEnabled) {
      doZoomRect(scale, p0.x, p1.x, limits);
    } else if (!scale.isHorizontal() && yEnabled) {
      doZoomRect(scale, p0.y, p1.y, limits);
    }
  });
  chart.update(transition);
  callback(zoomOptions.onZoom, [{ chart }]);
}
function zoomScale(chart, scaleId, range, transition = "none") {
  storeOriginalScaleLimits(chart, getState(chart));
  const scale = chart.scales[scaleId];
  updateRange(scale, range, void 0, true);
  chart.update(transition);
}
function resetZoom(chart, transition = "default") {
  const state = getState(chart);
  const originalScaleLimits = storeOriginalScaleLimits(chart, state);
  each(chart.scales, function(scale) {
    const scaleOptions = scale.options;
    if (originalScaleLimits[scale.id]) {
      scaleOptions.min = originalScaleLimits[scale.id].min.options;
      scaleOptions.max = originalScaleLimits[scale.id].max.options;
    } else {
      delete scaleOptions.min;
      delete scaleOptions.max;
    }
  });
  chart.update(transition);
  callback(state.options.zoom.onZoomComplete, [{ chart }]);
}
function getOriginalRange(state, scaleId) {
  const original = state.originalScaleLimits[scaleId];
  if (!original) {
    return;
  }
  const { min, max } = original;
  return valueOrDefault(max.options, max.scale) - valueOrDefault(min.options, min.scale);
}
function getZoomLevel(chart) {
  const state = getState(chart);
  let min = 1;
  let max = 1;
  each(chart.scales, function(scale) {
    const origRange = getOriginalRange(state, scale.id);
    if (origRange) {
      const level = Math.round(origRange / (scale.max - scale.min) * 100) / 100;
      min = Math.min(min, level);
      max = Math.max(max, level);
    }
  });
  return min < 1 ? min : max;
}
function panScale(scale, delta, limits, state) {
  const { panDelta } = state;
  const storedDelta = panDelta[scale.id] || 0;
  if (sign(storedDelta) === sign(delta)) {
    delta += storedDelta;
  }
  const fn = panFunctions[scale.type] || panFunctions.default;
  if (callback(fn, [scale, delta, limits])) {
    panDelta[scale.id] = 0;
  } else {
    panDelta[scale.id] = delta;
  }
}
function pan(chart, delta, enabledScales, transition = "none") {
  const { x = 0, y = 0 } = typeof delta === "number" ? { x: delta, y: delta } : delta;
  const state = getState(chart);
  const { options: { pan: panOptions, limits } } = state;
  const { onPan } = panOptions || {};
  storeOriginalScaleLimits(chart, state);
  const xEnabled = x !== 0;
  const yEnabled = y !== 0;
  each(enabledScales || chart.scales, function(scale) {
    if (scale.isHorizontal() && xEnabled) {
      panScale(scale, x, limits, state);
    } else if (!scale.isHorizontal() && yEnabled) {
      panScale(scale, y, limits, state);
    }
  });
  chart.update(transition);
  callback(onPan, [{ chart }]);
}
function getInitialScaleBounds(chart) {
  const state = getState(chart);
  storeOriginalScaleLimits(chart, state);
  const scaleBounds = {};
  for (const scaleId of Object.keys(chart.scales)) {
    const { min, max } = state.originalScaleLimits[scaleId] || { min: {}, max: {} };
    scaleBounds[scaleId] = { min: min.scale, max: max.scale };
  }
  return scaleBounds;
}
function isZoomedOrPanned(chart) {
  const scaleBounds = getInitialScaleBounds(chart);
  for (const scaleId of Object.keys(chart.scales)) {
    const { min: originalMin, max: originalMax } = scaleBounds[scaleId];
    if (originalMin !== void 0 && chart.scales[scaleId].min !== originalMin) {
      return true;
    }
    if (originalMax !== void 0 && chart.scales[scaleId].max !== originalMax) {
      return true;
    }
  }
  return false;
}
function removeHandler(chart, type) {
  const { handlers } = getState(chart);
  const handler = handlers[type];
  if (handler && handler.target) {
    handler.target.removeEventListener(type, handler);
    delete handlers[type];
  }
}
function addHandler(chart, target, type, handler) {
  const { handlers, options } = getState(chart);
  const oldHandler = handlers[type];
  if (oldHandler && oldHandler.target === target) {
    return;
  }
  removeHandler(chart, type);
  handlers[type] = (event) => handler(chart, event, options);
  handlers[type].target = target;
  target.addEventListener(type, handlers[type]);
}
function mouseMove(chart, event) {
  const state = getState(chart);
  if (state.dragStart) {
    state.dragging = true;
    state.dragEnd = event;
    chart.update("none");
  }
}
function keyDown(chart, event) {
  const state = getState(chart);
  if (!state.dragStart || event.key !== "Escape") {
    return;
  }
  removeHandler(chart, "keydown");
  state.dragging = false;
  state.dragStart = state.dragEnd = null;
  chart.update("none");
}
function zoomStart(chart, event, zoomOptions) {
  const { onZoomStart, onZoomRejected } = zoomOptions;
  if (onZoomStart) {
    const point = getRelativePosition(event, chart);
    if (callback(onZoomStart, [{ chart, event, point }]) === false) {
      callback(onZoomRejected, [{ chart, event }]);
      return false;
    }
  }
}
function mouseDown(chart, event) {
  const state = getState(chart);
  const { pan: panOptions, zoom: zoomOptions = {} } = state.options;
  if (event.button !== 0 || keyPressed(getModifierKey(panOptions), event) || keyNotPressed(getModifierKey(zoomOptions.drag), event)) {
    return callback(zoomOptions.onZoomRejected, [{ chart, event }]);
  }
  if (zoomStart(chart, event, zoomOptions) === false) {
    return;
  }
  state.dragStart = event;
  addHandler(chart, chart.canvas, "mousemove", mouseMove);
  addHandler(chart, window.document, "keydown", keyDown);
}
function computeDragRect(chart, mode, beginPointEvent, endPointEvent) {
  const xEnabled = directionEnabled(mode, "x", chart);
  const yEnabled = directionEnabled(mode, "y", chart);
  let { top, left, right, bottom, width: chartWidth, height: chartHeight } = chart.chartArea;
  const beginPoint = getRelativePosition(beginPointEvent, chart);
  const endPoint = getRelativePosition(endPointEvent, chart);
  if (xEnabled) {
    left = Math.min(beginPoint.x, endPoint.x);
    right = Math.max(beginPoint.x, endPoint.x);
  }
  if (yEnabled) {
    top = Math.min(beginPoint.y, endPoint.y);
    bottom = Math.max(beginPoint.y, endPoint.y);
  }
  const width = right - left;
  const height = bottom - top;
  return {
    left,
    top,
    right,
    bottom,
    width,
    height,
    zoomX: xEnabled && width ? 1 + (chartWidth - width) / chartWidth : 1,
    zoomY: yEnabled && height ? 1 + (chartHeight - height) / chartHeight : 1
  };
}
function mouseUp(chart, event) {
  const state = getState(chart);
  if (!state.dragStart) {
    return;
  }
  removeHandler(chart, "mousemove");
  const { mode, onZoomComplete, drag: { threshold = 0 } } = state.options.zoom;
  const rect = computeDragRect(chart, mode, state.dragStart, event);
  const distanceX = directionEnabled(mode, "x", chart) ? rect.width : 0;
  const distanceY = directionEnabled(mode, "y", chart) ? rect.height : 0;
  const distance = Math.sqrt(distanceX * distanceX + distanceY * distanceY);
  state.dragStart = state.dragEnd = null;
  if (distance <= threshold) {
    state.dragging = false;
    chart.update("none");
    return;
  }
  zoomRect(chart, { x: rect.left, y: rect.top }, { x: rect.right, y: rect.bottom }, "zoom");
  setTimeout(() => state.dragging = false, 500);
  callback(onZoomComplete, [{ chart }]);
}
function wheelPreconditions(chart, event, zoomOptions) {
  if (keyNotPressed(getModifierKey(zoomOptions.wheel), event)) {
    callback(zoomOptions.onZoomRejected, [{ chart, event }]);
    return;
  }
  if (zoomStart(chart, event, zoomOptions) === false) {
    return;
  }
  if (event.cancelable) {
    event.preventDefault();
  }
  if (event.deltaY === void 0) {
    return;
  }
  return true;
}
function wheel(chart, event) {
  const { handlers: { onZoomComplete }, options: { zoom: zoomOptions } } = getState(chart);
  if (!wheelPreconditions(chart, event, zoomOptions)) {
    return;
  }
  const rect = event.target.getBoundingClientRect();
  const speed = 1 + (event.deltaY >= 0 ? -zoomOptions.wheel.speed : zoomOptions.wheel.speed);
  const amount = {
    x: speed,
    y: speed,
    focalPoint: {
      x: event.clientX - rect.left,
      y: event.clientY - rect.top
    }
  };
  zoom(chart, amount);
  if (onZoomComplete) {
    onZoomComplete();
  }
}
function addDebouncedHandler(chart, name, handler, delay) {
  if (handler) {
    getState(chart).handlers[name] = debounce2(() => callback(handler, [{ chart }]), delay);
  }
}
function addListeners(chart, options) {
  const canvas = chart.canvas;
  const { wheel: wheelOptions, drag: dragOptions, onZoomComplete } = options.zoom;
  if (wheelOptions.enabled) {
    addHandler(chart, canvas, "wheel", wheel);
    addDebouncedHandler(chart, "onZoomComplete", onZoomComplete, 250);
  } else {
    removeHandler(chart, "wheel");
  }
  if (dragOptions.enabled) {
    addHandler(chart, canvas, "mousedown", mouseDown);
    addHandler(chart, canvas.ownerDocument, "mouseup", mouseUp);
  } else {
    removeHandler(chart, "mousedown");
    removeHandler(chart, "mousemove");
    removeHandler(chart, "mouseup");
    removeHandler(chart, "keydown");
  }
}
function removeListeners(chart) {
  removeHandler(chart, "mousedown");
  removeHandler(chart, "mousemove");
  removeHandler(chart, "mouseup");
  removeHandler(chart, "wheel");
  removeHandler(chart, "click");
  removeHandler(chart, "keydown");
}
function createEnabler(chart, state) {
  return function(recognizer, event) {
    const { pan: panOptions, zoom: zoomOptions = {} } = state.options;
    if (!panOptions || !panOptions.enabled) {
      return false;
    }
    const srcEvent = event && event.srcEvent;
    if (!srcEvent) {
      return true;
    }
    if (!state.panning && event.pointerType === "mouse" && (keyNotPressed(getModifierKey(panOptions), srcEvent) || keyPressed(getModifierKey(zoomOptions.drag), srcEvent))) {
      callback(panOptions.onPanRejected, [{ chart, event }]);
      return false;
    }
    return true;
  };
}
function pinchAxes(p0, p1) {
  const pinchX = Math.abs(p0.clientX - p1.clientX);
  const pinchY = Math.abs(p0.clientY - p1.clientY);
  const p = pinchX / pinchY;
  let x, y;
  if (p > 0.3 && p < 1.7) {
    x = y = true;
  } else if (pinchX > pinchY) {
    x = true;
  } else {
    y = true;
  }
  return { x, y };
}
function handlePinch(chart, state, e) {
  if (state.scale) {
    const { center, pointers } = e;
    const zoomPercent = 1 / state.scale * e.scale;
    const rect = e.target.getBoundingClientRect();
    const pinch = pinchAxes(pointers[0], pointers[1]);
    const mode = state.options.zoom.mode;
    const amount = {
      x: pinch.x && directionEnabled(mode, "x", chart) ? zoomPercent : 1,
      y: pinch.y && directionEnabled(mode, "y", chart) ? zoomPercent : 1,
      focalPoint: {
        x: center.x - rect.left,
        y: center.y - rect.top
      }
    };
    zoom(chart, amount);
    state.scale = e.scale;
  }
}
function startPinch(chart, state) {
  if (state.options.zoom.pinch.enabled) {
    state.scale = 1;
  }
}
function endPinch(chart, state, e) {
  if (state.scale) {
    handlePinch(chart, state, e);
    state.scale = null;
    callback(state.options.zoom.onZoomComplete, [{ chart }]);
  }
}
function handlePan(chart, state, e) {
  const delta = state.delta;
  if (delta) {
    state.panning = true;
    pan(chart, { x: e.deltaX - delta.x, y: e.deltaY - delta.y }, state.panScales);
    state.delta = { x: e.deltaX, y: e.deltaY };
  }
}
function startPan(chart, state, event) {
  const { enabled, onPanStart, onPanRejected } = state.options.pan;
  if (!enabled) {
    return;
  }
  const rect = event.target.getBoundingClientRect();
  const point = {
    x: event.center.x - rect.left,
    y: event.center.y - rect.top
  };
  if (callback(onPanStart, [{ chart, event, point }]) === false) {
    return callback(onPanRejected, [{ chart, event }]);
  }
  state.panScales = getEnabledScalesByPoint(state.options.pan, point, chart);
  state.delta = { x: 0, y: 0 };
  clearTimeout(state.panEndTimeout);
  handlePan(chart, state, event);
}
function endPan(chart, state) {
  state.delta = null;
  if (state.panning) {
    state.panEndTimeout = setTimeout(() => state.panning = false, 500);
    callback(state.options.pan.onPanComplete, [{ chart }]);
  }
}
var hammers = /* @__PURE__ */ new WeakMap();
function startHammer(chart, options) {
  const state = getState(chart);
  const canvas = chart.canvas;
  const { pan: panOptions, zoom: zoomOptions } = options;
  const mc = new import_hammerjs.default.Manager(canvas);
  if (zoomOptions && zoomOptions.pinch.enabled) {
    mc.add(new import_hammerjs.default.Pinch());
    mc.on("pinchstart", () => startPinch(chart, state));
    mc.on("pinch", (e) => handlePinch(chart, state, e));
    mc.on("pinchend", (e) => endPinch(chart, state, e));
  }
  if (panOptions && panOptions.enabled) {
    mc.add(new import_hammerjs.default.Pan({
      threshold: panOptions.threshold,
      enable: createEnabler(chart, state)
    }));
    mc.on("panstart", (e) => startPan(chart, state, e));
    mc.on("panmove", (e) => handlePan(chart, state, e));
    mc.on("panend", () => endPan(chart, state));
  }
  hammers.set(chart, mc);
}
function stopHammer(chart) {
  const mc = hammers.get(chart);
  if (mc) {
    mc.remove("pinchstart");
    mc.remove("pinch");
    mc.remove("pinchend");
    mc.remove("panstart");
    mc.remove("pan");
    mc.remove("panend");
    mc.destroy();
    hammers.delete(chart);
  }
}
var version2 = "2.0.1";
function draw2(chart, caller, options) {
  const dragOptions = options.zoom.drag;
  const { dragStart, dragEnd } = getState(chart);
  if (dragOptions.drawTime !== caller || !dragEnd) {
    return;
  }
  const { left, top, width, height } = computeDragRect(chart, options.zoom.mode, dragStart, dragEnd);
  const ctx = chart.ctx;
  ctx.save();
  ctx.beginPath();
  ctx.fillStyle = dragOptions.backgroundColor || "rgba(225,225,225,0.3)";
  ctx.fillRect(left, top, width, height);
  if (dragOptions.borderWidth > 0) {
    ctx.lineWidth = dragOptions.borderWidth;
    ctx.strokeStyle = dragOptions.borderColor || "rgba(225,225,225)";
    ctx.strokeRect(left, top, width, height);
  }
  ctx.restore();
}
var plugin = {
  id: "zoom",
  version: version2,
  defaults: {
    pan: {
      enabled: false,
      mode: "xy",
      threshold: 10,
      modifierKey: null
    },
    zoom: {
      wheel: {
        enabled: false,
        speed: 0.1,
        modifierKey: null
      },
      drag: {
        enabled: false,
        drawTime: "beforeDatasetsDraw",
        modifierKey: null
      },
      pinch: {
        enabled: false
      },
      mode: "xy"
    }
  },
  start: function(chart, _args, options) {
    const state = getState(chart);
    state.options = options;
    if (Object.prototype.hasOwnProperty.call(options.zoom, "enabled")) {
      console.warn("The option `zoom.enabled` is no longer supported. Please use `zoom.wheel.enabled`, `zoom.drag.enabled`, or `zoom.pinch.enabled`.");
    }
    if (Object.prototype.hasOwnProperty.call(options.zoom, "overScaleMode") || Object.prototype.hasOwnProperty.call(options.pan, "overScaleMode")) {
      console.warn("The option `overScaleMode` is deprecated. Please use `scaleMode` instead (and update `mode` as desired).");
    }
    if (import_hammerjs.default) {
      startHammer(chart, options);
    }
    chart.pan = (delta, panScales, transition) => pan(chart, delta, panScales, transition);
    chart.zoom = (args, transition) => zoom(chart, args, transition);
    chart.zoomRect = (p0, p1, transition) => zoomRect(chart, p0, p1, transition);
    chart.zoomScale = (id, range, transition) => zoomScale(chart, id, range, transition);
    chart.resetZoom = (transition) => resetZoom(chart, transition);
    chart.getZoomLevel = () => getZoomLevel(chart);
    chart.getInitialScaleBounds = () => getInitialScaleBounds(chart);
    chart.isZoomedOrPanned = () => isZoomedOrPanned(chart);
  },
  beforeEvent(chart) {
    const state = getState(chart);
    if (state.panning || state.dragging) {
      return false;
    }
  },
  beforeUpdate: function(chart, args, options) {
    const state = getState(chart);
    state.options = options;
    addListeners(chart, options);
  },
  beforeDatasetsDraw(chart, _args, options) {
    draw2(chart, "beforeDatasetsDraw", options);
  },
  afterDatasetsDraw(chart, _args, options) {
    draw2(chart, "afterDatasetsDraw", options);
  },
  beforeDraw(chart, _args, options) {
    draw2(chart, "beforeDraw", options);
  },
  afterDraw(chart, _args, options) {
    draw2(chart, "afterDraw", options);
  },
  stop: function(chart) {
    removeListeners(chart);
    if (import_hammerjs.default) {
      stopHammer(chart);
    }
    removeState(chart);
  },
  panFunctions,
  zoomFunctions,
  zoomRectFunctions
};

// src/chart.ts
Chart.register(...registerables, plugin);
function registerCSVChartProcessor(source, el, ctx_block, themeColors2) {
  var _a;
  const rows = source.split("\n").filter((row) => row.length > 0);
  if (rows.length < 2) {
    new import_obsidian2.Notice("CSV data is too short. At least one header row and one data row are required.");
    return;
  }
  const rawContent = ctx_block.getSectionInfo(el);
  const firstLine = (_a = rawContent == null ? void 0 : rawContent.text.split("\n")[rawContent == null ? void 0 : rawContent.lineStart]) != null ? _a : "";
  const options = firstLine.trim().split(/\s+/);
  const colorTheme = options.length > 1 && options[1].trim() !== "" ? options[1].trim().toLowerCase() : "orange";
  const colors2 = themeColors2.hasOwnProperty(colorTheme) ? themeColors2[colorTheme] : themeColors2.orange;
  const chartType = options.length > 2 && options[2].trim() !== "" ? options[2].trim().toLowerCase() : "bar";
  const chartLabels = [];
  const chartData = [];
  for (let i = 1; i < rows.length; i++) {
    const cols = rows[i].split(",");
    chartLabels.push(cols[0]);
    chartData.push(parseFloat(cols[1]));
  }
  const chartContainer = el.createEl("div", { cls: "chart-container" });
  const canvas = chartContainer.createEl("canvas", { cls: "csv-chart" });
  const ctx = canvas.getContext("2d");
  if (ctx) {
    new Chart(ctx, {
      type: chartType,
      // Dynamic chart type based on the third option
      data: {
        labels: chartLabels,
        datasets: [{
          label: rows[0].split(",")[1],
          data: chartData,
          backgroundColor: colors2.backgroundColor,
          borderColor: colors2.borderColor,
          borderWidth: 1
        }]
      },
      options: {
        scales: chartType === "bar" || chartType === "line" ? {
          // Only show scales for bar/line charts
          y: { beginAtZero: true }
        } : {},
        plugins: {
          zoom: {
            zoom: {
              wheel: {
                enabled: true
                // Enable zooming with mouse wheel
              },
              pinch: {
                enabled: true
                // Enable zooming with touch gestures
              },
              mode: "xy"
              // Zoom on both x and y axes
            },
            pan: {
              enabled: true,
              // Enable panning
              mode: "xy"
              // Pan on both axes
            }
          },
          tooltip: {
            enabled: true,
            // Enable tooltips on hover
            callbacks: {
              label: function(tooltipItem) {
                return `${tooltipItem.dataset.label}: ${tooltipItem.raw}`;
              }
            }
          }
        }
      }
    });
  } else {
    console.error("Unable to get canvas context");
  }
}

// src/csvTable_interactive.ts
function registerCSVTableProcessor(source, el, ctx) {
  var _a;
  const rawContent = ctx.getSectionInfo(el);
  const firstLine = (_a = rawContent == null ? void 0 : rawContent.text.split("\n")[rawContent == null ? void 0 : rawContent.lineStart]) != null ? _a : "";
  const options = firstLine.split(" ");
  let colorTheme = options.length > 1 ? options[1] : "orange";
  colorTheme = colorTheme.toLowerCase();
  const rows = source.split("\n").filter((row) => row.length > 0);
  const table = el.createEl("table");
  table.addClass(`${colorTheme}-theme`);
  const thead = table.createEl("thead");
  const tbody = table.createEl("tbody");
  const csvData = rows.map((row) => row.split(","));
  const headerRow = csvData[0];
  const header = thead.createEl("tr");
  headerRow.forEach((headerCell, index2) => {
    const th = header.createEl("th");
    th.createEl("span", { text: headerCell.trim() });
    let sortDirection = "asc";
    th.style.cursor = "pointer";
    th.onclick = () => {
      sortDirection = sortDirection === "asc" ? "desc" : "asc";
      const sortedRows = csvData.slice(1).sort((a, b) => {
        const valueA = a[index2].trim();
        const valueB = b[index2].trim();
        if (!isNaN(Number(valueA)) && !isNaN(Number(valueB))) {
          return sortDirection === "asc" ? Number(valueA) - Number(valueB) : Number(valueB) - Number(valueA);
        } else {
          return sortDirection === "asc" ? valueA.localeCompare(valueB) : valueB.localeCompare(valueA);
        }
      });
      updateSortIcons(header, index2, sortDirection);
      tbody.empty();
      renderRows(sortedRows, tbody);
    };
  });
  renderRows(csvData.slice(1), tbody);
}
function renderRows(rows, tbody) {
  rows.forEach((rowData) => {
    const row = tbody.createEl("tr");
    rowData.forEach((cellData) => {
      row.createEl("td", { text: cellData.trim() });
    });
  });
}
function updateSortIcons(headerRow, activeIndex, direction) {
  const headers = Array.from(headerRow.children);
  headers.forEach((header, index2) => {
    const headerSpan = header.querySelector("span");
    if (headerSpan) {
      if (index2 === activeIndex) {
        headerSpan.textContent = (headerSpan.textContent || "").replace(/▲|▼/, "") + (direction === "asc" ? " \u25B2" : " \u25BC");
      } else {
        headerSpan.textContent = (headerSpan.textContent || "").replace(/▲|▼/, "");
      }
    }
  });
}

// src/csv2markdown.ts
function isValidCSV(text) {
  const lines = text.trim().split("\n");
  if (lines.length < 2)
    return false;
  const headerColumns = lines[0].split(",").length;
  return lines.every((line) => line.split(",").length === headerColumns);
}
function convertCSVToMarkdownTable(csv) {
  const lines = csv.trim().split("\n");
  const headers = lines[0].split(",");
  let markdownTable = "| " + headers.map((header) => header.trim()).join(" | ") + " |\n";
  markdownTable += "|" + headers.map(() => "---").join("|") + "|\n";
  for (let i = 1; i < lines.length; i++) {
    const cells = lines[i].split(",");
    markdownTable += "| " + cells.map((cell) => cell.trim()).join(" | ") + " |\n";
  }
  return markdownTable;
}

// src/main.ts
var CSVTableConverter = class extends import_obsidian3.Plugin {
  async onload() {
    await this.loadSettings();
    this.registerMarkdownCodeBlockProcessor("csv-chart", (source, el, ctx) => {
      registerCSVChartProcessor(source, el, ctx, themeColors);
    });
    this.registerMarkdownCodeBlockProcessor("csv-table", (source, el, ctx) => {
      registerCSVTableProcessor(source, el, ctx);
    });
    this.addCommand({
      id: "convert-csv-to-markdown-table",
      name: "Convert CSV to Markdown Table",
      //hotkeys: [{ modifiers: ['Mod'], key: 'k' }],
      hotkeys: [],
      editorCallback: (editor, view) => {
        const selection = editor.getSelection();
        if (isValidCSV(selection)) {
          const markdownTable = convertCSVToMarkdownTable(selection);
          editor.replaceSelection(markdownTable);
        } else {
          new import_obsidian3.Notice("Selected text is not a valid CSV format");
        }
      }
    });
    this.addSettingTab(new CSVTableConverterSettingTab(this.app, this));
  }
  async loadSettings() {
    this.settings = Object.assign({}, {
      mySetting: ","
    }, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
};
/*! Bundled license information:

hammerjs/hammer.js:
  (*! Hammer.JS - v2.0.7 - 2016-04-22
   * http://hammerjs.github.io/
   *
   * Copyright (c) 2016 Jorik Tangelder;
   * Licensed under the MIT license *)

@kurkle/color/dist/color.esm.js:
  (*!
   * @kurkle/color v0.3.2
   * https://github.com/kurkle/color#readme
   * (c) 2023 Jukka Kurkela
   * Released under the MIT License
   *)

chart.js/dist/chunks/helpers.segment.js:
  (*!
   * Chart.js v4.4.4
   * https://www.chartjs.org
   * (c) 2024 Chart.js Contributors
   * Released under the MIT License
   *)

chart.js/dist/chart.js:
  (*!
   * Chart.js v4.4.4
   * https://www.chartjs.org
   * (c) 2024 Chart.js Contributors
   * Released under the MIT License
   *)

chart.js/dist/helpers.js:
  (*!
   * Chart.js v4.4.4
   * https://www.chartjs.org
   * (c) 2024 Chart.js Contributors
   * Released under the MIT License
   *)

chartjs-plugin-zoom/dist/chartjs-plugin-zoom.esm.js:
  (*!
  * chartjs-plugin-zoom v2.0.1
  * undefined
   * (c) 2016-2023 chartjs-plugin-zoom Contributors
   * Released under the MIT License
   *)
*/
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsibm9kZV9tb2R1bGVzL2hhbW1lcmpzL2hhbW1lci5qcyIsICJzcmMvbWFpbi50cyIsICJzcmMvY2hhcnRjb2xvci50cyIsICJzcmMvc2V0dGluZ3MudHMiLCAic3JjL2NoYXJ0LnRzIiwgIm5vZGVfbW9kdWxlcy9Aa3Vya2xlL2NvbG9yL2Rpc3QvY29sb3IuZXNtLmpzIiwgIm5vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvaGVscGVycy9oZWxwZXJzLmNvcmUudHMiLCAibm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9oZWxwZXJzL2hlbHBlcnMubWF0aC50cyIsICJub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL2hlbHBlcnMvaGVscGVycy5jb2xsZWN0aW9uLnRzIiwgIm5vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvaGVscGVycy9oZWxwZXJzLmV4dHJhcy50cyIsICJub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL2hlbHBlcnMvaGVscGVycy5lYXNpbmcudHMiLCAibm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9oZWxwZXJzL2hlbHBlcnMuY29sb3IudHMiLCAibm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9jb3JlL2NvcmUuYW5pbWF0aW9ucy5kZWZhdWx0cy5qcyIsICJub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL2NvcmUvY29yZS5sYXlvdXRzLmRlZmF1bHRzLmpzIiwgIm5vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvaGVscGVycy9oZWxwZXJzLmludGwudHMiLCAibm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9jb3JlL2NvcmUudGlja3MuanMiLCAibm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9jb3JlL2NvcmUuc2NhbGUuZGVmYXVsdHMuanMiLCAibm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9jb3JlL2NvcmUuZGVmYXVsdHMuanMiLCAibm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9oZWxwZXJzL2hlbHBlcnMuY2FudmFzLnRzIiwgIm5vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvaGVscGVycy9oZWxwZXJzLm9wdGlvbnMudHMiLCAibm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9oZWxwZXJzL2hlbHBlcnMuY29uZmlnLnRzIiwgIm5vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvaGVscGVycy9oZWxwZXJzLmN1cnZlLnRzIiwgIm5vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvaGVscGVycy9oZWxwZXJzLmRvbS50cyIsICJub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL2hlbHBlcnMvaGVscGVycy5pbnRlcnBvbGF0aW9uLnRzIiwgIm5vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvaGVscGVycy9oZWxwZXJzLnJ0bC50cyIsICJub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL2hlbHBlcnMvaGVscGVycy5zZWdtZW50LmpzIiwgIm5vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvY29yZS9jb3JlLmFuaW1hdG9yLmpzIiwgIm5vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvY29yZS9jb3JlLmFuaW1hdGlvbi5qcyIsICJub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL2NvcmUvY29yZS5hbmltYXRpb25zLmpzIiwgIm5vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvY29yZS9jb3JlLmRhdGFzZXRDb250cm9sbGVyLmpzIiwgIm5vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvY29udHJvbGxlcnMvY29udHJvbGxlci5iYXIuanMiLCAibm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9jb250cm9sbGVycy9jb250cm9sbGVyLmJ1YmJsZS5qcyIsICJub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL2NvbnRyb2xsZXJzL2NvbnRyb2xsZXIuZG91Z2hudXQuanMiLCAibm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9jb250cm9sbGVycy9jb250cm9sbGVyLmxpbmUuanMiLCAibm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9jb250cm9sbGVycy9jb250cm9sbGVyLnBvbGFyQXJlYS5qcyIsICJub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL2NvbnRyb2xsZXJzL2NvbnRyb2xsZXIucGllLmpzIiwgIm5vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvY29udHJvbGxlcnMvY29udHJvbGxlci5yYWRhci5qcyIsICJub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL2NvbnRyb2xsZXJzL2NvbnRyb2xsZXIuc2NhdHRlci5qcyIsICJub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL2NvcmUvY29yZS5hZGFwdGVycy50cyIsICJub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL2NvcmUvY29yZS5pbnRlcmFjdGlvbi5qcyIsICJub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL2NvcmUvY29yZS5sYXlvdXRzLmpzIiwgIm5vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvcGxhdGZvcm0vcGxhdGZvcm0uYmFzZS5qcyIsICJub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL3BsYXRmb3JtL3BsYXRmb3JtLmJhc2ljLmpzIiwgIm5vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvcGxhdGZvcm0vcGxhdGZvcm0uZG9tLmpzIiwgIm5vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvcGxhdGZvcm0vaW5kZXguanMiLCAibm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9jb3JlL2NvcmUuZWxlbWVudC50cyIsICJub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL2NvcmUvY29yZS5zY2FsZS5hdXRvc2tpcC5qcyIsICJub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL2NvcmUvY29yZS5zY2FsZS5qcyIsICJub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL2NvcmUvY29yZS50eXBlZFJlZ2lzdHJ5LmpzIiwgIm5vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvY29yZS9jb3JlLnJlZ2lzdHJ5LmpzIiwgIm5vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvY29yZS9jb3JlLnBsdWdpbnMuanMiLCAibm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9jb3JlL2NvcmUuY29uZmlnLmpzIiwgIm5vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvY29yZS9jb3JlLmNvbnRyb2xsZXIuanMiLCAibm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9lbGVtZW50cy9lbGVtZW50LmFyYy50cyIsICJub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL2VsZW1lbnRzL2VsZW1lbnQubGluZS5qcyIsICJub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL2VsZW1lbnRzL2VsZW1lbnQucG9pbnQudHMiLCAibm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9lbGVtZW50cy9lbGVtZW50LmJhci5qcyIsICJub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL3BsdWdpbnMvcGx1Z2luLmNvbG9ycy50cyIsICJub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL3BsdWdpbnMvcGx1Z2luLmRlY2ltYXRpb24uanMiLCAibm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9wbHVnaW5zL3BsdWdpbi5maWxsZXIvZmlsbGVyLnNlZ21lbnQuanMiLCAibm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9wbHVnaW5zL3BsdWdpbi5maWxsZXIvZmlsbGVyLmhlbHBlci5qcyIsICJub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL3BsdWdpbnMvcGx1Z2luLmZpbGxlci9maWxsZXIub3B0aW9ucy5qcyIsICJub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL3BsdWdpbnMvcGx1Z2luLmZpbGxlci9maWxsZXIudGFyZ2V0LnN0YWNrLmpzIiwgIm5vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvcGx1Z2lucy9wbHVnaW4uZmlsbGVyL3NpbXBsZUFyYy5qcyIsICJub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL3BsdWdpbnMvcGx1Z2luLmZpbGxlci9maWxsZXIudGFyZ2V0LmpzIiwgIm5vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvcGx1Z2lucy9wbHVnaW4uZmlsbGVyL2ZpbGxlci5kcmF3aW5nLmpzIiwgIm5vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvcGx1Z2lucy9wbHVnaW4uZmlsbGVyL2luZGV4LmpzIiwgIm5vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvcGx1Z2lucy9wbHVnaW4ubGVnZW5kLmpzIiwgIm5vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvcGx1Z2lucy9wbHVnaW4udGl0bGUuanMiLCAibm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9wbHVnaW5zL3BsdWdpbi5zdWJ0aXRsZS5qcyIsICJub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL3BsdWdpbnMvcGx1Z2luLnRvb2x0aXAuanMiLCAibm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9zY2FsZXMvc2NhbGUuY2F0ZWdvcnkuanMiLCAibm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9zY2FsZXMvc2NhbGUubGluZWFyYmFzZS5qcyIsICJub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL3NjYWxlcy9zY2FsZS5saW5lYXIuanMiLCAibm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9zY2FsZXMvc2NhbGUubG9nYXJpdGhtaWMuanMiLCAibm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9zY2FsZXMvc2NhbGUucmFkaWFsTGluZWFyLmpzIiwgIm5vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvc2NhbGVzL3NjYWxlLnRpbWUuanMiLCAibm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9zY2FsZXMvc2NhbGUudGltZXNlcmllcy5qcyIsICJub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL2luZGV4LnRzIiwgIm5vZGVfbW9kdWxlcy9jaGFydGpzLXBsdWdpbi16b29tL2Rpc3QvY2hhcnRqcy1wbHVnaW4tem9vbS5lc20uanMiLCAic3JjL2NzdlRhYmxlX2ludGVyYWN0aXZlLnRzIiwgInNyYy9jc3YybWFya2Rvd24udHMiXSwKICAic291cmNlc0NvbnRlbnQiOiBbIi8qISBIYW1tZXIuSlMgLSB2Mi4wLjcgLSAyMDE2LTA0LTIyXG4gKiBodHRwOi8vaGFtbWVyanMuZ2l0aHViLmlvL1xuICpcbiAqIENvcHlyaWdodCAoYykgMjAxNiBKb3JpayBUYW5nZWxkZXI7XG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgKi9cbihmdW5jdGlvbih3aW5kb3csIGRvY3VtZW50LCBleHBvcnROYW1lLCB1bmRlZmluZWQpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG52YXIgVkVORE9SX1BSRUZJWEVTID0gWycnLCAnd2Via2l0JywgJ01veicsICdNUycsICdtcycsICdvJ107XG52YXIgVEVTVF9FTEVNRU5UID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG5cbnZhciBUWVBFX0ZVTkNUSU9OID0gJ2Z1bmN0aW9uJztcblxudmFyIHJvdW5kID0gTWF0aC5yb3VuZDtcbnZhciBhYnMgPSBNYXRoLmFicztcbnZhciBub3cgPSBEYXRlLm5vdztcblxuLyoqXG4gKiBzZXQgYSB0aW1lb3V0IHdpdGggYSBnaXZlbiBzY29wZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAqIEBwYXJhbSB7TnVtYmVyfSB0aW1lb3V0XG4gKiBAcGFyYW0ge09iamVjdH0gY29udGV4dFxuICogQHJldHVybnMge251bWJlcn1cbiAqL1xuZnVuY3Rpb24gc2V0VGltZW91dENvbnRleHQoZm4sIHRpbWVvdXQsIGNvbnRleHQpIHtcbiAgICByZXR1cm4gc2V0VGltZW91dChiaW5kRm4oZm4sIGNvbnRleHQpLCB0aW1lb3V0KTtcbn1cblxuLyoqXG4gKiBpZiB0aGUgYXJndW1lbnQgaXMgYW4gYXJyYXksIHdlIHdhbnQgdG8gZXhlY3V0ZSB0aGUgZm4gb24gZWFjaCBlbnRyeVxuICogaWYgaXQgYWludCBhbiBhcnJheSB3ZSBkb24ndCB3YW50IHRvIGRvIGEgdGhpbmcuXG4gKiB0aGlzIGlzIHVzZWQgYnkgYWxsIHRoZSBtZXRob2RzIHRoYXQgYWNjZXB0IGEgc2luZ2xlIGFuZCBhcnJheSBhcmd1bWVudC5cbiAqIEBwYXJhbSB7KnxBcnJheX0gYXJnXG4gKiBAcGFyYW0ge1N0cmluZ30gZm5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbY29udGV4dF1cbiAqIEByZXR1cm5zIHtCb29sZWFufVxuICovXG5mdW5jdGlvbiBpbnZva2VBcnJheUFyZyhhcmcsIGZuLCBjb250ZXh0KSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoYXJnKSkge1xuICAgICAgICBlYWNoKGFyZywgY29udGV4dFtmbl0sIGNvbnRleHQpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuXG4vKipcbiAqIHdhbGsgb2JqZWN0cyBhbmQgYXJyYXlzXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRvclxuICogQHBhcmFtIHtPYmplY3R9IGNvbnRleHRcbiAqL1xuZnVuY3Rpb24gZWFjaChvYmosIGl0ZXJhdG9yLCBjb250ZXh0KSB7XG4gICAgdmFyIGk7XG5cbiAgICBpZiAoIW9iaikge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKG9iai5mb3JFYWNoKSB7XG4gICAgICAgIG9iai5mb3JFYWNoKGl0ZXJhdG9yLCBjb250ZXh0KTtcbiAgICB9IGVsc2UgaWYgKG9iai5sZW5ndGggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpID0gMDtcbiAgICAgICAgd2hpbGUgKGkgPCBvYmoubGVuZ3RoKSB7XG4gICAgICAgICAgICBpdGVyYXRvci5jYWxsKGNvbnRleHQsIG9ialtpXSwgaSwgb2JqKTtcbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAoaSBpbiBvYmopIHtcbiAgICAgICAgICAgIG9iai5oYXNPd25Qcm9wZXJ0eShpKSAmJiBpdGVyYXRvci5jYWxsKGNvbnRleHQsIG9ialtpXSwgaSwgb2JqKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuLyoqXG4gKiB3cmFwIGEgbWV0aG9kIHdpdGggYSBkZXByZWNhdGlvbiB3YXJuaW5nIGFuZCBzdGFjayB0cmFjZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gbWV0aG9kXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gQSBuZXcgZnVuY3Rpb24gd3JhcHBpbmcgdGhlIHN1cHBsaWVkIG1ldGhvZC5cbiAqL1xuZnVuY3Rpb24gZGVwcmVjYXRlKG1ldGhvZCwgbmFtZSwgbWVzc2FnZSkge1xuICAgIHZhciBkZXByZWNhdGlvbk1lc3NhZ2UgPSAnREVQUkVDQVRFRCBNRVRIT0Q6ICcgKyBuYW1lICsgJ1xcbicgKyBtZXNzYWdlICsgJyBBVCBcXG4nO1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGUgPSBuZXcgRXJyb3IoJ2dldC1zdGFjay10cmFjZScpO1xuICAgICAgICB2YXIgc3RhY2sgPSBlICYmIGUuc3RhY2sgPyBlLnN0YWNrLnJlcGxhY2UoL15bXlxcKF0rP1tcXG4kXS9nbSwgJycpXG4gICAgICAgICAgICAucmVwbGFjZSgvXlxccythdFxccysvZ20sICcnKVxuICAgICAgICAgICAgLnJlcGxhY2UoL15PYmplY3QuPGFub255bW91cz5cXHMqXFwoL2dtLCAne2Fub255bW91c30oKUAnKSA6ICdVbmtub3duIFN0YWNrIFRyYWNlJztcblxuICAgICAgICB2YXIgbG9nID0gd2luZG93LmNvbnNvbGUgJiYgKHdpbmRvdy5jb25zb2xlLndhcm4gfHwgd2luZG93LmNvbnNvbGUubG9nKTtcbiAgICAgICAgaWYgKGxvZykge1xuICAgICAgICAgICAgbG9nLmNhbGwod2luZG93LmNvbnNvbGUsIGRlcHJlY2F0aW9uTWVzc2FnZSwgc3RhY2spO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXRob2QuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9O1xufVxuXG4vKipcbiAqIGV4dGVuZCBvYmplY3QuXG4gKiBtZWFucyB0aGF0IHByb3BlcnRpZXMgaW4gZGVzdCB3aWxsIGJlIG92ZXJ3cml0dGVuIGJ5IHRoZSBvbmVzIGluIHNyYy5cbiAqIEBwYXJhbSB7T2JqZWN0fSB0YXJnZXRcbiAqIEBwYXJhbSB7Li4uT2JqZWN0fSBvYmplY3RzX3RvX2Fzc2lnblxuICogQHJldHVybnMge09iamVjdH0gdGFyZ2V0XG4gKi9cbnZhciBhc3NpZ247XG5pZiAodHlwZW9mIE9iamVjdC5hc3NpZ24gIT09ICdmdW5jdGlvbicpIHtcbiAgICBhc3NpZ24gPSBmdW5jdGlvbiBhc3NpZ24odGFyZ2V0KSB7XG4gICAgICAgIGlmICh0YXJnZXQgPT09IHVuZGVmaW5lZCB8fCB0YXJnZXQgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0Nhbm5vdCBjb252ZXJ0IHVuZGVmaW5lZCBvciBudWxsIHRvIG9iamVjdCcpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG91dHB1dCA9IE9iamVjdCh0YXJnZXQpO1xuICAgICAgICBmb3IgKHZhciBpbmRleCA9IDE7IGluZGV4IDwgYXJndW1lbnRzLmxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICAgICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpbmRleF07XG4gICAgICAgICAgICBpZiAoc291cmNlICE9PSB1bmRlZmluZWQgJiYgc291cmNlICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgbmV4dEtleSBpbiBzb3VyY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNvdXJjZS5oYXNPd25Qcm9wZXJ0eShuZXh0S2V5KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0W25leHRLZXldID0gc291cmNlW25leHRLZXldO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgfTtcbn0gZWxzZSB7XG4gICAgYXNzaWduID0gT2JqZWN0LmFzc2lnbjtcbn1cblxuLyoqXG4gKiBleHRlbmQgb2JqZWN0LlxuICogbWVhbnMgdGhhdCBwcm9wZXJ0aWVzIGluIGRlc3Qgd2lsbCBiZSBvdmVyd3JpdHRlbiBieSB0aGUgb25lcyBpbiBzcmMuXG4gKiBAcGFyYW0ge09iamVjdH0gZGVzdFxuICogQHBhcmFtIHtPYmplY3R9IHNyY1xuICogQHBhcmFtIHtCb29sZWFufSBbbWVyZ2U9ZmFsc2VdXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBkZXN0XG4gKi9cbnZhciBleHRlbmQgPSBkZXByZWNhdGUoZnVuY3Rpb24gZXh0ZW5kKGRlc3QsIHNyYywgbWVyZ2UpIHtcbiAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKHNyYyk7XG4gICAgdmFyIGkgPSAwO1xuICAgIHdoaWxlIChpIDwga2V5cy5sZW5ndGgpIHtcbiAgICAgICAgaWYgKCFtZXJnZSB8fCAobWVyZ2UgJiYgZGVzdFtrZXlzW2ldXSA9PT0gdW5kZWZpbmVkKSkge1xuICAgICAgICAgICAgZGVzdFtrZXlzW2ldXSA9IHNyY1trZXlzW2ldXTtcbiAgICAgICAgfVxuICAgICAgICBpKys7XG4gICAgfVxuICAgIHJldHVybiBkZXN0O1xufSwgJ2V4dGVuZCcsICdVc2UgYGFzc2lnbmAuJyk7XG5cbi8qKlxuICogbWVyZ2UgdGhlIHZhbHVlcyBmcm9tIHNyYyBpbiB0aGUgZGVzdC5cbiAqIG1lYW5zIHRoYXQgcHJvcGVydGllcyB0aGF0IGV4aXN0IGluIGRlc3Qgd2lsbCBub3QgYmUgb3ZlcndyaXR0ZW4gYnkgc3JjXG4gKiBAcGFyYW0ge09iamVjdH0gZGVzdFxuICogQHBhcmFtIHtPYmplY3R9IHNyY1xuICogQHJldHVybnMge09iamVjdH0gZGVzdFxuICovXG52YXIgbWVyZ2UgPSBkZXByZWNhdGUoZnVuY3Rpb24gbWVyZ2UoZGVzdCwgc3JjKSB7XG4gICAgcmV0dXJuIGV4dGVuZChkZXN0LCBzcmMsIHRydWUpO1xufSwgJ21lcmdlJywgJ1VzZSBgYXNzaWduYC4nKTtcblxuLyoqXG4gKiBzaW1wbGUgY2xhc3MgaW5oZXJpdGFuY2VcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNoaWxkXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBiYXNlXG4gKiBAcGFyYW0ge09iamVjdH0gW3Byb3BlcnRpZXNdXG4gKi9cbmZ1bmN0aW9uIGluaGVyaXQoY2hpbGQsIGJhc2UsIHByb3BlcnRpZXMpIHtcbiAgICB2YXIgYmFzZVAgPSBiYXNlLnByb3RvdHlwZSxcbiAgICAgICAgY2hpbGRQO1xuXG4gICAgY2hpbGRQID0gY2hpbGQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShiYXNlUCk7XG4gICAgY2hpbGRQLmNvbnN0cnVjdG9yID0gY2hpbGQ7XG4gICAgY2hpbGRQLl9zdXBlciA9IGJhc2VQO1xuXG4gICAgaWYgKHByb3BlcnRpZXMpIHtcbiAgICAgICAgYXNzaWduKGNoaWxkUCwgcHJvcGVydGllcyk7XG4gICAgfVxufVxuXG4vKipcbiAqIHNpbXBsZSBmdW5jdGlvbiBiaW5kXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICogQHBhcmFtIHtPYmplY3R9IGNvbnRleHRcbiAqIEByZXR1cm5zIHtGdW5jdGlvbn1cbiAqL1xuZnVuY3Rpb24gYmluZEZuKGZuLCBjb250ZXh0KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIGJvdW5kRm4oKSB7XG4gICAgICAgIHJldHVybiBmbi5hcHBseShjb250ZXh0LCBhcmd1bWVudHMpO1xuICAgIH07XG59XG5cbi8qKlxuICogbGV0IGEgYm9vbGVhbiB2YWx1ZSBhbHNvIGJlIGEgZnVuY3Rpb24gdGhhdCBtdXN0IHJldHVybiBhIGJvb2xlYW5cbiAqIHRoaXMgZmlyc3QgaXRlbSBpbiBhcmdzIHdpbGwgYmUgdXNlZCBhcyB0aGUgY29udGV4dFxuICogQHBhcmFtIHtCb29sZWFufEZ1bmN0aW9ufSB2YWxcbiAqIEBwYXJhbSB7QXJyYXl9IFthcmdzXVxuICogQHJldHVybnMge0Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGJvb2xPckZuKHZhbCwgYXJncykge1xuICAgIGlmICh0eXBlb2YgdmFsID09IFRZUEVfRlVOQ1RJT04pIHtcbiAgICAgICAgcmV0dXJuIHZhbC5hcHBseShhcmdzID8gYXJnc1swXSB8fCB1bmRlZmluZWQgOiB1bmRlZmluZWQsIGFyZ3MpO1xuICAgIH1cbiAgICByZXR1cm4gdmFsO1xufVxuXG4vKipcbiAqIHVzZSB0aGUgdmFsMiB3aGVuIHZhbDEgaXMgdW5kZWZpbmVkXG4gKiBAcGFyYW0geyp9IHZhbDFcbiAqIEBwYXJhbSB7Kn0gdmFsMlxuICogQHJldHVybnMgeyp9XG4gKi9cbmZ1bmN0aW9uIGlmVW5kZWZpbmVkKHZhbDEsIHZhbDIpIHtcbiAgICByZXR1cm4gKHZhbDEgPT09IHVuZGVmaW5lZCkgPyB2YWwyIDogdmFsMTtcbn1cblxuLyoqXG4gKiBhZGRFdmVudExpc3RlbmVyIHdpdGggbXVsdGlwbGUgZXZlbnRzIGF0IG9uY2VcbiAqIEBwYXJhbSB7RXZlbnRUYXJnZXR9IHRhcmdldFxuICogQHBhcmFtIHtTdHJpbmd9IHR5cGVzXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYW5kbGVyXG4gKi9cbmZ1bmN0aW9uIGFkZEV2ZW50TGlzdGVuZXJzKHRhcmdldCwgdHlwZXMsIGhhbmRsZXIpIHtcbiAgICBlYWNoKHNwbGl0U3RyKHR5cGVzKSwgZnVuY3Rpb24odHlwZSkge1xuICAgICAgICB0YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBoYW5kbGVyLCBmYWxzZSk7XG4gICAgfSk7XG59XG5cbi8qKlxuICogcmVtb3ZlRXZlbnRMaXN0ZW5lciB3aXRoIG11bHRpcGxlIGV2ZW50cyBhdCBvbmNlXG4gKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fSB0YXJnZXRcbiAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlc1xuICogQHBhcmFtIHtGdW5jdGlvbn0gaGFuZGxlclxuICovXG5mdW5jdGlvbiByZW1vdmVFdmVudExpc3RlbmVycyh0YXJnZXQsIHR5cGVzLCBoYW5kbGVyKSB7XG4gICAgZWFjaChzcGxpdFN0cih0eXBlcyksIGZ1bmN0aW9uKHR5cGUpIHtcbiAgICAgICAgdGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSwgaGFuZGxlciwgZmFsc2UpO1xuICAgIH0pO1xufVxuXG4vKipcbiAqIGZpbmQgaWYgYSBub2RlIGlzIGluIHRoZSBnaXZlbiBwYXJlbnRcbiAqIEBtZXRob2QgaGFzUGFyZW50XG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBub2RlXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBwYXJlbnRcbiAqIEByZXR1cm4ge0Jvb2xlYW59IGZvdW5kXG4gKi9cbmZ1bmN0aW9uIGhhc1BhcmVudChub2RlLCBwYXJlbnQpIHtcbiAgICB3aGlsZSAobm9kZSkge1xuICAgICAgICBpZiAobm9kZSA9PSBwYXJlbnQpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIG5vZGUgPSBub2RlLnBhcmVudE5vZGU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cblxuLyoqXG4gKiBzbWFsbCBpbmRleE9mIHdyYXBwZXJcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBmaW5kXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gZm91bmRcbiAqL1xuZnVuY3Rpb24gaW5TdHIoc3RyLCBmaW5kKSB7XG4gICAgcmV0dXJuIHN0ci5pbmRleE9mKGZpbmQpID4gLTE7XG59XG5cbi8qKlxuICogc3BsaXQgc3RyaW5nIG9uIHdoaXRlc3BhY2VcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm5zIHtBcnJheX0gd29yZHNcbiAqL1xuZnVuY3Rpb24gc3BsaXRTdHIoc3RyKSB7XG4gICAgcmV0dXJuIHN0ci50cmltKCkuc3BsaXQoL1xccysvZyk7XG59XG5cbi8qKlxuICogZmluZCBpZiBhIGFycmF5IGNvbnRhaW5zIHRoZSBvYmplY3QgdXNpbmcgaW5kZXhPZiBvciBhIHNpbXBsZSBwb2x5RmlsbFxuICogQHBhcmFtIHtBcnJheX0gc3JjXG4gKiBAcGFyYW0ge1N0cmluZ30gZmluZFxuICogQHBhcmFtIHtTdHJpbmd9IFtmaW5kQnlLZXldXG4gKiBAcmV0dXJuIHtCb29sZWFufE51bWJlcn0gZmFsc2Ugd2hlbiBub3QgZm91bmQsIG9yIHRoZSBpbmRleFxuICovXG5mdW5jdGlvbiBpbkFycmF5KHNyYywgZmluZCwgZmluZEJ5S2V5KSB7XG4gICAgaWYgKHNyYy5pbmRleE9mICYmICFmaW5kQnlLZXkpIHtcbiAgICAgICAgcmV0dXJuIHNyYy5pbmRleE9mKGZpbmQpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBpID0gMDtcbiAgICAgICAgd2hpbGUgKGkgPCBzcmMubGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAoKGZpbmRCeUtleSAmJiBzcmNbaV1bZmluZEJ5S2V5XSA9PSBmaW5kKSB8fCAoIWZpbmRCeUtleSAmJiBzcmNbaV0gPT09IGZpbmQpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpKys7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIC0xO1xuICAgIH1cbn1cblxuLyoqXG4gKiBjb252ZXJ0IGFycmF5LWxpa2Ugb2JqZWN0cyB0byByZWFsIGFycmF5c1xuICogQHBhcmFtIHtPYmplY3R9IG9ialxuICogQHJldHVybnMge0FycmF5fVxuICovXG5mdW5jdGlvbiB0b0FycmF5KG9iaikge1xuICAgIHJldHVybiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChvYmosIDApO1xufVxuXG4vKipcbiAqIHVuaXF1ZSBhcnJheSB3aXRoIG9iamVjdHMgYmFzZWQgb24gYSBrZXkgKGxpa2UgJ2lkJykgb3IganVzdCBieSB0aGUgYXJyYXkncyB2YWx1ZVxuICogQHBhcmFtIHtBcnJheX0gc3JjIFt7aWQ6MX0se2lkOjJ9LHtpZDoxfV1cbiAqIEBwYXJhbSB7U3RyaW5nfSBba2V5XVxuICogQHBhcmFtIHtCb29sZWFufSBbc29ydD1GYWxzZV1cbiAqIEByZXR1cm5zIHtBcnJheX0gW3tpZDoxfSx7aWQ6Mn1dXG4gKi9cbmZ1bmN0aW9uIHVuaXF1ZUFycmF5KHNyYywga2V5LCBzb3J0KSB7XG4gICAgdmFyIHJlc3VsdHMgPSBbXTtcbiAgICB2YXIgdmFsdWVzID0gW107XG4gICAgdmFyIGkgPSAwO1xuXG4gICAgd2hpbGUgKGkgPCBzcmMubGVuZ3RoKSB7XG4gICAgICAgIHZhciB2YWwgPSBrZXkgPyBzcmNbaV1ba2V5XSA6IHNyY1tpXTtcbiAgICAgICAgaWYgKGluQXJyYXkodmFsdWVzLCB2YWwpIDwgMCkge1xuICAgICAgICAgICAgcmVzdWx0cy5wdXNoKHNyY1tpXSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFsdWVzW2ldID0gdmFsO1xuICAgICAgICBpKys7XG4gICAgfVxuXG4gICAgaWYgKHNvcnQpIHtcbiAgICAgICAgaWYgKCFrZXkpIHtcbiAgICAgICAgICAgIHJlc3VsdHMgPSByZXN1bHRzLnNvcnQoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdHMgPSByZXN1bHRzLnNvcnQoZnVuY3Rpb24gc29ydFVuaXF1ZUFycmF5KGEsIGIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYVtrZXldID4gYltrZXldO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0cztcbn1cblxuLyoqXG4gKiBnZXQgdGhlIHByZWZpeGVkIHByb3BlcnR5XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqXG4gKiBAcGFyYW0ge1N0cmluZ30gcHJvcGVydHlcbiAqIEByZXR1cm5zIHtTdHJpbmd8VW5kZWZpbmVkfSBwcmVmaXhlZFxuICovXG5mdW5jdGlvbiBwcmVmaXhlZChvYmosIHByb3BlcnR5KSB7XG4gICAgdmFyIHByZWZpeCwgcHJvcDtcbiAgICB2YXIgY2FtZWxQcm9wID0gcHJvcGVydHlbMF0udG9VcHBlckNhc2UoKSArIHByb3BlcnR5LnNsaWNlKDEpO1xuXG4gICAgdmFyIGkgPSAwO1xuICAgIHdoaWxlIChpIDwgVkVORE9SX1BSRUZJWEVTLmxlbmd0aCkge1xuICAgICAgICBwcmVmaXggPSBWRU5ET1JfUFJFRklYRVNbaV07XG4gICAgICAgIHByb3AgPSAocHJlZml4KSA/IHByZWZpeCArIGNhbWVsUHJvcCA6IHByb3BlcnR5O1xuXG4gICAgICAgIGlmIChwcm9wIGluIG9iaikge1xuICAgICAgICAgICAgcmV0dXJuIHByb3A7XG4gICAgICAgIH1cbiAgICAgICAgaSsrO1xuICAgIH1cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xufVxuXG4vKipcbiAqIGdldCBhIHVuaXF1ZSBpZFxuICogQHJldHVybnMge251bWJlcn0gdW5pcXVlSWRcbiAqL1xudmFyIF91bmlxdWVJZCA9IDE7XG5mdW5jdGlvbiB1bmlxdWVJZCgpIHtcbiAgICByZXR1cm4gX3VuaXF1ZUlkKys7XG59XG5cbi8qKlxuICogZ2V0IHRoZSB3aW5kb3cgb2JqZWN0IG9mIGFuIGVsZW1lbnRcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnRcbiAqIEByZXR1cm5zIHtEb2N1bWVudFZpZXd8V2luZG93fVxuICovXG5mdW5jdGlvbiBnZXRXaW5kb3dGb3JFbGVtZW50KGVsZW1lbnQpIHtcbiAgICB2YXIgZG9jID0gZWxlbWVudC5vd25lckRvY3VtZW50IHx8IGVsZW1lbnQ7XG4gICAgcmV0dXJuIChkb2MuZGVmYXVsdFZpZXcgfHwgZG9jLnBhcmVudFdpbmRvdyB8fCB3aW5kb3cpO1xufVxuXG52YXIgTU9CSUxFX1JFR0VYID0gL21vYmlsZXx0YWJsZXR8aXAoYWR8aG9uZXxvZCl8YW5kcm9pZC9pO1xuXG52YXIgU1VQUE9SVF9UT1VDSCA9ICgnb250b3VjaHN0YXJ0JyBpbiB3aW5kb3cpO1xudmFyIFNVUFBPUlRfUE9JTlRFUl9FVkVOVFMgPSBwcmVmaXhlZCh3aW5kb3csICdQb2ludGVyRXZlbnQnKSAhPT0gdW5kZWZpbmVkO1xudmFyIFNVUFBPUlRfT05MWV9UT1VDSCA9IFNVUFBPUlRfVE9VQ0ggJiYgTU9CSUxFX1JFR0VYLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG5cbnZhciBJTlBVVF9UWVBFX1RPVUNIID0gJ3RvdWNoJztcbnZhciBJTlBVVF9UWVBFX1BFTiA9ICdwZW4nO1xudmFyIElOUFVUX1RZUEVfTU9VU0UgPSAnbW91c2UnO1xudmFyIElOUFVUX1RZUEVfS0lORUNUID0gJ2tpbmVjdCc7XG5cbnZhciBDT01QVVRFX0lOVEVSVkFMID0gMjU7XG5cbnZhciBJTlBVVF9TVEFSVCA9IDE7XG52YXIgSU5QVVRfTU9WRSA9IDI7XG52YXIgSU5QVVRfRU5EID0gNDtcbnZhciBJTlBVVF9DQU5DRUwgPSA4O1xuXG52YXIgRElSRUNUSU9OX05PTkUgPSAxO1xudmFyIERJUkVDVElPTl9MRUZUID0gMjtcbnZhciBESVJFQ1RJT05fUklHSFQgPSA0O1xudmFyIERJUkVDVElPTl9VUCA9IDg7XG52YXIgRElSRUNUSU9OX0RPV04gPSAxNjtcblxudmFyIERJUkVDVElPTl9IT1JJWk9OVEFMID0gRElSRUNUSU9OX0xFRlQgfCBESVJFQ1RJT05fUklHSFQ7XG52YXIgRElSRUNUSU9OX1ZFUlRJQ0FMID0gRElSRUNUSU9OX1VQIHwgRElSRUNUSU9OX0RPV047XG52YXIgRElSRUNUSU9OX0FMTCA9IERJUkVDVElPTl9IT1JJWk9OVEFMIHwgRElSRUNUSU9OX1ZFUlRJQ0FMO1xuXG52YXIgUFJPUFNfWFkgPSBbJ3gnLCAneSddO1xudmFyIFBST1BTX0NMSUVOVF9YWSA9IFsnY2xpZW50WCcsICdjbGllbnRZJ107XG5cbi8qKlxuICogY3JlYXRlIG5ldyBpbnB1dCB0eXBlIG1hbmFnZXJcbiAqIEBwYXJhbSB7TWFuYWdlcn0gbWFuYWdlclxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAqIEByZXR1cm5zIHtJbnB1dH1cbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBJbnB1dChtYW5hZ2VyLCBjYWxsYmFjaykge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB0aGlzLm1hbmFnZXIgPSBtYW5hZ2VyO1xuICAgIHRoaXMuY2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICB0aGlzLmVsZW1lbnQgPSBtYW5hZ2VyLmVsZW1lbnQ7XG4gICAgdGhpcy50YXJnZXQgPSBtYW5hZ2VyLm9wdGlvbnMuaW5wdXRUYXJnZXQ7XG5cbiAgICAvLyBzbWFsbGVyIHdyYXBwZXIgYXJvdW5kIHRoZSBoYW5kbGVyLCBmb3IgdGhlIHNjb3BlIGFuZCB0aGUgZW5hYmxlZCBzdGF0ZSBvZiB0aGUgbWFuYWdlcixcbiAgICAvLyBzbyB3aGVuIGRpc2FibGVkIHRoZSBpbnB1dCBldmVudHMgYXJlIGNvbXBsZXRlbHkgYnlwYXNzZWQuXG4gICAgdGhpcy5kb21IYW5kbGVyID0gZnVuY3Rpb24oZXYpIHtcbiAgICAgICAgaWYgKGJvb2xPckZuKG1hbmFnZXIub3B0aW9ucy5lbmFibGUsIFttYW5hZ2VyXSkpIHtcbiAgICAgICAgICAgIHNlbGYuaGFuZGxlcihldik7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgdGhpcy5pbml0KCk7XG5cbn1cblxuSW5wdXQucHJvdG90eXBlID0ge1xuICAgIC8qKlxuICAgICAqIHNob3VsZCBoYW5kbGUgdGhlIGlucHV0RXZlbnQgZGF0YSBhbmQgdHJpZ2dlciB0aGUgY2FsbGJhY2tcbiAgICAgKiBAdmlydHVhbFxuICAgICAqL1xuICAgIGhhbmRsZXI6IGZ1bmN0aW9uKCkgeyB9LFxuXG4gICAgLyoqXG4gICAgICogYmluZCB0aGUgZXZlbnRzXG4gICAgICovXG4gICAgaW5pdDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuZXZFbCAmJiBhZGRFdmVudExpc3RlbmVycyh0aGlzLmVsZW1lbnQsIHRoaXMuZXZFbCwgdGhpcy5kb21IYW5kbGVyKTtcbiAgICAgICAgdGhpcy5ldlRhcmdldCAmJiBhZGRFdmVudExpc3RlbmVycyh0aGlzLnRhcmdldCwgdGhpcy5ldlRhcmdldCwgdGhpcy5kb21IYW5kbGVyKTtcbiAgICAgICAgdGhpcy5ldldpbiAmJiBhZGRFdmVudExpc3RlbmVycyhnZXRXaW5kb3dGb3JFbGVtZW50KHRoaXMuZWxlbWVudCksIHRoaXMuZXZXaW4sIHRoaXMuZG9tSGFuZGxlcik7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIHVuYmluZCB0aGUgZXZlbnRzXG4gICAgICovXG4gICAgZGVzdHJveTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuZXZFbCAmJiByZW1vdmVFdmVudExpc3RlbmVycyh0aGlzLmVsZW1lbnQsIHRoaXMuZXZFbCwgdGhpcy5kb21IYW5kbGVyKTtcbiAgICAgICAgdGhpcy5ldlRhcmdldCAmJiByZW1vdmVFdmVudExpc3RlbmVycyh0aGlzLnRhcmdldCwgdGhpcy5ldlRhcmdldCwgdGhpcy5kb21IYW5kbGVyKTtcbiAgICAgICAgdGhpcy5ldldpbiAmJiByZW1vdmVFdmVudExpc3RlbmVycyhnZXRXaW5kb3dGb3JFbGVtZW50KHRoaXMuZWxlbWVudCksIHRoaXMuZXZXaW4sIHRoaXMuZG9tSGFuZGxlcik7XG4gICAgfVxufTtcblxuLyoqXG4gKiBjcmVhdGUgbmV3IGlucHV0IHR5cGUgbWFuYWdlclxuICogY2FsbGVkIGJ5IHRoZSBNYW5hZ2VyIGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0hhbW1lcn0gbWFuYWdlclxuICogQHJldHVybnMge0lucHV0fVxuICovXG5mdW5jdGlvbiBjcmVhdGVJbnB1dEluc3RhbmNlKG1hbmFnZXIpIHtcbiAgICB2YXIgVHlwZTtcbiAgICB2YXIgaW5wdXRDbGFzcyA9IG1hbmFnZXIub3B0aW9ucy5pbnB1dENsYXNzO1xuXG4gICAgaWYgKGlucHV0Q2xhc3MpIHtcbiAgICAgICAgVHlwZSA9IGlucHV0Q2xhc3M7XG4gICAgfSBlbHNlIGlmIChTVVBQT1JUX1BPSU5URVJfRVZFTlRTKSB7XG4gICAgICAgIFR5cGUgPSBQb2ludGVyRXZlbnRJbnB1dDtcbiAgICB9IGVsc2UgaWYgKFNVUFBPUlRfT05MWV9UT1VDSCkge1xuICAgICAgICBUeXBlID0gVG91Y2hJbnB1dDtcbiAgICB9IGVsc2UgaWYgKCFTVVBQT1JUX1RPVUNIKSB7XG4gICAgICAgIFR5cGUgPSBNb3VzZUlucHV0O1xuICAgIH0gZWxzZSB7XG4gICAgICAgIFR5cGUgPSBUb3VjaE1vdXNlSW5wdXQ7XG4gICAgfVxuICAgIHJldHVybiBuZXcgKFR5cGUpKG1hbmFnZXIsIGlucHV0SGFuZGxlcik7XG59XG5cbi8qKlxuICogaGFuZGxlIGlucHV0IGV2ZW50c1xuICogQHBhcmFtIHtNYW5hZ2VyfSBtYW5hZ2VyXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRUeXBlXG4gKiBAcGFyYW0ge09iamVjdH0gaW5wdXRcbiAqL1xuZnVuY3Rpb24gaW5wdXRIYW5kbGVyKG1hbmFnZXIsIGV2ZW50VHlwZSwgaW5wdXQpIHtcbiAgICB2YXIgcG9pbnRlcnNMZW4gPSBpbnB1dC5wb2ludGVycy5sZW5ndGg7XG4gICAgdmFyIGNoYW5nZWRQb2ludGVyc0xlbiA9IGlucHV0LmNoYW5nZWRQb2ludGVycy5sZW5ndGg7XG4gICAgdmFyIGlzRmlyc3QgPSAoZXZlbnRUeXBlICYgSU5QVVRfU1RBUlQgJiYgKHBvaW50ZXJzTGVuIC0gY2hhbmdlZFBvaW50ZXJzTGVuID09PSAwKSk7XG4gICAgdmFyIGlzRmluYWwgPSAoZXZlbnRUeXBlICYgKElOUFVUX0VORCB8IElOUFVUX0NBTkNFTCkgJiYgKHBvaW50ZXJzTGVuIC0gY2hhbmdlZFBvaW50ZXJzTGVuID09PSAwKSk7XG5cbiAgICBpbnB1dC5pc0ZpcnN0ID0gISFpc0ZpcnN0O1xuICAgIGlucHV0LmlzRmluYWwgPSAhIWlzRmluYWw7XG5cbiAgICBpZiAoaXNGaXJzdCkge1xuICAgICAgICBtYW5hZ2VyLnNlc3Npb24gPSB7fTtcbiAgICB9XG5cbiAgICAvLyBzb3VyY2UgZXZlbnQgaXMgdGhlIG5vcm1hbGl6ZWQgdmFsdWUgb2YgdGhlIGRvbUV2ZW50c1xuICAgIC8vIGxpa2UgJ3RvdWNoc3RhcnQsIG1vdXNldXAsIHBvaW50ZXJkb3duJ1xuICAgIGlucHV0LmV2ZW50VHlwZSA9IGV2ZW50VHlwZTtcblxuICAgIC8vIGNvbXB1dGUgc2NhbGUsIHJvdGF0aW9uIGV0Y1xuICAgIGNvbXB1dGVJbnB1dERhdGEobWFuYWdlciwgaW5wdXQpO1xuXG4gICAgLy8gZW1pdCBzZWNyZXQgZXZlbnRcbiAgICBtYW5hZ2VyLmVtaXQoJ2hhbW1lci5pbnB1dCcsIGlucHV0KTtcblxuICAgIG1hbmFnZXIucmVjb2duaXplKGlucHV0KTtcbiAgICBtYW5hZ2VyLnNlc3Npb24ucHJldklucHV0ID0gaW5wdXQ7XG59XG5cbi8qKlxuICogZXh0ZW5kIHRoZSBkYXRhIHdpdGggc29tZSB1c2FibGUgcHJvcGVydGllcyBsaWtlIHNjYWxlLCByb3RhdGUsIHZlbG9jaXR5IGV0Y1xuICogQHBhcmFtIHtPYmplY3R9IG1hbmFnZXJcbiAqIEBwYXJhbSB7T2JqZWN0fSBpbnB1dFxuICovXG5mdW5jdGlvbiBjb21wdXRlSW5wdXREYXRhKG1hbmFnZXIsIGlucHV0KSB7XG4gICAgdmFyIHNlc3Npb24gPSBtYW5hZ2VyLnNlc3Npb247XG4gICAgdmFyIHBvaW50ZXJzID0gaW5wdXQucG9pbnRlcnM7XG4gICAgdmFyIHBvaW50ZXJzTGVuZ3RoID0gcG9pbnRlcnMubGVuZ3RoO1xuXG4gICAgLy8gc3RvcmUgdGhlIGZpcnN0IGlucHV0IHRvIGNhbGN1bGF0ZSB0aGUgZGlzdGFuY2UgYW5kIGRpcmVjdGlvblxuICAgIGlmICghc2Vzc2lvbi5maXJzdElucHV0KSB7XG4gICAgICAgIHNlc3Npb24uZmlyc3RJbnB1dCA9IHNpbXBsZUNsb25lSW5wdXREYXRhKGlucHV0KTtcbiAgICB9XG5cbiAgICAvLyB0byBjb21wdXRlIHNjYWxlIGFuZCByb3RhdGlvbiB3ZSBuZWVkIHRvIHN0b3JlIHRoZSBtdWx0aXBsZSB0b3VjaGVzXG4gICAgaWYgKHBvaW50ZXJzTGVuZ3RoID4gMSAmJiAhc2Vzc2lvbi5maXJzdE11bHRpcGxlKSB7XG4gICAgICAgIHNlc3Npb24uZmlyc3RNdWx0aXBsZSA9IHNpbXBsZUNsb25lSW5wdXREYXRhKGlucHV0KTtcbiAgICB9IGVsc2UgaWYgKHBvaW50ZXJzTGVuZ3RoID09PSAxKSB7XG4gICAgICAgIHNlc3Npb24uZmlyc3RNdWx0aXBsZSA9IGZhbHNlO1xuICAgIH1cblxuICAgIHZhciBmaXJzdElucHV0ID0gc2Vzc2lvbi5maXJzdElucHV0O1xuICAgIHZhciBmaXJzdE11bHRpcGxlID0gc2Vzc2lvbi5maXJzdE11bHRpcGxlO1xuICAgIHZhciBvZmZzZXRDZW50ZXIgPSBmaXJzdE11bHRpcGxlID8gZmlyc3RNdWx0aXBsZS5jZW50ZXIgOiBmaXJzdElucHV0LmNlbnRlcjtcblxuICAgIHZhciBjZW50ZXIgPSBpbnB1dC5jZW50ZXIgPSBnZXRDZW50ZXIocG9pbnRlcnMpO1xuICAgIGlucHV0LnRpbWVTdGFtcCA9IG5vdygpO1xuICAgIGlucHV0LmRlbHRhVGltZSA9IGlucHV0LnRpbWVTdGFtcCAtIGZpcnN0SW5wdXQudGltZVN0YW1wO1xuXG4gICAgaW5wdXQuYW5nbGUgPSBnZXRBbmdsZShvZmZzZXRDZW50ZXIsIGNlbnRlcik7XG4gICAgaW5wdXQuZGlzdGFuY2UgPSBnZXREaXN0YW5jZShvZmZzZXRDZW50ZXIsIGNlbnRlcik7XG5cbiAgICBjb21wdXRlRGVsdGFYWShzZXNzaW9uLCBpbnB1dCk7XG4gICAgaW5wdXQub2Zmc2V0RGlyZWN0aW9uID0gZ2V0RGlyZWN0aW9uKGlucHV0LmRlbHRhWCwgaW5wdXQuZGVsdGFZKTtcblxuICAgIHZhciBvdmVyYWxsVmVsb2NpdHkgPSBnZXRWZWxvY2l0eShpbnB1dC5kZWx0YVRpbWUsIGlucHV0LmRlbHRhWCwgaW5wdXQuZGVsdGFZKTtcbiAgICBpbnB1dC5vdmVyYWxsVmVsb2NpdHlYID0gb3ZlcmFsbFZlbG9jaXR5Lng7XG4gICAgaW5wdXQub3ZlcmFsbFZlbG9jaXR5WSA9IG92ZXJhbGxWZWxvY2l0eS55O1xuICAgIGlucHV0Lm92ZXJhbGxWZWxvY2l0eSA9IChhYnMob3ZlcmFsbFZlbG9jaXR5LngpID4gYWJzKG92ZXJhbGxWZWxvY2l0eS55KSkgPyBvdmVyYWxsVmVsb2NpdHkueCA6IG92ZXJhbGxWZWxvY2l0eS55O1xuXG4gICAgaW5wdXQuc2NhbGUgPSBmaXJzdE11bHRpcGxlID8gZ2V0U2NhbGUoZmlyc3RNdWx0aXBsZS5wb2ludGVycywgcG9pbnRlcnMpIDogMTtcbiAgICBpbnB1dC5yb3RhdGlvbiA9IGZpcnN0TXVsdGlwbGUgPyBnZXRSb3RhdGlvbihmaXJzdE11bHRpcGxlLnBvaW50ZXJzLCBwb2ludGVycykgOiAwO1xuXG4gICAgaW5wdXQubWF4UG9pbnRlcnMgPSAhc2Vzc2lvbi5wcmV2SW5wdXQgPyBpbnB1dC5wb2ludGVycy5sZW5ndGggOiAoKGlucHV0LnBvaW50ZXJzLmxlbmd0aCA+XG4gICAgICAgIHNlc3Npb24ucHJldklucHV0Lm1heFBvaW50ZXJzKSA/IGlucHV0LnBvaW50ZXJzLmxlbmd0aCA6IHNlc3Npb24ucHJldklucHV0Lm1heFBvaW50ZXJzKTtcblxuICAgIGNvbXB1dGVJbnRlcnZhbElucHV0RGF0YShzZXNzaW9uLCBpbnB1dCk7XG5cbiAgICAvLyBmaW5kIHRoZSBjb3JyZWN0IHRhcmdldFxuICAgIHZhciB0YXJnZXQgPSBtYW5hZ2VyLmVsZW1lbnQ7XG4gICAgaWYgKGhhc1BhcmVudChpbnB1dC5zcmNFdmVudC50YXJnZXQsIHRhcmdldCkpIHtcbiAgICAgICAgdGFyZ2V0ID0gaW5wdXQuc3JjRXZlbnQudGFyZ2V0O1xuICAgIH1cbiAgICBpbnB1dC50YXJnZXQgPSB0YXJnZXQ7XG59XG5cbmZ1bmN0aW9uIGNvbXB1dGVEZWx0YVhZKHNlc3Npb24sIGlucHV0KSB7XG4gICAgdmFyIGNlbnRlciA9IGlucHV0LmNlbnRlcjtcbiAgICB2YXIgb2Zmc2V0ID0gc2Vzc2lvbi5vZmZzZXREZWx0YSB8fCB7fTtcbiAgICB2YXIgcHJldkRlbHRhID0gc2Vzc2lvbi5wcmV2RGVsdGEgfHwge307XG4gICAgdmFyIHByZXZJbnB1dCA9IHNlc3Npb24ucHJldklucHV0IHx8IHt9O1xuXG4gICAgaWYgKGlucHV0LmV2ZW50VHlwZSA9PT0gSU5QVVRfU1RBUlQgfHwgcHJldklucHV0LmV2ZW50VHlwZSA9PT0gSU5QVVRfRU5EKSB7XG4gICAgICAgIHByZXZEZWx0YSA9IHNlc3Npb24ucHJldkRlbHRhID0ge1xuICAgICAgICAgICAgeDogcHJldklucHV0LmRlbHRhWCB8fCAwLFxuICAgICAgICAgICAgeTogcHJldklucHV0LmRlbHRhWSB8fCAwXG4gICAgICAgIH07XG5cbiAgICAgICAgb2Zmc2V0ID0gc2Vzc2lvbi5vZmZzZXREZWx0YSA9IHtcbiAgICAgICAgICAgIHg6IGNlbnRlci54LFxuICAgICAgICAgICAgeTogY2VudGVyLnlcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBpbnB1dC5kZWx0YVggPSBwcmV2RGVsdGEueCArIChjZW50ZXIueCAtIG9mZnNldC54KTtcbiAgICBpbnB1dC5kZWx0YVkgPSBwcmV2RGVsdGEueSArIChjZW50ZXIueSAtIG9mZnNldC55KTtcbn1cblxuLyoqXG4gKiB2ZWxvY2l0eSBpcyBjYWxjdWxhdGVkIGV2ZXJ5IHggbXNcbiAqIEBwYXJhbSB7T2JqZWN0fSBzZXNzaW9uXG4gKiBAcGFyYW0ge09iamVjdH0gaW5wdXRcbiAqL1xuZnVuY3Rpb24gY29tcHV0ZUludGVydmFsSW5wdXREYXRhKHNlc3Npb24sIGlucHV0KSB7XG4gICAgdmFyIGxhc3QgPSBzZXNzaW9uLmxhc3RJbnRlcnZhbCB8fCBpbnB1dCxcbiAgICAgICAgZGVsdGFUaW1lID0gaW5wdXQudGltZVN0YW1wIC0gbGFzdC50aW1lU3RhbXAsXG4gICAgICAgIHZlbG9jaXR5LCB2ZWxvY2l0eVgsIHZlbG9jaXR5WSwgZGlyZWN0aW9uO1xuXG4gICAgaWYgKGlucHV0LmV2ZW50VHlwZSAhPSBJTlBVVF9DQU5DRUwgJiYgKGRlbHRhVGltZSA+IENPTVBVVEVfSU5URVJWQUwgfHwgbGFzdC52ZWxvY2l0eSA9PT0gdW5kZWZpbmVkKSkge1xuICAgICAgICB2YXIgZGVsdGFYID0gaW5wdXQuZGVsdGFYIC0gbGFzdC5kZWx0YVg7XG4gICAgICAgIHZhciBkZWx0YVkgPSBpbnB1dC5kZWx0YVkgLSBsYXN0LmRlbHRhWTtcblxuICAgICAgICB2YXIgdiA9IGdldFZlbG9jaXR5KGRlbHRhVGltZSwgZGVsdGFYLCBkZWx0YVkpO1xuICAgICAgICB2ZWxvY2l0eVggPSB2Lng7XG4gICAgICAgIHZlbG9jaXR5WSA9IHYueTtcbiAgICAgICAgdmVsb2NpdHkgPSAoYWJzKHYueCkgPiBhYnModi55KSkgPyB2LnggOiB2Lnk7XG4gICAgICAgIGRpcmVjdGlvbiA9IGdldERpcmVjdGlvbihkZWx0YVgsIGRlbHRhWSk7XG5cbiAgICAgICAgc2Vzc2lvbi5sYXN0SW50ZXJ2YWwgPSBpbnB1dDtcbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyB1c2UgbGF0ZXN0IHZlbG9jaXR5IGluZm8gaWYgaXQgZG9lc24ndCBvdmVydGFrZSBhIG1pbmltdW0gcGVyaW9kXG4gICAgICAgIHZlbG9jaXR5ID0gbGFzdC52ZWxvY2l0eTtcbiAgICAgICAgdmVsb2NpdHlYID0gbGFzdC52ZWxvY2l0eVg7XG4gICAgICAgIHZlbG9jaXR5WSA9IGxhc3QudmVsb2NpdHlZO1xuICAgICAgICBkaXJlY3Rpb24gPSBsYXN0LmRpcmVjdGlvbjtcbiAgICB9XG5cbiAgICBpbnB1dC52ZWxvY2l0eSA9IHZlbG9jaXR5O1xuICAgIGlucHV0LnZlbG9jaXR5WCA9IHZlbG9jaXR5WDtcbiAgICBpbnB1dC52ZWxvY2l0eVkgPSB2ZWxvY2l0eVk7XG4gICAgaW5wdXQuZGlyZWN0aW9uID0gZGlyZWN0aW9uO1xufVxuXG4vKipcbiAqIGNyZWF0ZSBhIHNpbXBsZSBjbG9uZSBmcm9tIHRoZSBpbnB1dCB1c2VkIGZvciBzdG9yYWdlIG9mIGZpcnN0SW5wdXQgYW5kIGZpcnN0TXVsdGlwbGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBpbnB1dFxuICogQHJldHVybnMge09iamVjdH0gY2xvbmVkSW5wdXREYXRhXG4gKi9cbmZ1bmN0aW9uIHNpbXBsZUNsb25lSW5wdXREYXRhKGlucHV0KSB7XG4gICAgLy8gbWFrZSBhIHNpbXBsZSBjb3B5IG9mIHRoZSBwb2ludGVycyBiZWNhdXNlIHdlIHdpbGwgZ2V0IGEgcmVmZXJlbmNlIGlmIHdlIGRvbid0XG4gICAgLy8gd2Ugb25seSBuZWVkIGNsaWVudFhZIGZvciB0aGUgY2FsY3VsYXRpb25zXG4gICAgdmFyIHBvaW50ZXJzID0gW107XG4gICAgdmFyIGkgPSAwO1xuICAgIHdoaWxlIChpIDwgaW5wdXQucG9pbnRlcnMubGVuZ3RoKSB7XG4gICAgICAgIHBvaW50ZXJzW2ldID0ge1xuICAgICAgICAgICAgY2xpZW50WDogcm91bmQoaW5wdXQucG9pbnRlcnNbaV0uY2xpZW50WCksXG4gICAgICAgICAgICBjbGllbnRZOiByb3VuZChpbnB1dC5wb2ludGVyc1tpXS5jbGllbnRZKVxuICAgICAgICB9O1xuICAgICAgICBpKys7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgdGltZVN0YW1wOiBub3coKSxcbiAgICAgICAgcG9pbnRlcnM6IHBvaW50ZXJzLFxuICAgICAgICBjZW50ZXI6IGdldENlbnRlcihwb2ludGVycyksXG4gICAgICAgIGRlbHRhWDogaW5wdXQuZGVsdGFYLFxuICAgICAgICBkZWx0YVk6IGlucHV0LmRlbHRhWVxuICAgIH07XG59XG5cbi8qKlxuICogZ2V0IHRoZSBjZW50ZXIgb2YgYWxsIHRoZSBwb2ludGVyc1xuICogQHBhcmFtIHtBcnJheX0gcG9pbnRlcnNcbiAqIEByZXR1cm4ge09iamVjdH0gY2VudGVyIGNvbnRhaW5zIGB4YCBhbmQgYHlgIHByb3BlcnRpZXNcbiAqL1xuZnVuY3Rpb24gZ2V0Q2VudGVyKHBvaW50ZXJzKSB7XG4gICAgdmFyIHBvaW50ZXJzTGVuZ3RoID0gcG9pbnRlcnMubGVuZ3RoO1xuXG4gICAgLy8gbm8gbmVlZCB0byBsb29wIHdoZW4gb25seSBvbmUgdG91Y2hcbiAgICBpZiAocG9pbnRlcnNMZW5ndGggPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHg6IHJvdW5kKHBvaW50ZXJzWzBdLmNsaWVudFgpLFxuICAgICAgICAgICAgeTogcm91bmQocG9pbnRlcnNbMF0uY2xpZW50WSlcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICB2YXIgeCA9IDAsIHkgPSAwLCBpID0gMDtcbiAgICB3aGlsZSAoaSA8IHBvaW50ZXJzTGVuZ3RoKSB7XG4gICAgICAgIHggKz0gcG9pbnRlcnNbaV0uY2xpZW50WDtcbiAgICAgICAgeSArPSBwb2ludGVyc1tpXS5jbGllbnRZO1xuICAgICAgICBpKys7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgeDogcm91bmQoeCAvIHBvaW50ZXJzTGVuZ3RoKSxcbiAgICAgICAgeTogcm91bmQoeSAvIHBvaW50ZXJzTGVuZ3RoKVxuICAgIH07XG59XG5cbi8qKlxuICogY2FsY3VsYXRlIHRoZSB2ZWxvY2l0eSBiZXR3ZWVuIHR3byBwb2ludHMuIHVuaXQgaXMgaW4gcHggcGVyIG1zLlxuICogQHBhcmFtIHtOdW1iZXJ9IGRlbHRhVGltZVxuICogQHBhcmFtIHtOdW1iZXJ9IHhcbiAqIEBwYXJhbSB7TnVtYmVyfSB5XG4gKiBAcmV0dXJuIHtPYmplY3R9IHZlbG9jaXR5IGB4YCBhbmQgYHlgXG4gKi9cbmZ1bmN0aW9uIGdldFZlbG9jaXR5KGRlbHRhVGltZSwgeCwgeSkge1xuICAgIHJldHVybiB7XG4gICAgICAgIHg6IHggLyBkZWx0YVRpbWUgfHwgMCxcbiAgICAgICAgeTogeSAvIGRlbHRhVGltZSB8fCAwXG4gICAgfTtcbn1cblxuLyoqXG4gKiBnZXQgdGhlIGRpcmVjdGlvbiBiZXR3ZWVuIHR3byBwb2ludHNcbiAqIEBwYXJhbSB7TnVtYmVyfSB4XG4gKiBAcGFyYW0ge051bWJlcn0geVxuICogQHJldHVybiB7TnVtYmVyfSBkaXJlY3Rpb25cbiAqL1xuZnVuY3Rpb24gZ2V0RGlyZWN0aW9uKHgsIHkpIHtcbiAgICBpZiAoeCA9PT0geSkge1xuICAgICAgICByZXR1cm4gRElSRUNUSU9OX05PTkU7XG4gICAgfVxuXG4gICAgaWYgKGFicyh4KSA+PSBhYnMoeSkpIHtcbiAgICAgICAgcmV0dXJuIHggPCAwID8gRElSRUNUSU9OX0xFRlQgOiBESVJFQ1RJT05fUklHSFQ7XG4gICAgfVxuICAgIHJldHVybiB5IDwgMCA/IERJUkVDVElPTl9VUCA6IERJUkVDVElPTl9ET1dOO1xufVxuXG4vKipcbiAqIGNhbGN1bGF0ZSB0aGUgYWJzb2x1dGUgZGlzdGFuY2UgYmV0d2VlbiB0d28gcG9pbnRzXG4gKiBAcGFyYW0ge09iamVjdH0gcDEge3gsIHl9XG4gKiBAcGFyYW0ge09iamVjdH0gcDIge3gsIHl9XG4gKiBAcGFyYW0ge0FycmF5fSBbcHJvcHNdIGNvbnRhaW5pbmcgeCBhbmQgeSBrZXlzXG4gKiBAcmV0dXJuIHtOdW1iZXJ9IGRpc3RhbmNlXG4gKi9cbmZ1bmN0aW9uIGdldERpc3RhbmNlKHAxLCBwMiwgcHJvcHMpIHtcbiAgICBpZiAoIXByb3BzKSB7XG4gICAgICAgIHByb3BzID0gUFJPUFNfWFk7XG4gICAgfVxuICAgIHZhciB4ID0gcDJbcHJvcHNbMF1dIC0gcDFbcHJvcHNbMF1dLFxuICAgICAgICB5ID0gcDJbcHJvcHNbMV1dIC0gcDFbcHJvcHNbMV1dO1xuXG4gICAgcmV0dXJuIE1hdGguc3FydCgoeCAqIHgpICsgKHkgKiB5KSk7XG59XG5cbi8qKlxuICogY2FsY3VsYXRlIHRoZSBhbmdsZSBiZXR3ZWVuIHR3byBjb29yZGluYXRlc1xuICogQHBhcmFtIHtPYmplY3R9IHAxXG4gKiBAcGFyYW0ge09iamVjdH0gcDJcbiAqIEBwYXJhbSB7QXJyYXl9IFtwcm9wc10gY29udGFpbmluZyB4IGFuZCB5IGtleXNcbiAqIEByZXR1cm4ge051bWJlcn0gYW5nbGVcbiAqL1xuZnVuY3Rpb24gZ2V0QW5nbGUocDEsIHAyLCBwcm9wcykge1xuICAgIGlmICghcHJvcHMpIHtcbiAgICAgICAgcHJvcHMgPSBQUk9QU19YWTtcbiAgICB9XG4gICAgdmFyIHggPSBwMltwcm9wc1swXV0gLSBwMVtwcm9wc1swXV0sXG4gICAgICAgIHkgPSBwMltwcm9wc1sxXV0gLSBwMVtwcm9wc1sxXV07XG4gICAgcmV0dXJuIE1hdGguYXRhbjIoeSwgeCkgKiAxODAgLyBNYXRoLlBJO1xufVxuXG4vKipcbiAqIGNhbGN1bGF0ZSB0aGUgcm90YXRpb24gZGVncmVlcyBiZXR3ZWVuIHR3byBwb2ludGVyc2V0c1xuICogQHBhcmFtIHtBcnJheX0gc3RhcnQgYXJyYXkgb2YgcG9pbnRlcnNcbiAqIEBwYXJhbSB7QXJyYXl9IGVuZCBhcnJheSBvZiBwb2ludGVyc1xuICogQHJldHVybiB7TnVtYmVyfSByb3RhdGlvblxuICovXG5mdW5jdGlvbiBnZXRSb3RhdGlvbihzdGFydCwgZW5kKSB7XG4gICAgcmV0dXJuIGdldEFuZ2xlKGVuZFsxXSwgZW5kWzBdLCBQUk9QU19DTElFTlRfWFkpICsgZ2V0QW5nbGUoc3RhcnRbMV0sIHN0YXJ0WzBdLCBQUk9QU19DTElFTlRfWFkpO1xufVxuXG4vKipcbiAqIGNhbGN1bGF0ZSB0aGUgc2NhbGUgZmFjdG9yIGJldHdlZW4gdHdvIHBvaW50ZXJzZXRzXG4gKiBubyBzY2FsZSBpcyAxLCBhbmQgZ29lcyBkb3duIHRvIDAgd2hlbiBwaW5jaGVkIHRvZ2V0aGVyLCBhbmQgYmlnZ2VyIHdoZW4gcGluY2hlZCBvdXRcbiAqIEBwYXJhbSB7QXJyYXl9IHN0YXJ0IGFycmF5IG9mIHBvaW50ZXJzXG4gKiBAcGFyYW0ge0FycmF5fSBlbmQgYXJyYXkgb2YgcG9pbnRlcnNcbiAqIEByZXR1cm4ge051bWJlcn0gc2NhbGVcbiAqL1xuZnVuY3Rpb24gZ2V0U2NhbGUoc3RhcnQsIGVuZCkge1xuICAgIHJldHVybiBnZXREaXN0YW5jZShlbmRbMF0sIGVuZFsxXSwgUFJPUFNfQ0xJRU5UX1hZKSAvIGdldERpc3RhbmNlKHN0YXJ0WzBdLCBzdGFydFsxXSwgUFJPUFNfQ0xJRU5UX1hZKTtcbn1cblxudmFyIE1PVVNFX0lOUFVUX01BUCA9IHtcbiAgICBtb3VzZWRvd246IElOUFVUX1NUQVJULFxuICAgIG1vdXNlbW92ZTogSU5QVVRfTU9WRSxcbiAgICBtb3VzZXVwOiBJTlBVVF9FTkRcbn07XG5cbnZhciBNT1VTRV9FTEVNRU5UX0VWRU5UUyA9ICdtb3VzZWRvd24nO1xudmFyIE1PVVNFX1dJTkRPV19FVkVOVFMgPSAnbW91c2Vtb3ZlIG1vdXNldXAnO1xuXG4vKipcbiAqIE1vdXNlIGV2ZW50cyBpbnB1dFxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyBJbnB1dFxuICovXG5mdW5jdGlvbiBNb3VzZUlucHV0KCkge1xuICAgIHRoaXMuZXZFbCA9IE1PVVNFX0VMRU1FTlRfRVZFTlRTO1xuICAgIHRoaXMuZXZXaW4gPSBNT1VTRV9XSU5ET1dfRVZFTlRTO1xuXG4gICAgdGhpcy5wcmVzc2VkID0gZmFsc2U7IC8vIG1vdXNlZG93biBzdGF0ZVxuXG4gICAgSW5wdXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuaW5oZXJpdChNb3VzZUlucHV0LCBJbnB1dCwge1xuICAgIC8qKlxuICAgICAqIGhhbmRsZSBtb3VzZSBldmVudHNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZcbiAgICAgKi9cbiAgICBoYW5kbGVyOiBmdW5jdGlvbiBNRWhhbmRsZXIoZXYpIHtcbiAgICAgICAgdmFyIGV2ZW50VHlwZSA9IE1PVVNFX0lOUFVUX01BUFtldi50eXBlXTtcblxuICAgICAgICAvLyBvbiBzdGFydCB3ZSB3YW50IHRvIGhhdmUgdGhlIGxlZnQgbW91c2UgYnV0dG9uIGRvd25cbiAgICAgICAgaWYgKGV2ZW50VHlwZSAmIElOUFVUX1NUQVJUICYmIGV2LmJ1dHRvbiA9PT0gMCkge1xuICAgICAgICAgICAgdGhpcy5wcmVzc2VkID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChldmVudFR5cGUgJiBJTlBVVF9NT1ZFICYmIGV2LndoaWNoICE9PSAxKSB7XG4gICAgICAgICAgICBldmVudFR5cGUgPSBJTlBVVF9FTkQ7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBtb3VzZSBtdXN0IGJlIGRvd25cbiAgICAgICAgaWYgKCF0aGlzLnByZXNzZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChldmVudFR5cGUgJiBJTlBVVF9FTkQpIHtcbiAgICAgICAgICAgIHRoaXMucHJlc3NlZCA9IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5jYWxsYmFjayh0aGlzLm1hbmFnZXIsIGV2ZW50VHlwZSwge1xuICAgICAgICAgICAgcG9pbnRlcnM6IFtldl0sXG4gICAgICAgICAgICBjaGFuZ2VkUG9pbnRlcnM6IFtldl0sXG4gICAgICAgICAgICBwb2ludGVyVHlwZTogSU5QVVRfVFlQRV9NT1VTRSxcbiAgICAgICAgICAgIHNyY0V2ZW50OiBldlxuICAgICAgICB9KTtcbiAgICB9XG59KTtcblxudmFyIFBPSU5URVJfSU5QVVRfTUFQID0ge1xuICAgIHBvaW50ZXJkb3duOiBJTlBVVF9TVEFSVCxcbiAgICBwb2ludGVybW92ZTogSU5QVVRfTU9WRSxcbiAgICBwb2ludGVydXA6IElOUFVUX0VORCxcbiAgICBwb2ludGVyY2FuY2VsOiBJTlBVVF9DQU5DRUwsXG4gICAgcG9pbnRlcm91dDogSU5QVVRfQ0FOQ0VMXG59O1xuXG4vLyBpbiBJRTEwIHRoZSBwb2ludGVyIHR5cGVzIGlzIGRlZmluZWQgYXMgYW4gZW51bVxudmFyIElFMTBfUE9JTlRFUl9UWVBFX0VOVU0gPSB7XG4gICAgMjogSU5QVVRfVFlQRV9UT1VDSCxcbiAgICAzOiBJTlBVVF9UWVBFX1BFTixcbiAgICA0OiBJTlBVVF9UWVBFX01PVVNFLFxuICAgIDU6IElOUFVUX1RZUEVfS0lORUNUIC8vIHNlZSBodHRwczovL3R3aXR0ZXIuY29tL2phY29icm9zc2kvc3RhdHVzLzQ4MDU5NjQzODQ4OTg5MDgxNlxufTtcblxudmFyIFBPSU5URVJfRUxFTUVOVF9FVkVOVFMgPSAncG9pbnRlcmRvd24nO1xudmFyIFBPSU5URVJfV0lORE9XX0VWRU5UUyA9ICdwb2ludGVybW92ZSBwb2ludGVydXAgcG9pbnRlcmNhbmNlbCc7XG5cbi8vIElFMTAgaGFzIHByZWZpeGVkIHN1cHBvcnQsIGFuZCBjYXNlLXNlbnNpdGl2ZVxuaWYgKHdpbmRvdy5NU1BvaW50ZXJFdmVudCAmJiAhd2luZG93LlBvaW50ZXJFdmVudCkge1xuICAgIFBPSU5URVJfRUxFTUVOVF9FVkVOVFMgPSAnTVNQb2ludGVyRG93bic7XG4gICAgUE9JTlRFUl9XSU5ET1dfRVZFTlRTID0gJ01TUG9pbnRlck1vdmUgTVNQb2ludGVyVXAgTVNQb2ludGVyQ2FuY2VsJztcbn1cblxuLyoqXG4gKiBQb2ludGVyIGV2ZW50cyBpbnB1dFxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyBJbnB1dFxuICovXG5mdW5jdGlvbiBQb2ludGVyRXZlbnRJbnB1dCgpIHtcbiAgICB0aGlzLmV2RWwgPSBQT0lOVEVSX0VMRU1FTlRfRVZFTlRTO1xuICAgIHRoaXMuZXZXaW4gPSBQT0lOVEVSX1dJTkRPV19FVkVOVFM7XG5cbiAgICBJbnB1dC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXG4gICAgdGhpcy5zdG9yZSA9ICh0aGlzLm1hbmFnZXIuc2Vzc2lvbi5wb2ludGVyRXZlbnRzID0gW10pO1xufVxuXG5pbmhlcml0KFBvaW50ZXJFdmVudElucHV0LCBJbnB1dCwge1xuICAgIC8qKlxuICAgICAqIGhhbmRsZSBtb3VzZSBldmVudHNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZcbiAgICAgKi9cbiAgICBoYW5kbGVyOiBmdW5jdGlvbiBQRWhhbmRsZXIoZXYpIHtcbiAgICAgICAgdmFyIHN0b3JlID0gdGhpcy5zdG9yZTtcbiAgICAgICAgdmFyIHJlbW92ZVBvaW50ZXIgPSBmYWxzZTtcblxuICAgICAgICB2YXIgZXZlbnRUeXBlTm9ybWFsaXplZCA9IGV2LnR5cGUudG9Mb3dlckNhc2UoKS5yZXBsYWNlKCdtcycsICcnKTtcbiAgICAgICAgdmFyIGV2ZW50VHlwZSA9IFBPSU5URVJfSU5QVVRfTUFQW2V2ZW50VHlwZU5vcm1hbGl6ZWRdO1xuICAgICAgICB2YXIgcG9pbnRlclR5cGUgPSBJRTEwX1BPSU5URVJfVFlQRV9FTlVNW2V2LnBvaW50ZXJUeXBlXSB8fCBldi5wb2ludGVyVHlwZTtcblxuICAgICAgICB2YXIgaXNUb3VjaCA9IChwb2ludGVyVHlwZSA9PSBJTlBVVF9UWVBFX1RPVUNIKTtcblxuICAgICAgICAvLyBnZXQgaW5kZXggb2YgdGhlIGV2ZW50IGluIHRoZSBzdG9yZVxuICAgICAgICB2YXIgc3RvcmVJbmRleCA9IGluQXJyYXkoc3RvcmUsIGV2LnBvaW50ZXJJZCwgJ3BvaW50ZXJJZCcpO1xuXG4gICAgICAgIC8vIHN0YXJ0IGFuZCBtb3VzZSBtdXN0IGJlIGRvd25cbiAgICAgICAgaWYgKGV2ZW50VHlwZSAmIElOUFVUX1NUQVJUICYmIChldi5idXR0b24gPT09IDAgfHwgaXNUb3VjaCkpIHtcbiAgICAgICAgICAgIGlmIChzdG9yZUluZGV4IDwgMCkge1xuICAgICAgICAgICAgICAgIHN0b3JlLnB1c2goZXYpO1xuICAgICAgICAgICAgICAgIHN0b3JlSW5kZXggPSBzdG9yZS5sZW5ndGggLSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGV2ZW50VHlwZSAmIChJTlBVVF9FTkQgfCBJTlBVVF9DQU5DRUwpKSB7XG4gICAgICAgICAgICByZW1vdmVQb2ludGVyID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGl0IG5vdCBmb3VuZCwgc28gdGhlIHBvaW50ZXIgaGFzbid0IGJlZW4gZG93biAoc28gaXQncyBwcm9iYWJseSBhIGhvdmVyKVxuICAgICAgICBpZiAoc3RvcmVJbmRleCA8IDApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHVwZGF0ZSB0aGUgZXZlbnQgaW4gdGhlIHN0b3JlXG4gICAgICAgIHN0b3JlW3N0b3JlSW5kZXhdID0gZXY7XG5cbiAgICAgICAgdGhpcy5jYWxsYmFjayh0aGlzLm1hbmFnZXIsIGV2ZW50VHlwZSwge1xuICAgICAgICAgICAgcG9pbnRlcnM6IHN0b3JlLFxuICAgICAgICAgICAgY2hhbmdlZFBvaW50ZXJzOiBbZXZdLFxuICAgICAgICAgICAgcG9pbnRlclR5cGU6IHBvaW50ZXJUeXBlLFxuICAgICAgICAgICAgc3JjRXZlbnQ6IGV2XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmIChyZW1vdmVQb2ludGVyKSB7XG4gICAgICAgICAgICAvLyByZW1vdmUgZnJvbSB0aGUgc3RvcmVcbiAgICAgICAgICAgIHN0b3JlLnNwbGljZShzdG9yZUluZGV4LCAxKTtcbiAgICAgICAgfVxuICAgIH1cbn0pO1xuXG52YXIgU0lOR0xFX1RPVUNIX0lOUFVUX01BUCA9IHtcbiAgICB0b3VjaHN0YXJ0OiBJTlBVVF9TVEFSVCxcbiAgICB0b3VjaG1vdmU6IElOUFVUX01PVkUsXG4gICAgdG91Y2hlbmQ6IElOUFVUX0VORCxcbiAgICB0b3VjaGNhbmNlbDogSU5QVVRfQ0FOQ0VMXG59O1xuXG52YXIgU0lOR0xFX1RPVUNIX1RBUkdFVF9FVkVOVFMgPSAndG91Y2hzdGFydCc7XG52YXIgU0lOR0xFX1RPVUNIX1dJTkRPV19FVkVOVFMgPSAndG91Y2hzdGFydCB0b3VjaG1vdmUgdG91Y2hlbmQgdG91Y2hjYW5jZWwnO1xuXG4vKipcbiAqIFRvdWNoIGV2ZW50cyBpbnB1dFxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyBJbnB1dFxuICovXG5mdW5jdGlvbiBTaW5nbGVUb3VjaElucHV0KCkge1xuICAgIHRoaXMuZXZUYXJnZXQgPSBTSU5HTEVfVE9VQ0hfVEFSR0VUX0VWRU5UUztcbiAgICB0aGlzLmV2V2luID0gU0lOR0xFX1RPVUNIX1dJTkRPV19FVkVOVFM7XG4gICAgdGhpcy5zdGFydGVkID0gZmFsc2U7XG5cbiAgICBJbnB1dC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5pbmhlcml0KFNpbmdsZVRvdWNoSW5wdXQsIElucHV0LCB7XG4gICAgaGFuZGxlcjogZnVuY3Rpb24gVEVoYW5kbGVyKGV2KSB7XG4gICAgICAgIHZhciB0eXBlID0gU0lOR0xFX1RPVUNIX0lOUFVUX01BUFtldi50eXBlXTtcblxuICAgICAgICAvLyBzaG91bGQgd2UgaGFuZGxlIHRoZSB0b3VjaCBldmVudHM/XG4gICAgICAgIGlmICh0eXBlID09PSBJTlBVVF9TVEFSVCkge1xuICAgICAgICAgICAgdGhpcy5zdGFydGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdGhpcy5zdGFydGVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdG91Y2hlcyA9IG5vcm1hbGl6ZVNpbmdsZVRvdWNoZXMuY2FsbCh0aGlzLCBldiwgdHlwZSk7XG5cbiAgICAgICAgLy8gd2hlbiBkb25lLCByZXNldCB0aGUgc3RhcnRlZCBzdGF0ZVxuICAgICAgICBpZiAodHlwZSAmIChJTlBVVF9FTkQgfCBJTlBVVF9DQU5DRUwpICYmIHRvdWNoZXNbMF0ubGVuZ3RoIC0gdG91Y2hlc1sxXS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMuc3RhcnRlZCA9IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5jYWxsYmFjayh0aGlzLm1hbmFnZXIsIHR5cGUsIHtcbiAgICAgICAgICAgIHBvaW50ZXJzOiB0b3VjaGVzWzBdLFxuICAgICAgICAgICAgY2hhbmdlZFBvaW50ZXJzOiB0b3VjaGVzWzFdLFxuICAgICAgICAgICAgcG9pbnRlclR5cGU6IElOUFVUX1RZUEVfVE9VQ0gsXG4gICAgICAgICAgICBzcmNFdmVudDogZXZcbiAgICAgICAgfSk7XG4gICAgfVxufSk7XG5cbi8qKlxuICogQHRoaXMge1RvdWNoSW5wdXR9XG4gKiBAcGFyYW0ge09iamVjdH0gZXZcbiAqIEBwYXJhbSB7TnVtYmVyfSB0eXBlIGZsYWdcbiAqIEByZXR1cm5zIHt1bmRlZmluZWR8QXJyYXl9IFthbGwsIGNoYW5nZWRdXG4gKi9cbmZ1bmN0aW9uIG5vcm1hbGl6ZVNpbmdsZVRvdWNoZXMoZXYsIHR5cGUpIHtcbiAgICB2YXIgYWxsID0gdG9BcnJheShldi50b3VjaGVzKTtcbiAgICB2YXIgY2hhbmdlZCA9IHRvQXJyYXkoZXYuY2hhbmdlZFRvdWNoZXMpO1xuXG4gICAgaWYgKHR5cGUgJiAoSU5QVVRfRU5EIHwgSU5QVVRfQ0FOQ0VMKSkge1xuICAgICAgICBhbGwgPSB1bmlxdWVBcnJheShhbGwuY29uY2F0KGNoYW5nZWQpLCAnaWRlbnRpZmllcicsIHRydWUpO1xuICAgIH1cblxuICAgIHJldHVybiBbYWxsLCBjaGFuZ2VkXTtcbn1cblxudmFyIFRPVUNIX0lOUFVUX01BUCA9IHtcbiAgICB0b3VjaHN0YXJ0OiBJTlBVVF9TVEFSVCxcbiAgICB0b3VjaG1vdmU6IElOUFVUX01PVkUsXG4gICAgdG91Y2hlbmQ6IElOUFVUX0VORCxcbiAgICB0b3VjaGNhbmNlbDogSU5QVVRfQ0FOQ0VMXG59O1xuXG52YXIgVE9VQ0hfVEFSR0VUX0VWRU5UUyA9ICd0b3VjaHN0YXJ0IHRvdWNobW92ZSB0b3VjaGVuZCB0b3VjaGNhbmNlbCc7XG5cbi8qKlxuICogTXVsdGktdXNlciB0b3VjaCBldmVudHMgaW5wdXRcbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMgSW5wdXRcbiAqL1xuZnVuY3Rpb24gVG91Y2hJbnB1dCgpIHtcbiAgICB0aGlzLmV2VGFyZ2V0ID0gVE9VQ0hfVEFSR0VUX0VWRU5UUztcbiAgICB0aGlzLnRhcmdldElkcyA9IHt9O1xuXG4gICAgSW5wdXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuaW5oZXJpdChUb3VjaElucHV0LCBJbnB1dCwge1xuICAgIGhhbmRsZXI6IGZ1bmN0aW9uIE1URWhhbmRsZXIoZXYpIHtcbiAgICAgICAgdmFyIHR5cGUgPSBUT1VDSF9JTlBVVF9NQVBbZXYudHlwZV07XG4gICAgICAgIHZhciB0b3VjaGVzID0gZ2V0VG91Y2hlcy5jYWxsKHRoaXMsIGV2LCB0eXBlKTtcbiAgICAgICAgaWYgKCF0b3VjaGVzKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmNhbGxiYWNrKHRoaXMubWFuYWdlciwgdHlwZSwge1xuICAgICAgICAgICAgcG9pbnRlcnM6IHRvdWNoZXNbMF0sXG4gICAgICAgICAgICBjaGFuZ2VkUG9pbnRlcnM6IHRvdWNoZXNbMV0sXG4gICAgICAgICAgICBwb2ludGVyVHlwZTogSU5QVVRfVFlQRV9UT1VDSCxcbiAgICAgICAgICAgIHNyY0V2ZW50OiBldlxuICAgICAgICB9KTtcbiAgICB9XG59KTtcblxuLyoqXG4gKiBAdGhpcyB7VG91Y2hJbnB1dH1cbiAqIEBwYXJhbSB7T2JqZWN0fSBldlxuICogQHBhcmFtIHtOdW1iZXJ9IHR5cGUgZmxhZ1xuICogQHJldHVybnMge3VuZGVmaW5lZHxBcnJheX0gW2FsbCwgY2hhbmdlZF1cbiAqL1xuZnVuY3Rpb24gZ2V0VG91Y2hlcyhldiwgdHlwZSkge1xuICAgIHZhciBhbGxUb3VjaGVzID0gdG9BcnJheShldi50b3VjaGVzKTtcbiAgICB2YXIgdGFyZ2V0SWRzID0gdGhpcy50YXJnZXRJZHM7XG5cbiAgICAvLyB3aGVuIHRoZXJlIGlzIG9ubHkgb25lIHRvdWNoLCB0aGUgcHJvY2VzcyBjYW4gYmUgc2ltcGxpZmllZFxuICAgIGlmICh0eXBlICYgKElOUFVUX1NUQVJUIHwgSU5QVVRfTU9WRSkgJiYgYWxsVG91Y2hlcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgdGFyZ2V0SWRzW2FsbFRvdWNoZXNbMF0uaWRlbnRpZmllcl0gPSB0cnVlO1xuICAgICAgICByZXR1cm4gW2FsbFRvdWNoZXMsIGFsbFRvdWNoZXNdO1xuICAgIH1cblxuICAgIHZhciBpLFxuICAgICAgICB0YXJnZXRUb3VjaGVzLFxuICAgICAgICBjaGFuZ2VkVG91Y2hlcyA9IHRvQXJyYXkoZXYuY2hhbmdlZFRvdWNoZXMpLFxuICAgICAgICBjaGFuZ2VkVGFyZ2V0VG91Y2hlcyA9IFtdLFxuICAgICAgICB0YXJnZXQgPSB0aGlzLnRhcmdldDtcblxuICAgIC8vIGdldCB0YXJnZXQgdG91Y2hlcyBmcm9tIHRvdWNoZXNcbiAgICB0YXJnZXRUb3VjaGVzID0gYWxsVG91Y2hlcy5maWx0ZXIoZnVuY3Rpb24odG91Y2gpIHtcbiAgICAgICAgcmV0dXJuIGhhc1BhcmVudCh0b3VjaC50YXJnZXQsIHRhcmdldCk7XG4gICAgfSk7XG5cbiAgICAvLyBjb2xsZWN0IHRvdWNoZXNcbiAgICBpZiAodHlwZSA9PT0gSU5QVVRfU1RBUlQpIHtcbiAgICAgICAgaSA9IDA7XG4gICAgICAgIHdoaWxlIChpIDwgdGFyZ2V0VG91Y2hlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRhcmdldElkc1t0YXJnZXRUb3VjaGVzW2ldLmlkZW50aWZpZXJdID0gdHJ1ZTtcbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIGZpbHRlciBjaGFuZ2VkIHRvdWNoZXMgdG8gb25seSBjb250YWluIHRvdWNoZXMgdGhhdCBleGlzdCBpbiB0aGUgY29sbGVjdGVkIHRhcmdldCBpZHNcbiAgICBpID0gMDtcbiAgICB3aGlsZSAoaSA8IGNoYW5nZWRUb3VjaGVzLmxlbmd0aCkge1xuICAgICAgICBpZiAodGFyZ2V0SWRzW2NoYW5nZWRUb3VjaGVzW2ldLmlkZW50aWZpZXJdKSB7XG4gICAgICAgICAgICBjaGFuZ2VkVGFyZ2V0VG91Y2hlcy5wdXNoKGNoYW5nZWRUb3VjaGVzW2ldKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGNsZWFudXAgcmVtb3ZlZCB0b3VjaGVzXG4gICAgICAgIGlmICh0eXBlICYgKElOUFVUX0VORCB8IElOUFVUX0NBTkNFTCkpIHtcbiAgICAgICAgICAgIGRlbGV0ZSB0YXJnZXRJZHNbY2hhbmdlZFRvdWNoZXNbaV0uaWRlbnRpZmllcl07XG4gICAgICAgIH1cbiAgICAgICAgaSsrO1xuICAgIH1cblxuICAgIGlmICghY2hhbmdlZFRhcmdldFRvdWNoZXMubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICByZXR1cm4gW1xuICAgICAgICAvLyBtZXJnZSB0YXJnZXRUb3VjaGVzIHdpdGggY2hhbmdlZFRhcmdldFRvdWNoZXMgc28gaXQgY29udGFpbnMgQUxMIHRvdWNoZXMsIGluY2x1ZGluZyAnZW5kJyBhbmQgJ2NhbmNlbCdcbiAgICAgICAgdW5pcXVlQXJyYXkodGFyZ2V0VG91Y2hlcy5jb25jYXQoY2hhbmdlZFRhcmdldFRvdWNoZXMpLCAnaWRlbnRpZmllcicsIHRydWUpLFxuICAgICAgICBjaGFuZ2VkVGFyZ2V0VG91Y2hlc1xuICAgIF07XG59XG5cbi8qKlxuICogQ29tYmluZWQgdG91Y2ggYW5kIG1vdXNlIGlucHV0XG4gKlxuICogVG91Y2ggaGFzIGEgaGlnaGVyIHByaW9yaXR5IHRoZW4gbW91c2UsIGFuZCB3aGlsZSB0b3VjaGluZyBubyBtb3VzZSBldmVudHMgYXJlIGFsbG93ZWQuXG4gKiBUaGlzIGJlY2F1c2UgdG91Y2ggZGV2aWNlcyBhbHNvIGVtaXQgbW91c2UgZXZlbnRzIHdoaWxlIGRvaW5nIGEgdG91Y2guXG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyBJbnB1dFxuICovXG5cbnZhciBERURVUF9USU1FT1VUID0gMjUwMDtcbnZhciBERURVUF9ESVNUQU5DRSA9IDI1O1xuXG5mdW5jdGlvbiBUb3VjaE1vdXNlSW5wdXQoKSB7XG4gICAgSW5wdXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblxuICAgIHZhciBoYW5kbGVyID0gYmluZEZuKHRoaXMuaGFuZGxlciwgdGhpcyk7XG4gICAgdGhpcy50b3VjaCA9IG5ldyBUb3VjaElucHV0KHRoaXMubWFuYWdlciwgaGFuZGxlcik7XG4gICAgdGhpcy5tb3VzZSA9IG5ldyBNb3VzZUlucHV0KHRoaXMubWFuYWdlciwgaGFuZGxlcik7XG5cbiAgICB0aGlzLnByaW1hcnlUb3VjaCA9IG51bGw7XG4gICAgdGhpcy5sYXN0VG91Y2hlcyA9IFtdO1xufVxuXG5pbmhlcml0KFRvdWNoTW91c2VJbnB1dCwgSW5wdXQsIHtcbiAgICAvKipcbiAgICAgKiBoYW5kbGUgbW91c2UgYW5kIHRvdWNoIGV2ZW50c1xuICAgICAqIEBwYXJhbSB7SGFtbWVyfSBtYW5hZ2VyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGlucHV0RXZlbnRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gaW5wdXREYXRhXG4gICAgICovXG4gICAgaGFuZGxlcjogZnVuY3Rpb24gVE1FaGFuZGxlcihtYW5hZ2VyLCBpbnB1dEV2ZW50LCBpbnB1dERhdGEpIHtcbiAgICAgICAgdmFyIGlzVG91Y2ggPSAoaW5wdXREYXRhLnBvaW50ZXJUeXBlID09IElOUFVUX1RZUEVfVE9VQ0gpLFxuICAgICAgICAgICAgaXNNb3VzZSA9IChpbnB1dERhdGEucG9pbnRlclR5cGUgPT0gSU5QVVRfVFlQRV9NT1VTRSk7XG5cbiAgICAgICAgaWYgKGlzTW91c2UgJiYgaW5wdXREYXRhLnNvdXJjZUNhcGFiaWxpdGllcyAmJiBpbnB1dERhdGEuc291cmNlQ2FwYWJpbGl0aWVzLmZpcmVzVG91Y2hFdmVudHMpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHdoZW4gd2UncmUgaW4gYSB0b3VjaCBldmVudCwgcmVjb3JkIHRvdWNoZXMgdG8gIGRlLWR1cGUgc3ludGhldGljIG1vdXNlIGV2ZW50XG4gICAgICAgIGlmIChpc1RvdWNoKSB7XG4gICAgICAgICAgICByZWNvcmRUb3VjaGVzLmNhbGwodGhpcywgaW5wdXRFdmVudCwgaW5wdXREYXRhKTtcbiAgICAgICAgfSBlbHNlIGlmIChpc01vdXNlICYmIGlzU3ludGhldGljRXZlbnQuY2FsbCh0aGlzLCBpbnB1dERhdGEpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmNhbGxiYWNrKG1hbmFnZXIsIGlucHV0RXZlbnQsIGlucHV0RGF0YSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIHJlbW92ZSB0aGUgZXZlbnQgbGlzdGVuZXJzXG4gICAgICovXG4gICAgZGVzdHJveTogZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy50b3VjaC5kZXN0cm95KCk7XG4gICAgICAgIHRoaXMubW91c2UuZGVzdHJveSgpO1xuICAgIH1cbn0pO1xuXG5mdW5jdGlvbiByZWNvcmRUb3VjaGVzKGV2ZW50VHlwZSwgZXZlbnREYXRhKSB7XG4gICAgaWYgKGV2ZW50VHlwZSAmIElOUFVUX1NUQVJUKSB7XG4gICAgICAgIHRoaXMucHJpbWFyeVRvdWNoID0gZXZlbnREYXRhLmNoYW5nZWRQb2ludGVyc1swXS5pZGVudGlmaWVyO1xuICAgICAgICBzZXRMYXN0VG91Y2guY2FsbCh0aGlzLCBldmVudERhdGEpO1xuICAgIH0gZWxzZSBpZiAoZXZlbnRUeXBlICYgKElOUFVUX0VORCB8IElOUFVUX0NBTkNFTCkpIHtcbiAgICAgICAgc2V0TGFzdFRvdWNoLmNhbGwodGhpcywgZXZlbnREYXRhKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIHNldExhc3RUb3VjaChldmVudERhdGEpIHtcbiAgICB2YXIgdG91Y2ggPSBldmVudERhdGEuY2hhbmdlZFBvaW50ZXJzWzBdO1xuXG4gICAgaWYgKHRvdWNoLmlkZW50aWZpZXIgPT09IHRoaXMucHJpbWFyeVRvdWNoKSB7XG4gICAgICAgIHZhciBsYXN0VG91Y2ggPSB7eDogdG91Y2guY2xpZW50WCwgeTogdG91Y2guY2xpZW50WX07XG4gICAgICAgIHRoaXMubGFzdFRvdWNoZXMucHVzaChsYXN0VG91Y2gpO1xuICAgICAgICB2YXIgbHRzID0gdGhpcy5sYXN0VG91Y2hlcztcbiAgICAgICAgdmFyIHJlbW92ZUxhc3RUb3VjaCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGkgPSBsdHMuaW5kZXhPZihsYXN0VG91Y2gpO1xuICAgICAgICAgICAgaWYgKGkgPiAtMSkge1xuICAgICAgICAgICAgICAgIGx0cy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHNldFRpbWVvdXQocmVtb3ZlTGFzdFRvdWNoLCBERURVUF9USU1FT1VUKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGlzU3ludGhldGljRXZlbnQoZXZlbnREYXRhKSB7XG4gICAgdmFyIHggPSBldmVudERhdGEuc3JjRXZlbnQuY2xpZW50WCwgeSA9IGV2ZW50RGF0YS5zcmNFdmVudC5jbGllbnRZO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sYXN0VG91Y2hlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgdCA9IHRoaXMubGFzdFRvdWNoZXNbaV07XG4gICAgICAgIHZhciBkeCA9IE1hdGguYWJzKHggLSB0LngpLCBkeSA9IE1hdGguYWJzKHkgLSB0LnkpO1xuICAgICAgICBpZiAoZHggPD0gREVEVVBfRElTVEFOQ0UgJiYgZHkgPD0gREVEVVBfRElTVEFOQ0UpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cblxudmFyIFBSRUZJWEVEX1RPVUNIX0FDVElPTiA9IHByZWZpeGVkKFRFU1RfRUxFTUVOVC5zdHlsZSwgJ3RvdWNoQWN0aW9uJyk7XG52YXIgTkFUSVZFX1RPVUNIX0FDVElPTiA9IFBSRUZJWEVEX1RPVUNIX0FDVElPTiAhPT0gdW5kZWZpbmVkO1xuXG4vLyBtYWdpY2FsIHRvdWNoQWN0aW9uIHZhbHVlXG52YXIgVE9VQ0hfQUNUSU9OX0NPTVBVVEUgPSAnY29tcHV0ZSc7XG52YXIgVE9VQ0hfQUNUSU9OX0FVVE8gPSAnYXV0byc7XG52YXIgVE9VQ0hfQUNUSU9OX01BTklQVUxBVElPTiA9ICdtYW5pcHVsYXRpb24nOyAvLyBub3QgaW1wbGVtZW50ZWRcbnZhciBUT1VDSF9BQ1RJT05fTk9ORSA9ICdub25lJztcbnZhciBUT1VDSF9BQ1RJT05fUEFOX1ggPSAncGFuLXgnO1xudmFyIFRPVUNIX0FDVElPTl9QQU5fWSA9ICdwYW4teSc7XG52YXIgVE9VQ0hfQUNUSU9OX01BUCA9IGdldFRvdWNoQWN0aW9uUHJvcHMoKTtcblxuLyoqXG4gKiBUb3VjaCBBY3Rpb25cbiAqIHNldHMgdGhlIHRvdWNoQWN0aW9uIHByb3BlcnR5IG9yIHVzZXMgdGhlIGpzIGFsdGVybmF0aXZlXG4gKiBAcGFyYW0ge01hbmFnZXJ9IG1hbmFnZXJcbiAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZVxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIFRvdWNoQWN0aW9uKG1hbmFnZXIsIHZhbHVlKSB7XG4gICAgdGhpcy5tYW5hZ2VyID0gbWFuYWdlcjtcbiAgICB0aGlzLnNldCh2YWx1ZSk7XG59XG5cblRvdWNoQWN0aW9uLnByb3RvdHlwZSA9IHtcbiAgICAvKipcbiAgICAgKiBzZXQgdGhlIHRvdWNoQWN0aW9uIHZhbHVlIG9uIHRoZSBlbGVtZW50IG9yIGVuYWJsZSB0aGUgcG9seWZpbGxcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdmFsdWVcbiAgICAgKi9cbiAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIC8vIGZpbmQgb3V0IHRoZSB0b3VjaC1hY3Rpb24gYnkgdGhlIGV2ZW50IGhhbmRsZXJzXG4gICAgICAgIGlmICh2YWx1ZSA9PSBUT1VDSF9BQ1RJT05fQ09NUFVURSkge1xuICAgICAgICAgICAgdmFsdWUgPSB0aGlzLmNvbXB1dGUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChOQVRJVkVfVE9VQ0hfQUNUSU9OICYmIHRoaXMubWFuYWdlci5lbGVtZW50LnN0eWxlICYmIFRPVUNIX0FDVElPTl9NQVBbdmFsdWVdKSB7XG4gICAgICAgICAgICB0aGlzLm1hbmFnZXIuZWxlbWVudC5zdHlsZVtQUkVGSVhFRF9UT1VDSF9BQ1RJT05dID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5hY3Rpb25zID0gdmFsdWUudG9Mb3dlckNhc2UoKS50cmltKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIGp1c3QgcmUtc2V0IHRoZSB0b3VjaEFjdGlvbiB2YWx1ZVxuICAgICAqL1xuICAgIHVwZGF0ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuc2V0KHRoaXMubWFuYWdlci5vcHRpb25zLnRvdWNoQWN0aW9uKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogY29tcHV0ZSB0aGUgdmFsdWUgZm9yIHRoZSB0b3VjaEFjdGlvbiBwcm9wZXJ0eSBiYXNlZCBvbiB0aGUgcmVjb2duaXplcidzIHNldHRpbmdzXG4gICAgICogQHJldHVybnMge1N0cmluZ30gdmFsdWVcbiAgICAgKi9cbiAgICBjb21wdXRlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGFjdGlvbnMgPSBbXTtcbiAgICAgICAgZWFjaCh0aGlzLm1hbmFnZXIucmVjb2duaXplcnMsIGZ1bmN0aW9uKHJlY29nbml6ZXIpIHtcbiAgICAgICAgICAgIGlmIChib29sT3JGbihyZWNvZ25pemVyLm9wdGlvbnMuZW5hYmxlLCBbcmVjb2duaXplcl0pKSB7XG4gICAgICAgICAgICAgICAgYWN0aW9ucyA9IGFjdGlvbnMuY29uY2F0KHJlY29nbml6ZXIuZ2V0VG91Y2hBY3Rpb24oKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gY2xlYW5Ub3VjaEFjdGlvbnMoYWN0aW9ucy5qb2luKCcgJykpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiB0aGlzIG1ldGhvZCBpcyBjYWxsZWQgb24gZWFjaCBpbnB1dCBjeWNsZSBhbmQgcHJvdmlkZXMgdGhlIHByZXZlbnRpbmcgb2YgdGhlIGJyb3dzZXIgYmVoYXZpb3JcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gaW5wdXRcbiAgICAgKi9cbiAgICBwcmV2ZW50RGVmYXVsdHM6IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgICAgIHZhciBzcmNFdmVudCA9IGlucHV0LnNyY0V2ZW50O1xuICAgICAgICB2YXIgZGlyZWN0aW9uID0gaW5wdXQub2Zmc2V0RGlyZWN0aW9uO1xuXG4gICAgICAgIC8vIGlmIHRoZSB0b3VjaCBhY3Rpb24gZGlkIHByZXZlbnRlZCBvbmNlIHRoaXMgc2Vzc2lvblxuICAgICAgICBpZiAodGhpcy5tYW5hZ2VyLnNlc3Npb24ucHJldmVudGVkKSB7XG4gICAgICAgICAgICBzcmNFdmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGFjdGlvbnMgPSB0aGlzLmFjdGlvbnM7XG4gICAgICAgIHZhciBoYXNOb25lID0gaW5TdHIoYWN0aW9ucywgVE9VQ0hfQUNUSU9OX05PTkUpICYmICFUT1VDSF9BQ1RJT05fTUFQW1RPVUNIX0FDVElPTl9OT05FXTtcbiAgICAgICAgdmFyIGhhc1BhblkgPSBpblN0cihhY3Rpb25zLCBUT1VDSF9BQ1RJT05fUEFOX1kpICYmICFUT1VDSF9BQ1RJT05fTUFQW1RPVUNIX0FDVElPTl9QQU5fWV07XG4gICAgICAgIHZhciBoYXNQYW5YID0gaW5TdHIoYWN0aW9ucywgVE9VQ0hfQUNUSU9OX1BBTl9YKSAmJiAhVE9VQ0hfQUNUSU9OX01BUFtUT1VDSF9BQ1RJT05fUEFOX1hdO1xuXG4gICAgICAgIGlmIChoYXNOb25lKSB7XG4gICAgICAgICAgICAvL2RvIG5vdCBwcmV2ZW50IGRlZmF1bHRzIGlmIHRoaXMgaXMgYSB0YXAgZ2VzdHVyZVxuXG4gICAgICAgICAgICB2YXIgaXNUYXBQb2ludGVyID0gaW5wdXQucG9pbnRlcnMubGVuZ3RoID09PSAxO1xuICAgICAgICAgICAgdmFyIGlzVGFwTW92ZW1lbnQgPSBpbnB1dC5kaXN0YW5jZSA8IDI7XG4gICAgICAgICAgICB2YXIgaXNUYXBUb3VjaFRpbWUgPSBpbnB1dC5kZWx0YVRpbWUgPCAyNTA7XG5cbiAgICAgICAgICAgIGlmIChpc1RhcFBvaW50ZXIgJiYgaXNUYXBNb3ZlbWVudCAmJiBpc1RhcFRvdWNoVGltZSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChoYXNQYW5YICYmIGhhc1BhblkpIHtcbiAgICAgICAgICAgIC8vIGBwYW4teCBwYW4teWAgbWVhbnMgYnJvd3NlciBoYW5kbGVzIGFsbCBzY3JvbGxpbmcvcGFubmluZywgZG8gbm90IHByZXZlbnRcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChoYXNOb25lIHx8XG4gICAgICAgICAgICAoaGFzUGFuWSAmJiBkaXJlY3Rpb24gJiBESVJFQ1RJT05fSE9SSVpPTlRBTCkgfHxcbiAgICAgICAgICAgIChoYXNQYW5YICYmIGRpcmVjdGlvbiAmIERJUkVDVElPTl9WRVJUSUNBTCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnByZXZlbnRTcmMoc3JjRXZlbnQpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIGNhbGwgcHJldmVudERlZmF1bHQgdG8gcHJldmVudCB0aGUgYnJvd3NlcidzIGRlZmF1bHQgYmVoYXZpb3IgKHNjcm9sbGluZyBpbiBtb3N0IGNhc2VzKVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzcmNFdmVudFxuICAgICAqL1xuICAgIHByZXZlbnRTcmM6IGZ1bmN0aW9uKHNyY0V2ZW50KSB7XG4gICAgICAgIHRoaXMubWFuYWdlci5zZXNzaW9uLnByZXZlbnRlZCA9IHRydWU7XG4gICAgICAgIHNyY0V2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgfVxufTtcblxuLyoqXG4gKiB3aGVuIHRoZSB0b3VjaEFjdGlvbnMgYXJlIGNvbGxlY3RlZCB0aGV5IGFyZSBub3QgYSB2YWxpZCB2YWx1ZSwgc28gd2UgbmVlZCB0byBjbGVhbiB0aGluZ3MgdXAuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBhY3Rpb25zXG4gKiBAcmV0dXJucyB7Kn1cbiAqL1xuZnVuY3Rpb24gY2xlYW5Ub3VjaEFjdGlvbnMoYWN0aW9ucykge1xuICAgIC8vIG5vbmVcbiAgICBpZiAoaW5TdHIoYWN0aW9ucywgVE9VQ0hfQUNUSU9OX05PTkUpKSB7XG4gICAgICAgIHJldHVybiBUT1VDSF9BQ1RJT05fTk9ORTtcbiAgICB9XG5cbiAgICB2YXIgaGFzUGFuWCA9IGluU3RyKGFjdGlvbnMsIFRPVUNIX0FDVElPTl9QQU5fWCk7XG4gICAgdmFyIGhhc1BhblkgPSBpblN0cihhY3Rpb25zLCBUT1VDSF9BQ1RJT05fUEFOX1kpO1xuXG4gICAgLy8gaWYgYm90aCBwYW4teCBhbmQgcGFuLXkgYXJlIHNldCAoZGlmZmVyZW50IHJlY29nbml6ZXJzXG4gICAgLy8gZm9yIGRpZmZlcmVudCBkaXJlY3Rpb25zLCBlLmcuIGhvcml6b250YWwgcGFuIGJ1dCB2ZXJ0aWNhbCBzd2lwZT8pXG4gICAgLy8gd2UgbmVlZCBub25lIChhcyBvdGhlcndpc2Ugd2l0aCBwYW4teCBwYW4teSBjb21iaW5lZCBub25lIG9mIHRoZXNlXG4gICAgLy8gcmVjb2duaXplcnMgd2lsbCB3b3JrLCBzaW5jZSB0aGUgYnJvd3NlciB3b3VsZCBoYW5kbGUgYWxsIHBhbm5pbmdcbiAgICBpZiAoaGFzUGFuWCAmJiBoYXNQYW5ZKSB7XG4gICAgICAgIHJldHVybiBUT1VDSF9BQ1RJT05fTk9ORTtcbiAgICB9XG5cbiAgICAvLyBwYW4teCBPUiBwYW4teVxuICAgIGlmIChoYXNQYW5YIHx8IGhhc1BhblkpIHtcbiAgICAgICAgcmV0dXJuIGhhc1BhblggPyBUT1VDSF9BQ1RJT05fUEFOX1ggOiBUT1VDSF9BQ1RJT05fUEFOX1k7XG4gICAgfVxuXG4gICAgLy8gbWFuaXB1bGF0aW9uXG4gICAgaWYgKGluU3RyKGFjdGlvbnMsIFRPVUNIX0FDVElPTl9NQU5JUFVMQVRJT04pKSB7XG4gICAgICAgIHJldHVybiBUT1VDSF9BQ1RJT05fTUFOSVBVTEFUSU9OO1xuICAgIH1cblxuICAgIHJldHVybiBUT1VDSF9BQ1RJT05fQVVUTztcbn1cblxuZnVuY3Rpb24gZ2V0VG91Y2hBY3Rpb25Qcm9wcygpIHtcbiAgICBpZiAoIU5BVElWRV9UT1VDSF9BQ1RJT04pIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB2YXIgdG91Y2hNYXAgPSB7fTtcbiAgICB2YXIgY3NzU3VwcG9ydHMgPSB3aW5kb3cuQ1NTICYmIHdpbmRvdy5DU1Muc3VwcG9ydHM7XG4gICAgWydhdXRvJywgJ21hbmlwdWxhdGlvbicsICdwYW4teScsICdwYW4teCcsICdwYW4teCBwYW4teScsICdub25lJ10uZm9yRWFjaChmdW5jdGlvbih2YWwpIHtcblxuICAgICAgICAvLyBJZiBjc3Muc3VwcG9ydHMgaXMgbm90IHN1cHBvcnRlZCBidXQgdGhlcmUgaXMgbmF0aXZlIHRvdWNoLWFjdGlvbiBhc3N1bWUgaXQgc3VwcG9ydHNcbiAgICAgICAgLy8gYWxsIHZhbHVlcy4gVGhpcyBpcyB0aGUgY2FzZSBmb3IgSUUgMTAgYW5kIDExLlxuICAgICAgICB0b3VjaE1hcFt2YWxdID0gY3NzU3VwcG9ydHMgPyB3aW5kb3cuQ1NTLnN1cHBvcnRzKCd0b3VjaC1hY3Rpb24nLCB2YWwpIDogdHJ1ZTtcbiAgICB9KTtcbiAgICByZXR1cm4gdG91Y2hNYXA7XG59XG5cbi8qKlxuICogUmVjb2duaXplciBmbG93IGV4cGxhaW5lZDsgKlxuICogQWxsIHJlY29nbml6ZXJzIGhhdmUgdGhlIGluaXRpYWwgc3RhdGUgb2YgUE9TU0lCTEUgd2hlbiBhIGlucHV0IHNlc3Npb24gc3RhcnRzLlxuICogVGhlIGRlZmluaXRpb24gb2YgYSBpbnB1dCBzZXNzaW9uIGlzIGZyb20gdGhlIGZpcnN0IGlucHV0IHVudGlsIHRoZSBsYXN0IGlucHV0LCB3aXRoIGFsbCBpdCdzIG1vdmVtZW50IGluIGl0LiAqXG4gKiBFeGFtcGxlIHNlc3Npb24gZm9yIG1vdXNlLWlucHV0OiBtb3VzZWRvd24gLT4gbW91c2Vtb3ZlIC0+IG1vdXNldXBcbiAqXG4gKiBPbiBlYWNoIHJlY29nbml6aW5nIGN5Y2xlIChzZWUgTWFuYWdlci5yZWNvZ25pemUpIHRoZSAucmVjb2duaXplKCkgbWV0aG9kIGlzIGV4ZWN1dGVkXG4gKiB3aGljaCBkZXRlcm1pbmVzIHdpdGggc3RhdGUgaXQgc2hvdWxkIGJlLlxuICpcbiAqIElmIHRoZSByZWNvZ25pemVyIGhhcyB0aGUgc3RhdGUgRkFJTEVELCBDQU5DRUxMRUQgb3IgUkVDT0dOSVpFRCAoZXF1YWxzIEVOREVEKSwgaXQgaXMgcmVzZXQgdG9cbiAqIFBPU1NJQkxFIHRvIGdpdmUgaXQgYW5vdGhlciBjaGFuZ2Ugb24gdGhlIG5leHQgY3ljbGUuXG4gKlxuICogICAgICAgICAgICAgICBQb3NzaWJsZVxuICogICAgICAgICAgICAgICAgICB8XG4gKiAgICAgICAgICAgICstLS0tLSstLS0tLS0tLS0tLS0tLS0rXG4gKiAgICAgICAgICAgIHwgICAgICAgICAgICAgICAgICAgICB8XG4gKiAgICAgICstLS0tLSstLS0tLSsgICAgICAgICAgICAgICB8XG4gKiAgICAgIHwgICAgICAgICAgIHwgICAgICAgICAgICAgICB8XG4gKiAgIEZhaWxlZCAgICAgIENhbmNlbGxlZCAgICAgICAgICB8XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgKy0tLS0tLS0rLS0tLS0tK1xuICogICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgICAgICAgICAgIHxcbiAqICAgICAgICAgICAgICAgICAgICAgIFJlY29nbml6ZWQgICAgICAgQmVnYW5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQ2hhbmdlZFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEVuZGVkL1JlY29nbml6ZWRcbiAqL1xudmFyIFNUQVRFX1BPU1NJQkxFID0gMTtcbnZhciBTVEFURV9CRUdBTiA9IDI7XG52YXIgU1RBVEVfQ0hBTkdFRCA9IDQ7XG52YXIgU1RBVEVfRU5ERUQgPSA4O1xudmFyIFNUQVRFX1JFQ09HTklaRUQgPSBTVEFURV9FTkRFRDtcbnZhciBTVEFURV9DQU5DRUxMRUQgPSAxNjtcbnZhciBTVEFURV9GQUlMRUQgPSAzMjtcblxuLyoqXG4gKiBSZWNvZ25pemVyXG4gKiBFdmVyeSByZWNvZ25pemVyIG5lZWRzIHRvIGV4dGVuZCBmcm9tIHRoaXMgY2xhc3MuXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKi9cbmZ1bmN0aW9uIFJlY29nbml6ZXIob3B0aW9ucykge1xuICAgIHRoaXMub3B0aW9ucyA9IGFzc2lnbih7fSwgdGhpcy5kZWZhdWx0cywgb3B0aW9ucyB8fCB7fSk7XG5cbiAgICB0aGlzLmlkID0gdW5pcXVlSWQoKTtcblxuICAgIHRoaXMubWFuYWdlciA9IG51bGw7XG5cbiAgICAvLyBkZWZhdWx0IGlzIGVuYWJsZSB0cnVlXG4gICAgdGhpcy5vcHRpb25zLmVuYWJsZSA9IGlmVW5kZWZpbmVkKHRoaXMub3B0aW9ucy5lbmFibGUsIHRydWUpO1xuXG4gICAgdGhpcy5zdGF0ZSA9IFNUQVRFX1BPU1NJQkxFO1xuXG4gICAgdGhpcy5zaW11bHRhbmVvdXMgPSB7fTtcbiAgICB0aGlzLnJlcXVpcmVGYWlsID0gW107XG59XG5cblJlY29nbml6ZXIucHJvdG90eXBlID0ge1xuICAgIC8qKlxuICAgICAqIEB2aXJ0dWFsXG4gICAgICogQHR5cGUge09iamVjdH1cbiAgICAgKi9cbiAgICBkZWZhdWx0czoge30sXG5cbiAgICAvKipcbiAgICAgKiBzZXQgb3B0aW9uc1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAgICogQHJldHVybiB7UmVjb2duaXplcn1cbiAgICAgKi9cbiAgICBzZXQ6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgICAgYXNzaWduKHRoaXMub3B0aW9ucywgb3B0aW9ucyk7XG5cbiAgICAgICAgLy8gYWxzbyB1cGRhdGUgdGhlIHRvdWNoQWN0aW9uLCBpbiBjYXNlIHNvbWV0aGluZyBjaGFuZ2VkIGFib3V0IHRoZSBkaXJlY3Rpb25zL2VuYWJsZWQgc3RhdGVcbiAgICAgICAgdGhpcy5tYW5hZ2VyICYmIHRoaXMubWFuYWdlci50b3VjaEFjdGlvbi51cGRhdGUoKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIHJlY29nbml6ZSBzaW11bHRhbmVvdXMgd2l0aCBhbiBvdGhlciByZWNvZ25pemVyLlxuICAgICAqIEBwYXJhbSB7UmVjb2duaXplcn0gb3RoZXJSZWNvZ25pemVyXG4gICAgICogQHJldHVybnMge1JlY29nbml6ZXJ9IHRoaXNcbiAgICAgKi9cbiAgICByZWNvZ25pemVXaXRoOiBmdW5jdGlvbihvdGhlclJlY29nbml6ZXIpIHtcbiAgICAgICAgaWYgKGludm9rZUFycmF5QXJnKG90aGVyUmVjb2duaXplciwgJ3JlY29nbml6ZVdpdGgnLCB0aGlzKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgc2ltdWx0YW5lb3VzID0gdGhpcy5zaW11bHRhbmVvdXM7XG4gICAgICAgIG90aGVyUmVjb2duaXplciA9IGdldFJlY29nbml6ZXJCeU5hbWVJZk1hbmFnZXIob3RoZXJSZWNvZ25pemVyLCB0aGlzKTtcbiAgICAgICAgaWYgKCFzaW11bHRhbmVvdXNbb3RoZXJSZWNvZ25pemVyLmlkXSkge1xuICAgICAgICAgICAgc2ltdWx0YW5lb3VzW290aGVyUmVjb2duaXplci5pZF0gPSBvdGhlclJlY29nbml6ZXI7XG4gICAgICAgICAgICBvdGhlclJlY29nbml6ZXIucmVjb2duaXplV2l0aCh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogZHJvcCB0aGUgc2ltdWx0YW5lb3VzIGxpbmsuIGl0IGRvZXNudCByZW1vdmUgdGhlIGxpbmsgb24gdGhlIG90aGVyIHJlY29nbml6ZXIuXG4gICAgICogQHBhcmFtIHtSZWNvZ25pemVyfSBvdGhlclJlY29nbml6ZXJcbiAgICAgKiBAcmV0dXJucyB7UmVjb2duaXplcn0gdGhpc1xuICAgICAqL1xuICAgIGRyb3BSZWNvZ25pemVXaXRoOiBmdW5jdGlvbihvdGhlclJlY29nbml6ZXIpIHtcbiAgICAgICAgaWYgKGludm9rZUFycmF5QXJnKG90aGVyUmVjb2duaXplciwgJ2Ryb3BSZWNvZ25pemVXaXRoJywgdGhpcykpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG5cbiAgICAgICAgb3RoZXJSZWNvZ25pemVyID0gZ2V0UmVjb2duaXplckJ5TmFtZUlmTWFuYWdlcihvdGhlclJlY29nbml6ZXIsIHRoaXMpO1xuICAgICAgICBkZWxldGUgdGhpcy5zaW11bHRhbmVvdXNbb3RoZXJSZWNvZ25pemVyLmlkXTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIHJlY29nbml6ZXIgY2FuIG9ubHkgcnVuIHdoZW4gYW4gb3RoZXIgaXMgZmFpbGluZ1xuICAgICAqIEBwYXJhbSB7UmVjb2duaXplcn0gb3RoZXJSZWNvZ25pemVyXG4gICAgICogQHJldHVybnMge1JlY29nbml6ZXJ9IHRoaXNcbiAgICAgKi9cbiAgICByZXF1aXJlRmFpbHVyZTogZnVuY3Rpb24ob3RoZXJSZWNvZ25pemVyKSB7XG4gICAgICAgIGlmIChpbnZva2VBcnJheUFyZyhvdGhlclJlY29nbml6ZXIsICdyZXF1aXJlRmFpbHVyZScsIHRoaXMpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciByZXF1aXJlRmFpbCA9IHRoaXMucmVxdWlyZUZhaWw7XG4gICAgICAgIG90aGVyUmVjb2duaXplciA9IGdldFJlY29nbml6ZXJCeU5hbWVJZk1hbmFnZXIob3RoZXJSZWNvZ25pemVyLCB0aGlzKTtcbiAgICAgICAgaWYgKGluQXJyYXkocmVxdWlyZUZhaWwsIG90aGVyUmVjb2duaXplcikgPT09IC0xKSB7XG4gICAgICAgICAgICByZXF1aXJlRmFpbC5wdXNoKG90aGVyUmVjb2duaXplcik7XG4gICAgICAgICAgICBvdGhlclJlY29nbml6ZXIucmVxdWlyZUZhaWx1cmUodGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIGRyb3AgdGhlIHJlcXVpcmVGYWlsdXJlIGxpbmsuIGl0IGRvZXMgbm90IHJlbW92ZSB0aGUgbGluayBvbiB0aGUgb3RoZXIgcmVjb2duaXplci5cbiAgICAgKiBAcGFyYW0ge1JlY29nbml6ZXJ9IG90aGVyUmVjb2duaXplclxuICAgICAqIEByZXR1cm5zIHtSZWNvZ25pemVyfSB0aGlzXG4gICAgICovXG4gICAgZHJvcFJlcXVpcmVGYWlsdXJlOiBmdW5jdGlvbihvdGhlclJlY29nbml6ZXIpIHtcbiAgICAgICAgaWYgKGludm9rZUFycmF5QXJnKG90aGVyUmVjb2duaXplciwgJ2Ryb3BSZXF1aXJlRmFpbHVyZScsIHRoaXMpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuXG4gICAgICAgIG90aGVyUmVjb2duaXplciA9IGdldFJlY29nbml6ZXJCeU5hbWVJZk1hbmFnZXIob3RoZXJSZWNvZ25pemVyLCB0aGlzKTtcbiAgICAgICAgdmFyIGluZGV4ID0gaW5BcnJheSh0aGlzLnJlcXVpcmVGYWlsLCBvdGhlclJlY29nbml6ZXIpO1xuICAgICAgICBpZiAoaW5kZXggPiAtMSkge1xuICAgICAgICAgICAgdGhpcy5yZXF1aXJlRmFpbC5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBoYXMgcmVxdWlyZSBmYWlsdXJlcyBib29sZWFuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgaGFzUmVxdWlyZUZhaWx1cmVzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVxdWlyZUZhaWwubGVuZ3RoID4gMDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogaWYgdGhlIHJlY29nbml6ZXIgY2FuIHJlY29nbml6ZSBzaW11bHRhbmVvdXMgd2l0aCBhbiBvdGhlciByZWNvZ25pemVyXG4gICAgICogQHBhcmFtIHtSZWNvZ25pemVyfSBvdGhlclJlY29nbml6ZXJcbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICBjYW5SZWNvZ25pemVXaXRoOiBmdW5jdGlvbihvdGhlclJlY29nbml6ZXIpIHtcbiAgICAgICAgcmV0dXJuICEhdGhpcy5zaW11bHRhbmVvdXNbb3RoZXJSZWNvZ25pemVyLmlkXTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogWW91IHNob3VsZCB1c2UgYHRyeUVtaXRgIGluc3RlYWQgb2YgYGVtaXRgIGRpcmVjdGx5IHRvIGNoZWNrXG4gICAgICogdGhhdCBhbGwgdGhlIG5lZWRlZCByZWNvZ25pemVycyBoYXMgZmFpbGVkIGJlZm9yZSBlbWl0dGluZy5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gaW5wdXRcbiAgICAgKi9cbiAgICBlbWl0OiBmdW5jdGlvbihpbnB1dCkge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHZhciBzdGF0ZSA9IHRoaXMuc3RhdGU7XG5cbiAgICAgICAgZnVuY3Rpb24gZW1pdChldmVudCkge1xuICAgICAgICAgICAgc2VsZi5tYW5hZ2VyLmVtaXQoZXZlbnQsIGlucHV0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vICdwYW5zdGFydCcgYW5kICdwYW5tb3ZlJ1xuICAgICAgICBpZiAoc3RhdGUgPCBTVEFURV9FTkRFRCkge1xuICAgICAgICAgICAgZW1pdChzZWxmLm9wdGlvbnMuZXZlbnQgKyBzdGF0ZVN0cihzdGF0ZSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgZW1pdChzZWxmLm9wdGlvbnMuZXZlbnQpOyAvLyBzaW1wbGUgJ2V2ZW50TmFtZScgZXZlbnRzXG5cbiAgICAgICAgaWYgKGlucHV0LmFkZGl0aW9uYWxFdmVudCkgeyAvLyBhZGRpdGlvbmFsIGV2ZW50KHBhbmxlZnQsIHBhbnJpZ2h0LCBwaW5jaGluLCBwaW5jaG91dC4uLilcbiAgICAgICAgICAgIGVtaXQoaW5wdXQuYWRkaXRpb25hbEV2ZW50KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHBhbmVuZCBhbmQgcGFuY2FuY2VsXG4gICAgICAgIGlmIChzdGF0ZSA+PSBTVEFURV9FTkRFRCkge1xuICAgICAgICAgICAgZW1pdChzZWxmLm9wdGlvbnMuZXZlbnQgKyBzdGF0ZVN0cihzdGF0ZSkpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENoZWNrIHRoYXQgYWxsIHRoZSByZXF1aXJlIGZhaWx1cmUgcmVjb2duaXplcnMgaGFzIGZhaWxlZCxcbiAgICAgKiBpZiB0cnVlLCBpdCBlbWl0cyBhIGdlc3R1cmUgZXZlbnQsXG4gICAgICogb3RoZXJ3aXNlLCBzZXR1cCB0aGUgc3RhdGUgdG8gRkFJTEVELlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBpbnB1dFxuICAgICAqL1xuICAgIHRyeUVtaXQ6IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgICAgIGlmICh0aGlzLmNhbkVtaXQoKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZW1pdChpbnB1dCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gaXQncyBmYWlsaW5nIGFueXdheVxuICAgICAgICB0aGlzLnN0YXRlID0gU1RBVEVfRkFJTEVEO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBjYW4gd2UgZW1pdD9cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBjYW5FbWl0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGkgPSAwO1xuICAgICAgICB3aGlsZSAoaSA8IHRoaXMucmVxdWlyZUZhaWwubGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAoISh0aGlzLnJlcXVpcmVGYWlsW2ldLnN0YXRlICYgKFNUQVRFX0ZBSUxFRCB8IFNUQVRFX1BPU1NJQkxFKSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpKys7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIHVwZGF0ZSB0aGUgcmVjb2duaXplclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBpbnB1dERhdGFcbiAgICAgKi9cbiAgICByZWNvZ25pemU6IGZ1bmN0aW9uKGlucHV0RGF0YSkge1xuICAgICAgICAvLyBtYWtlIGEgbmV3IGNvcHkgb2YgdGhlIGlucHV0RGF0YVxuICAgICAgICAvLyBzbyB3ZSBjYW4gY2hhbmdlIHRoZSBpbnB1dERhdGEgd2l0aG91dCBtZXNzaW5nIHVwIHRoZSBvdGhlciByZWNvZ25pemVyc1xuICAgICAgICB2YXIgaW5wdXREYXRhQ2xvbmUgPSBhc3NpZ24oe30sIGlucHV0RGF0YSk7XG5cbiAgICAgICAgLy8gaXMgaXMgZW5hYmxlZCBhbmQgYWxsb3cgcmVjb2duaXppbmc/XG4gICAgICAgIGlmICghYm9vbE9yRm4odGhpcy5vcHRpb25zLmVuYWJsZSwgW3RoaXMsIGlucHV0RGF0YUNsb25lXSkpIHtcbiAgICAgICAgICAgIHRoaXMucmVzZXQoKTtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBTVEFURV9GQUlMRUQ7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyByZXNldCB3aGVuIHdlJ3ZlIHJlYWNoZWQgdGhlIGVuZFxuICAgICAgICBpZiAodGhpcy5zdGF0ZSAmIChTVEFURV9SRUNPR05JWkVEIHwgU1RBVEVfQ0FOQ0VMTEVEIHwgU1RBVEVfRkFJTEVEKSkge1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IFNUQVRFX1BPU1NJQkxFO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5zdGF0ZSA9IHRoaXMucHJvY2VzcyhpbnB1dERhdGFDbG9uZSk7XG5cbiAgICAgICAgLy8gdGhlIHJlY29nbml6ZXIgaGFzIHJlY29nbml6ZWQgYSBnZXN0dXJlXG4gICAgICAgIC8vIHNvIHRyaWdnZXIgYW4gZXZlbnRcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUgJiAoU1RBVEVfQkVHQU4gfCBTVEFURV9DSEFOR0VEIHwgU1RBVEVfRU5ERUQgfCBTVEFURV9DQU5DRUxMRUQpKSB7XG4gICAgICAgICAgICB0aGlzLnRyeUVtaXQoaW5wdXREYXRhQ2xvbmUpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIHJldHVybiB0aGUgc3RhdGUgb2YgdGhlIHJlY29nbml6ZXJcbiAgICAgKiB0aGUgYWN0dWFsIHJlY29nbml6aW5nIGhhcHBlbnMgaW4gdGhpcyBtZXRob2RcbiAgICAgKiBAdmlydHVhbFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBpbnB1dERhdGFcbiAgICAgKiBAcmV0dXJucyB7Q29uc3R9IFNUQVRFXG4gICAgICovXG4gICAgcHJvY2VzczogZnVuY3Rpb24oaW5wdXREYXRhKSB7IH0sIC8vIGpzaGludCBpZ25vcmU6bGluZVxuXG4gICAgLyoqXG4gICAgICogcmV0dXJuIHRoZSBwcmVmZXJyZWQgdG91Y2gtYWN0aW9uXG4gICAgICogQHZpcnR1YWxcbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9XG4gICAgICovXG4gICAgZ2V0VG91Y2hBY3Rpb246IGZ1bmN0aW9uKCkgeyB9LFxuXG4gICAgLyoqXG4gICAgICogY2FsbGVkIHdoZW4gdGhlIGdlc3R1cmUgaXNuJ3QgYWxsb3dlZCB0byByZWNvZ25pemVcbiAgICAgKiBsaWtlIHdoZW4gYW5vdGhlciBpcyBiZWluZyByZWNvZ25pemVkIG9yIGl0IGlzIGRpc2FibGVkXG4gICAgICogQHZpcnR1YWxcbiAgICAgKi9cbiAgICByZXNldDogZnVuY3Rpb24oKSB7IH1cbn07XG5cbi8qKlxuICogZ2V0IGEgdXNhYmxlIHN0cmluZywgdXNlZCBhcyBldmVudCBwb3N0Zml4XG4gKiBAcGFyYW0ge0NvbnN0fSBzdGF0ZVxuICogQHJldHVybnMge1N0cmluZ30gc3RhdGVcbiAqL1xuZnVuY3Rpb24gc3RhdGVTdHIoc3RhdGUpIHtcbiAgICBpZiAoc3RhdGUgJiBTVEFURV9DQU5DRUxMRUQpIHtcbiAgICAgICAgcmV0dXJuICdjYW5jZWwnO1xuICAgIH0gZWxzZSBpZiAoc3RhdGUgJiBTVEFURV9FTkRFRCkge1xuICAgICAgICByZXR1cm4gJ2VuZCc7XG4gICAgfSBlbHNlIGlmIChzdGF0ZSAmIFNUQVRFX0NIQU5HRUQpIHtcbiAgICAgICAgcmV0dXJuICdtb3ZlJztcbiAgICB9IGVsc2UgaWYgKHN0YXRlICYgU1RBVEVfQkVHQU4pIHtcbiAgICAgICAgcmV0dXJuICdzdGFydCc7XG4gICAgfVxuICAgIHJldHVybiAnJztcbn1cblxuLyoqXG4gKiBkaXJlY3Rpb24gY29ucyB0byBzdHJpbmdcbiAqIEBwYXJhbSB7Q29uc3R9IGRpcmVjdGlvblxuICogQHJldHVybnMge1N0cmluZ31cbiAqL1xuZnVuY3Rpb24gZGlyZWN0aW9uU3RyKGRpcmVjdGlvbikge1xuICAgIGlmIChkaXJlY3Rpb24gPT0gRElSRUNUSU9OX0RPV04pIHtcbiAgICAgICAgcmV0dXJuICdkb3duJztcbiAgICB9IGVsc2UgaWYgKGRpcmVjdGlvbiA9PSBESVJFQ1RJT05fVVApIHtcbiAgICAgICAgcmV0dXJuICd1cCc7XG4gICAgfSBlbHNlIGlmIChkaXJlY3Rpb24gPT0gRElSRUNUSU9OX0xFRlQpIHtcbiAgICAgICAgcmV0dXJuICdsZWZ0JztcbiAgICB9IGVsc2UgaWYgKGRpcmVjdGlvbiA9PSBESVJFQ1RJT05fUklHSFQpIHtcbiAgICAgICAgcmV0dXJuICdyaWdodCc7XG4gICAgfVxuICAgIHJldHVybiAnJztcbn1cblxuLyoqXG4gKiBnZXQgYSByZWNvZ25pemVyIGJ5IG5hbWUgaWYgaXQgaXMgYm91bmQgdG8gYSBtYW5hZ2VyXG4gKiBAcGFyYW0ge1JlY29nbml6ZXJ8U3RyaW5nfSBvdGhlclJlY29nbml6ZXJcbiAqIEBwYXJhbSB7UmVjb2duaXplcn0gcmVjb2duaXplclxuICogQHJldHVybnMge1JlY29nbml6ZXJ9XG4gKi9cbmZ1bmN0aW9uIGdldFJlY29nbml6ZXJCeU5hbWVJZk1hbmFnZXIob3RoZXJSZWNvZ25pemVyLCByZWNvZ25pemVyKSB7XG4gICAgdmFyIG1hbmFnZXIgPSByZWNvZ25pemVyLm1hbmFnZXI7XG4gICAgaWYgKG1hbmFnZXIpIHtcbiAgICAgICAgcmV0dXJuIG1hbmFnZXIuZ2V0KG90aGVyUmVjb2duaXplcik7XG4gICAgfVxuICAgIHJldHVybiBvdGhlclJlY29nbml6ZXI7XG59XG5cbi8qKlxuICogVGhpcyByZWNvZ25pemVyIGlzIGp1c3QgdXNlZCBhcyBhIGJhc2UgZm9yIHRoZSBzaW1wbGUgYXR0cmlidXRlIHJlY29nbml6ZXJzLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyBSZWNvZ25pemVyXG4gKi9cbmZ1bmN0aW9uIEF0dHJSZWNvZ25pemVyKCkge1xuICAgIFJlY29nbml6ZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuaW5oZXJpdChBdHRyUmVjb2duaXplciwgUmVjb2duaXplciwge1xuICAgIC8qKlxuICAgICAqIEBuYW1lc3BhY2VcbiAgICAgKiBAbWVtYmVyb2YgQXR0clJlY29nbml6ZXJcbiAgICAgKi9cbiAgICBkZWZhdWx0czoge1xuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUge051bWJlcn1cbiAgICAgICAgICogQGRlZmF1bHQgMVxuICAgICAgICAgKi9cbiAgICAgICAgcG9pbnRlcnM6IDFcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVXNlZCB0byBjaGVjayBpZiBpdCB0aGUgcmVjb2duaXplciByZWNlaXZlcyB2YWxpZCBpbnB1dCwgbGlrZSBpbnB1dC5kaXN0YW5jZSA+IDEwLlxuICAgICAqIEBtZW1iZXJvZiBBdHRyUmVjb2duaXplclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBpbnB1dFxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufSByZWNvZ25pemVkXG4gICAgICovXG4gICAgYXR0clRlc3Q6IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgICAgIHZhciBvcHRpb25Qb2ludGVycyA9IHRoaXMub3B0aW9ucy5wb2ludGVycztcbiAgICAgICAgcmV0dXJuIG9wdGlvblBvaW50ZXJzID09PSAwIHx8IGlucHV0LnBvaW50ZXJzLmxlbmd0aCA9PT0gb3B0aW9uUG9pbnRlcnM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFByb2Nlc3MgdGhlIGlucHV0IGFuZCByZXR1cm4gdGhlIHN0YXRlIGZvciB0aGUgcmVjb2duaXplclxuICAgICAqIEBtZW1iZXJvZiBBdHRyUmVjb2duaXplclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBpbnB1dFxuICAgICAqIEByZXR1cm5zIHsqfSBTdGF0ZVxuICAgICAqL1xuICAgIHByb2Nlc3M6IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgICAgIHZhciBzdGF0ZSA9IHRoaXMuc3RhdGU7XG4gICAgICAgIHZhciBldmVudFR5cGUgPSBpbnB1dC5ldmVudFR5cGU7XG5cbiAgICAgICAgdmFyIGlzUmVjb2duaXplZCA9IHN0YXRlICYgKFNUQVRFX0JFR0FOIHwgU1RBVEVfQ0hBTkdFRCk7XG4gICAgICAgIHZhciBpc1ZhbGlkID0gdGhpcy5hdHRyVGVzdChpbnB1dCk7XG5cbiAgICAgICAgLy8gb24gY2FuY2VsIGlucHV0IGFuZCB3ZSd2ZSByZWNvZ25pemVkIGJlZm9yZSwgcmV0dXJuIFNUQVRFX0NBTkNFTExFRFxuICAgICAgICBpZiAoaXNSZWNvZ25pemVkICYmIChldmVudFR5cGUgJiBJTlBVVF9DQU5DRUwgfHwgIWlzVmFsaWQpKSB7XG4gICAgICAgICAgICByZXR1cm4gc3RhdGUgfCBTVEFURV9DQU5DRUxMRUQ7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNSZWNvZ25pemVkIHx8IGlzVmFsaWQpIHtcbiAgICAgICAgICAgIGlmIChldmVudFR5cGUgJiBJTlBVVF9FTkQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RhdGUgfCBTVEFURV9FTkRFRDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIShzdGF0ZSAmIFNUQVRFX0JFR0FOKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBTVEFURV9CRUdBTjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBzdGF0ZSB8IFNUQVRFX0NIQU5HRUQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFNUQVRFX0ZBSUxFRDtcbiAgICB9XG59KTtcblxuLyoqXG4gKiBQYW5cbiAqIFJlY29nbml6ZWQgd2hlbiB0aGUgcG9pbnRlciBpcyBkb3duIGFuZCBtb3ZlZCBpbiB0aGUgYWxsb3dlZCBkaXJlY3Rpb24uXG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIEF0dHJSZWNvZ25pemVyXG4gKi9cbmZ1bmN0aW9uIFBhblJlY29nbml6ZXIoKSB7XG4gICAgQXR0clJlY29nbml6ZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblxuICAgIHRoaXMucFggPSBudWxsO1xuICAgIHRoaXMucFkgPSBudWxsO1xufVxuXG5pbmhlcml0KFBhblJlY29nbml6ZXIsIEF0dHJSZWNvZ25pemVyLCB7XG4gICAgLyoqXG4gICAgICogQG5hbWVzcGFjZVxuICAgICAqIEBtZW1iZXJvZiBQYW5SZWNvZ25pemVyXG4gICAgICovXG4gICAgZGVmYXVsdHM6IHtcbiAgICAgICAgZXZlbnQ6ICdwYW4nLFxuICAgICAgICB0aHJlc2hvbGQ6IDEwLFxuICAgICAgICBwb2ludGVyczogMSxcbiAgICAgICAgZGlyZWN0aW9uOiBESVJFQ1RJT05fQUxMXG4gICAgfSxcblxuICAgIGdldFRvdWNoQWN0aW9uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGRpcmVjdGlvbiA9IHRoaXMub3B0aW9ucy5kaXJlY3Rpb247XG4gICAgICAgIHZhciBhY3Rpb25zID0gW107XG4gICAgICAgIGlmIChkaXJlY3Rpb24gJiBESVJFQ1RJT05fSE9SSVpPTlRBTCkge1xuICAgICAgICAgICAgYWN0aW9ucy5wdXNoKFRPVUNIX0FDVElPTl9QQU5fWSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRpcmVjdGlvbiAmIERJUkVDVElPTl9WRVJUSUNBTCkge1xuICAgICAgICAgICAgYWN0aW9ucy5wdXNoKFRPVUNIX0FDVElPTl9QQU5fWCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFjdGlvbnM7XG4gICAgfSxcblxuICAgIGRpcmVjdGlvblRlc3Q6IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgICAgIHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgICAgICB2YXIgaGFzTW92ZWQgPSB0cnVlO1xuICAgICAgICB2YXIgZGlzdGFuY2UgPSBpbnB1dC5kaXN0YW5jZTtcbiAgICAgICAgdmFyIGRpcmVjdGlvbiA9IGlucHV0LmRpcmVjdGlvbjtcbiAgICAgICAgdmFyIHggPSBpbnB1dC5kZWx0YVg7XG4gICAgICAgIHZhciB5ID0gaW5wdXQuZGVsdGFZO1xuXG4gICAgICAgIC8vIGxvY2sgdG8gYXhpcz9cbiAgICAgICAgaWYgKCEoZGlyZWN0aW9uICYgb3B0aW9ucy5kaXJlY3Rpb24pKSB7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5kaXJlY3Rpb24gJiBESVJFQ1RJT05fSE9SSVpPTlRBTCkge1xuICAgICAgICAgICAgICAgIGRpcmVjdGlvbiA9ICh4ID09PSAwKSA/IERJUkVDVElPTl9OT05FIDogKHggPCAwKSA/IERJUkVDVElPTl9MRUZUIDogRElSRUNUSU9OX1JJR0hUO1xuICAgICAgICAgICAgICAgIGhhc01vdmVkID0geCAhPSB0aGlzLnBYO1xuICAgICAgICAgICAgICAgIGRpc3RhbmNlID0gTWF0aC5hYnMoaW5wdXQuZGVsdGFYKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZGlyZWN0aW9uID0gKHkgPT09IDApID8gRElSRUNUSU9OX05PTkUgOiAoeSA8IDApID8gRElSRUNUSU9OX1VQIDogRElSRUNUSU9OX0RPV047XG4gICAgICAgICAgICAgICAgaGFzTW92ZWQgPSB5ICE9IHRoaXMucFk7XG4gICAgICAgICAgICAgICAgZGlzdGFuY2UgPSBNYXRoLmFicyhpbnB1dC5kZWx0YVkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlucHV0LmRpcmVjdGlvbiA9IGRpcmVjdGlvbjtcbiAgICAgICAgcmV0dXJuIGhhc01vdmVkICYmIGRpc3RhbmNlID4gb3B0aW9ucy50aHJlc2hvbGQgJiYgZGlyZWN0aW9uICYgb3B0aW9ucy5kaXJlY3Rpb247XG4gICAgfSxcblxuICAgIGF0dHJUZXN0OiBmdW5jdGlvbihpbnB1dCkge1xuICAgICAgICByZXR1cm4gQXR0clJlY29nbml6ZXIucHJvdG90eXBlLmF0dHJUZXN0LmNhbGwodGhpcywgaW5wdXQpICYmXG4gICAgICAgICAgICAodGhpcy5zdGF0ZSAmIFNUQVRFX0JFR0FOIHx8ICghKHRoaXMuc3RhdGUgJiBTVEFURV9CRUdBTikgJiYgdGhpcy5kaXJlY3Rpb25UZXN0KGlucHV0KSkpO1xuICAgIH0sXG5cbiAgICBlbWl0OiBmdW5jdGlvbihpbnB1dCkge1xuXG4gICAgICAgIHRoaXMucFggPSBpbnB1dC5kZWx0YVg7XG4gICAgICAgIHRoaXMucFkgPSBpbnB1dC5kZWx0YVk7XG5cbiAgICAgICAgdmFyIGRpcmVjdGlvbiA9IGRpcmVjdGlvblN0cihpbnB1dC5kaXJlY3Rpb24pO1xuXG4gICAgICAgIGlmIChkaXJlY3Rpb24pIHtcbiAgICAgICAgICAgIGlucHV0LmFkZGl0aW9uYWxFdmVudCA9IHRoaXMub3B0aW9ucy5ldmVudCArIGRpcmVjdGlvbjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9zdXBlci5lbWl0LmNhbGwodGhpcywgaW5wdXQpO1xuICAgIH1cbn0pO1xuXG4vKipcbiAqIFBpbmNoXG4gKiBSZWNvZ25pemVkIHdoZW4gdHdvIG9yIG1vcmUgcG9pbnRlcnMgYXJlIG1vdmluZyB0b3dhcmQgKHpvb20taW4pIG9yIGF3YXkgZnJvbSBlYWNoIG90aGVyICh6b29tLW91dCkuXG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIEF0dHJSZWNvZ25pemVyXG4gKi9cbmZ1bmN0aW9uIFBpbmNoUmVjb2duaXplcigpIHtcbiAgICBBdHRyUmVjb2duaXplci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5pbmhlcml0KFBpbmNoUmVjb2duaXplciwgQXR0clJlY29nbml6ZXIsIHtcbiAgICAvKipcbiAgICAgKiBAbmFtZXNwYWNlXG4gICAgICogQG1lbWJlcm9mIFBpbmNoUmVjb2duaXplclxuICAgICAqL1xuICAgIGRlZmF1bHRzOiB7XG4gICAgICAgIGV2ZW50OiAncGluY2gnLFxuICAgICAgICB0aHJlc2hvbGQ6IDAsXG4gICAgICAgIHBvaW50ZXJzOiAyXG4gICAgfSxcblxuICAgIGdldFRvdWNoQWN0aW9uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIFtUT1VDSF9BQ1RJT05fTk9ORV07XG4gICAgfSxcblxuICAgIGF0dHJUZXN0OiBmdW5jdGlvbihpbnB1dCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc3VwZXIuYXR0clRlc3QuY2FsbCh0aGlzLCBpbnB1dCkgJiZcbiAgICAgICAgICAgIChNYXRoLmFicyhpbnB1dC5zY2FsZSAtIDEpID4gdGhpcy5vcHRpb25zLnRocmVzaG9sZCB8fCB0aGlzLnN0YXRlICYgU1RBVEVfQkVHQU4pO1xuICAgIH0sXG5cbiAgICBlbWl0OiBmdW5jdGlvbihpbnB1dCkge1xuICAgICAgICBpZiAoaW5wdXQuc2NhbGUgIT09IDEpIHtcbiAgICAgICAgICAgIHZhciBpbk91dCA9IGlucHV0LnNjYWxlIDwgMSA/ICdpbicgOiAnb3V0JztcbiAgICAgICAgICAgIGlucHV0LmFkZGl0aW9uYWxFdmVudCA9IHRoaXMub3B0aW9ucy5ldmVudCArIGluT3V0O1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3N1cGVyLmVtaXQuY2FsbCh0aGlzLCBpbnB1dCk7XG4gICAgfVxufSk7XG5cbi8qKlxuICogUHJlc3NcbiAqIFJlY29nbml6ZWQgd2hlbiB0aGUgcG9pbnRlciBpcyBkb3duIGZvciB4IG1zIHdpdGhvdXQgYW55IG1vdmVtZW50LlxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyBSZWNvZ25pemVyXG4gKi9cbmZ1bmN0aW9uIFByZXNzUmVjb2duaXplcigpIHtcbiAgICBSZWNvZ25pemVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cbiAgICB0aGlzLl90aW1lciA9IG51bGw7XG4gICAgdGhpcy5faW5wdXQgPSBudWxsO1xufVxuXG5pbmhlcml0KFByZXNzUmVjb2duaXplciwgUmVjb2duaXplciwge1xuICAgIC8qKlxuICAgICAqIEBuYW1lc3BhY2VcbiAgICAgKiBAbWVtYmVyb2YgUHJlc3NSZWNvZ25pemVyXG4gICAgICovXG4gICAgZGVmYXVsdHM6IHtcbiAgICAgICAgZXZlbnQ6ICdwcmVzcycsXG4gICAgICAgIHBvaW50ZXJzOiAxLFxuICAgICAgICB0aW1lOiAyNTEsIC8vIG1pbmltYWwgdGltZSBvZiB0aGUgcG9pbnRlciB0byBiZSBwcmVzc2VkXG4gICAgICAgIHRocmVzaG9sZDogOSAvLyBhIG1pbmltYWwgbW92ZW1lbnQgaXMgb2ssIGJ1dCBrZWVwIGl0IGxvd1xuICAgIH0sXG5cbiAgICBnZXRUb3VjaEFjdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBbVE9VQ0hfQUNUSU9OX0FVVE9dO1xuICAgIH0sXG5cbiAgICBwcm9jZXNzOiBmdW5jdGlvbihpbnB1dCkge1xuICAgICAgICB2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICAgICAgdmFyIHZhbGlkUG9pbnRlcnMgPSBpbnB1dC5wb2ludGVycy5sZW5ndGggPT09IG9wdGlvbnMucG9pbnRlcnM7XG4gICAgICAgIHZhciB2YWxpZE1vdmVtZW50ID0gaW5wdXQuZGlzdGFuY2UgPCBvcHRpb25zLnRocmVzaG9sZDtcbiAgICAgICAgdmFyIHZhbGlkVGltZSA9IGlucHV0LmRlbHRhVGltZSA+IG9wdGlvbnMudGltZTtcblxuICAgICAgICB0aGlzLl9pbnB1dCA9IGlucHV0O1xuXG4gICAgICAgIC8vIHdlIG9ubHkgYWxsb3cgbGl0dGxlIG1vdmVtZW50XG4gICAgICAgIC8vIGFuZCB3ZSd2ZSByZWFjaGVkIGFuIGVuZCBldmVudCwgc28gYSB0YXAgaXMgcG9zc2libGVcbiAgICAgICAgaWYgKCF2YWxpZE1vdmVtZW50IHx8ICF2YWxpZFBvaW50ZXJzIHx8IChpbnB1dC5ldmVudFR5cGUgJiAoSU5QVVRfRU5EIHwgSU5QVVRfQ0FOQ0VMKSAmJiAhdmFsaWRUaW1lKSkge1xuICAgICAgICAgICAgdGhpcy5yZXNldCgpO1xuICAgICAgICB9IGVsc2UgaWYgKGlucHV0LmV2ZW50VHlwZSAmIElOUFVUX1NUQVJUKSB7XG4gICAgICAgICAgICB0aGlzLnJlc2V0KCk7XG4gICAgICAgICAgICB0aGlzLl90aW1lciA9IHNldFRpbWVvdXRDb250ZXh0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBTVEFURV9SRUNPR05JWkVEO1xuICAgICAgICAgICAgICAgIHRoaXMudHJ5RW1pdCgpO1xuICAgICAgICAgICAgfSwgb3B0aW9ucy50aW1lLCB0aGlzKTtcbiAgICAgICAgfSBlbHNlIGlmIChpbnB1dC5ldmVudFR5cGUgJiBJTlBVVF9FTkQpIHtcbiAgICAgICAgICAgIHJldHVybiBTVEFURV9SRUNPR05JWkVEO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBTVEFURV9GQUlMRUQ7XG4gICAgfSxcblxuICAgIHJlc2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuX3RpbWVyKTtcbiAgICB9LFxuXG4gICAgZW1pdDogZnVuY3Rpb24oaW5wdXQpIHtcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUgIT09IFNUQVRFX1JFQ09HTklaRUQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpbnB1dCAmJiAoaW5wdXQuZXZlbnRUeXBlICYgSU5QVVRfRU5EKSkge1xuICAgICAgICAgICAgdGhpcy5tYW5hZ2VyLmVtaXQodGhpcy5vcHRpb25zLmV2ZW50ICsgJ3VwJywgaW5wdXQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5faW5wdXQudGltZVN0YW1wID0gbm93KCk7XG4gICAgICAgICAgICB0aGlzLm1hbmFnZXIuZW1pdCh0aGlzLm9wdGlvbnMuZXZlbnQsIHRoaXMuX2lucHV0KTtcbiAgICAgICAgfVxuICAgIH1cbn0pO1xuXG4vKipcbiAqIFJvdGF0ZVxuICogUmVjb2duaXplZCB3aGVuIHR3byBvciBtb3JlIHBvaW50ZXIgYXJlIG1vdmluZyBpbiBhIGNpcmN1bGFyIG1vdGlvbi5cbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMgQXR0clJlY29nbml6ZXJcbiAqL1xuZnVuY3Rpb24gUm90YXRlUmVjb2duaXplcigpIHtcbiAgICBBdHRyUmVjb2duaXplci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5pbmhlcml0KFJvdGF0ZVJlY29nbml6ZXIsIEF0dHJSZWNvZ25pemVyLCB7XG4gICAgLyoqXG4gICAgICogQG5hbWVzcGFjZVxuICAgICAqIEBtZW1iZXJvZiBSb3RhdGVSZWNvZ25pemVyXG4gICAgICovXG4gICAgZGVmYXVsdHM6IHtcbiAgICAgICAgZXZlbnQ6ICdyb3RhdGUnLFxuICAgICAgICB0aHJlc2hvbGQ6IDAsXG4gICAgICAgIHBvaW50ZXJzOiAyXG4gICAgfSxcblxuICAgIGdldFRvdWNoQWN0aW9uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIFtUT1VDSF9BQ1RJT05fTk9ORV07XG4gICAgfSxcblxuICAgIGF0dHJUZXN0OiBmdW5jdGlvbihpbnB1dCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc3VwZXIuYXR0clRlc3QuY2FsbCh0aGlzLCBpbnB1dCkgJiZcbiAgICAgICAgICAgIChNYXRoLmFicyhpbnB1dC5yb3RhdGlvbikgPiB0aGlzLm9wdGlvbnMudGhyZXNob2xkIHx8IHRoaXMuc3RhdGUgJiBTVEFURV9CRUdBTik7XG4gICAgfVxufSk7XG5cbi8qKlxuICogU3dpcGVcbiAqIFJlY29nbml6ZWQgd2hlbiB0aGUgcG9pbnRlciBpcyBtb3ZpbmcgZmFzdCAodmVsb2NpdHkpLCB3aXRoIGVub3VnaCBkaXN0YW5jZSBpbiB0aGUgYWxsb3dlZCBkaXJlY3Rpb24uXG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIEF0dHJSZWNvZ25pemVyXG4gKi9cbmZ1bmN0aW9uIFN3aXBlUmVjb2duaXplcigpIHtcbiAgICBBdHRyUmVjb2duaXplci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5pbmhlcml0KFN3aXBlUmVjb2duaXplciwgQXR0clJlY29nbml6ZXIsIHtcbiAgICAvKipcbiAgICAgKiBAbmFtZXNwYWNlXG4gICAgICogQG1lbWJlcm9mIFN3aXBlUmVjb2duaXplclxuICAgICAqL1xuICAgIGRlZmF1bHRzOiB7XG4gICAgICAgIGV2ZW50OiAnc3dpcGUnLFxuICAgICAgICB0aHJlc2hvbGQ6IDEwLFxuICAgICAgICB2ZWxvY2l0eTogMC4zLFxuICAgICAgICBkaXJlY3Rpb246IERJUkVDVElPTl9IT1JJWk9OVEFMIHwgRElSRUNUSU9OX1ZFUlRJQ0FMLFxuICAgICAgICBwb2ludGVyczogMVxuICAgIH0sXG5cbiAgICBnZXRUb3VjaEFjdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBQYW5SZWNvZ25pemVyLnByb3RvdHlwZS5nZXRUb3VjaEFjdGlvbi5jYWxsKHRoaXMpO1xuICAgIH0sXG5cbiAgICBhdHRyVGVzdDogZnVuY3Rpb24oaW5wdXQpIHtcbiAgICAgICAgdmFyIGRpcmVjdGlvbiA9IHRoaXMub3B0aW9ucy5kaXJlY3Rpb247XG4gICAgICAgIHZhciB2ZWxvY2l0eTtcblxuICAgICAgICBpZiAoZGlyZWN0aW9uICYgKERJUkVDVElPTl9IT1JJWk9OVEFMIHwgRElSRUNUSU9OX1ZFUlRJQ0FMKSkge1xuICAgICAgICAgICAgdmVsb2NpdHkgPSBpbnB1dC5vdmVyYWxsVmVsb2NpdHk7XG4gICAgICAgIH0gZWxzZSBpZiAoZGlyZWN0aW9uICYgRElSRUNUSU9OX0hPUklaT05UQUwpIHtcbiAgICAgICAgICAgIHZlbG9jaXR5ID0gaW5wdXQub3ZlcmFsbFZlbG9jaXR5WDtcbiAgICAgICAgfSBlbHNlIGlmIChkaXJlY3Rpb24gJiBESVJFQ1RJT05fVkVSVElDQUwpIHtcbiAgICAgICAgICAgIHZlbG9jaXR5ID0gaW5wdXQub3ZlcmFsbFZlbG9jaXR5WTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLl9zdXBlci5hdHRyVGVzdC5jYWxsKHRoaXMsIGlucHV0KSAmJlxuICAgICAgICAgICAgZGlyZWN0aW9uICYgaW5wdXQub2Zmc2V0RGlyZWN0aW9uICYmXG4gICAgICAgICAgICBpbnB1dC5kaXN0YW5jZSA+IHRoaXMub3B0aW9ucy50aHJlc2hvbGQgJiZcbiAgICAgICAgICAgIGlucHV0Lm1heFBvaW50ZXJzID09IHRoaXMub3B0aW9ucy5wb2ludGVycyAmJlxuICAgICAgICAgICAgYWJzKHZlbG9jaXR5KSA+IHRoaXMub3B0aW9ucy52ZWxvY2l0eSAmJiBpbnB1dC5ldmVudFR5cGUgJiBJTlBVVF9FTkQ7XG4gICAgfSxcblxuICAgIGVtaXQ6IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgICAgIHZhciBkaXJlY3Rpb24gPSBkaXJlY3Rpb25TdHIoaW5wdXQub2Zmc2V0RGlyZWN0aW9uKTtcbiAgICAgICAgaWYgKGRpcmVjdGlvbikge1xuICAgICAgICAgICAgdGhpcy5tYW5hZ2VyLmVtaXQodGhpcy5vcHRpb25zLmV2ZW50ICsgZGlyZWN0aW9uLCBpbnB1dCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLm1hbmFnZXIuZW1pdCh0aGlzLm9wdGlvbnMuZXZlbnQsIGlucHV0KTtcbiAgICB9XG59KTtcblxuLyoqXG4gKiBBIHRhcCBpcyBlY29nbml6ZWQgd2hlbiB0aGUgcG9pbnRlciBpcyBkb2luZyBhIHNtYWxsIHRhcC9jbGljay4gTXVsdGlwbGUgdGFwcyBhcmUgcmVjb2duaXplZCBpZiB0aGV5IG9jY3VyXG4gKiBiZXR3ZWVuIHRoZSBnaXZlbiBpbnRlcnZhbCBhbmQgcG9zaXRpb24uIFRoZSBkZWxheSBvcHRpb24gY2FuIGJlIHVzZWQgdG8gcmVjb2duaXplIG11bHRpLXRhcHMgd2l0aG91dCBmaXJpbmdcbiAqIGEgc2luZ2xlIHRhcC5cbiAqXG4gKiBUaGUgZXZlbnREYXRhIGZyb20gdGhlIGVtaXR0ZWQgZXZlbnQgY29udGFpbnMgdGhlIHByb3BlcnR5IGB0YXBDb3VudGAsIHdoaWNoIGNvbnRhaW5zIHRoZSBhbW91bnQgb2ZcbiAqIG11bHRpLXRhcHMgYmVpbmcgcmVjb2duaXplZC5cbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMgUmVjb2duaXplclxuICovXG5mdW5jdGlvbiBUYXBSZWNvZ25pemVyKCkge1xuICAgIFJlY29nbml6ZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblxuICAgIC8vIHByZXZpb3VzIHRpbWUgYW5kIGNlbnRlcixcbiAgICAvLyB1c2VkIGZvciB0YXAgY291bnRpbmdcbiAgICB0aGlzLnBUaW1lID0gZmFsc2U7XG4gICAgdGhpcy5wQ2VudGVyID0gZmFsc2U7XG5cbiAgICB0aGlzLl90aW1lciA9IG51bGw7XG4gICAgdGhpcy5faW5wdXQgPSBudWxsO1xuICAgIHRoaXMuY291bnQgPSAwO1xufVxuXG5pbmhlcml0KFRhcFJlY29nbml6ZXIsIFJlY29nbml6ZXIsIHtcbiAgICAvKipcbiAgICAgKiBAbmFtZXNwYWNlXG4gICAgICogQG1lbWJlcm9mIFBpbmNoUmVjb2duaXplclxuICAgICAqL1xuICAgIGRlZmF1bHRzOiB7XG4gICAgICAgIGV2ZW50OiAndGFwJyxcbiAgICAgICAgcG9pbnRlcnM6IDEsXG4gICAgICAgIHRhcHM6IDEsXG4gICAgICAgIGludGVydmFsOiAzMDAsIC8vIG1heCB0aW1lIGJldHdlZW4gdGhlIG11bHRpLXRhcCB0YXBzXG4gICAgICAgIHRpbWU6IDI1MCwgLy8gbWF4IHRpbWUgb2YgdGhlIHBvaW50ZXIgdG8gYmUgZG93biAobGlrZSBmaW5nZXIgb24gdGhlIHNjcmVlbilcbiAgICAgICAgdGhyZXNob2xkOiA5LCAvLyBhIG1pbmltYWwgbW92ZW1lbnQgaXMgb2ssIGJ1dCBrZWVwIGl0IGxvd1xuICAgICAgICBwb3NUaHJlc2hvbGQ6IDEwIC8vIGEgbXVsdGktdGFwIGNhbiBiZSBhIGJpdCBvZmYgdGhlIGluaXRpYWwgcG9zaXRpb25cbiAgICB9LFxuXG4gICAgZ2V0VG91Y2hBY3Rpb246IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gW1RPVUNIX0FDVElPTl9NQU5JUFVMQVRJT05dO1xuICAgIH0sXG5cbiAgICBwcm9jZXNzOiBmdW5jdGlvbihpbnB1dCkge1xuICAgICAgICB2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcblxuICAgICAgICB2YXIgdmFsaWRQb2ludGVycyA9IGlucHV0LnBvaW50ZXJzLmxlbmd0aCA9PT0gb3B0aW9ucy5wb2ludGVycztcbiAgICAgICAgdmFyIHZhbGlkTW92ZW1lbnQgPSBpbnB1dC5kaXN0YW5jZSA8IG9wdGlvbnMudGhyZXNob2xkO1xuICAgICAgICB2YXIgdmFsaWRUb3VjaFRpbWUgPSBpbnB1dC5kZWx0YVRpbWUgPCBvcHRpb25zLnRpbWU7XG5cbiAgICAgICAgdGhpcy5yZXNldCgpO1xuXG4gICAgICAgIGlmICgoaW5wdXQuZXZlbnRUeXBlICYgSU5QVVRfU1RBUlQpICYmICh0aGlzLmNvdW50ID09PSAwKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmFpbFRpbWVvdXQoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHdlIG9ubHkgYWxsb3cgbGl0dGxlIG1vdmVtZW50XG4gICAgICAgIC8vIGFuZCB3ZSd2ZSByZWFjaGVkIGFuIGVuZCBldmVudCwgc28gYSB0YXAgaXMgcG9zc2libGVcbiAgICAgICAgaWYgKHZhbGlkTW92ZW1lbnQgJiYgdmFsaWRUb3VjaFRpbWUgJiYgdmFsaWRQb2ludGVycykge1xuICAgICAgICAgICAgaWYgKGlucHV0LmV2ZW50VHlwZSAhPSBJTlBVVF9FTkQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5mYWlsVGltZW91dCgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgdmFsaWRJbnRlcnZhbCA9IHRoaXMucFRpbWUgPyAoaW5wdXQudGltZVN0YW1wIC0gdGhpcy5wVGltZSA8IG9wdGlvbnMuaW50ZXJ2YWwpIDogdHJ1ZTtcbiAgICAgICAgICAgIHZhciB2YWxpZE11bHRpVGFwID0gIXRoaXMucENlbnRlciB8fCBnZXREaXN0YW5jZSh0aGlzLnBDZW50ZXIsIGlucHV0LmNlbnRlcikgPCBvcHRpb25zLnBvc1RocmVzaG9sZDtcblxuICAgICAgICAgICAgdGhpcy5wVGltZSA9IGlucHV0LnRpbWVTdGFtcDtcbiAgICAgICAgICAgIHRoaXMucENlbnRlciA9IGlucHV0LmNlbnRlcjtcblxuICAgICAgICAgICAgaWYgKCF2YWxpZE11bHRpVGFwIHx8ICF2YWxpZEludGVydmFsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jb3VudCA9IDE7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuY291bnQgKz0gMTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5faW5wdXQgPSBpbnB1dDtcblxuICAgICAgICAgICAgLy8gaWYgdGFwIGNvdW50IG1hdGNoZXMgd2UgaGF2ZSByZWNvZ25pemVkIGl0LFxuICAgICAgICAgICAgLy8gZWxzZSBpdCBoYXMgYmVnYW4gcmVjb2duaXppbmcuLi5cbiAgICAgICAgICAgIHZhciB0YXBDb3VudCA9IHRoaXMuY291bnQgJSBvcHRpb25zLnRhcHM7XG4gICAgICAgICAgICBpZiAodGFwQ291bnQgPT09IDApIHtcbiAgICAgICAgICAgICAgICAvLyBubyBmYWlsaW5nIHJlcXVpcmVtZW50cywgaW1tZWRpYXRlbHkgdHJpZ2dlciB0aGUgdGFwIGV2ZW50XG4gICAgICAgICAgICAgICAgLy8gb3Igd2FpdCBhcyBsb25nIGFzIHRoZSBtdWx0aXRhcCBpbnRlcnZhbCB0byB0cmlnZ2VyXG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLmhhc1JlcXVpcmVGYWlsdXJlcygpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBTVEFURV9SRUNPR05JWkVEO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3RpbWVyID0gc2V0VGltZW91dENvbnRleHQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gU1RBVEVfUkVDT0dOSVpFRDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudHJ5RW1pdCgpO1xuICAgICAgICAgICAgICAgICAgICB9LCBvcHRpb25zLmludGVydmFsLCB0aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFNUQVRFX0JFR0FOO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gU1RBVEVfRkFJTEVEO1xuICAgIH0sXG5cbiAgICBmYWlsVGltZW91dDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuX3RpbWVyID0gc2V0VGltZW91dENvbnRleHQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gU1RBVEVfRkFJTEVEO1xuICAgICAgICB9LCB0aGlzLm9wdGlvbnMuaW50ZXJ2YWwsIHRoaXMpO1xuICAgICAgICByZXR1cm4gU1RBVEVfRkFJTEVEO1xuICAgIH0sXG5cbiAgICByZXNldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLl90aW1lcik7XG4gICAgfSxcblxuICAgIGVtaXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5zdGF0ZSA9PSBTVEFURV9SRUNPR05JWkVEKSB7XG4gICAgICAgICAgICB0aGlzLl9pbnB1dC50YXBDb3VudCA9IHRoaXMuY291bnQ7XG4gICAgICAgICAgICB0aGlzLm1hbmFnZXIuZW1pdCh0aGlzLm9wdGlvbnMuZXZlbnQsIHRoaXMuX2lucHV0KTtcbiAgICAgICAgfVxuICAgIH1cbn0pO1xuXG4vKipcbiAqIFNpbXBsZSB3YXkgdG8gY3JlYXRlIGEgbWFuYWdlciB3aXRoIGEgZGVmYXVsdCBzZXQgb2YgcmVjb2duaXplcnMuXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50XG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gSGFtbWVyKGVsZW1lbnQsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICBvcHRpb25zLnJlY29nbml6ZXJzID0gaWZVbmRlZmluZWQob3B0aW9ucy5yZWNvZ25pemVycywgSGFtbWVyLmRlZmF1bHRzLnByZXNldCk7XG4gICAgcmV0dXJuIG5ldyBNYW5hZ2VyKGVsZW1lbnQsIG9wdGlvbnMpO1xufVxuXG4vKipcbiAqIEBjb25zdCB7c3RyaW5nfVxuICovXG5IYW1tZXIuVkVSU0lPTiA9ICcyLjAuNyc7XG5cbi8qKlxuICogZGVmYXVsdCBzZXR0aW5nc1xuICogQG5hbWVzcGFjZVxuICovXG5IYW1tZXIuZGVmYXVsdHMgPSB7XG4gICAgLyoqXG4gICAgICogc2V0IGlmIERPTSBldmVudHMgYXJlIGJlaW5nIHRyaWdnZXJlZC5cbiAgICAgKiBCdXQgdGhpcyBpcyBzbG93ZXIgYW5kIHVudXNlZCBieSBzaW1wbGUgaW1wbGVtZW50YXRpb25zLCBzbyBkaXNhYmxlZCBieSBkZWZhdWx0LlxuICAgICAqIEB0eXBlIHtCb29sZWFufVxuICAgICAqIEBkZWZhdWx0IGZhbHNlXG4gICAgICovXG4gICAgZG9tRXZlbnRzOiBmYWxzZSxcblxuICAgIC8qKlxuICAgICAqIFRoZSB2YWx1ZSBmb3IgdGhlIHRvdWNoQWN0aW9uIHByb3BlcnR5L2ZhbGxiYWNrLlxuICAgICAqIFdoZW4gc2V0IHRvIGBjb21wdXRlYCBpdCB3aWxsIG1hZ2ljYWxseSBzZXQgdGhlIGNvcnJlY3QgdmFsdWUgYmFzZWQgb24gdGhlIGFkZGVkIHJlY29nbml6ZXJzLlxuICAgICAqIEB0eXBlIHtTdHJpbmd9XG4gICAgICogQGRlZmF1bHQgY29tcHV0ZVxuICAgICAqL1xuICAgIHRvdWNoQWN0aW9uOiBUT1VDSF9BQ1RJT05fQ09NUFVURSxcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtCb29sZWFufVxuICAgICAqIEBkZWZhdWx0IHRydWVcbiAgICAgKi9cbiAgICBlbmFibGU6IHRydWUsXG5cbiAgICAvKipcbiAgICAgKiBFWFBFUklNRU5UQUwgRkVBVFVSRSAtLSBjYW4gYmUgcmVtb3ZlZC9jaGFuZ2VkXG4gICAgICogQ2hhbmdlIHRoZSBwYXJlbnQgaW5wdXQgdGFyZ2V0IGVsZW1lbnQuXG4gICAgICogSWYgTnVsbCwgdGhlbiBpdCBpcyBiZWluZyBzZXQgdGhlIHRvIG1haW4gZWxlbWVudC5cbiAgICAgKiBAdHlwZSB7TnVsbHxFdmVudFRhcmdldH1cbiAgICAgKiBAZGVmYXVsdCBudWxsXG4gICAgICovXG4gICAgaW5wdXRUYXJnZXQ6IG51bGwsXG5cbiAgICAvKipcbiAgICAgKiBmb3JjZSBhbiBpbnB1dCBjbGFzc1xuICAgICAqIEB0eXBlIHtOdWxsfEZ1bmN0aW9ufVxuICAgICAqIEBkZWZhdWx0IG51bGxcbiAgICAgKi9cbiAgICBpbnB1dENsYXNzOiBudWxsLFxuXG4gICAgLyoqXG4gICAgICogRGVmYXVsdCByZWNvZ25pemVyIHNldHVwIHdoZW4gY2FsbGluZyBgSGFtbWVyKClgXG4gICAgICogV2hlbiBjcmVhdGluZyBhIG5ldyBNYW5hZ2VyIHRoZXNlIHdpbGwgYmUgc2tpcHBlZC5cbiAgICAgKiBAdHlwZSB7QXJyYXl9XG4gICAgICovXG4gICAgcHJlc2V0OiBbXG4gICAgICAgIC8vIFJlY29nbml6ZXJDbGFzcywgb3B0aW9ucywgW3JlY29nbml6ZVdpdGgsIC4uLl0sIFtyZXF1aXJlRmFpbHVyZSwgLi4uXVxuICAgICAgICBbUm90YXRlUmVjb2duaXplciwge2VuYWJsZTogZmFsc2V9XSxcbiAgICAgICAgW1BpbmNoUmVjb2duaXplciwge2VuYWJsZTogZmFsc2V9LCBbJ3JvdGF0ZSddXSxcbiAgICAgICAgW1N3aXBlUmVjb2duaXplciwge2RpcmVjdGlvbjogRElSRUNUSU9OX0hPUklaT05UQUx9XSxcbiAgICAgICAgW1BhblJlY29nbml6ZXIsIHtkaXJlY3Rpb246IERJUkVDVElPTl9IT1JJWk9OVEFMfSwgWydzd2lwZSddXSxcbiAgICAgICAgW1RhcFJlY29nbml6ZXJdLFxuICAgICAgICBbVGFwUmVjb2duaXplciwge2V2ZW50OiAnZG91YmxldGFwJywgdGFwczogMn0sIFsndGFwJ11dLFxuICAgICAgICBbUHJlc3NSZWNvZ25pemVyXVxuICAgIF0sXG5cbiAgICAvKipcbiAgICAgKiBTb21lIENTUyBwcm9wZXJ0aWVzIGNhbiBiZSB1c2VkIHRvIGltcHJvdmUgdGhlIHdvcmtpbmcgb2YgSGFtbWVyLlxuICAgICAqIEFkZCB0aGVtIHRvIHRoaXMgbWV0aG9kIGFuZCB0aGV5IHdpbGwgYmUgc2V0IHdoZW4gY3JlYXRpbmcgYSBuZXcgTWFuYWdlci5cbiAgICAgKiBAbmFtZXNwYWNlXG4gICAgICovXG4gICAgY3NzUHJvcHM6IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIERpc2FibGVzIHRleHQgc2VsZWN0aW9uIHRvIGltcHJvdmUgdGhlIGRyYWdnaW5nIGdlc3R1cmUuIE1haW5seSBmb3IgZGVza3RvcCBicm93c2Vycy5cbiAgICAgICAgICogQHR5cGUge1N0cmluZ31cbiAgICAgICAgICogQGRlZmF1bHQgJ25vbmUnXG4gICAgICAgICAqL1xuICAgICAgICB1c2VyU2VsZWN0OiAnbm9uZScsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIERpc2FibGUgdGhlIFdpbmRvd3MgUGhvbmUgZ3JpcHBlcnMgd2hlbiBwcmVzc2luZyBhbiBlbGVtZW50LlxuICAgICAgICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgICAgICAgKiBAZGVmYXVsdCAnbm9uZSdcbiAgICAgICAgICovXG4gICAgICAgIHRvdWNoU2VsZWN0OiAnbm9uZScsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIERpc2FibGVzIHRoZSBkZWZhdWx0IGNhbGxvdXQgc2hvd24gd2hlbiB5b3UgdG91Y2ggYW5kIGhvbGQgYSB0b3VjaCB0YXJnZXQuXG4gICAgICAgICAqIE9uIGlPUywgd2hlbiB5b3UgdG91Y2ggYW5kIGhvbGQgYSB0b3VjaCB0YXJnZXQgc3VjaCBhcyBhIGxpbmssIFNhZmFyaSBkaXNwbGF5c1xuICAgICAgICAgKiBhIGNhbGxvdXQgY29udGFpbmluZyBpbmZvcm1hdGlvbiBhYm91dCB0aGUgbGluay4gVGhpcyBwcm9wZXJ0eSBhbGxvd3MgeW91IHRvIGRpc2FibGUgdGhhdCBjYWxsb3V0LlxuICAgICAgICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgICAgICAgKiBAZGVmYXVsdCAnbm9uZSdcbiAgICAgICAgICovXG4gICAgICAgIHRvdWNoQ2FsbG91dDogJ25vbmUnLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTcGVjaWZpZXMgd2hldGhlciB6b29taW5nIGlzIGVuYWJsZWQuIFVzZWQgYnkgSUUxMD5cbiAgICAgICAgICogQHR5cGUge1N0cmluZ31cbiAgICAgICAgICogQGRlZmF1bHQgJ25vbmUnXG4gICAgICAgICAqL1xuICAgICAgICBjb250ZW50Wm9vbWluZzogJ25vbmUnLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTcGVjaWZpZXMgdGhhdCBhbiBlbnRpcmUgZWxlbWVudCBzaG91bGQgYmUgZHJhZ2dhYmxlIGluc3RlYWQgb2YgaXRzIGNvbnRlbnRzLiBNYWlubHkgZm9yIGRlc2t0b3AgYnJvd3NlcnMuXG4gICAgICAgICAqIEB0eXBlIHtTdHJpbmd9XG4gICAgICAgICAqIEBkZWZhdWx0ICdub25lJ1xuICAgICAgICAgKi9cbiAgICAgICAgdXNlckRyYWc6ICdub25lJyxcblxuICAgICAgICAvKipcbiAgICAgICAgICogT3ZlcnJpZGVzIHRoZSBoaWdobGlnaHQgY29sb3Igc2hvd24gd2hlbiB0aGUgdXNlciB0YXBzIGEgbGluayBvciBhIEphdmFTY3JpcHRcbiAgICAgICAgICogY2xpY2thYmxlIGVsZW1lbnQgaW4gaU9TLiBUaGlzIHByb3BlcnR5IG9iZXlzIHRoZSBhbHBoYSB2YWx1ZSwgaWYgc3BlY2lmaWVkLlxuICAgICAgICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgICAgICAgKiBAZGVmYXVsdCAncmdiYSgwLDAsMCwwKSdcbiAgICAgICAgICovXG4gICAgICAgIHRhcEhpZ2hsaWdodENvbG9yOiAncmdiYSgwLDAsMCwwKSdcbiAgICB9XG59O1xuXG52YXIgU1RPUCA9IDE7XG52YXIgRk9SQ0VEX1NUT1AgPSAyO1xuXG4vKipcbiAqIE1hbmFnZXJcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnRcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBNYW5hZ2VyKGVsZW1lbnQsIG9wdGlvbnMpIHtcbiAgICB0aGlzLm9wdGlvbnMgPSBhc3NpZ24oe30sIEhhbW1lci5kZWZhdWx0cywgb3B0aW9ucyB8fCB7fSk7XG5cbiAgICB0aGlzLm9wdGlvbnMuaW5wdXRUYXJnZXQgPSB0aGlzLm9wdGlvbnMuaW5wdXRUYXJnZXQgfHwgZWxlbWVudDtcblxuICAgIHRoaXMuaGFuZGxlcnMgPSB7fTtcbiAgICB0aGlzLnNlc3Npb24gPSB7fTtcbiAgICB0aGlzLnJlY29nbml6ZXJzID0gW107XG4gICAgdGhpcy5vbGRDc3NQcm9wcyA9IHt9O1xuXG4gICAgdGhpcy5lbGVtZW50ID0gZWxlbWVudDtcbiAgICB0aGlzLmlucHV0ID0gY3JlYXRlSW5wdXRJbnN0YW5jZSh0aGlzKTtcbiAgICB0aGlzLnRvdWNoQWN0aW9uID0gbmV3IFRvdWNoQWN0aW9uKHRoaXMsIHRoaXMub3B0aW9ucy50b3VjaEFjdGlvbik7XG5cbiAgICB0b2dnbGVDc3NQcm9wcyh0aGlzLCB0cnVlKTtcblxuICAgIGVhY2godGhpcy5vcHRpb25zLnJlY29nbml6ZXJzLCBmdW5jdGlvbihpdGVtKSB7XG4gICAgICAgIHZhciByZWNvZ25pemVyID0gdGhpcy5hZGQobmV3IChpdGVtWzBdKShpdGVtWzFdKSk7XG4gICAgICAgIGl0ZW1bMl0gJiYgcmVjb2duaXplci5yZWNvZ25pemVXaXRoKGl0ZW1bMl0pO1xuICAgICAgICBpdGVtWzNdICYmIHJlY29nbml6ZXIucmVxdWlyZUZhaWx1cmUoaXRlbVszXSk7XG4gICAgfSwgdGhpcyk7XG59XG5cbk1hbmFnZXIucHJvdG90eXBlID0ge1xuICAgIC8qKlxuICAgICAqIHNldCBvcHRpb25zXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICAgKiBAcmV0dXJucyB7TWFuYWdlcn1cbiAgICAgKi9cbiAgICBzZXQ6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgICAgYXNzaWduKHRoaXMub3B0aW9ucywgb3B0aW9ucyk7XG5cbiAgICAgICAgLy8gT3B0aW9ucyB0aGF0IG5lZWQgYSBsaXR0bGUgbW9yZSBzZXR1cFxuICAgICAgICBpZiAob3B0aW9ucy50b3VjaEFjdGlvbikge1xuICAgICAgICAgICAgdGhpcy50b3VjaEFjdGlvbi51cGRhdGUoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucy5pbnB1dFRhcmdldCkge1xuICAgICAgICAgICAgLy8gQ2xlYW4gdXAgZXhpc3RpbmcgZXZlbnQgbGlzdGVuZXJzIGFuZCByZWluaXRpYWxpemVcbiAgICAgICAgICAgIHRoaXMuaW5wdXQuZGVzdHJveSgpO1xuICAgICAgICAgICAgdGhpcy5pbnB1dC50YXJnZXQgPSBvcHRpb25zLmlucHV0VGFyZ2V0O1xuICAgICAgICAgICAgdGhpcy5pbnB1dC5pbml0KCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIHN0b3AgcmVjb2duaXppbmcgZm9yIHRoaXMgc2Vzc2lvbi5cbiAgICAgKiBUaGlzIHNlc3Npb24gd2lsbCBiZSBkaXNjYXJkZWQsIHdoZW4gYSBuZXcgW2lucHV0XXN0YXJ0IGV2ZW50IGlzIGZpcmVkLlxuICAgICAqIFdoZW4gZm9yY2VkLCB0aGUgcmVjb2duaXplciBjeWNsZSBpcyBzdG9wcGVkIGltbWVkaWF0ZWx5LlxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2ZvcmNlXVxuICAgICAqL1xuICAgIHN0b3A6IGZ1bmN0aW9uKGZvcmNlKSB7XG4gICAgICAgIHRoaXMuc2Vzc2lvbi5zdG9wcGVkID0gZm9yY2UgPyBGT1JDRURfU1RPUCA6IFNUT1A7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIHJ1biB0aGUgcmVjb2duaXplcnMhXG4gICAgICogY2FsbGVkIGJ5IHRoZSBpbnB1dEhhbmRsZXIgZnVuY3Rpb24gb24gZXZlcnkgbW92ZW1lbnQgb2YgdGhlIHBvaW50ZXJzICh0b3VjaGVzKVxuICAgICAqIGl0IHdhbGtzIHRocm91Z2ggYWxsIHRoZSByZWNvZ25pemVycyBhbmQgdHJpZXMgdG8gZGV0ZWN0IHRoZSBnZXN0dXJlIHRoYXQgaXMgYmVpbmcgbWFkZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBpbnB1dERhdGFcbiAgICAgKi9cbiAgICByZWNvZ25pemU6IGZ1bmN0aW9uKGlucHV0RGF0YSkge1xuICAgICAgICB2YXIgc2Vzc2lvbiA9IHRoaXMuc2Vzc2lvbjtcbiAgICAgICAgaWYgKHNlc3Npb24uc3RvcHBlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gcnVuIHRoZSB0b3VjaC1hY3Rpb24gcG9seWZpbGxcbiAgICAgICAgdGhpcy50b3VjaEFjdGlvbi5wcmV2ZW50RGVmYXVsdHMoaW5wdXREYXRhKTtcblxuICAgICAgICB2YXIgcmVjb2duaXplcjtcbiAgICAgICAgdmFyIHJlY29nbml6ZXJzID0gdGhpcy5yZWNvZ25pemVycztcblxuICAgICAgICAvLyB0aGlzIGhvbGRzIHRoZSByZWNvZ25pemVyIHRoYXQgaXMgYmVpbmcgcmVjb2duaXplZC5cbiAgICAgICAgLy8gc28gdGhlIHJlY29nbml6ZXIncyBzdGF0ZSBuZWVkcyB0byBiZSBCRUdBTiwgQ0hBTkdFRCwgRU5ERUQgb3IgUkVDT0dOSVpFRFxuICAgICAgICAvLyBpZiBubyByZWNvZ25pemVyIGlzIGRldGVjdGluZyBhIHRoaW5nLCBpdCBpcyBzZXQgdG8gYG51bGxgXG4gICAgICAgIHZhciBjdXJSZWNvZ25pemVyID0gc2Vzc2lvbi5jdXJSZWNvZ25pemVyO1xuXG4gICAgICAgIC8vIHJlc2V0IHdoZW4gdGhlIGxhc3QgcmVjb2duaXplciBpcyByZWNvZ25pemVkXG4gICAgICAgIC8vIG9yIHdoZW4gd2UncmUgaW4gYSBuZXcgc2Vzc2lvblxuICAgICAgICBpZiAoIWN1clJlY29nbml6ZXIgfHwgKGN1clJlY29nbml6ZXIgJiYgY3VyUmVjb2duaXplci5zdGF0ZSAmIFNUQVRFX1JFQ09HTklaRUQpKSB7XG4gICAgICAgICAgICBjdXJSZWNvZ25pemVyID0gc2Vzc2lvbi5jdXJSZWNvZ25pemVyID0gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBpID0gMDtcbiAgICAgICAgd2hpbGUgKGkgPCByZWNvZ25pemVycy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJlY29nbml6ZXIgPSByZWNvZ25pemVyc1tpXTtcblxuICAgICAgICAgICAgLy8gZmluZCBvdXQgaWYgd2UgYXJlIGFsbG93ZWQgdHJ5IHRvIHJlY29nbml6ZSB0aGUgaW5wdXQgZm9yIHRoaXMgb25lLlxuICAgICAgICAgICAgLy8gMS4gICBhbGxvdyBpZiB0aGUgc2Vzc2lvbiBpcyBOT1QgZm9yY2VkIHN0b3BwZWQgKHNlZSB0aGUgLnN0b3AoKSBtZXRob2QpXG4gICAgICAgICAgICAvLyAyLiAgIGFsbG93IGlmIHdlIHN0aWxsIGhhdmVuJ3QgcmVjb2duaXplZCBhIGdlc3R1cmUgaW4gdGhpcyBzZXNzaW9uLCBvciB0aGUgdGhpcyByZWNvZ25pemVyIGlzIHRoZSBvbmVcbiAgICAgICAgICAgIC8vICAgICAgdGhhdCBpcyBiZWluZyByZWNvZ25pemVkLlxuICAgICAgICAgICAgLy8gMy4gICBhbGxvdyBpZiB0aGUgcmVjb2duaXplciBpcyBhbGxvd2VkIHRvIHJ1biBzaW11bHRhbmVvdXMgd2l0aCB0aGUgY3VycmVudCByZWNvZ25pemVkIHJlY29nbml6ZXIuXG4gICAgICAgICAgICAvLyAgICAgIHRoaXMgY2FuIGJlIHNldHVwIHdpdGggdGhlIGByZWNvZ25pemVXaXRoKClgIG1ldGhvZCBvbiB0aGUgcmVjb2duaXplci5cbiAgICAgICAgICAgIGlmIChzZXNzaW9uLnN0b3BwZWQgIT09IEZPUkNFRF9TVE9QICYmICggLy8gMVxuICAgICAgICAgICAgICAgICAgICAhY3VyUmVjb2duaXplciB8fCByZWNvZ25pemVyID09IGN1clJlY29nbml6ZXIgfHwgLy8gMlxuICAgICAgICAgICAgICAgICAgICByZWNvZ25pemVyLmNhblJlY29nbml6ZVdpdGgoY3VyUmVjb2duaXplcikpKSB7IC8vIDNcbiAgICAgICAgICAgICAgICByZWNvZ25pemVyLnJlY29nbml6ZShpbnB1dERhdGEpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZWNvZ25pemVyLnJlc2V0KCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGlmIHRoZSByZWNvZ25pemVyIGhhcyBiZWVuIHJlY29nbml6aW5nIHRoZSBpbnB1dCBhcyBhIHZhbGlkIGdlc3R1cmUsIHdlIHdhbnQgdG8gc3RvcmUgdGhpcyBvbmUgYXMgdGhlXG4gICAgICAgICAgICAvLyBjdXJyZW50IGFjdGl2ZSByZWNvZ25pemVyLiBidXQgb25seSBpZiB3ZSBkb24ndCBhbHJlYWR5IGhhdmUgYW4gYWN0aXZlIHJlY29nbml6ZXJcbiAgICAgICAgICAgIGlmICghY3VyUmVjb2duaXplciAmJiByZWNvZ25pemVyLnN0YXRlICYgKFNUQVRFX0JFR0FOIHwgU1RBVEVfQ0hBTkdFRCB8IFNUQVRFX0VOREVEKSkge1xuICAgICAgICAgICAgICAgIGN1clJlY29nbml6ZXIgPSBzZXNzaW9uLmN1clJlY29nbml6ZXIgPSByZWNvZ25pemVyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaSsrO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIGdldCBhIHJlY29nbml6ZXIgYnkgaXRzIGV2ZW50IG5hbWUuXG4gICAgICogQHBhcmFtIHtSZWNvZ25pemVyfFN0cmluZ30gcmVjb2duaXplclxuICAgICAqIEByZXR1cm5zIHtSZWNvZ25pemVyfE51bGx9XG4gICAgICovXG4gICAgZ2V0OiBmdW5jdGlvbihyZWNvZ25pemVyKSB7XG4gICAgICAgIGlmIChyZWNvZ25pemVyIGluc3RhbmNlb2YgUmVjb2duaXplcikge1xuICAgICAgICAgICAgcmV0dXJuIHJlY29nbml6ZXI7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcmVjb2duaXplcnMgPSB0aGlzLnJlY29nbml6ZXJzO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJlY29nbml6ZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAocmVjb2duaXplcnNbaV0ub3B0aW9ucy5ldmVudCA9PSByZWNvZ25pemVyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlY29nbml6ZXJzW2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBhZGQgYSByZWNvZ25pemVyIHRvIHRoZSBtYW5hZ2VyXG4gICAgICogZXhpc3RpbmcgcmVjb2duaXplcnMgd2l0aCB0aGUgc2FtZSBldmVudCBuYW1lIHdpbGwgYmUgcmVtb3ZlZFxuICAgICAqIEBwYXJhbSB7UmVjb2duaXplcn0gcmVjb2duaXplclxuICAgICAqIEByZXR1cm5zIHtSZWNvZ25pemVyfE1hbmFnZXJ9XG4gICAgICovXG4gICAgYWRkOiBmdW5jdGlvbihyZWNvZ25pemVyKSB7XG4gICAgICAgIGlmIChpbnZva2VBcnJheUFyZyhyZWNvZ25pemVyLCAnYWRkJywgdGhpcykpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gcmVtb3ZlIGV4aXN0aW5nXG4gICAgICAgIHZhciBleGlzdGluZyA9IHRoaXMuZ2V0KHJlY29nbml6ZXIub3B0aW9ucy5ldmVudCk7XG4gICAgICAgIGlmIChleGlzdGluZykge1xuICAgICAgICAgICAgdGhpcy5yZW1vdmUoZXhpc3RpbmcpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5yZWNvZ25pemVycy5wdXNoKHJlY29nbml6ZXIpO1xuICAgICAgICByZWNvZ25pemVyLm1hbmFnZXIgPSB0aGlzO1xuXG4gICAgICAgIHRoaXMudG91Y2hBY3Rpb24udXBkYXRlKCk7XG4gICAgICAgIHJldHVybiByZWNvZ25pemVyO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiByZW1vdmUgYSByZWNvZ25pemVyIGJ5IG5hbWUgb3IgaW5zdGFuY2VcbiAgICAgKiBAcGFyYW0ge1JlY29nbml6ZXJ8U3RyaW5nfSByZWNvZ25pemVyXG4gICAgICogQHJldHVybnMge01hbmFnZXJ9XG4gICAgICovXG4gICAgcmVtb3ZlOiBmdW5jdGlvbihyZWNvZ25pemVyKSB7XG4gICAgICAgIGlmIChpbnZva2VBcnJheUFyZyhyZWNvZ25pemVyLCAncmVtb3ZlJywgdGhpcykpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVjb2duaXplciA9IHRoaXMuZ2V0KHJlY29nbml6ZXIpO1xuXG4gICAgICAgIC8vIGxldCdzIG1ha2Ugc3VyZSB0aGlzIHJlY29nbml6ZXIgZXhpc3RzXG4gICAgICAgIGlmIChyZWNvZ25pemVyKSB7XG4gICAgICAgICAgICB2YXIgcmVjb2duaXplcnMgPSB0aGlzLnJlY29nbml6ZXJzO1xuICAgICAgICAgICAgdmFyIGluZGV4ID0gaW5BcnJheShyZWNvZ25pemVycywgcmVjb2duaXplcik7XG5cbiAgICAgICAgICAgIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICByZWNvZ25pemVycy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgICAgICAgIHRoaXMudG91Y2hBY3Rpb24udXBkYXRlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogYmluZCBldmVudFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBldmVudHNcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYW5kbGVyXG4gICAgICogQHJldHVybnMge0V2ZW50RW1pdHRlcn0gdGhpc1xuICAgICAqL1xuICAgIG9uOiBmdW5jdGlvbihldmVudHMsIGhhbmRsZXIpIHtcbiAgICAgICAgaWYgKGV2ZW50cyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhhbmRsZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGhhbmRsZXJzID0gdGhpcy5oYW5kbGVycztcbiAgICAgICAgZWFjaChzcGxpdFN0cihldmVudHMpLCBmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgICAgaGFuZGxlcnNbZXZlbnRdID0gaGFuZGxlcnNbZXZlbnRdIHx8IFtdO1xuICAgICAgICAgICAgaGFuZGxlcnNbZXZlbnRdLnB1c2goaGFuZGxlcik7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogdW5iaW5kIGV2ZW50LCBsZWF2ZSBlbWl0IGJsYW5rIHRvIHJlbW92ZSBhbGwgaGFuZGxlcnNcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRzXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2hhbmRsZXJdXG4gICAgICogQHJldHVybnMge0V2ZW50RW1pdHRlcn0gdGhpc1xuICAgICAqL1xuICAgIG9mZjogZnVuY3Rpb24oZXZlbnRzLCBoYW5kbGVyKSB7XG4gICAgICAgIGlmIChldmVudHMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGhhbmRsZXJzID0gdGhpcy5oYW5kbGVycztcbiAgICAgICAgZWFjaChzcGxpdFN0cihldmVudHMpLCBmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgICAgaWYgKCFoYW5kbGVyKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIGhhbmRsZXJzW2V2ZW50XTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaGFuZGxlcnNbZXZlbnRdICYmIGhhbmRsZXJzW2V2ZW50XS5zcGxpY2UoaW5BcnJheShoYW5kbGVyc1tldmVudF0sIGhhbmRsZXIpLCAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBlbWl0IGV2ZW50IHRvIHRoZSBsaXN0ZW5lcnNcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqL1xuICAgIGVtaXQ6IGZ1bmN0aW9uKGV2ZW50LCBkYXRhKSB7XG4gICAgICAgIC8vIHdlIGFsc28gd2FudCB0byB0cmlnZ2VyIGRvbSBldmVudHNcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5kb21FdmVudHMpIHtcbiAgICAgICAgICAgIHRyaWdnZXJEb21FdmVudChldmVudCwgZGF0YSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBubyBoYW5kbGVycywgc28gc2tpcCBpdCBhbGxcbiAgICAgICAgdmFyIGhhbmRsZXJzID0gdGhpcy5oYW5kbGVyc1tldmVudF0gJiYgdGhpcy5oYW5kbGVyc1tldmVudF0uc2xpY2UoKTtcbiAgICAgICAgaWYgKCFoYW5kbGVycyB8fCAhaGFuZGxlcnMubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBkYXRhLnR5cGUgPSBldmVudDtcbiAgICAgICAgZGF0YS5wcmV2ZW50RGVmYXVsdCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgZGF0YS5zcmNFdmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBpID0gMDtcbiAgICAgICAgd2hpbGUgKGkgPCBoYW5kbGVycy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGhhbmRsZXJzW2ldKGRhdGEpO1xuICAgICAgICAgICAgaSsrO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIGRlc3Ryb3kgdGhlIG1hbmFnZXIgYW5kIHVuYmluZHMgYWxsIGV2ZW50c1xuICAgICAqIGl0IGRvZXNuJ3QgdW5iaW5kIGRvbSBldmVudHMsIHRoYXQgaXMgdGhlIHVzZXIgb3duIHJlc3BvbnNpYmlsaXR5XG4gICAgICovXG4gICAgZGVzdHJveTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuZWxlbWVudCAmJiB0b2dnbGVDc3NQcm9wcyh0aGlzLCBmYWxzZSk7XG5cbiAgICAgICAgdGhpcy5oYW5kbGVycyA9IHt9O1xuICAgICAgICB0aGlzLnNlc3Npb24gPSB7fTtcbiAgICAgICAgdGhpcy5pbnB1dC5kZXN0cm95KCk7XG4gICAgICAgIHRoaXMuZWxlbWVudCA9IG51bGw7XG4gICAgfVxufTtcblxuLyoqXG4gKiBhZGQvcmVtb3ZlIHRoZSBjc3MgcHJvcGVydGllcyBhcyBkZWZpbmVkIGluIG1hbmFnZXIub3B0aW9ucy5jc3NQcm9wc1xuICogQHBhcmFtIHtNYW5hZ2VyfSBtYW5hZ2VyXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGFkZFxuICovXG5mdW5jdGlvbiB0b2dnbGVDc3NQcm9wcyhtYW5hZ2VyLCBhZGQpIHtcbiAgICB2YXIgZWxlbWVudCA9IG1hbmFnZXIuZWxlbWVudDtcbiAgICBpZiAoIWVsZW1lbnQuc3R5bGUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgcHJvcDtcbiAgICBlYWNoKG1hbmFnZXIub3B0aW9ucy5jc3NQcm9wcywgZnVuY3Rpb24odmFsdWUsIG5hbWUpIHtcbiAgICAgICAgcHJvcCA9IHByZWZpeGVkKGVsZW1lbnQuc3R5bGUsIG5hbWUpO1xuICAgICAgICBpZiAoYWRkKSB7XG4gICAgICAgICAgICBtYW5hZ2VyLm9sZENzc1Byb3BzW3Byb3BdID0gZWxlbWVudC5zdHlsZVtwcm9wXTtcbiAgICAgICAgICAgIGVsZW1lbnQuc3R5bGVbcHJvcF0gPSB2YWx1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGVsZW1lbnQuc3R5bGVbcHJvcF0gPSBtYW5hZ2VyLm9sZENzc1Byb3BzW3Byb3BdIHx8ICcnO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgaWYgKCFhZGQpIHtcbiAgICAgICAgbWFuYWdlci5vbGRDc3NQcm9wcyA9IHt9O1xuICAgIH1cbn1cblxuLyoqXG4gKiB0cmlnZ2VyIGRvbSBldmVudFxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XG4gKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICovXG5mdW5jdGlvbiB0cmlnZ2VyRG9tRXZlbnQoZXZlbnQsIGRhdGEpIHtcbiAgICB2YXIgZ2VzdHVyZUV2ZW50ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ0V2ZW50Jyk7XG4gICAgZ2VzdHVyZUV2ZW50LmluaXRFdmVudChldmVudCwgdHJ1ZSwgdHJ1ZSk7XG4gICAgZ2VzdHVyZUV2ZW50Lmdlc3R1cmUgPSBkYXRhO1xuICAgIGRhdGEudGFyZ2V0LmRpc3BhdGNoRXZlbnQoZ2VzdHVyZUV2ZW50KTtcbn1cblxuYXNzaWduKEhhbW1lciwge1xuICAgIElOUFVUX1NUQVJUOiBJTlBVVF9TVEFSVCxcbiAgICBJTlBVVF9NT1ZFOiBJTlBVVF9NT1ZFLFxuICAgIElOUFVUX0VORDogSU5QVVRfRU5ELFxuICAgIElOUFVUX0NBTkNFTDogSU5QVVRfQ0FOQ0VMLFxuXG4gICAgU1RBVEVfUE9TU0lCTEU6IFNUQVRFX1BPU1NJQkxFLFxuICAgIFNUQVRFX0JFR0FOOiBTVEFURV9CRUdBTixcbiAgICBTVEFURV9DSEFOR0VEOiBTVEFURV9DSEFOR0VELFxuICAgIFNUQVRFX0VOREVEOiBTVEFURV9FTkRFRCxcbiAgICBTVEFURV9SRUNPR05JWkVEOiBTVEFURV9SRUNPR05JWkVELFxuICAgIFNUQVRFX0NBTkNFTExFRDogU1RBVEVfQ0FOQ0VMTEVELFxuICAgIFNUQVRFX0ZBSUxFRDogU1RBVEVfRkFJTEVELFxuXG4gICAgRElSRUNUSU9OX05PTkU6IERJUkVDVElPTl9OT05FLFxuICAgIERJUkVDVElPTl9MRUZUOiBESVJFQ1RJT05fTEVGVCxcbiAgICBESVJFQ1RJT05fUklHSFQ6IERJUkVDVElPTl9SSUdIVCxcbiAgICBESVJFQ1RJT05fVVA6IERJUkVDVElPTl9VUCxcbiAgICBESVJFQ1RJT05fRE9XTjogRElSRUNUSU9OX0RPV04sXG4gICAgRElSRUNUSU9OX0hPUklaT05UQUw6IERJUkVDVElPTl9IT1JJWk9OVEFMLFxuICAgIERJUkVDVElPTl9WRVJUSUNBTDogRElSRUNUSU9OX1ZFUlRJQ0FMLFxuICAgIERJUkVDVElPTl9BTEw6IERJUkVDVElPTl9BTEwsXG5cbiAgICBNYW5hZ2VyOiBNYW5hZ2VyLFxuICAgIElucHV0OiBJbnB1dCxcbiAgICBUb3VjaEFjdGlvbjogVG91Y2hBY3Rpb24sXG5cbiAgICBUb3VjaElucHV0OiBUb3VjaElucHV0LFxuICAgIE1vdXNlSW5wdXQ6IE1vdXNlSW5wdXQsXG4gICAgUG9pbnRlckV2ZW50SW5wdXQ6IFBvaW50ZXJFdmVudElucHV0LFxuICAgIFRvdWNoTW91c2VJbnB1dDogVG91Y2hNb3VzZUlucHV0LFxuICAgIFNpbmdsZVRvdWNoSW5wdXQ6IFNpbmdsZVRvdWNoSW5wdXQsXG5cbiAgICBSZWNvZ25pemVyOiBSZWNvZ25pemVyLFxuICAgIEF0dHJSZWNvZ25pemVyOiBBdHRyUmVjb2duaXplcixcbiAgICBUYXA6IFRhcFJlY29nbml6ZXIsXG4gICAgUGFuOiBQYW5SZWNvZ25pemVyLFxuICAgIFN3aXBlOiBTd2lwZVJlY29nbml6ZXIsXG4gICAgUGluY2g6IFBpbmNoUmVjb2duaXplcixcbiAgICBSb3RhdGU6IFJvdGF0ZVJlY29nbml6ZXIsXG4gICAgUHJlc3M6IFByZXNzUmVjb2duaXplcixcblxuICAgIG9uOiBhZGRFdmVudExpc3RlbmVycyxcbiAgICBvZmY6IHJlbW92ZUV2ZW50TGlzdGVuZXJzLFxuICAgIGVhY2g6IGVhY2gsXG4gICAgbWVyZ2U6IG1lcmdlLFxuICAgIGV4dGVuZDogZXh0ZW5kLFxuICAgIGFzc2lnbjogYXNzaWduLFxuICAgIGluaGVyaXQ6IGluaGVyaXQsXG4gICAgYmluZEZuOiBiaW5kRm4sXG4gICAgcHJlZml4ZWQ6IHByZWZpeGVkXG59KTtcblxuLy8gdGhpcyBwcmV2ZW50cyBlcnJvcnMgd2hlbiBIYW1tZXIgaXMgbG9hZGVkIGluIHRoZSBwcmVzZW5jZSBvZiBhbiBBTURcbi8vICBzdHlsZSBsb2FkZXIgYnV0IGJ5IHNjcmlwdCB0YWcsIG5vdCBieSB0aGUgbG9hZGVyLlxudmFyIGZyZWVHbG9iYWwgPSAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyB3aW5kb3cgOiAodHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnID8gc2VsZiA6IHt9KSk7IC8vIGpzaGludCBpZ25vcmU6bGluZVxuZnJlZUdsb2JhbC5IYW1tZXIgPSBIYW1tZXI7XG5cbmlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHtcbiAgICBkZWZpbmUoZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBIYW1tZXI7XG4gICAgfSk7XG59IGVsc2UgaWYgKHR5cGVvZiBtb2R1bGUgIT0gJ3VuZGVmaW5lZCcgJiYgbW9kdWxlLmV4cG9ydHMpIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IEhhbW1lcjtcbn0gZWxzZSB7XG4gICAgd2luZG93W2V4cG9ydE5hbWVdID0gSGFtbWVyO1xufVxuXG59KSh3aW5kb3csIGRvY3VtZW50LCAnSGFtbWVyJyk7XG4iLCAiaW1wb3J0IHsgUGx1Z2luLCBFZGl0b3IsIE1hcmtkb3duVmlldywgTm90aWNlIH0gZnJvbSAnb2JzaWRpYW4nO1xuaW1wb3J0IHsgdGhlbWVDb2xvcnMgfSBmcm9tICcuL2NoYXJ0Y29sb3InO1xuaW1wb3J0IHsgQ1NWVGFibGVDb252ZXJ0ZXJTZXR0aW5nVGFiIH0gZnJvbSAnLi9zZXR0aW5ncyc7XG5pbXBvcnQgeyByZWdpc3RlckNTVkNoYXJ0UHJvY2Vzc29yIH0gZnJvbSAnLi9jaGFydCc7XG5pbXBvcnQgeyByZWdpc3RlckNTVlRhYmxlUHJvY2Vzc29yIH0gZnJvbSAnLi9jc3ZUYWJsZV9pbnRlcmFjdGl2ZSc7XG5pbXBvcnQgeyBpc1ZhbGlkQ1NWLCBjb252ZXJ0Q1NWVG9NYXJrZG93blRhYmxlIH0gZnJvbSAnLi9jc3YybWFya2Rvd24nO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDU1ZUYWJsZUNvbnZlcnRlciBleHRlbmRzIFBsdWdpbiB7XG4gICAgc2V0dGluZ3M6IHtcbiAgICAgICAgbXlTZXR0aW5nOiBzdHJpbmc7XG4gICAgfTtcbiAgICBhc3luYyBvbmxvYWQoKSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZFNldHRpbmdzKCk7XG5cbiAgICAgICAgLy8gUmVnaXN0ZXIgQ1NWIENoYXJ0IGNvZGUgYmxvY2sgcHJvY2Vzc29yXG4gICAgICAgIHRoaXMucmVnaXN0ZXJNYXJrZG93bkNvZGVCbG9ja1Byb2Nlc3NvcihcImNzdi1jaGFydFwiLCAoc291cmNlLCBlbCwgY3R4KSA9PiB7XG4gICAgICAgICAgICByZWdpc3RlckNTVkNoYXJ0UHJvY2Vzc29yKHNvdXJjZSwgZWwsIGN0eCwgdGhlbWVDb2xvcnMpO1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyBSZWdpc3RlciBDU1YgdG8gTWFya2Rvd24gdGFibGUgY29kZSBibG9jayBwcm9jZXNzb3JcbiAgICAgICAgdGhpcy5yZWdpc3Rlck1hcmtkb3duQ29kZUJsb2NrUHJvY2Vzc29yKFwiY3N2LXRhYmxlXCIsIChzb3VyY2UsIGVsLCBjdHgpID0+IHtcbiAgICAgICAgICAgIHJlZ2lzdGVyQ1NWVGFibGVQcm9jZXNzb3Ioc291cmNlLCBlbCwgY3R4KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gQWRkIGEgY29tbWFuZCB0byBjb252ZXJ0IENTViBmb3JtYXR0ZWQgdGV4dCB0byBhIE1hcmtkb3duIHRhYmxlXG4gICAgICAgIC8vIFRoaXMgY29tbWFuZCBjYW4gYmUgZXhlY3V0ZWQgYWZ0ZXIgc2VsZWN0aW5nIENTViB0ZXh0IGluIHRoZSBlZGl0b3JcbiAgICAgICAgLy8gSWYgdGhlIHNlbGVjdGVkIHRleHQgaXMgdmFsaWQgQ1NWIGZvcm1hdCwgaXQgd2lsbCBiZSBjb252ZXJ0ZWQgdG8gYSBNYXJrZG93biB0YWJsZSBhbmQgcmVwbGFjZSB0aGUgb3JpZ2luYWwgdGV4dFxuICAgICAgICAvLyBJZiB0aGUgc2VsZWN0ZWQgdGV4dCBpcyBub3QgdmFsaWQgQ1NWIGZvcm1hdCwgYSBub3RpZmljYXRpb24gd2lsbCBiZSBkaXNwbGF5ZWRcbiAgICAgICAgdGhpcy5hZGRDb21tYW5kKHtcblx0XHRcdGlkOiAnY29udmVydC1jc3YtdG8tbWFya2Rvd24tdGFibGUnLFxuXHRcdFx0bmFtZTogJ0NvbnZlcnQgQ1NWIHRvIE1hcmtkb3duIFRhYmxlJyxcblx0XHRcdC8vaG90a2V5czogW3sgbW9kaWZpZXJzOiBbJ01vZCddLCBrZXk6ICdrJyB9XSxcbiAgICAgICAgICAgIGhvdGtleXM6IFtdLFxuXHRcdFx0ZWRpdG9yQ2FsbGJhY2s6IChlZGl0b3I6IEVkaXRvciwgdmlldzogTWFya2Rvd25WaWV3KSA9PiB7XG5cdFx0XHRcdGNvbnN0IHNlbGVjdGlvbiA9IGVkaXRvci5nZXRTZWxlY3Rpb24oKTtcblx0XHRcdFx0aWYgKGlzVmFsaWRDU1Yoc2VsZWN0aW9uKSkge1xuXHRcdFx0XHRcdGNvbnN0IG1hcmtkb3duVGFibGUgPSBjb252ZXJ0Q1NWVG9NYXJrZG93blRhYmxlKHNlbGVjdGlvbik7XG5cdFx0XHRcdFx0ZWRpdG9yLnJlcGxhY2VTZWxlY3Rpb24obWFya2Rvd25UYWJsZSk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0bmV3IE5vdGljZSgnU2VsZWN0ZWQgdGV4dCBpcyBub3QgYSB2YWxpZCBDU1YgZm9ybWF0Jyk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9KTtcblxuICAgICAgICAvLyBBZGQgc2V0dGluZ3MgdGFiXG4gICAgICAgIHRoaXMuYWRkU2V0dGluZ1RhYihuZXcgQ1NWVGFibGVDb252ZXJ0ZXJTZXR0aW5nVGFiKHRoaXMuYXBwLCB0aGlzKSk7XG4gICAgfVxuXG4gICAgYXN5bmMgbG9hZFNldHRpbmdzKCkge1xuICAgICAgICB0aGlzLnNldHRpbmdzID0gT2JqZWN0LmFzc2lnbih7fSwge1xuICAgICAgICAgICAgbXlTZXR0aW5nOiAnLCdcbiAgICAgICAgfSwgYXdhaXQgdGhpcy5sb2FkRGF0YSgpKTtcbiAgICB9XG5cbiAgICBhc3luYyBzYXZlU2V0dGluZ3MoKSB7XG4gICAgICAgIGF3YWl0IHRoaXMuc2F2ZURhdGEodGhpcy5zZXR0aW5ncyk7XG4gICAgfVxufVxuIiwgImV4cG9ydCBjb25zdCB0aGVtZUNvbG9ycyA9IHtcbiAgICBvcmFuZ2U6IHtcbiAgICAgICAgYmFja2dyb3VuZENvbG9yOiBbXG4gICAgICAgICAgICAncmdiYSgyMzMsIDExMywgNTAsIDAuNiknLCBcbiAgICAgICAgICAgICdyZ2JhKDI1NSwgMTU5LCA2NCwgMC42KScsIFxuICAgICAgICAgICAgJ3JnYmEoMjU1LCA5NCwgNzcsIDAuNiknLCBcbiAgICAgICAgICAgICdyZ2JhKDI1NSwgMTkwLCAxMDUsIDAuNiknXG4gICAgICAgIF0sIC8vIEFycmF5IG9mIGNvbG9ycyBmb3IgcGllIGNoYXJ0IHNlZ21lbnRzXG4gICAgICAgIGJvcmRlckNvbG9yOiBbXG4gICAgICAgICAgICAncmdiYSgyMzMsIDExMywgNTAsIDEpJywgXG4gICAgICAgICAgICAncmdiYSgyNTUsIDE1OSwgNjQsIDEpJywgXG4gICAgICAgICAgICAncmdiYSgyNTUsIDk0LCA3NywgMSknLCBcbiAgICAgICAgICAgICdyZ2JhKDI1NSwgMTkwLCAxMDUsIDEpJ1xuICAgICAgICBdLCAvLyBBcnJheSBvZiBjb2xvcnMgZm9yIHBpZSBjaGFydCBib3JkZXJzXG4gICAgfSxcbiAgICBibHVlOiB7XG4gICAgICAgIGJhY2tncm91bmRDb2xvcjogW1xuICAgICAgICAgICAgJ3JnYmEoNTEsIDEwMiwgMTUzLCAwLjYpJywgXG4gICAgICAgICAgICAncmdiYSg3MiwgMTMzLCAyMzcsIDAuNiknLCBcbiAgICAgICAgICAgICdyZ2JhKDkzLCAxNjUsIDIxOCwgMC42KScsIFxuICAgICAgICAgICAgJ3JnYmEoMTI4LCAxOTQsIDI1NSwgMC42KSdcbiAgICAgICAgXSxcbiAgICAgICAgYm9yZGVyQ29sb3I6IFtcbiAgICAgICAgICAgICdyZ2JhKDUxLCAxMDIsIDE1MywgMSknLCBcbiAgICAgICAgICAgICdyZ2JhKDcyLCAxMzMsIDIzNywgMSknLCBcbiAgICAgICAgICAgICdyZ2JhKDkzLCAxNjUsIDIxOCwgMSknLCBcbiAgICAgICAgICAgICdyZ2JhKDEyOCwgMTk0LCAyNTUsIDEpJ1xuICAgICAgICBdLFxuICAgIH0sXG4gICAgZ3JlZW46IHtcbiAgICAgICAgYmFja2dyb3VuZENvbG9yOiBbXG4gICAgICAgICAgICAncmdiYSg0NCwgMTU5LCA2OSwgMC42KScsIFxuICAgICAgICAgICAgJ3JnYmEoNzUsIDE4MSwgNjcsIDAuNiknLCBcbiAgICAgICAgICAgICdyZ2JhKDEwMCwgMTkzLCAxMTgsIDAuNiknLCBcbiAgICAgICAgICAgICdyZ2JhKDE0NSwgMjMyLCA2NiwgMC42KSdcbiAgICAgICAgXSxcbiAgICAgICAgYm9yZGVyQ29sb3I6IFtcbiAgICAgICAgICAgICdyZ2JhKDQ0LCAxNTksIDY5LCAxKScsIFxuICAgICAgICAgICAgJ3JnYmEoNzUsIDE4MSwgNjcsIDEpJywgXG4gICAgICAgICAgICAncmdiYSgxMDAsIDE5MywgMTE4LCAxKScsIFxuICAgICAgICAgICAgJ3JnYmEoMTQ1LCAyMzIsIDY2LCAxKSdcbiAgICAgICAgXSxcbiAgICB9LFxuICAgIHB1cnBsZToge1xuICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IFtcbiAgICAgICAgICAgICdyZ2JhKDEwOCwgNTIsIDEzMSwgMC42KScsIFxuICAgICAgICAgICAgJ3JnYmEoMTQyLCA2OCwgMTczLCAwLjYpJywgXG4gICAgICAgICAgICAncmdiYSgxNjUsIDEwNSwgMTg5LCAwLjYpJywgXG4gICAgICAgICAgICAncmdiYSgxODcsIDE0MywgMjA2LCAwLjYpJ1xuICAgICAgICBdLFxuICAgICAgICBib3JkZXJDb2xvcjogW1xuICAgICAgICAgICAgJ3JnYmEoMTA4LCA1MiwgMTMxLCAxKScsIFxuICAgICAgICAgICAgJ3JnYmEoMTQyLCA2OCwgMTczLCAxKScsIFxuICAgICAgICAgICAgJ3JnYmEoMTY1LCAxMDUsIDE4OSwgMSknLCBcbiAgICAgICAgICAgICdyZ2JhKDE4NywgMTQzLCAyMDYsIDEpJ1xuICAgICAgICBdLFxuICAgIH0sXG4gICAgcmVkOiB7XG4gICAgICAgIGJhY2tncm91bmRDb2xvcjogW1xuICAgICAgICAgICAgJ3JnYmEoMTkyLCA1NywgNDMsIDAuNiknLCBcbiAgICAgICAgICAgICdyZ2JhKDIzMSwgNzYsIDYwLCAwLjYpJywgXG4gICAgICAgICAgICAncmdiYSgyMzUsIDg5LCA3MiwgMC42KScsIFxuICAgICAgICAgICAgJ3JnYmEoMjQxLCA5OCwgNzQsIDAuNiknXG4gICAgICAgIF0sXG4gICAgICAgIGJvcmRlckNvbG9yOiBbXG4gICAgICAgICAgICAncmdiYSgxOTIsIDU3LCA0MywgMSknLCBcbiAgICAgICAgICAgICdyZ2JhKDIzMSwgNzYsIDYwLCAxKScsIFxuICAgICAgICAgICAgJ3JnYmEoMjM1LCA4OSwgNzIsIDEpJywgXG4gICAgICAgICAgICAncmdiYSgyNDEsIDk4LCA3NCwgMSknXG4gICAgICAgIF0sXG4gICAgfSxcbiAgICBncmF5OiB7XG4gICAgICAgIGJhY2tncm91bmRDb2xvcjogW1xuICAgICAgICAgICAgJ3JnYmEoMTI3LCAxNDAsIDE0MSwgMC42KScsIFxuICAgICAgICAgICAgJ3JnYmEoMTQ5LCAxNjUsIDE2NiwgMC42KScsIFxuICAgICAgICAgICAgJ3JnYmEoMTg5LCAxOTUsIDE5OSwgMC42KScsIFxuICAgICAgICAgICAgJ3JnYmEoMjA0LCAyMTQsIDIxNywgMC42KSdcbiAgICAgICAgXSxcbiAgICAgICAgYm9yZGVyQ29sb3I6IFtcbiAgICAgICAgICAgICdyZ2JhKDEyNywgMTQwLCAxNDEsIDEpJywgXG4gICAgICAgICAgICAncmdiYSgxNDksIDE2NSwgMTY2LCAxKScsIFxuICAgICAgICAgICAgJ3JnYmEoMTg5LCAxOTUsIDE5OSwgMSknLCBcbiAgICAgICAgICAgICdyZ2JhKDIwNCwgMjE0LCAyMTcsIDEpJ1xuICAgICAgICBdLFxuICAgIH0sXG4gICAgeWVsbG93OiB7XG4gICAgICAgIGJhY2tncm91bmRDb2xvcjogW1xuICAgICAgICAgICAgJ3JnYmEoMjQxLCAxOTYsIDE1LCAwLjYpJywgXG4gICAgICAgICAgICAncmdiYSgyNDcsIDIyMCwgMTExLCAwLjYpJywgXG4gICAgICAgICAgICAncmdiYSgyNDgsIDIzMSwgMjgsIDAuNiknLCBcbiAgICAgICAgICAgICdyZ2JhKDI1MywgMjU1LCAxMzAsIDAuNiknXG4gICAgICAgIF0sXG4gICAgICAgIGJvcmRlckNvbG9yOiBbXG4gICAgICAgICAgICAncmdiYSgyNDEsIDE5NiwgMTUsIDEpJywgXG4gICAgICAgICAgICAncmdiYSgyNDcsIDIyMCwgMTExLCAxKScsIFxuICAgICAgICAgICAgJ3JnYmEoMjQ4LCAyMzEsIDI4LCAxKScsIFxuICAgICAgICAgICAgJ3JnYmEoMjUzLCAyNTUsIDEzMCwgMSknXG4gICAgICAgIF0sXG4gICAgfSxcbiAgICBwaW5rOiB7XG4gICAgICAgIGJhY2tncm91bmRDb2xvcjogW1xuICAgICAgICAgICAgJ3JnYmEoMjMzLCAzMCwgOTksIDAuNiknLCBcbiAgICAgICAgICAgICdyZ2JhKDIzNiwgNzIsIDEzMCwgMC42KScsIFxuICAgICAgICAgICAgJ3JnYmEoMjQxLCAxMDgsIDE1MCwgMC42KScsIFxuICAgICAgICAgICAgJ3JnYmEoMjQ1LCAxMzYsIDE2MiwgMC42KSdcbiAgICAgICAgXSxcbiAgICAgICAgYm9yZGVyQ29sb3I6IFtcbiAgICAgICAgICAgICdyZ2JhKDIzMywgMzAsIDk5LCAxKScsIFxuICAgICAgICAgICAgJ3JnYmEoMjM2LCA3MiwgMTMwLCAxKScsIFxuICAgICAgICAgICAgJ3JnYmEoMjQxLCAxMDgsIDE1MCwgMSknLCBcbiAgICAgICAgICAgICdyZ2JhKDI0NSwgMTM2LCAxNjIsIDEpJ1xuICAgICAgICBdLFxuICAgIH1cbn07XG4iLCAiXG5pbXBvcnQgeyBQbHVnaW5TZXR0aW5nVGFiLCBBcHAsIFNldHRpbmcgfSBmcm9tICdvYnNpZGlhbic7XG5pbXBvcnQgQ1NWVGFibGVDb252ZXJ0ZXIgZnJvbSAnLi9tYWluJztcblxuZXhwb3J0IGNsYXNzIENTVlRhYmxlQ29udmVydGVyU2V0dGluZ1RhYiBleHRlbmRzIFBsdWdpblNldHRpbmdUYWIge1xuICAgIHBsdWdpbjogQ1NWVGFibGVDb252ZXJ0ZXI7XG5cbiAgICBjb25zdHJ1Y3RvcihhcHA6IEFwcCwgcGx1Z2luOiBDU1ZUYWJsZUNvbnZlcnRlcikge1xuICAgICAgICBzdXBlcihhcHAsIHBsdWdpbik7XG4gICAgICAgIHRoaXMucGx1Z2luID0gcGx1Z2luO1xuICAgIH1cblxuICAgIGRpc3BsYXkoKTogdm9pZCB7XG4gICAgICAgIGNvbnN0IHsgY29udGFpbmVyRWwgfSA9IHRoaXM7XG5cbiAgICAgICAgY29udGFpbmVyRWwuZW1wdHkoKTtcblxuICAgICAgICBuZXcgU2V0dGluZyhjb250YWluZXJFbClcbiAgICAgICAgICAgIC5zZXROYW1lKCdEZWZhdWx0IERlbGltaXRlcicpXG4gICAgICAgICAgICAuc2V0RGVzYygnU2V0IHRoZSBkZWZhdWx0IGRlbGltaXRlciBmb3IgQ1NWJylcbiAgICAgICAgICAgIC5hZGRUZXh0KHRleHQgPT4gdGV4dFxuICAgICAgICAgICAgICAgIC5zZXRQbGFjZWhvbGRlcignRW50ZXIgZGVsaW1pdGVyLCBlLmcuICwnKVxuICAgICAgICAgICAgICAgIC5zZXRWYWx1ZSh0aGlzLnBsdWdpbi5zZXR0aW5ncy5teVNldHRpbmcpXG4gICAgICAgICAgICAgICAgLm9uQ2hhbmdlKGFzeW5jICh2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnBsdWdpbi5zZXR0aW5ncy5teVNldHRpbmcgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCk7XG4gICAgICAgICAgICAgICAgfSkpO1xuICAgIH1cbn1cbiIsICJpbXBvcnQgeyBNYXJrZG93blBvc3RQcm9jZXNzb3JDb250ZXh0LCBOb3RpY2UgfSBmcm9tICdvYnNpZGlhbic7XG5pbXBvcnQgeyBDaGFydCwgcmVnaXN0ZXJhYmxlcyB9IGZyb20gJ2NoYXJ0LmpzJztcbmltcG9ydCB6b29tUGx1Z2luIGZyb20gJ2NoYXJ0anMtcGx1Z2luLXpvb20nO1xuQ2hhcnQucmVnaXN0ZXIoLi4ucmVnaXN0ZXJhYmxlcywgem9vbVBsdWdpbik7XG5cbmludGVyZmFjZSBUaGVtZUNvbG9ycyB7XG4gICAgW2tleTogc3RyaW5nXToge1xuICAgICAgYmFja2dyb3VuZENvbG9yOiBzdHJpbmc7XG4gICAgICBib3JkZXJDb2xvcjogc3RyaW5nO1xuICAgIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiByZWdpc3RlckNTVkNoYXJ0UHJvY2Vzc29yKHNvdXJjZTogc3RyaW5nLCBlbDogSFRNTEVsZW1lbnQsIGN0eF9ibG9jazogTWFya2Rvd25Qb3N0UHJvY2Vzc29yQ29udGV4dCwgdGhlbWVDb2xvcnM6IFRoZW1lQ29sb3JzKSB7XG4gICAgY29uc3Qgcm93cyA9IHNvdXJjZS5zcGxpdChcIlxcblwiKS5maWx0ZXIoKHJvdykgPT4gcm93Lmxlbmd0aCA+IDApO1xuXG4gICAgaWYgKHJvd3MubGVuZ3RoIDwgMikge1xuICAgICAgICBuZXcgTm90aWNlKCdDU1YgZGF0YSBpcyB0b28gc2hvcnQuIEF0IGxlYXN0IG9uZSBoZWFkZXIgcm93IGFuZCBvbmUgZGF0YSByb3cgYXJlIHJlcXVpcmVkLicpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgcmF3Q29udGVudCA9IGN0eF9ibG9jay5nZXRTZWN0aW9uSW5mbyhlbCk7XG4gICAgY29uc3QgZmlyc3RMaW5lID0gcmF3Q29udGVudD8udGV4dC5zcGxpdChcIlxcblwiKVtyYXdDb250ZW50Py5saW5lU3RhcnRdID8/IFwiXCI7XG4gICAgY29uc3Qgb3B0aW9ucyA9IGZpcnN0TGluZS50cmltKCkuc3BsaXQoL1xccysvKTtcblxuICAgIC8vIEdldCB0aGUgY29sb3IgdGhlbWUgZnJvbSBvcHRpb25zWzFdIG9yIGRlZmF1bHQgdG8gXCJvcmFuZ2VcIlxuICAgIGNvbnN0IGNvbG9yVGhlbWUgPSBvcHRpb25zLmxlbmd0aCA+IDEgJiYgb3B0aW9uc1sxXS50cmltKCkgIT09IFwiXCIgPyBvcHRpb25zWzFdLnRyaW0oKS50b0xvd2VyQ2FzZSgpIDogXCJvcmFuZ2VcIjtcbiAgICBjb25zdCBjb2xvcnMgPSB0aGVtZUNvbG9ycy5oYXNPd25Qcm9wZXJ0eShjb2xvclRoZW1lKSA/IHRoZW1lQ29sb3JzW2NvbG9yVGhlbWVdIDogdGhlbWVDb2xvcnMub3JhbmdlO1xuXG4gICAgLy8gXHU1QjlBXHU0RTQ5XHU1MTQxXHU4QkI4XHU3Njg0XHU1NkZFXHU4ODY4XHU3QzdCXHU1NzhCXG4gICAgdHlwZSBBbGxvd2VkQ2hhcnRUeXBlID0gJ2JhcicgfCAnbGluZScgfCAncGllJyB8ICdkb3VnaG51dCcgfCAncmFkYXInO1xuXG4gICAgLy8gXHU0RkVFXHU2NTM5IGNoYXJ0VHlwZSBcdTc2ODRcdTU4RjBcdTY2MEVcbiAgICBjb25zdCBjaGFydFR5cGUgPSAob3B0aW9ucy5sZW5ndGggPiAyICYmIG9wdGlvbnNbMl0udHJpbSgpICE9PSBcIlwiID8gb3B0aW9uc1syXS50cmltKCkudG9Mb3dlckNhc2UoKSA6IFwiYmFyXCIpIGFzIEFsbG93ZWRDaGFydFR5cGU7XG5cbiAgICAvLyBQcmVwYXJlIGNoYXJ0IGRhdGFcbiAgICBjb25zdCBjaGFydExhYmVscyA9IFtdO1xuICAgIGNvbnN0IGNoYXJ0RGF0YSA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAxOyBpIDwgcm93cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBjb2xzID0gcm93c1tpXS5zcGxpdChcIixcIik7XG4gICAgICAgIGNoYXJ0TGFiZWxzLnB1c2goY29sc1swXSk7XG4gICAgICAgIGNoYXJ0RGF0YS5wdXNoKHBhcnNlRmxvYXQoY29sc1sxXSkpO1xuICAgIH1cblxuICAgIC8vIENyZWF0ZSBjaGFydCBjb250YWluZXJcbiAgICBjb25zdCBjaGFydENvbnRhaW5lciA9IGVsLmNyZWF0ZUVsKFwiZGl2XCIsIHsgY2xzOiAnY2hhcnQtY29udGFpbmVyJyB9KTtcbiAgICBjb25zdCBjYW52YXMgPSBjaGFydENvbnRhaW5lci5jcmVhdGVFbChcImNhbnZhc1wiLCB7IGNsczogJ2Nzdi1jaGFydCcgfSk7XG4gICBcbiAgICBjb25zdCBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICBpZiAoY3R4KSB7XG4gICAgICAgIG5ldyBDaGFydChjdHgsIHtcbiAgICAgICAgICAgIHR5cGU6IGNoYXJ0VHlwZSwgLy8gRHluYW1pYyBjaGFydCB0eXBlIGJhc2VkIG9uIHRoZSB0aGlyZCBvcHRpb25cbiAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICBsYWJlbHM6IGNoYXJ0TGFiZWxzLFxuICAgICAgICAgICAgICAgIGRhdGFzZXRzOiBbe1xuICAgICAgICAgICAgICAgICAgICBsYWJlbDogcm93c1swXS5zcGxpdChcIixcIilbMV0sXG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IGNoYXJ0RGF0YSxcbiAgICAgICAgICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiBjb2xvcnMuYmFja2dyb3VuZENvbG9yLFxuICAgICAgICAgICAgICAgICAgICBib3JkZXJDb2xvcjogY29sb3JzLmJvcmRlckNvbG9yLFxuICAgICAgICAgICAgICAgICAgICBib3JkZXJXaWR0aDogMSxcbiAgICAgICAgICAgICAgICB9XSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBvcHRpb25zOiB7XG4gICAgICAgICAgICAgICAgc2NhbGVzOiBjaGFydFR5cGUgPT09ICdiYXInIHx8IGNoYXJ0VHlwZSA9PT0gJ2xpbmUnID8geyAvLyBPbmx5IHNob3cgc2NhbGVzIGZvciBiYXIvbGluZSBjaGFydHNcbiAgICAgICAgICAgICAgICAgICAgeTogeyBiZWdpbkF0WmVybzogdHJ1ZSB9LFxuICAgICAgICAgICAgICAgIH0gOiB7fSxcbiAgICAgICAgICAgICAgICBwbHVnaW5zOiB7XG4gICAgICAgICAgICAgICAgICAgIHpvb206IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHpvb206IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aGVlbDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmFibGVkOiB0cnVlLCAvLyBFbmFibGUgem9vbWluZyB3aXRoIG1vdXNlIHdoZWVsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwaW5jaDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmFibGVkOiB0cnVlLCAvLyBFbmFibGUgem9vbWluZyB3aXRoIHRvdWNoIGdlc3R1cmVzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtb2RlOiAneHknLCAvLyBab29tIG9uIGJvdGggeCBhbmQgeSBheGVzXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgcGFuOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5hYmxlZDogdHJ1ZSwgLy8gRW5hYmxlIHBhbm5pbmdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtb2RlOiAneHknLCAvLyBQYW4gb24gYm90aCBheGVzXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB0b29sdGlwOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbmFibGVkOiB0cnVlLCAvLyBFbmFibGUgdG9vbHRpcHMgb24gaG92ZXJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsOiBmdW5jdGlvbih0b29sdGlwSXRlbSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYCR7dG9vbHRpcEl0ZW0uZGF0YXNldC5sYWJlbH06ICR7dG9vbHRpcEl0ZW0ucmF3fWA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignVW5hYmxlIHRvIGdldCBjYW52YXMgY29udGV4dCcpO1xuICAgIH1cbn1cbiIsICIvKiFcbiAqIEBrdXJrbGUvY29sb3IgdjAuMy4yXG4gKiBodHRwczovL2dpdGh1Yi5jb20va3Vya2xlL2NvbG9yI3JlYWRtZVxuICogKGMpIDIwMjMgSnVra2EgS3Vya2VsYVxuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlXG4gKi9cbmZ1bmN0aW9uIHJvdW5kKHYpIHtcbiAgcmV0dXJuIHYgKyAwLjUgfCAwO1xufVxuY29uc3QgbGltID0gKHYsIGwsIGgpID0+IE1hdGgubWF4KE1hdGgubWluKHYsIGgpLCBsKTtcbmZ1bmN0aW9uIHAyYih2KSB7XG4gIHJldHVybiBsaW0ocm91bmQodiAqIDIuNTUpLCAwLCAyNTUpO1xufVxuZnVuY3Rpb24gYjJwKHYpIHtcbiAgcmV0dXJuIGxpbShyb3VuZCh2IC8gMi41NSksIDAsIDEwMCk7XG59XG5mdW5jdGlvbiBuMmIodikge1xuICByZXR1cm4gbGltKHJvdW5kKHYgKiAyNTUpLCAwLCAyNTUpO1xufVxuZnVuY3Rpb24gYjJuKHYpIHtcbiAgcmV0dXJuIGxpbShyb3VuZCh2IC8gMi41NSkgLyAxMDAsIDAsIDEpO1xufVxuZnVuY3Rpb24gbjJwKHYpIHtcbiAgcmV0dXJuIGxpbShyb3VuZCh2ICogMTAwKSwgMCwgMTAwKTtcbn1cblxuY29uc3QgbWFwJDEgPSB7MDogMCwgMTogMSwgMjogMiwgMzogMywgNDogNCwgNTogNSwgNjogNiwgNzogNywgODogOCwgOTogOSwgQTogMTAsIEI6IDExLCBDOiAxMiwgRDogMTMsIEU6IDE0LCBGOiAxNSwgYTogMTAsIGI6IDExLCBjOiAxMiwgZDogMTMsIGU6IDE0LCBmOiAxNX07XG5jb25zdCBoZXggPSBbLi4uJzAxMjM0NTY3ODlBQkNERUYnXTtcbmNvbnN0IGgxID0gYiA9PiBoZXhbYiAmIDB4Rl07XG5jb25zdCBoMiA9IGIgPT4gaGV4WyhiICYgMHhGMCkgPj4gNF0gKyBoZXhbYiAmIDB4Rl07XG5jb25zdCBlcSA9IGIgPT4gKChiICYgMHhGMCkgPj4gNCkgPT09IChiICYgMHhGKTtcbmNvbnN0IGlzU2hvcnQgPSB2ID0+IGVxKHYucikgJiYgZXEodi5nKSAmJiBlcSh2LmIpICYmIGVxKHYuYSk7XG5mdW5jdGlvbiBoZXhQYXJzZShzdHIpIHtcbiAgdmFyIGxlbiA9IHN0ci5sZW5ndGg7XG4gIHZhciByZXQ7XG4gIGlmIChzdHJbMF0gPT09ICcjJykge1xuICAgIGlmIChsZW4gPT09IDQgfHwgbGVuID09PSA1KSB7XG4gICAgICByZXQgPSB7XG4gICAgICAgIHI6IDI1NSAmIG1hcCQxW3N0clsxXV0gKiAxNyxcbiAgICAgICAgZzogMjU1ICYgbWFwJDFbc3RyWzJdXSAqIDE3LFxuICAgICAgICBiOiAyNTUgJiBtYXAkMVtzdHJbM11dICogMTcsXG4gICAgICAgIGE6IGxlbiA9PT0gNSA/IG1hcCQxW3N0cls0XV0gKiAxNyA6IDI1NVxuICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKGxlbiA9PT0gNyB8fCBsZW4gPT09IDkpIHtcbiAgICAgIHJldCA9IHtcbiAgICAgICAgcjogbWFwJDFbc3RyWzFdXSA8PCA0IHwgbWFwJDFbc3RyWzJdXSxcbiAgICAgICAgZzogbWFwJDFbc3RyWzNdXSA8PCA0IHwgbWFwJDFbc3RyWzRdXSxcbiAgICAgICAgYjogbWFwJDFbc3RyWzVdXSA8PCA0IHwgbWFwJDFbc3RyWzZdXSxcbiAgICAgICAgYTogbGVuID09PSA5ID8gKG1hcCQxW3N0cls3XV0gPDwgNCB8IG1hcCQxW3N0cls4XV0pIDogMjU1XG4gICAgICB9O1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmV0O1xufVxuY29uc3QgYWxwaGEgPSAoYSwgZikgPT4gYSA8IDI1NSA/IGYoYSkgOiAnJztcbmZ1bmN0aW9uIGhleFN0cmluZyh2KSB7XG4gIHZhciBmID0gaXNTaG9ydCh2KSA/IGgxIDogaDI7XG4gIHJldHVybiB2XG4gICAgPyAnIycgKyBmKHYucikgKyBmKHYuZykgKyBmKHYuYikgKyBhbHBoYSh2LmEsIGYpXG4gICAgOiB1bmRlZmluZWQ7XG59XG5cbmNvbnN0IEhVRV9SRSA9IC9eKGhzbGE/fGh3Ynxoc3YpXFwoXFxzKihbLSsuZVxcZF0rKSg/OmRlZyk/W1xccyxdKyhbLSsuZVxcZF0rKSVbXFxzLF0rKFstKy5lXFxkXSspJSg/OltcXHMsXSsoWy0rLmVcXGRdKykoJSk/KT9cXHMqXFwpJC87XG5mdW5jdGlvbiBoc2wycmdibihoLCBzLCBsKSB7XG4gIGNvbnN0IGEgPSBzICogTWF0aC5taW4obCwgMSAtIGwpO1xuICBjb25zdCBmID0gKG4sIGsgPSAobiArIGggLyAzMCkgJSAxMikgPT4gbCAtIGEgKiBNYXRoLm1heChNYXRoLm1pbihrIC0gMywgOSAtIGssIDEpLCAtMSk7XG4gIHJldHVybiBbZigwKSwgZig4KSwgZig0KV07XG59XG5mdW5jdGlvbiBoc3YycmdibihoLCBzLCB2KSB7XG4gIGNvbnN0IGYgPSAobiwgayA9IChuICsgaCAvIDYwKSAlIDYpID0+IHYgLSB2ICogcyAqIE1hdGgubWF4KE1hdGgubWluKGssIDQgLSBrLCAxKSwgMCk7XG4gIHJldHVybiBbZig1KSwgZigzKSwgZigxKV07XG59XG5mdW5jdGlvbiBod2IycmdibihoLCB3LCBiKSB7XG4gIGNvbnN0IHJnYiA9IGhzbDJyZ2JuKGgsIDEsIDAuNSk7XG4gIGxldCBpO1xuICBpZiAodyArIGIgPiAxKSB7XG4gICAgaSA9IDEgLyAodyArIGIpO1xuICAgIHcgKj0gaTtcbiAgICBiICo9IGk7XG4gIH1cbiAgZm9yIChpID0gMDsgaSA8IDM7IGkrKykge1xuICAgIHJnYltpXSAqPSAxIC0gdyAtIGI7XG4gICAgcmdiW2ldICs9IHc7XG4gIH1cbiAgcmV0dXJuIHJnYjtcbn1cbmZ1bmN0aW9uIGh1ZVZhbHVlKHIsIGcsIGIsIGQsIG1heCkge1xuICBpZiAociA9PT0gbWF4KSB7XG4gICAgcmV0dXJuICgoZyAtIGIpIC8gZCkgKyAoZyA8IGIgPyA2IDogMCk7XG4gIH1cbiAgaWYgKGcgPT09IG1heCkge1xuICAgIHJldHVybiAoYiAtIHIpIC8gZCArIDI7XG4gIH1cbiAgcmV0dXJuIChyIC0gZykgLyBkICsgNDtcbn1cbmZ1bmN0aW9uIHJnYjJoc2wodikge1xuICBjb25zdCByYW5nZSA9IDI1NTtcbiAgY29uc3QgciA9IHYuciAvIHJhbmdlO1xuICBjb25zdCBnID0gdi5nIC8gcmFuZ2U7XG4gIGNvbnN0IGIgPSB2LmIgLyByYW5nZTtcbiAgY29uc3QgbWF4ID0gTWF0aC5tYXgociwgZywgYik7XG4gIGNvbnN0IG1pbiA9IE1hdGgubWluKHIsIGcsIGIpO1xuICBjb25zdCBsID0gKG1heCArIG1pbikgLyAyO1xuICBsZXQgaCwgcywgZDtcbiAgaWYgKG1heCAhPT0gbWluKSB7XG4gICAgZCA9IG1heCAtIG1pbjtcbiAgICBzID0gbCA+IDAuNSA/IGQgLyAoMiAtIG1heCAtIG1pbikgOiBkIC8gKG1heCArIG1pbik7XG4gICAgaCA9IGh1ZVZhbHVlKHIsIGcsIGIsIGQsIG1heCk7XG4gICAgaCA9IGggKiA2MCArIDAuNTtcbiAgfVxuICByZXR1cm4gW2ggfCAwLCBzIHx8IDAsIGxdO1xufVxuZnVuY3Rpb24gY2FsbG4oZiwgYSwgYiwgYykge1xuICByZXR1cm4gKFxuICAgIEFycmF5LmlzQXJyYXkoYSlcbiAgICAgID8gZihhWzBdLCBhWzFdLCBhWzJdKVxuICAgICAgOiBmKGEsIGIsIGMpXG4gICkubWFwKG4yYik7XG59XG5mdW5jdGlvbiBoc2wycmdiKGgsIHMsIGwpIHtcbiAgcmV0dXJuIGNhbGxuKGhzbDJyZ2JuLCBoLCBzLCBsKTtcbn1cbmZ1bmN0aW9uIGh3YjJyZ2IoaCwgdywgYikge1xuICByZXR1cm4gY2FsbG4oaHdiMnJnYm4sIGgsIHcsIGIpO1xufVxuZnVuY3Rpb24gaHN2MnJnYihoLCBzLCB2KSB7XG4gIHJldHVybiBjYWxsbihoc3YycmdibiwgaCwgcywgdik7XG59XG5mdW5jdGlvbiBodWUoaCkge1xuICByZXR1cm4gKGggJSAzNjAgKyAzNjApICUgMzYwO1xufVxuZnVuY3Rpb24gaHVlUGFyc2Uoc3RyKSB7XG4gIGNvbnN0IG0gPSBIVUVfUkUuZXhlYyhzdHIpO1xuICBsZXQgYSA9IDI1NTtcbiAgbGV0IHY7XG4gIGlmICghbSkge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAobVs1XSAhPT0gdikge1xuICAgIGEgPSBtWzZdID8gcDJiKCttWzVdKSA6IG4yYigrbVs1XSk7XG4gIH1cbiAgY29uc3QgaCA9IGh1ZSgrbVsyXSk7XG4gIGNvbnN0IHAxID0gK21bM10gLyAxMDA7XG4gIGNvbnN0IHAyID0gK21bNF0gLyAxMDA7XG4gIGlmIChtWzFdID09PSAnaHdiJykge1xuICAgIHYgPSBod2IycmdiKGgsIHAxLCBwMik7XG4gIH0gZWxzZSBpZiAobVsxXSA9PT0gJ2hzdicpIHtcbiAgICB2ID0gaHN2MnJnYihoLCBwMSwgcDIpO1xuICB9IGVsc2Uge1xuICAgIHYgPSBoc2wycmdiKGgsIHAxLCBwMik7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICByOiB2WzBdLFxuICAgIGc6IHZbMV0sXG4gICAgYjogdlsyXSxcbiAgICBhOiBhXG4gIH07XG59XG5mdW5jdGlvbiByb3RhdGUodiwgZGVnKSB7XG4gIHZhciBoID0gcmdiMmhzbCh2KTtcbiAgaFswXSA9IGh1ZShoWzBdICsgZGVnKTtcbiAgaCA9IGhzbDJyZ2IoaCk7XG4gIHYuciA9IGhbMF07XG4gIHYuZyA9IGhbMV07XG4gIHYuYiA9IGhbMl07XG59XG5mdW5jdGlvbiBoc2xTdHJpbmcodikge1xuICBpZiAoIXYpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgYSA9IHJnYjJoc2wodik7XG4gIGNvbnN0IGggPSBhWzBdO1xuICBjb25zdCBzID0gbjJwKGFbMV0pO1xuICBjb25zdCBsID0gbjJwKGFbMl0pO1xuICByZXR1cm4gdi5hIDwgMjU1XG4gICAgPyBgaHNsYSgke2h9LCAke3N9JSwgJHtsfSUsICR7YjJuKHYuYSl9KWBcbiAgICA6IGBoc2woJHtofSwgJHtzfSUsICR7bH0lKWA7XG59XG5cbmNvbnN0IG1hcCA9IHtcbiAgeDogJ2RhcmsnLFxuICBaOiAnbGlnaHQnLFxuICBZOiAncmUnLFxuICBYOiAnYmx1JyxcbiAgVzogJ2dyJyxcbiAgVjogJ21lZGl1bScsXG4gIFU6ICdzbGF0ZScsXG4gIEE6ICdlZScsXG4gIFQ6ICdvbCcsXG4gIFM6ICdvcicsXG4gIEI6ICdyYScsXG4gIEM6ICdsYXRlZycsXG4gIEQ6ICdpZ2h0cycsXG4gIFI6ICdpbicsXG4gIFE6ICd0dXJxdW9pcycsXG4gIEU6ICdoaScsXG4gIFA6ICdybycsXG4gIE86ICdhbCcsXG4gIE46ICdsZScsXG4gIE06ICdkZScsXG4gIEw6ICd5ZWxsbycsXG4gIEY6ICdlbicsXG4gIEs6ICdjaCcsXG4gIEc6ICdhcmtzJyxcbiAgSDogJ2VhJyxcbiAgSTogJ2lnaHRnJyxcbiAgSjogJ3doJ1xufTtcbmNvbnN0IG5hbWVzJDEgPSB7XG4gIE9pY2VYZTogJ2YwZjhmZicsXG4gIGFudGlxdWV3RXRlOiAnZmFlYmQ3JyxcbiAgYXF1YTogJ2ZmZmYnLFxuICBhcXVhbWFyUmU6ICc3ZmZmZDQnLFxuICBhenVZOiAnZjBmZmZmJyxcbiAgYmVpZ2U6ICdmNWY1ZGMnLFxuICBiaXNxdWU6ICdmZmU0YzQnLFxuICBibGFjazogJzAnLFxuICBibGFuS2VkT21vbmQ6ICdmZmViY2QnLFxuICBYZTogJ2ZmJyxcbiAgWGV2aVRldDogJzhhMmJlMicsXG4gIGJQd246ICdhNTJhMmEnLFxuICBidXJseXdvb2Q6ICdkZWI4ODcnLFxuICBjYU10WGU6ICc1ZjllYTAnLFxuICBLYXJ0WXVzZTogJzdmZmYwMCcsXG4gIEtvY1RhdGU6ICdkMjY5MWUnLFxuICBjU086ICdmZjdmNTAnLFxuICBjU25mbG93ZXJYZTogJzY0OTVlZCcsXG4gIGNTbnNpbGs6ICdmZmY4ZGMnLFxuICBjcmltc29uOiAnZGMxNDNjJyxcbiAgY3lhbjogJ2ZmZmYnLFxuICB4WGU6ICc4YicsXG4gIHhjeWFuOiAnOGI4YicsXG4gIHhnVE1uUGQ6ICdiODg2MGInLFxuICB4V2F5OiAnYTlhOWE5JyxcbiAgeGdZRjogJzY0MDAnLFxuICB4Z1l5OiAnYTlhOWE5JyxcbiAgeGtoYWtpOiAnYmRiNzZiJyxcbiAgeG1hZ0Z0YTogJzhiMDA4YicsXG4gIHhUaXZlZ1lGOiAnNTU2YjJmJyxcbiAgeFNhbmdlOiAnZmY4YzAwJyxcbiAgeFNjRWQ6ICc5OTMyY2MnLFxuICB4WWQ6ICc4YjAwMDAnLFxuICB4c09tb246ICdlOTk2N2EnLFxuICB4c0hnWUY6ICc4ZmJjOGYnLFxuICB4VVhlOiAnNDgzZDhiJyxcbiAgeFVXYXk6ICcyZjRmNGYnLFxuICB4VWdZeTogJzJmNGY0ZicsXG4gIHhRZTogJ2NlZDEnLFxuICB4dmlUZXQ6ICc5NDAwZDMnLFxuICBkQXBwUms6ICdmZjE0OTMnLFxuICBkQXBza3lYZTogJ2JmZmYnLFxuICBkaW1XYXk6ICc2OTY5NjknLFxuICBkaW1nWXk6ICc2OTY5NjknLFxuICBkb2RnZXJYZTogJzFlOTBmZicsXG4gIGZpWWJyaWNrOiAnYjIyMjIyJyxcbiAgZmxTT3dFdGU6ICdmZmZhZjAnLFxuICBmb1lzdFdBbjogJzIyOGIyMicsXG4gIGZ1S3NpYTogJ2ZmMDBmZicsXG4gIGdhUnNiU286ICdkY2RjZGMnLFxuICBnaG9zdHdFdGU6ICdmOGY4ZmYnLFxuICBnVGQ6ICdmZmQ3MDAnLFxuICBnVE1uUGQ6ICdkYWE1MjAnLFxuICBXYXk6ICc4MDgwODAnLFxuICBnWUY6ICc4MDAwJyxcbiAgZ1lGTHc6ICdhZGZmMmYnLFxuICBnWXk6ICc4MDgwODAnLFxuICBob25leU13OiAnZjBmZmYwJyxcbiAgaG90cFJrOiAnZmY2OWI0JyxcbiAgUmRpYW5ZZDogJ2NkNWM1YycsXG4gIFJkaWdvOiAnNGIwMDgyJyxcbiAgaXZTeTogJ2ZmZmZmMCcsXG4gIGtoYWtpOiAnZjBlNjhjJyxcbiAgbGF2Rk1yOiAnZTZlNmZhJyxcbiAgbGF2Rk1yWHNoOiAnZmZmMGY1JyxcbiAgbGF3bmdZRjogJzdjZmMwMCcsXG4gIE5tb25jRWZmb246ICdmZmZhY2QnLFxuICBaWGU6ICdhZGQ4ZTYnLFxuICBaY1NPOiAnZjA4MDgwJyxcbiAgWmN5YW46ICdlMGZmZmYnLFxuICBaZ1RNblBkTHc6ICdmYWZhZDInLFxuICBaV2F5OiAnZDNkM2QzJyxcbiAgWmdZRjogJzkwZWU5MCcsXG4gIFpnWXk6ICdkM2QzZDMnLFxuICBacFJrOiAnZmZiNmMxJyxcbiAgWnNPbW9uOiAnZmZhMDdhJyxcbiAgWnNIZ1lGOiAnMjBiMmFhJyxcbiAgWnNreVhlOiAnODdjZWZhJyxcbiAgWlVXYXk6ICc3Nzg4OTknLFxuICBaVWdZeTogJzc3ODg5OScsXG4gIFpzdEFsWGU6ICdiMGM0ZGUnLFxuICBaTHc6ICdmZmZmZTAnLFxuICBsaW1lOiAnZmYwMCcsXG4gIGxpbWVnWUY6ICczMmNkMzInLFxuICBsUkY6ICdmYWYwZTYnLFxuICBtYWdGdGE6ICdmZjAwZmYnLFxuICBtYVBvbjogJzgwMDAwMCcsXG4gIFZhcXVhbWFyUmU6ICc2NmNkYWEnLFxuICBWWGU6ICdjZCcsXG4gIFZTY0VkOiAnYmE1NWQzJyxcbiAgVnB1cnBOOiAnOTM3MGRiJyxcbiAgVnNIZ1lGOiAnM2NiMzcxJyxcbiAgVlVYZTogJzdiNjhlZScsXG4gIFZzcHJSZ2dZRjogJ2ZhOWEnLFxuICBWUWU6ICc0OGQxY2MnLFxuICBWdmlUZXRZZDogJ2M3MTU4NScsXG4gIG1pZG5pZ2h0WGU6ICcxOTE5NzAnLFxuICBtUnRjWWFtOiAnZjVmZmZhJyxcbiAgbWlzdHlQc2U6ICdmZmU0ZTEnLFxuICBtb2NjYXNSOiAnZmZlNGI1JyxcbiAgbmF2YWpvd0V0ZTogJ2ZmZGVhZCcsXG4gIG5hdnk6ICc4MCcsXG4gIFRkbGFjZTogJ2ZkZjVlNicsXG4gIFRpdmU6ICc4MDgwMDAnLFxuICBUaXZlZEJiOiAnNmI4ZTIzJyxcbiAgU2FuZ2U6ICdmZmE1MDAnLFxuICBTYW5nZVlkOiAnZmY0NTAwJyxcbiAgU2NFZDogJ2RhNzBkNicsXG4gIHBPZWdUTW5QZDogJ2VlZThhYScsXG4gIHBPZWdZRjogJzk4ZmI5OCcsXG4gIHBPZVFlOiAnYWZlZWVlJyxcbiAgcE9ldmlUZXRZZDogJ2RiNzA5MycsXG4gIHBhcGF5YXdFcDogJ2ZmZWZkNScsXG4gIHBIS3B1ZmY6ICdmZmRhYjknLFxuICBwZXJ1OiAnY2Q4NTNmJyxcbiAgcFJrOiAnZmZjMGNiJyxcbiAgcGx1bTogJ2RkYTBkZCcsXG4gIHBvd01yWGU6ICdiMGUwZTYnLFxuICBwdXJwTjogJzgwMDA4MCcsXG4gIFliZWNjYXB1cnBOOiAnNjYzMzk5JyxcbiAgWWQ6ICdmZjAwMDAnLFxuICBQc3licm93bjogJ2JjOGY4ZicsXG4gIFB5T1hlOiAnNDE2OWUxJyxcbiAgc2FkZE5iUHduOiAnOGI0NTEzJyxcbiAgc09tb246ICdmYTgwNzInLFxuICBzYW5keWJQd246ICdmNGE0NjAnLFxuICBzSGdZRjogJzJlOGI1NycsXG4gIHNIc2hlbGw6ICdmZmY1ZWUnLFxuICBzaUZuYTogJ2EwNTIyZCcsXG4gIHNpbHZlcjogJ2MwYzBjMCcsXG4gIHNreVhlOiAnODdjZWViJyxcbiAgVVhlOiAnNmE1YWNkJyxcbiAgVVdheTogJzcwODA5MCcsXG4gIFVnWXk6ICc3MDgwOTAnLFxuICBzbm93OiAnZmZmYWZhJyxcbiAgc3ByUmdnWUY6ICdmZjdmJyxcbiAgc3RBbFhlOiAnNDY4MmI0JyxcbiAgdGFuOiAnZDJiNDhjJyxcbiAgdGVPOiAnODA4MCcsXG4gIHRFc3ROOiAnZDhiZmQ4JyxcbiAgdG9tYXRvOiAnZmY2MzQ3JyxcbiAgUWU6ICc0MGUwZDAnLFxuICB2aVRldDogJ2VlODJlZScsXG4gIEpIdDogJ2Y1ZGViMycsXG4gIHdFdGU6ICdmZmZmZmYnLFxuICB3RXRlc21va2U6ICdmNWY1ZjUnLFxuICBMdzogJ2ZmZmYwMCcsXG4gIEx3Z1lGOiAnOWFjZDMyJ1xufTtcbmZ1bmN0aW9uIHVucGFjaygpIHtcbiAgY29uc3QgdW5wYWNrZWQgPSB7fTtcbiAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKG5hbWVzJDEpO1xuICBjb25zdCB0a2V5cyA9IE9iamVjdC5rZXlzKG1hcCk7XG4gIGxldCBpLCBqLCBrLCBvaywgbms7XG4gIGZvciAoaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgb2sgPSBuayA9IGtleXNbaV07XG4gICAgZm9yIChqID0gMDsgaiA8IHRrZXlzLmxlbmd0aDsgaisrKSB7XG4gICAgICBrID0gdGtleXNbal07XG4gICAgICBuayA9IG5rLnJlcGxhY2UoaywgbWFwW2tdKTtcbiAgICB9XG4gICAgayA9IHBhcnNlSW50KG5hbWVzJDFbb2tdLCAxNik7XG4gICAgdW5wYWNrZWRbbmtdID0gW2sgPj4gMTYgJiAweEZGLCBrID4+IDggJiAweEZGLCBrICYgMHhGRl07XG4gIH1cbiAgcmV0dXJuIHVucGFja2VkO1xufVxuXG5sZXQgbmFtZXM7XG5mdW5jdGlvbiBuYW1lUGFyc2Uoc3RyKSB7XG4gIGlmICghbmFtZXMpIHtcbiAgICBuYW1lcyA9IHVucGFjaygpO1xuICAgIG5hbWVzLnRyYW5zcGFyZW50ID0gWzAsIDAsIDAsIDBdO1xuICB9XG4gIGNvbnN0IGEgPSBuYW1lc1tzdHIudG9Mb3dlckNhc2UoKV07XG4gIHJldHVybiBhICYmIHtcbiAgICByOiBhWzBdLFxuICAgIGc6IGFbMV0sXG4gICAgYjogYVsyXSxcbiAgICBhOiBhLmxlbmd0aCA9PT0gNCA/IGFbM10gOiAyNTVcbiAgfTtcbn1cblxuY29uc3QgUkdCX1JFID0gL15yZ2JhP1xcKFxccyooWy0rLlxcZF0rKSglKT9bXFxzLF0rKFstKy5lXFxkXSspKCUpP1tcXHMsXSsoWy0rLmVcXGRdKykoJSk/KD86W1xccywvXSsoWy0rLmVcXGRdKykoJSk/KT9cXHMqXFwpJC87XG5mdW5jdGlvbiByZ2JQYXJzZShzdHIpIHtcbiAgY29uc3QgbSA9IFJHQl9SRS5leGVjKHN0cik7XG4gIGxldCBhID0gMjU1O1xuICBsZXQgciwgZywgYjtcbiAgaWYgKCFtKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChtWzddICE9PSByKSB7XG4gICAgY29uc3QgdiA9ICttWzddO1xuICAgIGEgPSBtWzhdID8gcDJiKHYpIDogbGltKHYgKiAyNTUsIDAsIDI1NSk7XG4gIH1cbiAgciA9ICttWzFdO1xuICBnID0gK21bM107XG4gIGIgPSArbVs1XTtcbiAgciA9IDI1NSAmIChtWzJdID8gcDJiKHIpIDogbGltKHIsIDAsIDI1NSkpO1xuICBnID0gMjU1ICYgKG1bNF0gPyBwMmIoZykgOiBsaW0oZywgMCwgMjU1KSk7XG4gIGIgPSAyNTUgJiAobVs2XSA/IHAyYihiKSA6IGxpbShiLCAwLCAyNTUpKTtcbiAgcmV0dXJuIHtcbiAgICByOiByLFxuICAgIGc6IGcsXG4gICAgYjogYixcbiAgICBhOiBhXG4gIH07XG59XG5mdW5jdGlvbiByZ2JTdHJpbmcodikge1xuICByZXR1cm4gdiAmJiAoXG4gICAgdi5hIDwgMjU1XG4gICAgICA/IGByZ2JhKCR7di5yfSwgJHt2Lmd9LCAke3YuYn0sICR7YjJuKHYuYSl9KWBcbiAgICAgIDogYHJnYigke3Yucn0sICR7di5nfSwgJHt2LmJ9KWBcbiAgKTtcbn1cblxuY29uc3QgdG8gPSB2ID0+IHYgPD0gMC4wMDMxMzA4ID8gdiAqIDEyLjkyIDogTWF0aC5wb3codiwgMS4wIC8gMi40KSAqIDEuMDU1IC0gMC4wNTU7XG5jb25zdCBmcm9tID0gdiA9PiB2IDw9IDAuMDQwNDUgPyB2IC8gMTIuOTIgOiBNYXRoLnBvdygodiArIDAuMDU1KSAvIDEuMDU1LCAyLjQpO1xuZnVuY3Rpb24gaW50ZXJwb2xhdGUocmdiMSwgcmdiMiwgdCkge1xuICBjb25zdCByID0gZnJvbShiMm4ocmdiMS5yKSk7XG4gIGNvbnN0IGcgPSBmcm9tKGIybihyZ2IxLmcpKTtcbiAgY29uc3QgYiA9IGZyb20oYjJuKHJnYjEuYikpO1xuICByZXR1cm4ge1xuICAgIHI6IG4yYih0byhyICsgdCAqIChmcm9tKGIybihyZ2IyLnIpKSAtIHIpKSksXG4gICAgZzogbjJiKHRvKGcgKyB0ICogKGZyb20oYjJuKHJnYjIuZykpIC0gZykpKSxcbiAgICBiOiBuMmIodG8oYiArIHQgKiAoZnJvbShiMm4ocmdiMi5iKSkgLSBiKSkpLFxuICAgIGE6IHJnYjEuYSArIHQgKiAocmdiMi5hIC0gcmdiMS5hKVxuICB9O1xufVxuXG5mdW5jdGlvbiBtb2RIU0wodiwgaSwgcmF0aW8pIHtcbiAgaWYgKHYpIHtcbiAgICBsZXQgdG1wID0gcmdiMmhzbCh2KTtcbiAgICB0bXBbaV0gPSBNYXRoLm1heCgwLCBNYXRoLm1pbih0bXBbaV0gKyB0bXBbaV0gKiByYXRpbywgaSA9PT0gMCA/IDM2MCA6IDEpKTtcbiAgICB0bXAgPSBoc2wycmdiKHRtcCk7XG4gICAgdi5yID0gdG1wWzBdO1xuICAgIHYuZyA9IHRtcFsxXTtcbiAgICB2LmIgPSB0bXBbMl07XG4gIH1cbn1cbmZ1bmN0aW9uIGNsb25lKHYsIHByb3RvKSB7XG4gIHJldHVybiB2ID8gT2JqZWN0LmFzc2lnbihwcm90byB8fCB7fSwgdikgOiB2O1xufVxuZnVuY3Rpb24gZnJvbU9iamVjdChpbnB1dCkge1xuICB2YXIgdiA9IHtyOiAwLCBnOiAwLCBiOiAwLCBhOiAyNTV9O1xuICBpZiAoQXJyYXkuaXNBcnJheShpbnB1dCkpIHtcbiAgICBpZiAoaW5wdXQubGVuZ3RoID49IDMpIHtcbiAgICAgIHYgPSB7cjogaW5wdXRbMF0sIGc6IGlucHV0WzFdLCBiOiBpbnB1dFsyXSwgYTogMjU1fTtcbiAgICAgIGlmIChpbnB1dC5sZW5ndGggPiAzKSB7XG4gICAgICAgIHYuYSA9IG4yYihpbnB1dFszXSk7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHYgPSBjbG9uZShpbnB1dCwge3I6IDAsIGc6IDAsIGI6IDAsIGE6IDF9KTtcbiAgICB2LmEgPSBuMmIodi5hKTtcbiAgfVxuICByZXR1cm4gdjtcbn1cbmZ1bmN0aW9uIGZ1bmN0aW9uUGFyc2Uoc3RyKSB7XG4gIGlmIChzdHIuY2hhckF0KDApID09PSAncicpIHtcbiAgICByZXR1cm4gcmdiUGFyc2Uoc3RyKTtcbiAgfVxuICByZXR1cm4gaHVlUGFyc2Uoc3RyKTtcbn1cbmNsYXNzIENvbG9yIHtcbiAgY29uc3RydWN0b3IoaW5wdXQpIHtcbiAgICBpZiAoaW5wdXQgaW5zdGFuY2VvZiBDb2xvcikge1xuICAgICAgcmV0dXJuIGlucHV0O1xuICAgIH1cbiAgICBjb25zdCB0eXBlID0gdHlwZW9mIGlucHV0O1xuICAgIGxldCB2O1xuICAgIGlmICh0eXBlID09PSAnb2JqZWN0Jykge1xuICAgICAgdiA9IGZyb21PYmplY3QoaW5wdXQpO1xuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHYgPSBoZXhQYXJzZShpbnB1dCkgfHwgbmFtZVBhcnNlKGlucHV0KSB8fCBmdW5jdGlvblBhcnNlKGlucHV0KTtcbiAgICB9XG4gICAgdGhpcy5fcmdiID0gdjtcbiAgICB0aGlzLl92YWxpZCA9ICEhdjtcbiAgfVxuICBnZXQgdmFsaWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3ZhbGlkO1xuICB9XG4gIGdldCByZ2IoKSB7XG4gICAgdmFyIHYgPSBjbG9uZSh0aGlzLl9yZ2IpO1xuICAgIGlmICh2KSB7XG4gICAgICB2LmEgPSBiMm4odi5hKTtcbiAgICB9XG4gICAgcmV0dXJuIHY7XG4gIH1cbiAgc2V0IHJnYihvYmopIHtcbiAgICB0aGlzLl9yZ2IgPSBmcm9tT2JqZWN0KG9iaik7XG4gIH1cbiAgcmdiU3RyaW5nKCkge1xuICAgIHJldHVybiB0aGlzLl92YWxpZCA/IHJnYlN0cmluZyh0aGlzLl9yZ2IpIDogdW5kZWZpbmVkO1xuICB9XG4gIGhleFN0cmluZygpIHtcbiAgICByZXR1cm4gdGhpcy5fdmFsaWQgPyBoZXhTdHJpbmcodGhpcy5fcmdiKSA6IHVuZGVmaW5lZDtcbiAgfVxuICBoc2xTdHJpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3ZhbGlkID8gaHNsU3RyaW5nKHRoaXMuX3JnYikgOiB1bmRlZmluZWQ7XG4gIH1cbiAgbWl4KGNvbG9yLCB3ZWlnaHQpIHtcbiAgICBpZiAoY29sb3IpIHtcbiAgICAgIGNvbnN0IGMxID0gdGhpcy5yZ2I7XG4gICAgICBjb25zdCBjMiA9IGNvbG9yLnJnYjtcbiAgICAgIGxldCB3MjtcbiAgICAgIGNvbnN0IHAgPSB3ZWlnaHQgPT09IHcyID8gMC41IDogd2VpZ2h0O1xuICAgICAgY29uc3QgdyA9IDIgKiBwIC0gMTtcbiAgICAgIGNvbnN0IGEgPSBjMS5hIC0gYzIuYTtcbiAgICAgIGNvbnN0IHcxID0gKCh3ICogYSA9PT0gLTEgPyB3IDogKHcgKyBhKSAvICgxICsgdyAqIGEpKSArIDEpIC8gMi4wO1xuICAgICAgdzIgPSAxIC0gdzE7XG4gICAgICBjMS5yID0gMHhGRiAmIHcxICogYzEuciArIHcyICogYzIuciArIDAuNTtcbiAgICAgIGMxLmcgPSAweEZGICYgdzEgKiBjMS5nICsgdzIgKiBjMi5nICsgMC41O1xuICAgICAgYzEuYiA9IDB4RkYgJiB3MSAqIGMxLmIgKyB3MiAqIGMyLmIgKyAwLjU7XG4gICAgICBjMS5hID0gcCAqIGMxLmEgKyAoMSAtIHApICogYzIuYTtcbiAgICAgIHRoaXMucmdiID0gYzE7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIGludGVycG9sYXRlKGNvbG9yLCB0KSB7XG4gICAgaWYgKGNvbG9yKSB7XG4gICAgICB0aGlzLl9yZ2IgPSBpbnRlcnBvbGF0ZSh0aGlzLl9yZ2IsIGNvbG9yLl9yZ2IsIHQpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBjbG9uZSgpIHtcbiAgICByZXR1cm4gbmV3IENvbG9yKHRoaXMucmdiKTtcbiAgfVxuICBhbHBoYShhKSB7XG4gICAgdGhpcy5fcmdiLmEgPSBuMmIoYSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgY2xlYXJlcihyYXRpbykge1xuICAgIGNvbnN0IHJnYiA9IHRoaXMuX3JnYjtcbiAgICByZ2IuYSAqPSAxIC0gcmF0aW87XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgZ3JleXNjYWxlKCkge1xuICAgIGNvbnN0IHJnYiA9IHRoaXMuX3JnYjtcbiAgICBjb25zdCB2YWwgPSByb3VuZChyZ2IuciAqIDAuMyArIHJnYi5nICogMC41OSArIHJnYi5iICogMC4xMSk7XG4gICAgcmdiLnIgPSByZ2IuZyA9IHJnYi5iID0gdmFsO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIG9wYXF1ZXIocmF0aW8pIHtcbiAgICBjb25zdCByZ2IgPSB0aGlzLl9yZ2I7XG4gICAgcmdiLmEgKj0gMSArIHJhdGlvO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIG5lZ2F0ZSgpIHtcbiAgICBjb25zdCB2ID0gdGhpcy5fcmdiO1xuICAgIHYuciA9IDI1NSAtIHYucjtcbiAgICB2LmcgPSAyNTUgLSB2Lmc7XG4gICAgdi5iID0gMjU1IC0gdi5iO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIGxpZ2h0ZW4ocmF0aW8pIHtcbiAgICBtb2RIU0wodGhpcy5fcmdiLCAyLCByYXRpbyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgZGFya2VuKHJhdGlvKSB7XG4gICAgbW9kSFNMKHRoaXMuX3JnYiwgMiwgLXJhdGlvKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBzYXR1cmF0ZShyYXRpbykge1xuICAgIG1vZEhTTCh0aGlzLl9yZ2IsIDEsIHJhdGlvKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBkZXNhdHVyYXRlKHJhdGlvKSB7XG4gICAgbW9kSFNMKHRoaXMuX3JnYiwgMSwgLXJhdGlvKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICByb3RhdGUoZGVnKSB7XG4gICAgcm90YXRlKHRoaXMuX3JnYiwgZGVnKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxufVxuXG5mdW5jdGlvbiBpbmRleF9lc20oaW5wdXQpIHtcbiAgcmV0dXJuIG5ldyBDb2xvcihpbnB1dCk7XG59XG5cbmV4cG9ydCB7IENvbG9yLCBiMm4sIGIycCwgaW5kZXhfZXNtIGFzIGRlZmF1bHQsIGhleFBhcnNlLCBoZXhTdHJpbmcsIGhzbDJyZ2IsIGhzbFN0cmluZywgaHN2MnJnYiwgaHVlUGFyc2UsIGh3YjJyZ2IsIGxpbSwgbjJiLCBuMnAsIG5hbWVQYXJzZSwgcDJiLCByZ2IyaHNsLCByZ2JQYXJzZSwgcmdiU3RyaW5nLCByb3RhdGUsIHJvdW5kIH07XG4iLCAiLyoqXG4gKiBAbmFtZXNwYWNlIENoYXJ0LmhlbHBlcnNcbiAqL1xuXG5pbXBvcnQgdHlwZSB7QW55T2JqZWN0fSBmcm9tICcuLi90eXBlcy9iYXNpYy5qcyc7XG5pbXBvcnQgdHlwZSB7QWN0aXZlRGF0YVBvaW50LCBDaGFydEV2ZW50fSBmcm9tICcuLi90eXBlcy9pbmRleC5qcyc7XG5cbi8qKlxuICogQW4gZW1wdHkgZnVuY3Rpb24gdGhhdCBjYW4gYmUgdXNlZCwgZm9yIGV4YW1wbGUsIGZvciBvcHRpb25hbCBjYWxsYmFjay5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG5vb3AoKSB7XG4gIC8qIG5vb3AgKi9cbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgdW5pcXVlIGlkLCBzZXF1ZW50aWFsbHkgZ2VuZXJhdGVkIGZyb20gYSBnbG9iYWwgdmFyaWFibGUuXG4gKi9cbmV4cG9ydCBjb25zdCB1aWQgPSAoKCkgPT4ge1xuICBsZXQgaWQgPSAwO1xuICByZXR1cm4gKCkgPT4gaWQrKztcbn0pKCk7XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIGB2YWx1ZWAgaXMgbmVpdGhlciBudWxsIG5vciB1bmRlZmluZWQsIGVsc2UgcmV0dXJucyBmYWxzZS5cbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byB0ZXN0LlxuICogQHNpbmNlIDIuNy4wXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc051bGxPclVuZGVmKHZhbHVlOiB1bmtub3duKTogdmFsdWUgaXMgbnVsbCB8IHVuZGVmaW5lZCB7XG4gIHJldHVybiB2YWx1ZSA9PT0gbnVsbCB8fCB0eXBlb2YgdmFsdWUgPT09ICd1bmRlZmluZWQnO1xufVxuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiBgdmFsdWVgIGlzIGFuIGFycmF5IChpbmNsdWRpbmcgdHlwZWQgYXJyYXlzKSwgZWxzZSByZXR1cm5zIGZhbHNlLlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIHRlc3QuXG4gKiBAZnVuY3Rpb25cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzQXJyYXk8VCA9IHVua25vd24+KHZhbHVlOiB1bmtub3duKTogdmFsdWUgaXMgVFtdIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkgJiYgQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBjb25zdCB0eXBlID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKTtcbiAgaWYgKHR5cGUuc2xpY2UoMCwgNykgPT09ICdbb2JqZWN0JyAmJiB0eXBlLnNsaWNlKC02KSA9PT0gJ0FycmF5XScpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIGB2YWx1ZWAgaXMgYW4gb2JqZWN0IChleGNsdWRpbmcgbnVsbCksIGVsc2UgcmV0dXJucyBmYWxzZS5cbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byB0ZXN0LlxuICogQHNpbmNlIDIuNy4wXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc09iamVjdCh2YWx1ZTogdW5rbm93bik6IHZhbHVlIGlzIEFueU9iamVjdCB7XG4gIHJldHVybiB2YWx1ZSAhPT0gbnVsbCAmJiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpID09PSAnW29iamVjdCBPYmplY3RdJztcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgYHZhbHVlYCBpcyBhIGZpbml0ZSBudW1iZXIsIGVsc2UgcmV0dXJucyBmYWxzZVxuICogQHBhcmFtIHZhbHVlICAtIFRoZSB2YWx1ZSB0byB0ZXN0LlxuICovXG5mdW5jdGlvbiBpc051bWJlckZpbml0ZSh2YWx1ZTogdW5rbm93bik6IHZhbHVlIGlzIG51bWJlciB7XG4gIHJldHVybiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyB8fCB2YWx1ZSBpbnN0YW5jZW9mIE51bWJlcikgJiYgaXNGaW5pdGUoK3ZhbHVlKTtcbn1cbmV4cG9ydCB7XG4gIGlzTnVtYmVyRmluaXRlIGFzIGlzRmluaXRlLFxufTtcblxuLyoqXG4gKiBSZXR1cm5zIGB2YWx1ZWAgaWYgZmluaXRlLCBlbHNlIHJldHVybnMgYGRlZmF1bHRWYWx1ZWAuXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gcmV0dXJuIGlmIGRlZmluZWQuXG4gKiBAcGFyYW0gZGVmYXVsdFZhbHVlIC0gVGhlIHZhbHVlIHRvIHJldHVybiBpZiBgdmFsdWVgIGlzIG5vdCBmaW5pdGUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmaW5pdGVPckRlZmF1bHQodmFsdWU6IHVua25vd24sIGRlZmF1bHRWYWx1ZTogbnVtYmVyKSB7XG4gIHJldHVybiBpc051bWJlckZpbml0ZSh2YWx1ZSkgPyB2YWx1ZSA6IGRlZmF1bHRWYWx1ZTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGB2YWx1ZWAgaWYgZGVmaW5lZCwgZWxzZSByZXR1cm5zIGBkZWZhdWx0VmFsdWVgLlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIHJldHVybiBpZiBkZWZpbmVkLlxuICogQHBhcmFtIGRlZmF1bHRWYWx1ZSAtIFRoZSB2YWx1ZSB0byByZXR1cm4gaWYgYHZhbHVlYCBpcyB1bmRlZmluZWQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB2YWx1ZU9yRGVmYXVsdDxUPih2YWx1ZTogVCB8IHVuZGVmaW5lZCwgZGVmYXVsdFZhbHVlOiBUKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICd1bmRlZmluZWQnID8gZGVmYXVsdFZhbHVlIDogdmFsdWU7XG59XG5cbmV4cG9ydCBjb25zdCB0b1BlcmNlbnRhZ2UgPSAodmFsdWU6IG51bWJlciB8IHN0cmluZywgZGltZW5zaW9uOiBudW1iZXIpID0+XG4gIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgJiYgdmFsdWUuZW5kc1dpdGgoJyUnKSA/XG4gICAgcGFyc2VGbG9hdCh2YWx1ZSkgLyAxMDBcbiAgICA6ICt2YWx1ZSAvIGRpbWVuc2lvbjtcblxuZXhwb3J0IGNvbnN0IHRvRGltZW5zaW9uID0gKHZhbHVlOiBudW1iZXIgfCBzdHJpbmcsIGRpbWVuc2lvbjogbnVtYmVyKSA9PlxuICB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnICYmIHZhbHVlLmVuZHNXaXRoKCclJykgP1xuICAgIHBhcnNlRmxvYXQodmFsdWUpIC8gMTAwICogZGltZW5zaW9uXG4gICAgOiArdmFsdWU7XG5cbi8qKlxuICogQ2FsbHMgYGZuYCB3aXRoIHRoZSBnaXZlbiBgYXJnc2AgaW4gdGhlIHNjb3BlIGRlZmluZWQgYnkgYHRoaXNBcmdgIGFuZCByZXR1cm5zIHRoZVxuICogdmFsdWUgcmV0dXJuZWQgYnkgYGZuYC4gSWYgYGZuYCBpcyBub3QgYSBmdW5jdGlvbiwgdGhpcyBtZXRob2QgcmV0dXJucyB1bmRlZmluZWQuXG4gKiBAcGFyYW0gZm4gLSBUaGUgZnVuY3Rpb24gdG8gY2FsbC5cbiAqIEBwYXJhbSBhcmdzIC0gVGhlIGFyZ3VtZW50cyB3aXRoIHdoaWNoIGBmbmAgc2hvdWxkIGJlIGNhbGxlZC5cbiAqIEBwYXJhbSBbdGhpc0FyZ10gLSBUaGUgdmFsdWUgb2YgYHRoaXNgIHByb3ZpZGVkIGZvciB0aGUgY2FsbCB0byBgZm5gLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY2FsbGJhY2s8VCBleHRlbmRzICh0aGlzOiBUQSwgLi4ucmVzdEFyZ3M6IHVua25vd25bXSkgPT4gUiwgVEEsIFI+KFxuICBmbjogVCB8IHVuZGVmaW5lZCxcbiAgYXJnczogdW5rbm93bltdLFxuICB0aGlzQXJnPzogVEFcbik6IFIgfCB1bmRlZmluZWQge1xuICBpZiAoZm4gJiYgdHlwZW9mIGZuLmNhbGwgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gZm4uYXBwbHkodGhpc0FyZywgYXJncyk7XG4gIH1cbn1cblxuLyoqXG4gKiBOb3RlKFNCKSBmb3IgcGVyZm9ybWFuY2Ugc2FrZSwgdGhpcyBtZXRob2Qgc2hvdWxkIG9ubHkgYmUgdXNlZCB3aGVuIGxvb3BhYmxlIHR5cGVcbiAqIGlzIHVua25vd24gb3IgaW4gbm9uZSBpbnRlbnNpdmUgY29kZSAobm90IGNhbGxlZCBvZnRlbiBhbmQgc21hbGwgbG9vcGFibGUpLiBFbHNlXG4gKiBpdCdzIHByZWZlcmFibGUgdG8gdXNlIGEgcmVndWxhciBmb3IoKSBsb29wIGFuZCBzYXZlIGV4dHJhIGZ1bmN0aW9uIGNhbGxzLlxuICogQHBhcmFtIGxvb3BhYmxlIC0gVGhlIG9iamVjdCBvciBhcnJheSB0byBiZSBpdGVyYXRlZC5cbiAqIEBwYXJhbSBmbiAtIFRoZSBmdW5jdGlvbiB0byBjYWxsIGZvciBlYWNoIGl0ZW0uXG4gKiBAcGFyYW0gW3RoaXNBcmddIC0gVGhlIHZhbHVlIG9mIGB0aGlzYCBwcm92aWRlZCBmb3IgdGhlIGNhbGwgdG8gYGZuYC5cbiAqIEBwYXJhbSBbcmV2ZXJzZV0gLSBJZiB0cnVlLCBpdGVyYXRlcyBiYWNrd2FyZCBvbiB0aGUgbG9vcGFibGUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBlYWNoPFQsIFRBPihcbiAgbG9vcGFibGU6IFJlY29yZDxzdHJpbmcsIFQ+LFxuICBmbjogKHRoaXM6IFRBLCB2OiBULCBpOiBzdHJpbmcpID0+IHZvaWQsXG4gIHRoaXNBcmc/OiBUQSxcbiAgcmV2ZXJzZT86IGJvb2xlYW5cbik6IHZvaWQ7XG5leHBvcnQgZnVuY3Rpb24gZWFjaDxULCBUQT4oXG4gIGxvb3BhYmxlOiBUW10sXG4gIGZuOiAodGhpczogVEEsIHY6IFQsIGk6IG51bWJlcikgPT4gdm9pZCxcbiAgdGhpc0FyZz86IFRBLFxuICByZXZlcnNlPzogYm9vbGVhblxuKTogdm9pZDtcbmV4cG9ydCBmdW5jdGlvbiBlYWNoPFQsIFRBPihcbiAgbG9vcGFibGU6IFRbXSB8IFJlY29yZDxzdHJpbmcsIFQ+LFxuICBmbjogKHRoaXM6IFRBLCB2OiBULCBpOiBhbnkpID0+IHZvaWQsXG4gIHRoaXNBcmc/OiBUQSxcbiAgcmV2ZXJzZT86IGJvb2xlYW5cbikge1xuICBsZXQgaTogbnVtYmVyLCBsZW46IG51bWJlciwga2V5czogc3RyaW5nW107XG4gIGlmIChpc0FycmF5KGxvb3BhYmxlKSkge1xuICAgIGxlbiA9IGxvb3BhYmxlLmxlbmd0aDtcbiAgICBpZiAocmV2ZXJzZSkge1xuICAgICAgZm9yIChpID0gbGVuIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgZm4uY2FsbCh0aGlzQXJnLCBsb29wYWJsZVtpXSwgaSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBmbi5jYWxsKHRoaXNBcmcsIGxvb3BhYmxlW2ldLCBpKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNPYmplY3QobG9vcGFibGUpKSB7XG4gICAga2V5cyA9IE9iamVjdC5rZXlzKGxvb3BhYmxlKTtcbiAgICBsZW4gPSBrZXlzLmxlbmd0aDtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGZuLmNhbGwodGhpc0FyZywgbG9vcGFibGVba2V5c1tpXV0sIGtleXNbaV0pO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgYGEwYCBhbmQgYGExYCBhcnJheXMgaGF2ZSB0aGUgc2FtZSBjb250ZW50LCBlbHNlIHJldHVybnMgZmFsc2UuXG4gKiBAcGFyYW0gYTAgLSBUaGUgYXJyYXkgdG8gY29tcGFyZVxuICogQHBhcmFtIGExIC0gVGhlIGFycmF5IHRvIGNvbXBhcmVcbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBfZWxlbWVudHNFcXVhbChhMDogQWN0aXZlRGF0YVBvaW50W10sIGExOiBBY3RpdmVEYXRhUG9pbnRbXSkge1xuICBsZXQgaTogbnVtYmVyLCBpbGVuOiBudW1iZXIsIHYwOiBBY3RpdmVEYXRhUG9pbnQsIHYxOiBBY3RpdmVEYXRhUG9pbnQ7XG5cbiAgaWYgKCFhMCB8fCAhYTEgfHwgYTAubGVuZ3RoICE9PSBhMS5sZW5ndGgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBmb3IgKGkgPSAwLCBpbGVuID0gYTAubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgdjAgPSBhMFtpXTtcbiAgICB2MSA9IGExW2ldO1xuXG4gICAgaWYgKHYwLmRhdGFzZXRJbmRleCAhPT0gdjEuZGF0YXNldEluZGV4IHx8IHYwLmluZGV4ICE9PSB2MS5pbmRleCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG4vKipcbiAqIFJldHVybnMgYSBkZWVwIGNvcHkgb2YgYHNvdXJjZWAgd2l0aG91dCBrZWVwaW5nIHJlZmVyZW5jZXMgb24gb2JqZWN0cyBhbmQgYXJyYXlzLlxuICogQHBhcmFtIHNvdXJjZSAtIFRoZSB2YWx1ZSB0byBjbG9uZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNsb25lPFQ+KHNvdXJjZTogVCk6IFQge1xuICBpZiAoaXNBcnJheShzb3VyY2UpKSB7XG4gICAgcmV0dXJuIHNvdXJjZS5tYXAoY2xvbmUpIGFzIHVua25vd24gYXMgVDtcbiAgfVxuXG4gIGlmIChpc09iamVjdChzb3VyY2UpKSB7XG4gICAgY29uc3QgdGFyZ2V0ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMoc291cmNlKTtcbiAgICBjb25zdCBrbGVuID0ga2V5cy5sZW5ndGg7XG4gICAgbGV0IGsgPSAwO1xuXG4gICAgZm9yICg7IGsgPCBrbGVuOyArK2spIHtcbiAgICAgIHRhcmdldFtrZXlzW2tdXSA9IGNsb25lKHNvdXJjZVtrZXlzW2tdXSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRhcmdldDtcbiAgfVxuXG4gIHJldHVybiBzb3VyY2U7XG59XG5cbmZ1bmN0aW9uIGlzVmFsaWRLZXkoa2V5OiBzdHJpbmcpIHtcbiAgcmV0dXJuIFsnX19wcm90b19fJywgJ3Byb3RvdHlwZScsICdjb25zdHJ1Y3RvciddLmluZGV4T2Yoa2V5KSA9PT0gLTE7XG59XG5cbi8qKlxuICogVGhlIGRlZmF1bHQgbWVyZ2VyIHdoZW4gQ2hhcnQuaGVscGVycy5tZXJnZSBpcyBjYWxsZWQgd2l0aG91dCBtZXJnZXIgb3B0aW9uLlxuICogTm90ZShTQik6IGFsc28gdXNlZCBieSBtZXJnZUNvbmZpZyBhbmQgbWVyZ2VTY2FsZUNvbmZpZyBhcyBmYWxsYmFjay5cbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBfbWVyZ2VyKGtleTogc3RyaW5nLCB0YXJnZXQ6IEFueU9iamVjdCwgc291cmNlOiBBbnlPYmplY3QsIG9wdGlvbnM6IEFueU9iamVjdCkge1xuICBpZiAoIWlzVmFsaWRLZXkoa2V5KSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGNvbnN0IHR2YWwgPSB0YXJnZXRba2V5XTtcbiAgY29uc3Qgc3ZhbCA9IHNvdXJjZVtrZXldO1xuXG4gIGlmIChpc09iamVjdCh0dmFsKSAmJiBpc09iamVjdChzdmFsKSkge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdXNlLWJlZm9yZS1kZWZpbmVcbiAgICBtZXJnZSh0dmFsLCBzdmFsLCBvcHRpb25zKTtcbiAgfSBlbHNlIHtcbiAgICB0YXJnZXRba2V5XSA9IGNsb25lKHN2YWwpO1xuICB9XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgTWVyZ2VPcHRpb25zIHtcbiAgbWVyZ2VyPzogKGtleTogc3RyaW5nLCB0YXJnZXQ6IEFueU9iamVjdCwgc291cmNlOiBBbnlPYmplY3QsIG9wdGlvbnM/OiBBbnlPYmplY3QpID0+IHZvaWQ7XG59XG5cbi8qKlxuICogUmVjdXJzaXZlbHkgZGVlcCBjb3BpZXMgYHNvdXJjZWAgcHJvcGVydGllcyBpbnRvIGB0YXJnZXRgIHdpdGggdGhlIGdpdmVuIGBvcHRpb25zYC5cbiAqIElNUE9SVEFOVDogYHRhcmdldGAgaXMgbm90IGNsb25lZCBhbmQgd2lsbCBiZSB1cGRhdGVkIHdpdGggYHNvdXJjZWAgcHJvcGVydGllcy5cbiAqIEBwYXJhbSB0YXJnZXQgLSBUaGUgdGFyZ2V0IG9iamVjdCBpbiB3aGljaCBhbGwgc291cmNlcyBhcmUgbWVyZ2VkIGludG8uXG4gKiBAcGFyYW0gc291cmNlIC0gT2JqZWN0KHMpIHRvIG1lcmdlIGludG8gYHRhcmdldGAuXG4gKiBAcGFyYW0gW29wdGlvbnNdIC0gTWVyZ2luZyBvcHRpb25zOlxuICogQHBhcmFtIFtvcHRpb25zLm1lcmdlcl0gLSBUaGUgbWVyZ2UgbWV0aG9kIChrZXksIHRhcmdldCwgc291cmNlLCBvcHRpb25zKVxuICogQHJldHVybnMgVGhlIGB0YXJnZXRgIG9iamVjdC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1lcmdlPFQ+KHRhcmdldDogVCwgc291cmNlOiBbXSwgb3B0aW9ucz86IE1lcmdlT3B0aW9ucyk6IFQ7XG5leHBvcnQgZnVuY3Rpb24gbWVyZ2U8VCwgUzE+KHRhcmdldDogVCwgc291cmNlOiBTMSwgb3B0aW9ucz86IE1lcmdlT3B0aW9ucyk6IFQgJiBTMTtcbmV4cG9ydCBmdW5jdGlvbiBtZXJnZTxULCBTMT4odGFyZ2V0OiBULCBzb3VyY2U6IFtTMV0sIG9wdGlvbnM/OiBNZXJnZU9wdGlvbnMpOiBUICYgUzE7XG5leHBvcnQgZnVuY3Rpb24gbWVyZ2U8VCwgUzEsIFMyPih0YXJnZXQ6IFQsIHNvdXJjZTogW1MxLCBTMl0sIG9wdGlvbnM/OiBNZXJnZU9wdGlvbnMpOiBUICYgUzEgJiBTMjtcbmV4cG9ydCBmdW5jdGlvbiBtZXJnZTxULCBTMSwgUzIsIFMzPih0YXJnZXQ6IFQsIHNvdXJjZTogW1MxLCBTMiwgUzNdLCBvcHRpb25zPzogTWVyZ2VPcHRpb25zKTogVCAmIFMxICYgUzIgJiBTMztcbmV4cG9ydCBmdW5jdGlvbiBtZXJnZTxULCBTMSwgUzIsIFMzLCBTND4oXG4gIHRhcmdldDogVCxcbiAgc291cmNlOiBbUzEsIFMyLCBTMywgUzRdLFxuICBvcHRpb25zPzogTWVyZ2VPcHRpb25zXG4pOiBUICYgUzEgJiBTMiAmIFMzICYgUzQ7XG5leHBvcnQgZnVuY3Rpb24gbWVyZ2U8VD4odGFyZ2V0OiBULCBzb3VyY2U6IEFueU9iamVjdFtdLCBvcHRpb25zPzogTWVyZ2VPcHRpb25zKTogQW55T2JqZWN0O1xuZXhwb3J0IGZ1bmN0aW9uIG1lcmdlPFQ+KHRhcmdldDogVCwgc291cmNlOiBBbnlPYmplY3RbXSwgb3B0aW9ucz86IE1lcmdlT3B0aW9ucyk6IEFueU9iamVjdCB7XG4gIGNvbnN0IHNvdXJjZXMgPSBpc0FycmF5KHNvdXJjZSkgPyBzb3VyY2UgOiBbc291cmNlXTtcbiAgY29uc3QgaWxlbiA9IHNvdXJjZXMubGVuZ3RoO1xuXG4gIGlmICghaXNPYmplY3QodGFyZ2V0KSkge1xuICAgIHJldHVybiB0YXJnZXQgYXMgQW55T2JqZWN0O1xuICB9XG5cbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIGNvbnN0IG1lcmdlciA9IG9wdGlvbnMubWVyZ2VyIHx8IF9tZXJnZXI7XG4gIGxldCBjdXJyZW50OiBBbnlPYmplY3Q7XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbGVuOyArK2kpIHtcbiAgICBjdXJyZW50ID0gc291cmNlc1tpXTtcbiAgICBpZiAoIWlzT2JqZWN0KGN1cnJlbnQpKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMoY3VycmVudCk7XG4gICAgZm9yIChsZXQgayA9IDAsIGtsZW4gPSBrZXlzLmxlbmd0aDsgayA8IGtsZW47ICsraykge1xuICAgICAgbWVyZ2VyKGtleXNba10sIHRhcmdldCwgY3VycmVudCwgb3B0aW9ucyBhcyBBbnlPYmplY3QpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0YXJnZXQ7XG59XG5cbi8qKlxuICogUmVjdXJzaXZlbHkgZGVlcCBjb3BpZXMgYHNvdXJjZWAgcHJvcGVydGllcyBpbnRvIGB0YXJnZXRgICpvbmx5KiBpZiBub3QgZGVmaW5lZCBpbiB0YXJnZXQuXG4gKiBJTVBPUlRBTlQ6IGB0YXJnZXRgIGlzIG5vdCBjbG9uZWQgYW5kIHdpbGwgYmUgdXBkYXRlZCB3aXRoIGBzb3VyY2VgIHByb3BlcnRpZXMuXG4gKiBAcGFyYW0gdGFyZ2V0IC0gVGhlIHRhcmdldCBvYmplY3QgaW4gd2hpY2ggYWxsIHNvdXJjZXMgYXJlIG1lcmdlZCBpbnRvLlxuICogQHBhcmFtIHNvdXJjZSAtIE9iamVjdChzKSB0byBtZXJnZSBpbnRvIGB0YXJnZXRgLlxuICogQHJldHVybnMgVGhlIGB0YXJnZXRgIG9iamVjdC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1lcmdlSWY8VD4odGFyZ2V0OiBULCBzb3VyY2U6IFtdKTogVDtcbmV4cG9ydCBmdW5jdGlvbiBtZXJnZUlmPFQsIFMxPih0YXJnZXQ6IFQsIHNvdXJjZTogUzEpOiBUICYgUzE7XG5leHBvcnQgZnVuY3Rpb24gbWVyZ2VJZjxULCBTMT4odGFyZ2V0OiBULCBzb3VyY2U6IFtTMV0pOiBUICYgUzE7XG5leHBvcnQgZnVuY3Rpb24gbWVyZ2VJZjxULCBTMSwgUzI+KHRhcmdldDogVCwgc291cmNlOiBbUzEsIFMyXSk6IFQgJiBTMSAmIFMyO1xuZXhwb3J0IGZ1bmN0aW9uIG1lcmdlSWY8VCwgUzEsIFMyLCBTMz4odGFyZ2V0OiBULCBzb3VyY2U6IFtTMSwgUzIsIFMzXSk6IFQgJiBTMSAmIFMyICYgUzM7XG5leHBvcnQgZnVuY3Rpb24gbWVyZ2VJZjxULCBTMSwgUzIsIFMzLCBTND4odGFyZ2V0OiBULCBzb3VyY2U6IFtTMSwgUzIsIFMzLCBTNF0pOiBUICYgUzEgJiBTMiAmIFMzICYgUzQ7XG5leHBvcnQgZnVuY3Rpb24gbWVyZ2VJZjxUPih0YXJnZXQ6IFQsIHNvdXJjZTogQW55T2JqZWN0W10pOiBBbnlPYmplY3Q7XG5leHBvcnQgZnVuY3Rpb24gbWVyZ2VJZjxUPih0YXJnZXQ6IFQsIHNvdXJjZTogQW55T2JqZWN0W10pOiBBbnlPYmplY3Qge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVzZS1iZWZvcmUtZGVmaW5lXG4gIHJldHVybiBtZXJnZTxUPih0YXJnZXQsIHNvdXJjZSwge21lcmdlcjogX21lcmdlcklmfSk7XG59XG5cbi8qKlxuICogTWVyZ2VzIHNvdXJjZVtrZXldIGluIHRhcmdldFtrZXldIG9ubHkgaWYgdGFyZ2V0W2tleV0gaXMgdW5kZWZpbmVkLlxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIF9tZXJnZXJJZihrZXk6IHN0cmluZywgdGFyZ2V0OiBBbnlPYmplY3QsIHNvdXJjZTogQW55T2JqZWN0KSB7XG4gIGlmICghaXNWYWxpZEtleShrZXkpKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgY29uc3QgdHZhbCA9IHRhcmdldFtrZXldO1xuICBjb25zdCBzdmFsID0gc291cmNlW2tleV07XG5cbiAgaWYgKGlzT2JqZWN0KHR2YWwpICYmIGlzT2JqZWN0KHN2YWwpKSB7XG4gICAgbWVyZ2VJZih0dmFsLCBzdmFsKTtcbiAgfSBlbHNlIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRhcmdldCwga2V5KSkge1xuICAgIHRhcmdldFtrZXldID0gY2xvbmUoc3ZhbCk7XG4gIH1cbn1cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gX2RlcHJlY2F0ZWQoc2NvcGU6IHN0cmluZywgdmFsdWU6IHVua25vd24sIHByZXZpb3VzOiBzdHJpbmcsIGN1cnJlbnQ6IHN0cmluZykge1xuICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgIGNvbnNvbGUud2FybihzY29wZSArICc6IFwiJyArIHByZXZpb3VzICtcbiAgICAgICdcIiBpcyBkZXByZWNhdGVkLiBQbGVhc2UgdXNlIFwiJyArIGN1cnJlbnQgKyAnXCIgaW5zdGVhZCcpO1xuICB9XG59XG5cbi8vIHJlc29sdmVPYmplY3RLZXkgcmVzb2x2ZXIgY2FjaGVcbmNvbnN0IGtleVJlc29sdmVycyA9IHtcbiAgLy8gQ2hhcnQuaGVscGVycy5jb3JlIHJlc29sdmVPYmplY3RLZXkgc2hvdWxkIHJlc29sdmUgZW1wdHkga2V5IHRvIHJvb3Qgb2JqZWN0XG4gICcnOiB2ID0+IHYsXG4gIC8vIGRlZmF1bHQgcmVzb2x2ZXJzXG4gIHg6IG8gPT4gby54LFxuICB5OiBvID0+IG8ueVxufTtcblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gX3NwbGl0S2V5KGtleTogc3RyaW5nKSB7XG4gIGNvbnN0IHBhcnRzID0ga2V5LnNwbGl0KCcuJyk7XG4gIGNvbnN0IGtleXM6IHN0cmluZ1tdID0gW107XG4gIGxldCB0bXAgPSAnJztcbiAgZm9yIChjb25zdCBwYXJ0IG9mIHBhcnRzKSB7XG4gICAgdG1wICs9IHBhcnQ7XG4gICAgaWYgKHRtcC5lbmRzV2l0aCgnXFxcXCcpKSB7XG4gICAgICB0bXAgPSB0bXAuc2xpY2UoMCwgLTEpICsgJy4nO1xuICAgIH0gZWxzZSB7XG4gICAgICBrZXlzLnB1c2godG1wKTtcbiAgICAgIHRtcCA9ICcnO1xuICAgIH1cbiAgfVxuICByZXR1cm4ga2V5cztcbn1cblxuZnVuY3Rpb24gX2dldEtleVJlc29sdmVyKGtleTogc3RyaW5nKSB7XG4gIGNvbnN0IGtleXMgPSBfc3BsaXRLZXkoa2V5KTtcbiAgcmV0dXJuIG9iaiA9PiB7XG4gICAgZm9yIChjb25zdCBrIG9mIGtleXMpIHtcbiAgICAgIGlmIChrID09PSAnJykge1xuICAgICAgICAvLyBGb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eTpcbiAgICAgICAgLy8gQ2hhcnQuaGVscGVycy5jb3JlIHJlc29sdmVPYmplY3RLZXkgc2hvdWxkIGJyZWFrIGF0IGVtcHR5IGtleVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIG9iaiA9IG9iaiAmJiBvYmpba107XG4gICAgfVxuICAgIHJldHVybiBvYmo7XG4gIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiByZXNvbHZlT2JqZWN0S2V5KG9iajogQW55T2JqZWN0LCBrZXk6IHN0cmluZyk6IGFueSB7XG4gIGNvbnN0IHJlc29sdmVyID0ga2V5UmVzb2x2ZXJzW2tleV0gfHwgKGtleVJlc29sdmVyc1trZXldID0gX2dldEtleVJlc29sdmVyKGtleSkpO1xuICByZXR1cm4gcmVzb2x2ZXIob2JqKTtcbn1cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gX2NhcGl0YWxpemUoc3RyOiBzdHJpbmcpIHtcbiAgcmV0dXJuIHN0ci5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHN0ci5zbGljZSgxKTtcbn1cblxuXG5leHBvcnQgY29uc3QgZGVmaW5lZCA9ICh2YWx1ZTogdW5rbm93bikgPT4gdHlwZW9mIHZhbHVlICE9PSAndW5kZWZpbmVkJztcblxuZXhwb3J0IGNvbnN0IGlzRnVuY3Rpb24gPSAodmFsdWU6IHVua25vd24pOiB2YWx1ZSBpcyAoLi4uYXJnczogYW55W10pID0+IGFueSA9PiB0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbic7XG5cbi8vIEFkYXB0ZWQgZnJvbSBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8zMTEyODg1NS9jb21wYXJpbmctZWNtYTYtc2V0cy1mb3ItZXF1YWxpdHkjMzExMjkzODRcbmV4cG9ydCBjb25zdCBzZXRzRXF1YWwgPSA8VD4oYTogU2V0PFQ+LCBiOiBTZXQ8VD4pID0+IHtcbiAgaWYgKGEuc2l6ZSAhPT0gYi5zaXplKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgZm9yIChjb25zdCBpdGVtIG9mIGEpIHtcbiAgICBpZiAoIWIuaGFzKGl0ZW0pKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG4vKipcbiAqIEBwYXJhbSBlIC0gVGhlIGV2ZW50XG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gX2lzQ2xpY2tFdmVudChlOiBDaGFydEV2ZW50KSB7XG4gIHJldHVybiBlLnR5cGUgPT09ICdtb3VzZXVwJyB8fCBlLnR5cGUgPT09ICdjbGljaycgfHwgZS50eXBlID09PSAnY29udGV4dG1lbnUnO1xufVxuIiwgImltcG9ydCB0eXBlIHtQb2ludH0gZnJvbSAnLi4vdHlwZXMvZ2VvbWV0cmljLmpzJztcbmltcG9ydCB7aXNGaW5pdGUgYXMgaXNGaW5pdGVOdW1iZXJ9IGZyb20gJy4vaGVscGVycy5jb3JlLmpzJztcblxuLyoqXG4gKiBAYWxpYXMgQ2hhcnQuaGVscGVycy5tYXRoXG4gKiBAbmFtZXNwYWNlXG4gKi9cblxuZXhwb3J0IGNvbnN0IFBJID0gTWF0aC5QSTtcbmV4cG9ydCBjb25zdCBUQVUgPSAyICogUEk7XG5leHBvcnQgY29uc3QgUElUQVUgPSBUQVUgKyBQSTtcbmV4cG9ydCBjb25zdCBJTkZJTklUWSA9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcbmV4cG9ydCBjb25zdCBSQURfUEVSX0RFRyA9IFBJIC8gMTgwO1xuZXhwb3J0IGNvbnN0IEhBTEZfUEkgPSBQSSAvIDI7XG5leHBvcnQgY29uc3QgUVVBUlRFUl9QSSA9IFBJIC8gNDtcbmV4cG9ydCBjb25zdCBUV09fVEhJUkRTX1BJID0gUEkgKiAyIC8gMztcblxuZXhwb3J0IGNvbnN0IGxvZzEwID0gTWF0aC5sb2cxMDtcbmV4cG9ydCBjb25zdCBzaWduID0gTWF0aC5zaWduO1xuXG5leHBvcnQgZnVuY3Rpb24gYWxtb3N0RXF1YWxzKHg6IG51bWJlciwgeTogbnVtYmVyLCBlcHNpbG9uOiBudW1iZXIpIHtcbiAgcmV0dXJuIE1hdGguYWJzKHggLSB5KSA8IGVwc2lsb247XG59XG5cbi8qKlxuICogSW1wbGVtZW50YXRpb24gb2YgdGhlIG5pY2UgbnVtYmVyIGFsZ29yaXRobSB1c2VkIGluIGRldGVybWluaW5nIHdoZXJlIGF4aXMgbGFiZWxzIHdpbGwgZ29cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG5pY2VOdW0ocmFuZ2U6IG51bWJlcikge1xuICBjb25zdCByb3VuZGVkUmFuZ2UgPSBNYXRoLnJvdW5kKHJhbmdlKTtcbiAgcmFuZ2UgPSBhbG1vc3RFcXVhbHMocmFuZ2UsIHJvdW5kZWRSYW5nZSwgcmFuZ2UgLyAxMDAwKSA/IHJvdW5kZWRSYW5nZSA6IHJhbmdlO1xuICBjb25zdCBuaWNlUmFuZ2UgPSBNYXRoLnBvdygxMCwgTWF0aC5mbG9vcihsb2cxMChyYW5nZSkpKTtcbiAgY29uc3QgZnJhY3Rpb24gPSByYW5nZSAvIG5pY2VSYW5nZTtcbiAgY29uc3QgbmljZUZyYWN0aW9uID0gZnJhY3Rpb24gPD0gMSA/IDEgOiBmcmFjdGlvbiA8PSAyID8gMiA6IGZyYWN0aW9uIDw9IDUgPyA1IDogMTA7XG4gIHJldHVybiBuaWNlRnJhY3Rpb24gKiBuaWNlUmFuZ2U7XG59XG5cbi8qKlxuICogUmV0dXJucyBhbiBhcnJheSBvZiBmYWN0b3JzIHNvcnRlZCBmcm9tIDEgdG8gc3FydCh2YWx1ZSlcbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBfZmFjdG9yaXplKHZhbHVlOiBudW1iZXIpIHtcbiAgY29uc3QgcmVzdWx0OiBudW1iZXJbXSA9IFtdO1xuICBjb25zdCBzcXJ0ID0gTWF0aC5zcXJ0KHZhbHVlKTtcbiAgbGV0IGk6IG51bWJlcjtcblxuICBmb3IgKGkgPSAxOyBpIDwgc3FydDsgaSsrKSB7XG4gICAgaWYgKHZhbHVlICUgaSA9PT0gMCkge1xuICAgICAgcmVzdWx0LnB1c2goaSk7XG4gICAgICByZXN1bHQucHVzaCh2YWx1ZSAvIGkpO1xuICAgIH1cbiAgfVxuICBpZiAoc3FydCA9PT0gKHNxcnQgfCAwKSkgeyAvLyBpZiB2YWx1ZSBpcyBhIHNxdWFyZSBudW1iZXJcbiAgICByZXN1bHQucHVzaChzcXJ0KTtcbiAgfVxuXG4gIHJlc3VsdC5zb3J0KChhLCBiKSA9PiBhIC0gYikucG9wKCk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc051bWJlcihuOiB1bmtub3duKTogbiBpcyBudW1iZXIge1xuICByZXR1cm4gIWlzTmFOKHBhcnNlRmxvYXQobiBhcyBzdHJpbmcpKSAmJiBpc0Zpbml0ZShuIGFzIG51bWJlcik7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhbG1vc3RXaG9sZSh4OiBudW1iZXIsIGVwc2lsb246IG51bWJlcikge1xuICBjb25zdCByb3VuZGVkID0gTWF0aC5yb3VuZCh4KTtcbiAgcmV0dXJuICgocm91bmRlZCAtIGVwc2lsb24pIDw9IHgpICYmICgocm91bmRlZCArIGVwc2lsb24pID49IHgpO1xufVxuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBfc2V0TWluQW5kTWF4QnlLZXkoXG4gIGFycmF5OiBSZWNvcmQ8c3RyaW5nLCBudW1iZXI+W10sXG4gIHRhcmdldDogeyBtaW46IG51bWJlciwgbWF4OiBudW1iZXIgfSxcbiAgcHJvcGVydHk6IHN0cmluZ1xuKSB7XG4gIGxldCBpOiBudW1iZXIsIGlsZW46IG51bWJlciwgdmFsdWU6IG51bWJlcjtcblxuICBmb3IgKGkgPSAwLCBpbGVuID0gYXJyYXkubGVuZ3RoOyBpIDwgaWxlbjsgaSsrKSB7XG4gICAgdmFsdWUgPSBhcnJheVtpXVtwcm9wZXJ0eV07XG4gICAgaWYgKCFpc05hTih2YWx1ZSkpIHtcbiAgICAgIHRhcmdldC5taW4gPSBNYXRoLm1pbih0YXJnZXQubWluLCB2YWx1ZSk7XG4gICAgICB0YXJnZXQubWF4ID0gTWF0aC5tYXgodGFyZ2V0Lm1heCwgdmFsdWUpO1xuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gdG9SYWRpYW5zKGRlZ3JlZXM6IG51bWJlcikge1xuICByZXR1cm4gZGVncmVlcyAqIChQSSAvIDE4MCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB0b0RlZ3JlZXMocmFkaWFuczogbnVtYmVyKSB7XG4gIHJldHVybiByYWRpYW5zICogKDE4MCAvIFBJKTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBudW1iZXIgb2YgZGVjaW1hbCBwbGFjZXNcbiAqIGkuZS4gdGhlIG51bWJlciBvZiBkaWdpdHMgYWZ0ZXIgdGhlIGRlY2ltYWwgcG9pbnQsIG9mIHRoZSB2YWx1ZSBvZiB0aGlzIE51bWJlci5cbiAqIEBwYXJhbSB4IC0gQSBudW1iZXIuXG4gKiBAcmV0dXJucyBUaGUgbnVtYmVyIG9mIGRlY2ltYWwgcGxhY2VzLlxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIF9kZWNpbWFsUGxhY2VzKHg6IG51bWJlcikge1xuICBpZiAoIWlzRmluaXRlTnVtYmVyKHgpKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGxldCBlID0gMTtcbiAgbGV0IHAgPSAwO1xuICB3aGlsZSAoTWF0aC5yb3VuZCh4ICogZSkgLyBlICE9PSB4KSB7XG4gICAgZSAqPSAxMDtcbiAgICBwKys7XG4gIH1cbiAgcmV0dXJuIHA7XG59XG5cbi8vIEdldHMgdGhlIGFuZ2xlIGZyb20gdmVydGljYWwgdXByaWdodCB0byB0aGUgcG9pbnQgYWJvdXQgYSBjZW50cmUuXG5leHBvcnQgZnVuY3Rpb24gZ2V0QW5nbGVGcm9tUG9pbnQoXG4gIGNlbnRyZVBvaW50OiBQb2ludCxcbiAgYW5nbGVQb2ludDogUG9pbnRcbikge1xuICBjb25zdCBkaXN0YW5jZUZyb21YQ2VudGVyID0gYW5nbGVQb2ludC54IC0gY2VudHJlUG9pbnQueDtcbiAgY29uc3QgZGlzdGFuY2VGcm9tWUNlbnRlciA9IGFuZ2xlUG9pbnQueSAtIGNlbnRyZVBvaW50Lnk7XG4gIGNvbnN0IHJhZGlhbERpc3RhbmNlRnJvbUNlbnRlciA9IE1hdGguc3FydChkaXN0YW5jZUZyb21YQ2VudGVyICogZGlzdGFuY2VGcm9tWENlbnRlciArIGRpc3RhbmNlRnJvbVlDZW50ZXIgKiBkaXN0YW5jZUZyb21ZQ2VudGVyKTtcblxuICBsZXQgYW5nbGUgPSBNYXRoLmF0YW4yKGRpc3RhbmNlRnJvbVlDZW50ZXIsIGRpc3RhbmNlRnJvbVhDZW50ZXIpO1xuXG4gIGlmIChhbmdsZSA8ICgtMC41ICogUEkpKSB7XG4gICAgYW5nbGUgKz0gVEFVOyAvLyBtYWtlIHN1cmUgdGhlIHJldHVybmVkIGFuZ2xlIGlzIGluIHRoZSByYW5nZSBvZiAoLVBJLzIsIDNQSS8yXVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBhbmdsZSxcbiAgICBkaXN0YW5jZTogcmFkaWFsRGlzdGFuY2VGcm9tQ2VudGVyXG4gIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBkaXN0YW5jZUJldHdlZW5Qb2ludHMocHQxOiBQb2ludCwgcHQyOiBQb2ludCkge1xuICByZXR1cm4gTWF0aC5zcXJ0KE1hdGgucG93KHB0Mi54IC0gcHQxLngsIDIpICsgTWF0aC5wb3cocHQyLnkgLSBwdDEueSwgMikpO1xufVxuXG4vKipcbiAqIFNob3J0ZXN0IGRpc3RhbmNlIGJldHdlZW4gYW5nbGVzLCBpbiBlaXRoZXIgZGlyZWN0aW9uLlxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIF9hbmdsZURpZmYoYTogbnVtYmVyLCBiOiBudW1iZXIpIHtcbiAgcmV0dXJuIChhIC0gYiArIFBJVEFVKSAlIFRBVSAtIFBJO1xufVxuXG4vKipcbiAqIE5vcm1hbGl6ZSBhbmdsZSB0byBiZSBiZXR3ZWVuIDAgYW5kIDIqUElcbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBfbm9ybWFsaXplQW5nbGUoYTogbnVtYmVyKSB7XG4gIHJldHVybiAoYSAlIFRBVSArIFRBVSkgJSBUQVU7XG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIF9hbmdsZUJldHdlZW4oYW5nbGU6IG51bWJlciwgc3RhcnQ6IG51bWJlciwgZW5kOiBudW1iZXIsIHNhbWVBbmdsZUlzRnVsbENpcmNsZT86IGJvb2xlYW4pIHtcbiAgY29uc3QgYSA9IF9ub3JtYWxpemVBbmdsZShhbmdsZSk7XG4gIGNvbnN0IHMgPSBfbm9ybWFsaXplQW5nbGUoc3RhcnQpO1xuICBjb25zdCBlID0gX25vcm1hbGl6ZUFuZ2xlKGVuZCk7XG4gIGNvbnN0IGFuZ2xlVG9TdGFydCA9IF9ub3JtYWxpemVBbmdsZShzIC0gYSk7XG4gIGNvbnN0IGFuZ2xlVG9FbmQgPSBfbm9ybWFsaXplQW5nbGUoZSAtIGEpO1xuICBjb25zdCBzdGFydFRvQW5nbGUgPSBfbm9ybWFsaXplQW5nbGUoYSAtIHMpO1xuICBjb25zdCBlbmRUb0FuZ2xlID0gX25vcm1hbGl6ZUFuZ2xlKGEgLSBlKTtcbiAgcmV0dXJuIGEgPT09IHMgfHwgYSA9PT0gZSB8fCAoc2FtZUFuZ2xlSXNGdWxsQ2lyY2xlICYmIHMgPT09IGUpXG4gICAgfHwgKGFuZ2xlVG9TdGFydCA+IGFuZ2xlVG9FbmQgJiYgc3RhcnRUb0FuZ2xlIDwgZW5kVG9BbmdsZSk7XG59XG5cbi8qKlxuICogTGltaXQgYHZhbHVlYCBiZXR3ZWVuIGBtaW5gIGFuZCBgbWF4YFxuICogQHBhcmFtIHZhbHVlXG4gKiBAcGFyYW0gbWluXG4gKiBAcGFyYW0gbWF4XG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gX2xpbWl0VmFsdWUodmFsdWU6IG51bWJlciwgbWluOiBudW1iZXIsIG1heDogbnVtYmVyKSB7XG4gIHJldHVybiBNYXRoLm1heChtaW4sIE1hdGgubWluKG1heCwgdmFsdWUpKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcn0gdmFsdWVcbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBfaW50MTZSYW5nZSh2YWx1ZTogbnVtYmVyKSB7XG4gIHJldHVybiBfbGltaXRWYWx1ZSh2YWx1ZSwgLTMyNzY4LCAzMjc2Nyk7XG59XG5cbi8qKlxuICogQHBhcmFtIHZhbHVlXG4gKiBAcGFyYW0gc3RhcnRcbiAqIEBwYXJhbSBlbmRcbiAqIEBwYXJhbSBbZXBzaWxvbl1cbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBfaXNCZXR3ZWVuKHZhbHVlOiBudW1iZXIsIHN0YXJ0OiBudW1iZXIsIGVuZDogbnVtYmVyLCBlcHNpbG9uID0gMWUtNikge1xuICByZXR1cm4gdmFsdWUgPj0gTWF0aC5taW4oc3RhcnQsIGVuZCkgLSBlcHNpbG9uICYmIHZhbHVlIDw9IE1hdGgubWF4KHN0YXJ0LCBlbmQpICsgZXBzaWxvbjtcbn1cbiIsICJpbXBvcnQge19jYXBpdGFsaXplfSBmcm9tICcuL2hlbHBlcnMuY29yZS5qcyc7XG5cbi8qKlxuICogQmluYXJ5IHNlYXJjaFxuICogQHBhcmFtIHRhYmxlIC0gdGhlIHRhYmxlIHNlYXJjaC4gbXVzdCBiZSBzb3J0ZWQhXG4gKiBAcGFyYW0gdmFsdWUgLSB2YWx1ZSB0byBmaW5kXG4gKiBAcGFyYW0gY21wXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gX2xvb2t1cChcbiAgdGFibGU6IG51bWJlcltdLFxuICB2YWx1ZTogbnVtYmVyLFxuICBjbXA/OiAodmFsdWU6IG51bWJlcikgPT4gYm9vbGVhblxuKToge2xvOiBudW1iZXIsIGhpOiBudW1iZXJ9O1xuZXhwb3J0IGZ1bmN0aW9uIF9sb29rdXA8VD4oXG4gIHRhYmxlOiBUW10sXG4gIHZhbHVlOiBudW1iZXIsXG4gIGNtcDogKHZhbHVlOiBudW1iZXIpID0+IGJvb2xlYW5cbik6IHtsbzogbnVtYmVyLCBoaTogbnVtYmVyfTtcbmV4cG9ydCBmdW5jdGlvbiBfbG9va3VwKFxuICB0YWJsZTogdW5rbm93bltdLFxuICB2YWx1ZTogbnVtYmVyLFxuICBjbXA/OiAodmFsdWU6IG51bWJlcikgPT4gYm9vbGVhblxuKSB7XG4gIGNtcCA9IGNtcCB8fCAoKGluZGV4KSA9PiB0YWJsZVtpbmRleF0gPCB2YWx1ZSk7XG4gIGxldCBoaSA9IHRhYmxlLmxlbmd0aCAtIDE7XG4gIGxldCBsbyA9IDA7XG4gIGxldCBtaWQ6IG51bWJlcjtcblxuICB3aGlsZSAoaGkgLSBsbyA+IDEpIHtcbiAgICBtaWQgPSAobG8gKyBoaSkgPj4gMTtcbiAgICBpZiAoY21wKG1pZCkpIHtcbiAgICAgIGxvID0gbWlkO1xuICAgIH0gZWxzZSB7XG4gICAgICBoaSA9IG1pZDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4ge2xvLCBoaX07XG59XG5cbi8qKlxuICogQmluYXJ5IHNlYXJjaFxuICogQHBhcmFtIHRhYmxlIC0gdGhlIHRhYmxlIHNlYXJjaC4gbXVzdCBiZSBzb3J0ZWQhXG4gKiBAcGFyYW0ga2V5IC0gcHJvcGVydHkgbmFtZSBmb3IgdGhlIHZhbHVlIGluIGVhY2ggZW50cnlcbiAqIEBwYXJhbSB2YWx1ZSAtIHZhbHVlIHRvIGZpbmRcbiAqIEBwYXJhbSBsYXN0IC0gbG9va3VwIGxhc3QgaW5kZXhcbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBjb25zdCBfbG9va3VwQnlLZXkgPSAoXG4gIHRhYmxlOiBSZWNvcmQ8c3RyaW5nLCBudW1iZXI+W10sXG4gIGtleTogc3RyaW5nLFxuICB2YWx1ZTogbnVtYmVyLFxuICBsYXN0PzogYm9vbGVhblxuKSA9PlxuICBfbG9va3VwKHRhYmxlLCB2YWx1ZSwgbGFzdFxuICAgID8gaW5kZXggPT4ge1xuICAgICAgY29uc3QgdGkgPSB0YWJsZVtpbmRleF1ba2V5XTtcbiAgICAgIHJldHVybiB0aSA8IHZhbHVlIHx8IHRpID09PSB2YWx1ZSAmJiB0YWJsZVtpbmRleCArIDFdW2tleV0gPT09IHZhbHVlO1xuICAgIH1cbiAgICA6IGluZGV4ID0+IHRhYmxlW2luZGV4XVtrZXldIDwgdmFsdWUpO1xuXG4vKipcbiAqIFJldmVyc2UgYmluYXJ5IHNlYXJjaFxuICogQHBhcmFtIHRhYmxlIC0gdGhlIHRhYmxlIHNlYXJjaC4gbXVzdCBiZSBzb3J0ZWQhXG4gKiBAcGFyYW0ga2V5IC0gcHJvcGVydHkgbmFtZSBmb3IgdGhlIHZhbHVlIGluIGVhY2ggZW50cnlcbiAqIEBwYXJhbSB2YWx1ZSAtIHZhbHVlIHRvIGZpbmRcbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBjb25zdCBfcmxvb2t1cEJ5S2V5ID0gKFxuICB0YWJsZTogUmVjb3JkPHN0cmluZywgbnVtYmVyPltdLFxuICBrZXk6IHN0cmluZyxcbiAgdmFsdWU6IG51bWJlclxuKSA9PlxuICBfbG9va3VwKHRhYmxlLCB2YWx1ZSwgaW5kZXggPT4gdGFibGVbaW5kZXhdW2tleV0gPj0gdmFsdWUpO1xuXG4vKipcbiAqIFJldHVybiBzdWJzZXQgb2YgYHZhbHVlc2AgYmV0d2VlbiBgbWluYCBhbmQgYG1heGAgaW5jbHVzaXZlLlxuICogVmFsdWVzIGFyZSBhc3N1bWVkIHRvIGJlIGluIHNvcnRlZCBvcmRlci5cbiAqIEBwYXJhbSB2YWx1ZXMgLSBzb3J0ZWQgYXJyYXkgb2YgdmFsdWVzXG4gKiBAcGFyYW0gbWluIC0gbWluIHZhbHVlXG4gKiBAcGFyYW0gbWF4IC0gbWF4IHZhbHVlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBfZmlsdGVyQmV0d2Vlbih2YWx1ZXM6IG51bWJlcltdLCBtaW46IG51bWJlciwgbWF4OiBudW1iZXIpIHtcbiAgbGV0IHN0YXJ0ID0gMDtcbiAgbGV0IGVuZCA9IHZhbHVlcy5sZW5ndGg7XG5cbiAgd2hpbGUgKHN0YXJ0IDwgZW5kICYmIHZhbHVlc1tzdGFydF0gPCBtaW4pIHtcbiAgICBzdGFydCsrO1xuICB9XG4gIHdoaWxlIChlbmQgPiBzdGFydCAmJiB2YWx1ZXNbZW5kIC0gMV0gPiBtYXgpIHtcbiAgICBlbmQtLTtcbiAgfVxuXG4gIHJldHVybiBzdGFydCA+IDAgfHwgZW5kIDwgdmFsdWVzLmxlbmd0aFxuICAgID8gdmFsdWVzLnNsaWNlKHN0YXJ0LCBlbmQpXG4gICAgOiB2YWx1ZXM7XG59XG5cbmNvbnN0IGFycmF5RXZlbnRzID0gWydwdXNoJywgJ3BvcCcsICdzaGlmdCcsICdzcGxpY2UnLCAndW5zaGlmdCddIGFzIGNvbnN0O1xuXG5leHBvcnQgaW50ZXJmYWNlIEFycmF5TGlzdGVuZXI8VD4ge1xuICBfb25EYXRhUHVzaD8oLi4uaXRlbTogVFtdKTogdm9pZDtcbiAgX29uRGF0YVBvcD8oKTogdm9pZDtcbiAgX29uRGF0YVNoaWZ0PygpOiB2b2lkO1xuICBfb25EYXRhU3BsaWNlPyhpbmRleDogbnVtYmVyLCBkZWxldGVDb3VudDogbnVtYmVyLCAuLi5pdGVtczogVFtdKTogdm9pZDtcbiAgX29uRGF0YVVuc2hpZnQ/KC4uLml0ZW06IFRbXSk6IHZvaWQ7XG59XG5cbi8qKlxuICogSG9va3MgdGhlIGFycmF5IG1ldGhvZHMgdGhhdCBhZGQgb3IgcmVtb3ZlIHZhbHVlcyAoJ3B1c2gnLCBwb3AnLCAnc2hpZnQnLCAnc3BsaWNlJyxcbiAqICd1bnNoaWZ0JykgYW5kIG5vdGlmeSB0aGUgbGlzdGVuZXIgQUZURVIgdGhlIGFycmF5IGhhcyBiZWVuIGFsdGVyZWQuIExpc3RlbmVycyBhcmVcbiAqIGNhbGxlZCBvbiB0aGUgJ19vbkRhdGEqJyBjYWxsYmFja3MgKGUuZy4gX29uRGF0YVB1c2gsIGV0Yy4pIHdpdGggc2FtZSBhcmd1bWVudHMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBsaXN0ZW5BcnJheUV2ZW50czxUPihhcnJheTogVFtdLCBsaXN0ZW5lcjogQXJyYXlMaXN0ZW5lcjxUPik6IHZvaWQ7XG5leHBvcnQgZnVuY3Rpb24gbGlzdGVuQXJyYXlFdmVudHMoYXJyYXksIGxpc3RlbmVyKSB7XG4gIGlmIChhcnJheS5fY2hhcnRqcykge1xuICAgIGFycmF5Ll9jaGFydGpzLmxpc3RlbmVycy5wdXNoKGxpc3RlbmVyKTtcbiAgICByZXR1cm47XG4gIH1cblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoYXJyYXksICdfY2hhcnRqcycsIHtcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgdmFsdWU6IHtcbiAgICAgIGxpc3RlbmVyczogW2xpc3RlbmVyXVxuICAgIH1cbiAgfSk7XG5cbiAgYXJyYXlFdmVudHMuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgY29uc3QgbWV0aG9kID0gJ19vbkRhdGEnICsgX2NhcGl0YWxpemUoa2V5KTtcbiAgICBjb25zdCBiYXNlID0gYXJyYXlba2V5XTtcblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShhcnJheSwga2V5LCB7XG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIHZhbHVlKC4uLmFyZ3MpIHtcbiAgICAgICAgY29uc3QgcmVzID0gYmFzZS5hcHBseSh0aGlzLCBhcmdzKTtcblxuICAgICAgICBhcnJheS5fY2hhcnRqcy5saXN0ZW5lcnMuZm9yRWFjaCgob2JqZWN0KSA9PiB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBvYmplY3RbbWV0aG9kXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgb2JqZWN0W21ldGhvZF0oLi4uYXJncyk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgfVxuICAgIH0pO1xuICB9KTtcbn1cblxuXG4vKipcbiAqIFJlbW92ZXMgdGhlIGdpdmVuIGFycmF5IGV2ZW50IGxpc3RlbmVyIGFuZCBjbGVhbnVwIGV4dHJhIGF0dGFjaGVkIHByb3BlcnRpZXMgKHN1Y2ggYXNcbiAqIHRoZSBfY2hhcnRqcyBzdHViIGFuZCBvdmVycmlkZGVuIG1ldGhvZHMpIGlmIGFycmF5IGRvZXNuJ3QgaGF2ZSBhbnkgbW9yZSBsaXN0ZW5lcnMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1bmxpc3RlbkFycmF5RXZlbnRzPFQ+KGFycmF5OiBUW10sIGxpc3RlbmVyOiBBcnJheUxpc3RlbmVyPFQ+KTogdm9pZDtcbmV4cG9ydCBmdW5jdGlvbiB1bmxpc3RlbkFycmF5RXZlbnRzKGFycmF5LCBsaXN0ZW5lcikge1xuICBjb25zdCBzdHViID0gYXJyYXkuX2NoYXJ0anM7XG4gIGlmICghc3R1Yikge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGNvbnN0IGxpc3RlbmVycyA9IHN0dWIubGlzdGVuZXJzO1xuICBjb25zdCBpbmRleCA9IGxpc3RlbmVycy5pbmRleE9mKGxpc3RlbmVyKTtcbiAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgIGxpc3RlbmVycy5zcGxpY2UoaW5kZXgsIDEpO1xuICB9XG5cbiAgaWYgKGxpc3RlbmVycy5sZW5ndGggPiAwKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgYXJyYXlFdmVudHMuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgZGVsZXRlIGFycmF5W2tleV07XG4gIH0pO1xuXG4gIGRlbGV0ZSBhcnJheS5fY2hhcnRqcztcbn1cblxuLyoqXG4gKiBAcGFyYW0gaXRlbXNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIF9hcnJheVVuaXF1ZTxUPihpdGVtczogVFtdKSB7XG4gIGNvbnN0IHNldCA9IG5ldyBTZXQ8VD4oaXRlbXMpO1xuXG4gIGlmIChzZXQuc2l6ZSA9PT0gaXRlbXMubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGl0ZW1zO1xuICB9XG5cbiAgcmV0dXJuIEFycmF5LmZyb20oc2V0KTtcbn1cbiIsICJpbXBvcnQgdHlwZSB7Q2hhcnRNZXRhLCBQb2ludEVsZW1lbnR9IGZyb20gJy4uL3R5cGVzL2luZGV4LmpzJztcblxuaW1wb3J0IHtfbGltaXRWYWx1ZX0gZnJvbSAnLi9oZWxwZXJzLm1hdGguanMnO1xuaW1wb3J0IHtfbG9va3VwQnlLZXl9IGZyb20gJy4vaGVscGVycy5jb2xsZWN0aW9uLmpzJztcblxuZXhwb3J0IGZ1bmN0aW9uIGZvbnRTdHJpbmcocGl4ZWxTaXplOiBudW1iZXIsIGZvbnRTdHlsZTogc3RyaW5nLCBmb250RmFtaWx5OiBzdHJpbmcpIHtcbiAgcmV0dXJuIGZvbnRTdHlsZSArICcgJyArIHBpeGVsU2l6ZSArICdweCAnICsgZm9udEZhbWlseTtcbn1cblxuLyoqXG4qIFJlcXVlc3QgYW5pbWF0aW9uIHBvbHlmaWxsXG4qL1xuZXhwb3J0IGNvbnN0IHJlcXVlc3RBbmltRnJhbWUgPSAoZnVuY3Rpb24oKSB7XG4gIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBmdW5jdGlvbihjYWxsYmFjaykge1xuICAgICAgcmV0dXJuIGNhbGxiYWNrKCk7XG4gICAgfTtcbiAgfVxuICByZXR1cm4gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZTtcbn0oKSk7XG5cbi8qKlxuICogVGhyb3R0bGVzIGNhbGxpbmcgYGZuYCBvbmNlIHBlciBhbmltYXRpb24gZnJhbWVcbiAqIExhdGVzdCBhcmd1bWVudHMgYXJlIHVzZWQgb24gdGhlIGFjdHVhbCBjYWxsXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0aHJvdHRsZWQ8VEFyZ3MgZXh0ZW5kcyBBcnJheTxhbnk+PihcbiAgZm46ICguLi5hcmdzOiBUQXJncykgPT4gdm9pZCxcbiAgdGhpc0FyZzogYW55LFxuKSB7XG4gIGxldCBhcmdzVG9Vc2UgPSBbXSBhcyBUQXJncztcbiAgbGV0IHRpY2tpbmcgPSBmYWxzZTtcblxuICByZXR1cm4gZnVuY3Rpb24oLi4uYXJnczogVEFyZ3MpIHtcbiAgICAvLyBTYXZlIHRoZSBhcmdzIGZvciB1c2UgbGF0ZXJcbiAgICBhcmdzVG9Vc2UgPSBhcmdzO1xuICAgIGlmICghdGlja2luZykge1xuICAgICAgdGlja2luZyA9IHRydWU7XG4gICAgICByZXF1ZXN0QW5pbUZyYW1lLmNhbGwod2luZG93LCAoKSA9PiB7XG4gICAgICAgIHRpY2tpbmcgPSBmYWxzZTtcbiAgICAgICAgZm4uYXBwbHkodGhpc0FyZywgYXJnc1RvVXNlKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcbn1cblxuLyoqXG4gKiBEZWJvdW5jZXMgY2FsbGluZyBgZm5gIGZvciBgZGVsYXlgIG1zXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkZWJvdW5jZTxUQXJncyBleHRlbmRzIEFycmF5PGFueT4+KGZuOiAoLi4uYXJnczogVEFyZ3MpID0+IHZvaWQsIGRlbGF5OiBudW1iZXIpIHtcbiAgbGV0IHRpbWVvdXQ7XG4gIHJldHVybiBmdW5jdGlvbiguLi5hcmdzOiBUQXJncykge1xuICAgIGlmIChkZWxheSkge1xuICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgICAgdGltZW91dCA9IHNldFRpbWVvdXQoZm4sIGRlbGF5LCBhcmdzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZm4uYXBwbHkodGhpcywgYXJncyk7XG4gICAgfVxuICAgIHJldHVybiBkZWxheTtcbiAgfTtcbn1cblxuLyoqXG4gKiBDb252ZXJ0cyAnc3RhcnQnIHRvICdsZWZ0JywgJ2VuZCcgdG8gJ3JpZ2h0JyBhbmQgb3RoZXJzIHRvICdjZW50ZXInXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgY29uc3QgX3RvTGVmdFJpZ2h0Q2VudGVyID0gKGFsaWduOiAnc3RhcnQnIHwgJ2VuZCcgfCAnY2VudGVyJykgPT4gYWxpZ24gPT09ICdzdGFydCcgPyAnbGVmdCcgOiBhbGlnbiA9PT0gJ2VuZCcgPyAncmlnaHQnIDogJ2NlbnRlcic7XG5cbi8qKlxuICogUmV0dXJucyBgc3RhcnRgLCBgZW5kYCBvciBgKHN0YXJ0ICsgZW5kKSAvIDJgIGRlcGVuZGluZyBvbiBgYWxpZ25gLiBEZWZhdWx0cyB0byBgY2VudGVyYFxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGNvbnN0IF9hbGlnblN0YXJ0RW5kID0gKGFsaWduOiAnc3RhcnQnIHwgJ2VuZCcgfCAnY2VudGVyJywgc3RhcnQ6IG51bWJlciwgZW5kOiBudW1iZXIpID0+IGFsaWduID09PSAnc3RhcnQnID8gc3RhcnQgOiBhbGlnbiA9PT0gJ2VuZCcgPyBlbmQgOiAoc3RhcnQgKyBlbmQpIC8gMjtcblxuLyoqXG4gKiBSZXR1cm5zIGBsZWZ0YCwgYHJpZ2h0YCBvciBgKGxlZnQgKyByaWdodCkgLyAyYCBkZXBlbmRpbmcgb24gYGFsaWduYC4gRGVmYXVsdHMgdG8gYGxlZnRgXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgY29uc3QgX3RleHRYID0gKGFsaWduOiAnbGVmdCcgfCAncmlnaHQnIHwgJ2NlbnRlcicsIGxlZnQ6IG51bWJlciwgcmlnaHQ6IG51bWJlciwgcnRsOiBib29sZWFuKSA9PiB7XG4gIGNvbnN0IGNoZWNrID0gcnRsID8gJ2xlZnQnIDogJ3JpZ2h0JztcbiAgcmV0dXJuIGFsaWduID09PSBjaGVjayA/IHJpZ2h0IDogYWxpZ24gPT09ICdjZW50ZXInID8gKGxlZnQgKyByaWdodCkgLyAyIDogbGVmdDtcbn07XG5cbi8qKlxuICogUmV0dXJuIHN0YXJ0IGFuZCBjb3VudCBvZiB2aXNpYmxlIHBvaW50cy5cbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBfZ2V0U3RhcnRBbmRDb3VudE9mVmlzaWJsZVBvaW50cyhtZXRhOiBDaGFydE1ldGE8J2xpbmUnIHwgJ3NjYXR0ZXInPiwgcG9pbnRzOiBQb2ludEVsZW1lbnRbXSwgYW5pbWF0aW9uc0Rpc2FibGVkOiBib29sZWFuKSB7XG4gIGNvbnN0IHBvaW50Q291bnQgPSBwb2ludHMubGVuZ3RoO1xuXG4gIGxldCBzdGFydCA9IDA7XG4gIGxldCBjb3VudCA9IHBvaW50Q291bnQ7XG5cbiAgaWYgKG1ldGEuX3NvcnRlZCkge1xuICAgIGNvbnN0IHtpU2NhbGUsIF9wYXJzZWR9ID0gbWV0YTtcbiAgICBjb25zdCBheGlzID0gaVNjYWxlLmF4aXM7XG4gICAgY29uc3Qge21pbiwgbWF4LCBtaW5EZWZpbmVkLCBtYXhEZWZpbmVkfSA9IGlTY2FsZS5nZXRVc2VyQm91bmRzKCk7XG5cbiAgICBpZiAobWluRGVmaW5lZCkge1xuICAgICAgc3RhcnQgPSBfbGltaXRWYWx1ZShNYXRoLm1pbihcbiAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciBOZWVkIHRvIHR5cGUgX3BhcnNlZFxuICAgICAgICBfbG9va3VwQnlLZXkoX3BhcnNlZCwgYXhpcywgbWluKS5sbyxcbiAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciBOZWVkIHRvIGZpeCB0eXBlcyBvbiBfbG9va3VwQnlLZXlcbiAgICAgICAgYW5pbWF0aW9uc0Rpc2FibGVkID8gcG9pbnRDb3VudCA6IF9sb29rdXBCeUtleShwb2ludHMsIGF4aXMsIGlTY2FsZS5nZXRQaXhlbEZvclZhbHVlKG1pbikpLmxvKSxcbiAgICAgIDAsIHBvaW50Q291bnQgLSAxKTtcbiAgICB9XG4gICAgaWYgKG1heERlZmluZWQpIHtcbiAgICAgIGNvdW50ID0gX2xpbWl0VmFsdWUoTWF0aC5tYXgoXG4gICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgTmVlZCB0byB0eXBlIF9wYXJzZWRcbiAgICAgICAgX2xvb2t1cEJ5S2V5KF9wYXJzZWQsIGlTY2FsZS5heGlzLCBtYXgsIHRydWUpLmhpICsgMSxcbiAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciBOZWVkIHRvIGZpeCB0eXBlcyBvbiBfbG9va3VwQnlLZXlcbiAgICAgICAgYW5pbWF0aW9uc0Rpc2FibGVkID8gMCA6IF9sb29rdXBCeUtleShwb2ludHMsIGF4aXMsIGlTY2FsZS5nZXRQaXhlbEZvclZhbHVlKG1heCksIHRydWUpLmhpICsgMSksXG4gICAgICBzdGFydCwgcG9pbnRDb3VudCkgLSBzdGFydDtcbiAgICB9IGVsc2Uge1xuICAgICAgY291bnQgPSBwb2ludENvdW50IC0gc3RhcnQ7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtzdGFydCwgY291bnR9O1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiB0aGUgc2NhbGUgcmFuZ2VzIGhhdmUgY2hhbmdlZC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBtZXRhIC0gZGF0YXNldCBtZXRhLlxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gX3NjYWxlUmFuZ2VzQ2hhbmdlZChtZXRhKSB7XG4gIGNvbnN0IHt4U2NhbGUsIHlTY2FsZSwgX3NjYWxlUmFuZ2VzfSA9IG1ldGE7XG4gIGNvbnN0IG5ld1JhbmdlcyA9IHtcbiAgICB4bWluOiB4U2NhbGUubWluLFxuICAgIHhtYXg6IHhTY2FsZS5tYXgsXG4gICAgeW1pbjogeVNjYWxlLm1pbixcbiAgICB5bWF4OiB5U2NhbGUubWF4XG4gIH07XG4gIGlmICghX3NjYWxlUmFuZ2VzKSB7XG4gICAgbWV0YS5fc2NhbGVSYW5nZXMgPSBuZXdSYW5nZXM7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgY29uc3QgY2hhbmdlZCA9IF9zY2FsZVJhbmdlcy54bWluICE9PSB4U2NhbGUubWluXG5cdFx0fHwgX3NjYWxlUmFuZ2VzLnhtYXggIT09IHhTY2FsZS5tYXhcblx0XHR8fCBfc2NhbGVSYW5nZXMueW1pbiAhPT0geVNjYWxlLm1pblxuXHRcdHx8IF9zY2FsZVJhbmdlcy55bWF4ICE9PSB5U2NhbGUubWF4O1xuXG4gIE9iamVjdC5hc3NpZ24oX3NjYWxlUmFuZ2VzLCBuZXdSYW5nZXMpO1xuICByZXR1cm4gY2hhbmdlZDtcbn1cbiIsICJpbXBvcnQge1BJLCBUQVUsIEhBTEZfUEl9IGZyb20gJy4vaGVscGVycy5tYXRoLmpzJztcblxuY29uc3QgYXRFZGdlID0gKHQ6IG51bWJlcikgPT4gdCA9PT0gMCB8fCB0ID09PSAxO1xuY29uc3QgZWxhc3RpY0luID0gKHQ6IG51bWJlciwgczogbnVtYmVyLCBwOiBudW1iZXIpID0+IC0oTWF0aC5wb3coMiwgMTAgKiAodCAtPSAxKSkgKiBNYXRoLnNpbigodCAtIHMpICogVEFVIC8gcCkpO1xuY29uc3QgZWxhc3RpY091dCA9ICh0OiBudW1iZXIsIHM6IG51bWJlciwgcDogbnVtYmVyKSA9PiBNYXRoLnBvdygyLCAtMTAgKiB0KSAqIE1hdGguc2luKCh0IC0gcykgKiBUQVUgLyBwKSArIDE7XG5cbi8qKlxuICogRWFzaW5nIGZ1bmN0aW9ucyBhZGFwdGVkIGZyb20gUm9iZXJ0IFBlbm5lcidzIGVhc2luZyBlcXVhdGlvbnMuXG4gKiBAbmFtZXNwYWNlIENoYXJ0LmhlbHBlcnMuZWFzaW5nLmVmZmVjdHNcbiAqIEBzZWUgaHR0cDovL3d3dy5yb2JlcnRwZW5uZXIuY29tL2Vhc2luZy9cbiAqL1xuY29uc3QgZWZmZWN0cyA9IHtcbiAgbGluZWFyOiAodDogbnVtYmVyKSA9PiB0LFxuXG4gIGVhc2VJblF1YWQ6ICh0OiBudW1iZXIpID0+IHQgKiB0LFxuXG4gIGVhc2VPdXRRdWFkOiAodDogbnVtYmVyKSA9PiAtdCAqICh0IC0gMiksXG5cbiAgZWFzZUluT3V0UXVhZDogKHQ6IG51bWJlcikgPT4gKCh0IC89IDAuNSkgPCAxKVxuICAgID8gMC41ICogdCAqIHRcbiAgICA6IC0wLjUgKiAoKC0tdCkgKiAodCAtIDIpIC0gMSksXG5cbiAgZWFzZUluQ3ViaWM6ICh0OiBudW1iZXIpID0+IHQgKiB0ICogdCxcblxuICBlYXNlT3V0Q3ViaWM6ICh0OiBudW1iZXIpID0+ICh0IC09IDEpICogdCAqIHQgKyAxLFxuXG4gIGVhc2VJbk91dEN1YmljOiAodDogbnVtYmVyKSA9PiAoKHQgLz0gMC41KSA8IDEpXG4gICAgPyAwLjUgKiB0ICogdCAqIHRcbiAgICA6IDAuNSAqICgodCAtPSAyKSAqIHQgKiB0ICsgMiksXG5cbiAgZWFzZUluUXVhcnQ6ICh0OiBudW1iZXIpID0+IHQgKiB0ICogdCAqIHQsXG5cbiAgZWFzZU91dFF1YXJ0OiAodDogbnVtYmVyKSA9PiAtKCh0IC09IDEpICogdCAqIHQgKiB0IC0gMSksXG5cbiAgZWFzZUluT3V0UXVhcnQ6ICh0OiBudW1iZXIpID0+ICgodCAvPSAwLjUpIDwgMSlcbiAgICA/IDAuNSAqIHQgKiB0ICogdCAqIHRcbiAgICA6IC0wLjUgKiAoKHQgLT0gMikgKiB0ICogdCAqIHQgLSAyKSxcblxuICBlYXNlSW5RdWludDogKHQ6IG51bWJlcikgPT4gdCAqIHQgKiB0ICogdCAqIHQsXG5cbiAgZWFzZU91dFF1aW50OiAodDogbnVtYmVyKSA9PiAodCAtPSAxKSAqIHQgKiB0ICogdCAqIHQgKyAxLFxuXG4gIGVhc2VJbk91dFF1aW50OiAodDogbnVtYmVyKSA9PiAoKHQgLz0gMC41KSA8IDEpXG4gICAgPyAwLjUgKiB0ICogdCAqIHQgKiB0ICogdFxuICAgIDogMC41ICogKCh0IC09IDIpICogdCAqIHQgKiB0ICogdCArIDIpLFxuXG4gIGVhc2VJblNpbmU6ICh0OiBudW1iZXIpID0+IC1NYXRoLmNvcyh0ICogSEFMRl9QSSkgKyAxLFxuXG4gIGVhc2VPdXRTaW5lOiAodDogbnVtYmVyKSA9PiBNYXRoLnNpbih0ICogSEFMRl9QSSksXG5cbiAgZWFzZUluT3V0U2luZTogKHQ6IG51bWJlcikgPT4gLTAuNSAqIChNYXRoLmNvcyhQSSAqIHQpIC0gMSksXG5cbiAgZWFzZUluRXhwbzogKHQ6IG51bWJlcikgPT4gKHQgPT09IDApID8gMCA6IE1hdGgucG93KDIsIDEwICogKHQgLSAxKSksXG5cbiAgZWFzZU91dEV4cG86ICh0OiBudW1iZXIpID0+ICh0ID09PSAxKSA/IDEgOiAtTWF0aC5wb3coMiwgLTEwICogdCkgKyAxLFxuXG4gIGVhc2VJbk91dEV4cG86ICh0OiBudW1iZXIpID0+IGF0RWRnZSh0KSA/IHQgOiB0IDwgMC41XG4gICAgPyAwLjUgKiBNYXRoLnBvdygyLCAxMCAqICh0ICogMiAtIDEpKVxuICAgIDogMC41ICogKC1NYXRoLnBvdygyLCAtMTAgKiAodCAqIDIgLSAxKSkgKyAyKSxcblxuICBlYXNlSW5DaXJjOiAodDogbnVtYmVyKSA9PiAodCA+PSAxKSA/IHQgOiAtKE1hdGguc3FydCgxIC0gdCAqIHQpIC0gMSksXG5cbiAgZWFzZU91dENpcmM6ICh0OiBudW1iZXIpID0+IE1hdGguc3FydCgxIC0gKHQgLT0gMSkgKiB0KSxcblxuICBlYXNlSW5PdXRDaXJjOiAodDogbnVtYmVyKSA9PiAoKHQgLz0gMC41KSA8IDEpXG4gICAgPyAtMC41ICogKE1hdGguc3FydCgxIC0gdCAqIHQpIC0gMSlcbiAgICA6IDAuNSAqIChNYXRoLnNxcnQoMSAtICh0IC09IDIpICogdCkgKyAxKSxcblxuICBlYXNlSW5FbGFzdGljOiAodDogbnVtYmVyKSA9PiBhdEVkZ2UodCkgPyB0IDogZWxhc3RpY0luKHQsIDAuMDc1LCAwLjMpLFxuXG4gIGVhc2VPdXRFbGFzdGljOiAodDogbnVtYmVyKSA9PiBhdEVkZ2UodCkgPyB0IDogZWxhc3RpY091dCh0LCAwLjA3NSwgMC4zKSxcblxuICBlYXNlSW5PdXRFbGFzdGljKHQ6IG51bWJlcikge1xuICAgIGNvbnN0IHMgPSAwLjExMjU7XG4gICAgY29uc3QgcCA9IDAuNDU7XG4gICAgcmV0dXJuIGF0RWRnZSh0KSA/IHQgOlxuICAgICAgdCA8IDAuNVxuICAgICAgICA/IDAuNSAqIGVsYXN0aWNJbih0ICogMiwgcywgcClcbiAgICAgICAgOiAwLjUgKyAwLjUgKiBlbGFzdGljT3V0KHQgKiAyIC0gMSwgcywgcCk7XG4gIH0sXG5cbiAgZWFzZUluQmFjayh0OiBudW1iZXIpIHtcbiAgICBjb25zdCBzID0gMS43MDE1ODtcbiAgICByZXR1cm4gdCAqIHQgKiAoKHMgKyAxKSAqIHQgLSBzKTtcbiAgfSxcblxuICBlYXNlT3V0QmFjayh0OiBudW1iZXIpIHtcbiAgICBjb25zdCBzID0gMS43MDE1ODtcbiAgICByZXR1cm4gKHQgLT0gMSkgKiB0ICogKChzICsgMSkgKiB0ICsgcykgKyAxO1xuICB9LFxuXG4gIGVhc2VJbk91dEJhY2sodDogbnVtYmVyKSB7XG4gICAgbGV0IHMgPSAxLjcwMTU4O1xuICAgIGlmICgodCAvPSAwLjUpIDwgMSkge1xuICAgICAgcmV0dXJuIDAuNSAqICh0ICogdCAqICgoKHMgKj0gKDEuNTI1KSkgKyAxKSAqIHQgLSBzKSk7XG4gICAgfVxuICAgIHJldHVybiAwLjUgKiAoKHQgLT0gMikgKiB0ICogKCgocyAqPSAoMS41MjUpKSArIDEpICogdCArIHMpICsgMik7XG4gIH0sXG5cbiAgZWFzZUluQm91bmNlOiAodDogbnVtYmVyKSA9PiAxIC0gZWZmZWN0cy5lYXNlT3V0Qm91bmNlKDEgLSB0KSxcblxuICBlYXNlT3V0Qm91bmNlKHQ6IG51bWJlcikge1xuICAgIGNvbnN0IG0gPSA3LjU2MjU7XG4gICAgY29uc3QgZCA9IDIuNzU7XG4gICAgaWYgKHQgPCAoMSAvIGQpKSB7XG4gICAgICByZXR1cm4gbSAqIHQgKiB0O1xuICAgIH1cbiAgICBpZiAodCA8ICgyIC8gZCkpIHtcbiAgICAgIHJldHVybiBtICogKHQgLT0gKDEuNSAvIGQpKSAqIHQgKyAwLjc1O1xuICAgIH1cbiAgICBpZiAodCA8ICgyLjUgLyBkKSkge1xuICAgICAgcmV0dXJuIG0gKiAodCAtPSAoMi4yNSAvIGQpKSAqIHQgKyAwLjkzNzU7XG4gICAgfVxuICAgIHJldHVybiBtICogKHQgLT0gKDIuNjI1IC8gZCkpICogdCArIDAuOTg0Mzc1O1xuICB9LFxuXG4gIGVhc2VJbk91dEJvdW5jZTogKHQ6IG51bWJlcikgPT4gKHQgPCAwLjUpXG4gICAgPyBlZmZlY3RzLmVhc2VJbkJvdW5jZSh0ICogMikgKiAwLjVcbiAgICA6IGVmZmVjdHMuZWFzZU91dEJvdW5jZSh0ICogMiAtIDEpICogMC41ICsgMC41LFxufSBhcyBjb25zdDtcblxuZXhwb3J0IHR5cGUgRWFzaW5nRnVuY3Rpb24gPSBrZXlvZiB0eXBlb2YgZWZmZWN0c1xuXG5leHBvcnQgZGVmYXVsdCBlZmZlY3RzO1xuIiwgImltcG9ydCB7Q29sb3J9IGZyb20gJ0BrdXJrbGUvY29sb3InO1xuXG5leHBvcnQgZnVuY3Rpb24gaXNQYXR0ZXJuT3JHcmFkaWVudCh2YWx1ZTogdW5rbm93bik6IHZhbHVlIGlzIENhbnZhc1BhdHRlcm4gfCBDYW52YXNHcmFkaWVudCB7XG4gIGlmICh2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnKSB7XG4gICAgY29uc3QgdHlwZSA9IHZhbHVlLnRvU3RyaW5nKCk7XG4gICAgcmV0dXJuIHR5cGUgPT09ICdbb2JqZWN0IENhbnZhc1BhdHRlcm5dJyB8fCB0eXBlID09PSAnW29iamVjdCBDYW52YXNHcmFkaWVudF0nO1xuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY29sb3IodmFsdWU6IENhbnZhc0dyYWRpZW50KTogQ2FudmFzR3JhZGllbnQ7XG5leHBvcnQgZnVuY3Rpb24gY29sb3IodmFsdWU6IENhbnZhc1BhdHRlcm4pOiBDYW52YXNQYXR0ZXJuO1xuZXhwb3J0IGZ1bmN0aW9uIGNvbG9yKFxuICB2YWx1ZTpcbiAgfCBzdHJpbmdcbiAgfCB7IHI6IG51bWJlcjsgZzogbnVtYmVyOyBiOiBudW1iZXI7IGE6IG51bWJlciB9XG4gIHwgW251bWJlciwgbnVtYmVyLCBudW1iZXJdXG4gIHwgW251bWJlciwgbnVtYmVyLCBudW1iZXIsIG51bWJlcl1cbik6IENvbG9yO1xuZXhwb3J0IGZ1bmN0aW9uIGNvbG9yKHZhbHVlKSB7XG4gIHJldHVybiBpc1BhdHRlcm5PckdyYWRpZW50KHZhbHVlKSA/IHZhbHVlIDogbmV3IENvbG9yKHZhbHVlKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldEhvdmVyQ29sb3IodmFsdWU6IENhbnZhc0dyYWRpZW50KTogQ2FudmFzR3JhZGllbnQ7XG5leHBvcnQgZnVuY3Rpb24gZ2V0SG92ZXJDb2xvcih2YWx1ZTogQ2FudmFzUGF0dGVybik6IENhbnZhc1BhdHRlcm47XG5leHBvcnQgZnVuY3Rpb24gZ2V0SG92ZXJDb2xvcih2YWx1ZTogc3RyaW5nKTogc3RyaW5nO1xuZXhwb3J0IGZ1bmN0aW9uIGdldEhvdmVyQ29sb3IodmFsdWUpIHtcbiAgcmV0dXJuIGlzUGF0dGVybk9yR3JhZGllbnQodmFsdWUpXG4gICAgPyB2YWx1ZVxuICAgIDogbmV3IENvbG9yKHZhbHVlKS5zYXR1cmF0ZSgwLjUpLmRhcmtlbigwLjEpLmhleFN0cmluZygpO1xufVxuIiwgImNvbnN0IG51bWJlcnMgPSBbJ3gnLCAneScsICdib3JkZXJXaWR0aCcsICdyYWRpdXMnLCAndGVuc2lvbiddO1xuY29uc3QgY29sb3JzID0gWydjb2xvcicsICdib3JkZXJDb2xvcicsICdiYWNrZ3JvdW5kQ29sb3InXTtcblxuZXhwb3J0IGZ1bmN0aW9uIGFwcGx5QW5pbWF0aW9uc0RlZmF1bHRzKGRlZmF1bHRzKSB7XG4gIGRlZmF1bHRzLnNldCgnYW5pbWF0aW9uJywge1xuICAgIGRlbGF5OiB1bmRlZmluZWQsXG4gICAgZHVyYXRpb246IDEwMDAsXG4gICAgZWFzaW5nOiAnZWFzZU91dFF1YXJ0JyxcbiAgICBmbjogdW5kZWZpbmVkLFxuICAgIGZyb206IHVuZGVmaW5lZCxcbiAgICBsb29wOiB1bmRlZmluZWQsXG4gICAgdG86IHVuZGVmaW5lZCxcbiAgICB0eXBlOiB1bmRlZmluZWQsXG4gIH0pO1xuXG4gIGRlZmF1bHRzLmRlc2NyaWJlKCdhbmltYXRpb24nLCB7XG4gICAgX2ZhbGxiYWNrOiBmYWxzZSxcbiAgICBfaW5kZXhhYmxlOiBmYWxzZSxcbiAgICBfc2NyaXB0YWJsZTogKG5hbWUpID0+IG5hbWUgIT09ICdvblByb2dyZXNzJyAmJiBuYW1lICE9PSAnb25Db21wbGV0ZScgJiYgbmFtZSAhPT0gJ2ZuJyxcbiAgfSk7XG5cbiAgZGVmYXVsdHMuc2V0KCdhbmltYXRpb25zJywge1xuICAgIGNvbG9yczoge1xuICAgICAgdHlwZTogJ2NvbG9yJyxcbiAgICAgIHByb3BlcnRpZXM6IGNvbG9yc1xuICAgIH0sXG4gICAgbnVtYmVyczoge1xuICAgICAgdHlwZTogJ251bWJlcicsXG4gICAgICBwcm9wZXJ0aWVzOiBudW1iZXJzXG4gICAgfSxcbiAgfSk7XG5cbiAgZGVmYXVsdHMuZGVzY3JpYmUoJ2FuaW1hdGlvbnMnLCB7XG4gICAgX2ZhbGxiYWNrOiAnYW5pbWF0aW9uJyxcbiAgfSk7XG5cbiAgZGVmYXVsdHMuc2V0KCd0cmFuc2l0aW9ucycsIHtcbiAgICBhY3RpdmU6IHtcbiAgICAgIGFuaW1hdGlvbjoge1xuICAgICAgICBkdXJhdGlvbjogNDAwXG4gICAgICB9XG4gICAgfSxcbiAgICByZXNpemU6IHtcbiAgICAgIGFuaW1hdGlvbjoge1xuICAgICAgICBkdXJhdGlvbjogMFxuICAgICAgfVxuICAgIH0sXG4gICAgc2hvdzoge1xuICAgICAgYW5pbWF0aW9uczoge1xuICAgICAgICBjb2xvcnM6IHtcbiAgICAgICAgICBmcm9tOiAndHJhbnNwYXJlbnQnXG4gICAgICAgIH0sXG4gICAgICAgIHZpc2libGU6IHtcbiAgICAgICAgICB0eXBlOiAnYm9vbGVhbicsXG4gICAgICAgICAgZHVyYXRpb246IDAgLy8gc2hvdyBpbW1lZGlhdGVseVxuICAgICAgICB9LFxuICAgICAgfVxuICAgIH0sXG4gICAgaGlkZToge1xuICAgICAgYW5pbWF0aW9uczoge1xuICAgICAgICBjb2xvcnM6IHtcbiAgICAgICAgICB0bzogJ3RyYW5zcGFyZW50J1xuICAgICAgICB9LFxuICAgICAgICB2aXNpYmxlOiB7XG4gICAgICAgICAgdHlwZTogJ2Jvb2xlYW4nLFxuICAgICAgICAgIGVhc2luZzogJ2xpbmVhcicsXG4gICAgICAgICAgZm46IHYgPT4gdiB8IDAgLy8gZm9yIGtlZXBpbmcgdGhlIGRhdGFzZXQgdmlzaWJsZSBhbGwgdGhlIHdheSB0aHJvdWdoIHRoZSBhbmltYXRpb25cbiAgICAgICAgfSxcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xufVxuIiwgImV4cG9ydCBmdW5jdGlvbiBhcHBseUxheW91dHNEZWZhdWx0cyhkZWZhdWx0cykge1xuICBkZWZhdWx0cy5zZXQoJ2xheW91dCcsIHtcbiAgICBhdXRvUGFkZGluZzogdHJ1ZSxcbiAgICBwYWRkaW5nOiB7XG4gICAgICB0b3A6IDAsXG4gICAgICByaWdodDogMCxcbiAgICAgIGJvdHRvbTogMCxcbiAgICAgIGxlZnQ6IDBcbiAgICB9XG4gIH0pO1xufVxuIiwgIlxuY29uc3QgaW50bENhY2hlID0gbmV3IE1hcDxzdHJpbmcsIEludGwuTnVtYmVyRm9ybWF0PigpO1xuXG5mdW5jdGlvbiBnZXROdW1iZXJGb3JtYXQobG9jYWxlOiBzdHJpbmcsIG9wdGlvbnM/OiBJbnRsLk51bWJlckZvcm1hdE9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIGNvbnN0IGNhY2hlS2V5ID0gbG9jYWxlICsgSlNPTi5zdHJpbmdpZnkob3B0aW9ucyk7XG4gIGxldCBmb3JtYXR0ZXIgPSBpbnRsQ2FjaGUuZ2V0KGNhY2hlS2V5KTtcbiAgaWYgKCFmb3JtYXR0ZXIpIHtcbiAgICBmb3JtYXR0ZXIgPSBuZXcgSW50bC5OdW1iZXJGb3JtYXQobG9jYWxlLCBvcHRpb25zKTtcbiAgICBpbnRsQ2FjaGUuc2V0KGNhY2hlS2V5LCBmb3JtYXR0ZXIpO1xuICB9XG4gIHJldHVybiBmb3JtYXR0ZXI7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBmb3JtYXROdW1iZXIobnVtOiBudW1iZXIsIGxvY2FsZTogc3RyaW5nLCBvcHRpb25zPzogSW50bC5OdW1iZXJGb3JtYXRPcHRpb25zKSB7XG4gIHJldHVybiBnZXROdW1iZXJGb3JtYXQobG9jYWxlLCBvcHRpb25zKS5mb3JtYXQobnVtKTtcbn1cbiIsICJpbXBvcnQge2lzQXJyYXl9IGZyb20gJy4uL2hlbHBlcnMvaGVscGVycy5jb3JlLmpzJztcbmltcG9ydCB7Zm9ybWF0TnVtYmVyfSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMuaW50bC5qcyc7XG5pbXBvcnQge2xvZzEwfSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMubWF0aC5qcyc7XG5cbi8qKlxuICogTmFtZXNwYWNlIHRvIGhvbGQgZm9ybWF0dGVycyBmb3IgZGlmZmVyZW50IHR5cGVzIG9mIHRpY2tzXG4gKiBAbmFtZXNwYWNlIENoYXJ0LlRpY2tzLmZvcm1hdHRlcnNcbiAqL1xuY29uc3QgZm9ybWF0dGVycyA9IHtcbiAgLyoqXG4gICAqIEZvcm1hdHRlciBmb3IgdmFsdWUgbGFiZWxzXG4gICAqIEBtZXRob2QgQ2hhcnQuVGlja3MuZm9ybWF0dGVycy52YWx1ZXNcbiAgICogQHBhcmFtIHZhbHVlIHRoZSB2YWx1ZSB0byBkaXNwbGF5XG4gICAqIEByZXR1cm4ge3N0cmluZ3xzdHJpbmdbXX0gdGhlIGxhYmVsIHRvIGRpc3BsYXlcbiAgICovXG4gIHZhbHVlcyh2YWx1ZSkge1xuICAgIHJldHVybiBpc0FycmF5KHZhbHVlKSA/IC8qKiBAdHlwZSB7c3RyaW5nW119ICovICh2YWx1ZSkgOiAnJyArIHZhbHVlO1xuICB9LFxuXG4gIC8qKlxuICAgKiBGb3JtYXR0ZXIgZm9yIG51bWVyaWMgdGlja3NcbiAgICogQG1ldGhvZCBDaGFydC5UaWNrcy5mb3JtYXR0ZXJzLm51bWVyaWNcbiAgICogQHBhcmFtIHRpY2tWYWx1ZSB7bnVtYmVyfSB0aGUgdmFsdWUgdG8gYmUgZm9ybWF0dGVkXG4gICAqIEBwYXJhbSBpbmRleCB7bnVtYmVyfSB0aGUgcG9zaXRpb24gb2YgdGhlIHRpY2tWYWx1ZSBwYXJhbWV0ZXIgaW4gdGhlIHRpY2tzIGFycmF5XG4gICAqIEBwYXJhbSB0aWNrcyB7b2JqZWN0W119IHRoZSBsaXN0IG9mIHRpY2tzIGJlaW5nIGNvbnZlcnRlZFxuICAgKiBAcmV0dXJuIHtzdHJpbmd9IHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgdGlja1ZhbHVlIHBhcmFtZXRlclxuICAgKi9cbiAgbnVtZXJpYyh0aWNrVmFsdWUsIGluZGV4LCB0aWNrcykge1xuICAgIGlmICh0aWNrVmFsdWUgPT09IDApIHtcbiAgICAgIHJldHVybiAnMCc7IC8vIG5ldmVyIHNob3cgZGVjaW1hbCBwbGFjZXMgZm9yIDBcbiAgICB9XG5cbiAgICBjb25zdCBsb2NhbGUgPSB0aGlzLmNoYXJ0Lm9wdGlvbnMubG9jYWxlO1xuICAgIGxldCBub3RhdGlvbjtcbiAgICBsZXQgZGVsdGEgPSB0aWNrVmFsdWU7IC8vIFRoaXMgaXMgdXNlZCB3aGVuIHRoZXJlIGFyZSBsZXNzIHRoYW4gMiB0aWNrcyBhcyB0aGUgdGljayBpbnRlcnZhbC5cblxuICAgIGlmICh0aWNrcy5sZW5ndGggPiAxKSB7XG4gICAgICAvLyBhbGwgdGlja3MgYXJlIHNtYWxsIG9yIHRoZXJlIGh1Z2UgbnVtYmVyczsgdXNlIHNjaWVudGlmaWMgbm90YXRpb25cbiAgICAgIGNvbnN0IG1heFRpY2sgPSBNYXRoLm1heChNYXRoLmFicyh0aWNrc1swXS52YWx1ZSksIE1hdGguYWJzKHRpY2tzW3RpY2tzLmxlbmd0aCAtIDFdLnZhbHVlKSk7XG4gICAgICBpZiAobWF4VGljayA8IDFlLTQgfHwgbWF4VGljayA+IDFlKzE1KSB7XG4gICAgICAgIG5vdGF0aW9uID0gJ3NjaWVudGlmaWMnO1xuICAgICAgfVxuXG4gICAgICBkZWx0YSA9IGNhbGN1bGF0ZURlbHRhKHRpY2tWYWx1ZSwgdGlja3MpO1xuICAgIH1cblxuICAgIGNvbnN0IGxvZ0RlbHRhID0gbG9nMTAoTWF0aC5hYnMoZGVsdGEpKTtcblxuICAgIC8vIFdoZW4gZGF0YXNldHMgaGF2ZSB2YWx1ZXMgYXBwcm9hY2hpbmcgTnVtYmVyLk1BWF9WQUxVRSwgdGhlIHRpY2sgY2FsY3VsYXRpb25zIG1pZ2h0IHJlc3VsdCBpblxuICAgIC8vIGluZmluaXR5IGFuZCBldmVudHVhbGx5IE5hTi4gUGFzc2luZyBOYU4gZm9yIG1pbmltdW1GcmFjdGlvbkRpZ2l0cyBvciBtYXhpbXVtRnJhY3Rpb25EaWdpdHNcbiAgICAvLyB3aWxsIG1ha2UgdGhlIG51bWJlciBmb3JtYXR0ZXIgdGhyb3cuIFNvIGluc3RlYWQgd2UgY2hlY2sgZm9yIGlzTmFOIGFuZCB1c2UgYSBmYWxsYmFjayB2YWx1ZS5cbiAgICAvL1xuICAgIC8vIHRvRml4ZWQgaGFzIGEgbWF4IG9mIDIwIGRlY2ltYWwgcGxhY2VzXG4gICAgY29uc3QgbnVtRGVjaW1hbCA9IGlzTmFOKGxvZ0RlbHRhKSA/IDEgOiBNYXRoLm1heChNYXRoLm1pbigtMSAqIE1hdGguZmxvb3IobG9nRGVsdGEpLCAyMCksIDApO1xuXG4gICAgY29uc3Qgb3B0aW9ucyA9IHtub3RhdGlvbiwgbWluaW11bUZyYWN0aW9uRGlnaXRzOiBudW1EZWNpbWFsLCBtYXhpbXVtRnJhY3Rpb25EaWdpdHM6IG51bURlY2ltYWx9O1xuICAgIE9iamVjdC5hc3NpZ24ob3B0aW9ucywgdGhpcy5vcHRpb25zLnRpY2tzLmZvcm1hdCk7XG5cbiAgICByZXR1cm4gZm9ybWF0TnVtYmVyKHRpY2tWYWx1ZSwgbG9jYWxlLCBvcHRpb25zKTtcbiAgfSxcblxuXG4gIC8qKlxuICAgKiBGb3JtYXR0ZXIgZm9yIGxvZ2FyaXRobWljIHRpY2tzXG4gICAqIEBtZXRob2QgQ2hhcnQuVGlja3MuZm9ybWF0dGVycy5sb2dhcml0aG1pY1xuICAgKiBAcGFyYW0gdGlja1ZhbHVlIHtudW1iZXJ9IHRoZSB2YWx1ZSB0byBiZSBmb3JtYXR0ZWRcbiAgICogQHBhcmFtIGluZGV4IHtudW1iZXJ9IHRoZSBwb3NpdGlvbiBvZiB0aGUgdGlja1ZhbHVlIHBhcmFtZXRlciBpbiB0aGUgdGlja3MgYXJyYXlcbiAgICogQHBhcmFtIHRpY2tzIHtvYmplY3RbXX0gdGhlIGxpc3Qgb2YgdGlja3MgYmVpbmcgY29udmVydGVkXG4gICAqIEByZXR1cm4ge3N0cmluZ30gc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSB0aWNrVmFsdWUgcGFyYW1ldGVyXG4gICAqL1xuICBsb2dhcml0aG1pYyh0aWNrVmFsdWUsIGluZGV4LCB0aWNrcykge1xuICAgIGlmICh0aWNrVmFsdWUgPT09IDApIHtcbiAgICAgIHJldHVybiAnMCc7XG4gICAgfVxuICAgIGNvbnN0IHJlbWFpbiA9IHRpY2tzW2luZGV4XS5zaWduaWZpY2FuZCB8fCAodGlja1ZhbHVlIC8gKE1hdGgucG93KDEwLCBNYXRoLmZsb29yKGxvZzEwKHRpY2tWYWx1ZSkpKSkpO1xuICAgIGlmIChbMSwgMiwgMywgNSwgMTAsIDE1XS5pbmNsdWRlcyhyZW1haW4pIHx8IGluZGV4ID4gMC44ICogdGlja3MubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gZm9ybWF0dGVycy5udW1lcmljLmNhbGwodGhpcywgdGlja1ZhbHVlLCBpbmRleCwgdGlja3MpO1xuICAgIH1cbiAgICByZXR1cm4gJyc7XG4gIH1cblxufTtcblxuXG5mdW5jdGlvbiBjYWxjdWxhdGVEZWx0YSh0aWNrVmFsdWUsIHRpY2tzKSB7XG4gIC8vIEZpZ3VyZSBvdXQgaG93IG1hbnkgZGlnaXRzIHRvIHNob3dcbiAgLy8gVGhlIHNwYWNlIGJldHdlZW4gdGhlIGZpcnN0IHR3byB0aWNrcyBtaWdodCBiZSBzbWFsbGVyIHRoYW4gbm9ybWFsIHNwYWNpbmdcbiAgbGV0IGRlbHRhID0gdGlja3MubGVuZ3RoID4gMyA/IHRpY2tzWzJdLnZhbHVlIC0gdGlja3NbMV0udmFsdWUgOiB0aWNrc1sxXS52YWx1ZSAtIHRpY2tzWzBdLnZhbHVlO1xuXG4gIC8vIElmIHdlIGhhdmUgYSBudW1iZXIgbGlrZSAyLjUgYXMgdGhlIGRlbHRhLCBmaWd1cmUgb3V0IGhvdyBtYW55IGRlY2ltYWwgcGxhY2VzIHdlIG5lZWRcbiAgaWYgKE1hdGguYWJzKGRlbHRhKSA+PSAxICYmIHRpY2tWYWx1ZSAhPT0gTWF0aC5mbG9vcih0aWNrVmFsdWUpKSB7XG4gICAgLy8gbm90IGFuIGludGVnZXJcbiAgICBkZWx0YSA9IHRpY2tWYWx1ZSAtIE1hdGguZmxvb3IodGlja1ZhbHVlKTtcbiAgfVxuICByZXR1cm4gZGVsdGE7XG59XG5cbi8qKlxuICogTmFtZXNwYWNlIHRvIGhvbGQgc3RhdGljIHRpY2sgZ2VuZXJhdGlvbiBmdW5jdGlvbnNcbiAqIEBuYW1lc3BhY2UgQ2hhcnQuVGlja3NcbiAqL1xuZXhwb3J0IGRlZmF1bHQge2Zvcm1hdHRlcnN9O1xuIiwgImltcG9ydCBUaWNrcyBmcm9tICcuL2NvcmUudGlja3MuanMnO1xuXG5leHBvcnQgZnVuY3Rpb24gYXBwbHlTY2FsZURlZmF1bHRzKGRlZmF1bHRzKSB7XG4gIGRlZmF1bHRzLnNldCgnc2NhbGUnLCB7XG4gICAgZGlzcGxheTogdHJ1ZSxcbiAgICBvZmZzZXQ6IGZhbHNlLFxuICAgIHJldmVyc2U6IGZhbHNlLFxuICAgIGJlZ2luQXRaZXJvOiBmYWxzZSxcblxuICAgIC8qKlxuICAgICAqIFNjYWxlIGJvdW5kYXJ5IHN0cmF0ZWd5IChieXBhc3NlZCBieSBtaW4vbWF4IHRpbWUgb3B0aW9ucylcbiAgICAgKiAtIGBkYXRhYDogbWFrZSBzdXJlIGRhdGEgYXJlIGZ1bGx5IHZpc2libGUsIHRpY2tzIG91dHNpZGUgYXJlIHJlbW92ZWRcbiAgICAgKiAtIGB0aWNrc2A6IG1ha2Ugc3VyZSB0aWNrcyBhcmUgZnVsbHkgdmlzaWJsZSwgZGF0YSBvdXRzaWRlIGFyZSB0cnVuY2F0ZWRcbiAgICAgKiBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9jaGFydGpzL0NoYXJ0LmpzL3B1bGwvNDU1NlxuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqL1xuICAgIGJvdW5kczogJ3RpY2tzJyxcblxuICAgIGNsaXA6IHRydWUsXG5cbiAgICAvKipcbiAgICAgKiBBZGRpdGlvbiBncmFjZSBhZGRlZCB0byBtYXggYW5kIHJlZHVjZWQgZnJvbSBtaW4gZGF0YSB2YWx1ZS5cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKi9cbiAgICBncmFjZTogMCxcblxuICAgIC8vIGdyaWQgbGluZSBzZXR0aW5nc1xuICAgIGdyaWQ6IHtcbiAgICAgIGRpc3BsYXk6IHRydWUsXG4gICAgICBsaW5lV2lkdGg6IDEsXG4gICAgICBkcmF3T25DaGFydEFyZWE6IHRydWUsXG4gICAgICBkcmF3VGlja3M6IHRydWUsXG4gICAgICB0aWNrTGVuZ3RoOiA4LFxuICAgICAgdGlja1dpZHRoOiAoX2N0eCwgb3B0aW9ucykgPT4gb3B0aW9ucy5saW5lV2lkdGgsXG4gICAgICB0aWNrQ29sb3I6IChfY3R4LCBvcHRpb25zKSA9PiBvcHRpb25zLmNvbG9yLFxuICAgICAgb2Zmc2V0OiBmYWxzZSxcbiAgICB9LFxuXG4gICAgYm9yZGVyOiB7XG4gICAgICBkaXNwbGF5OiB0cnVlLFxuICAgICAgZGFzaDogW10sXG4gICAgICBkYXNoT2Zmc2V0OiAwLjAsXG4gICAgICB3aWR0aDogMVxuICAgIH0sXG5cbiAgICAvLyBzY2FsZSB0aXRsZVxuICAgIHRpdGxlOiB7XG4gICAgICAvLyBkaXNwbGF5IHByb3BlcnR5XG4gICAgICBkaXNwbGF5OiBmYWxzZSxcblxuICAgICAgLy8gYWN0dWFsIGxhYmVsXG4gICAgICB0ZXh0OiAnJyxcblxuICAgICAgLy8gdG9wL2JvdHRvbSBwYWRkaW5nXG4gICAgICBwYWRkaW5nOiB7XG4gICAgICAgIHRvcDogNCxcbiAgICAgICAgYm90dG9tOiA0XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8vIGxhYmVsIHNldHRpbmdzXG4gICAgdGlja3M6IHtcbiAgICAgIG1pblJvdGF0aW9uOiAwLFxuICAgICAgbWF4Um90YXRpb246IDUwLFxuICAgICAgbWlycm9yOiBmYWxzZSxcbiAgICAgIHRleHRTdHJva2VXaWR0aDogMCxcbiAgICAgIHRleHRTdHJva2VDb2xvcjogJycsXG4gICAgICBwYWRkaW5nOiAzLFxuICAgICAgZGlzcGxheTogdHJ1ZSxcbiAgICAgIGF1dG9Ta2lwOiB0cnVlLFxuICAgICAgYXV0b1NraXBQYWRkaW5nOiAzLFxuICAgICAgbGFiZWxPZmZzZXQ6IDAsXG4gICAgICAvLyBXZSBwYXNzIHRocm91Z2ggYXJyYXlzIHRvIGJlIHJlbmRlcmVkIGFzIG11bHRpbGluZSBsYWJlbHMsIHdlIGNvbnZlcnQgT3RoZXJzIHRvIHN0cmluZ3MgaGVyZS5cbiAgICAgIGNhbGxiYWNrOiBUaWNrcy5mb3JtYXR0ZXJzLnZhbHVlcyxcbiAgICAgIG1pbm9yOiB7fSxcbiAgICAgIG1ham9yOiB7fSxcbiAgICAgIGFsaWduOiAnY2VudGVyJyxcbiAgICAgIGNyb3NzQWxpZ246ICduZWFyJyxcblxuICAgICAgc2hvd0xhYmVsQmFja2Ryb3A6IGZhbHNlLFxuICAgICAgYmFja2Ryb3BDb2xvcjogJ3JnYmEoMjU1LCAyNTUsIDI1NSwgMC43NSknLFxuICAgICAgYmFja2Ryb3BQYWRkaW5nOiAyLFxuICAgIH1cbiAgfSk7XG5cbiAgZGVmYXVsdHMucm91dGUoJ3NjYWxlLnRpY2tzJywgJ2NvbG9yJywgJycsICdjb2xvcicpO1xuICBkZWZhdWx0cy5yb3V0ZSgnc2NhbGUuZ3JpZCcsICdjb2xvcicsICcnLCAnYm9yZGVyQ29sb3InKTtcbiAgZGVmYXVsdHMucm91dGUoJ3NjYWxlLmJvcmRlcicsICdjb2xvcicsICcnLCAnYm9yZGVyQ29sb3InKTtcbiAgZGVmYXVsdHMucm91dGUoJ3NjYWxlLnRpdGxlJywgJ2NvbG9yJywgJycsICdjb2xvcicpO1xuXG4gIGRlZmF1bHRzLmRlc2NyaWJlKCdzY2FsZScsIHtcbiAgICBfZmFsbGJhY2s6IGZhbHNlLFxuICAgIF9zY3JpcHRhYmxlOiAobmFtZSkgPT4gIW5hbWUuc3RhcnRzV2l0aCgnYmVmb3JlJykgJiYgIW5hbWUuc3RhcnRzV2l0aCgnYWZ0ZXInKSAmJiBuYW1lICE9PSAnY2FsbGJhY2snICYmIG5hbWUgIT09ICdwYXJzZXInLFxuICAgIF9pbmRleGFibGU6IChuYW1lKSA9PiBuYW1lICE9PSAnYm9yZGVyRGFzaCcgJiYgbmFtZSAhPT0gJ3RpY2tCb3JkZXJEYXNoJyAmJiBuYW1lICE9PSAnZGFzaCcsXG4gIH0pO1xuXG4gIGRlZmF1bHRzLmRlc2NyaWJlKCdzY2FsZXMnLCB7XG4gICAgX2ZhbGxiYWNrOiAnc2NhbGUnLFxuICB9KTtcblxuICBkZWZhdWx0cy5kZXNjcmliZSgnc2NhbGUudGlja3MnLCB7XG4gICAgX3NjcmlwdGFibGU6IChuYW1lKSA9PiBuYW1lICE9PSAnYmFja2Ryb3BQYWRkaW5nJyAmJiBuYW1lICE9PSAnY2FsbGJhY2snLFxuICAgIF9pbmRleGFibGU6IChuYW1lKSA9PiBuYW1lICE9PSAnYmFja2Ryb3BQYWRkaW5nJyxcbiAgfSk7XG59XG4iLCAiaW1wb3J0IHtnZXRIb3ZlckNvbG9yfSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMuY29sb3IuanMnO1xuaW1wb3J0IHtpc09iamVjdCwgbWVyZ2UsIHZhbHVlT3JEZWZhdWx0fSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMuY29yZS5qcyc7XG5pbXBvcnQge2FwcGx5QW5pbWF0aW9uc0RlZmF1bHRzfSBmcm9tICcuL2NvcmUuYW5pbWF0aW9ucy5kZWZhdWx0cy5qcyc7XG5pbXBvcnQge2FwcGx5TGF5b3V0c0RlZmF1bHRzfSBmcm9tICcuL2NvcmUubGF5b3V0cy5kZWZhdWx0cy5qcyc7XG5pbXBvcnQge2FwcGx5U2NhbGVEZWZhdWx0c30gZnJvbSAnLi9jb3JlLnNjYWxlLmRlZmF1bHRzLmpzJztcblxuZXhwb3J0IGNvbnN0IG92ZXJyaWRlcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5leHBvcnQgY29uc3QgZGVzY3JpcHRvcnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG4vKipcbiAqIEBwYXJhbSB7b2JqZWN0fSBub2RlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5XG4gKiBAcmV0dXJuIHtvYmplY3R9XG4gKi9cbmZ1bmN0aW9uIGdldFNjb3BlKG5vZGUsIGtleSkge1xuICBpZiAoIWtleSkge1xuICAgIHJldHVybiBub2RlO1xuICB9XG4gIGNvbnN0IGtleXMgPSBrZXkuc3BsaXQoJy4nKTtcbiAgZm9yIChsZXQgaSA9IDAsIG4gPSBrZXlzLmxlbmd0aDsgaSA8IG47ICsraSkge1xuICAgIGNvbnN0IGsgPSBrZXlzW2ldO1xuICAgIG5vZGUgPSBub2RlW2tdIHx8IChub2RlW2tdID0gT2JqZWN0LmNyZWF0ZShudWxsKSk7XG4gIH1cbiAgcmV0dXJuIG5vZGU7XG59XG5cbmZ1bmN0aW9uIHNldChyb290LCBzY29wZSwgdmFsdWVzKSB7XG4gIGlmICh0eXBlb2Ygc2NvcGUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIG1lcmdlKGdldFNjb3BlKHJvb3QsIHNjb3BlKSwgdmFsdWVzKTtcbiAgfVxuICByZXR1cm4gbWVyZ2UoZ2V0U2NvcGUocm9vdCwgJycpLCBzY29wZSk7XG59XG5cbi8qKlxuICogUGxlYXNlIHVzZSB0aGUgbW9kdWxlJ3MgZGVmYXVsdCBleHBvcnQgd2hpY2ggcHJvdmlkZXMgYSBzaW5nbGV0b24gaW5zdGFuY2VcbiAqIE5vdGU6IGNsYXNzIGlzIGV4cG9ydGVkIGZvciB0eXBlZG9jXG4gKi9cbmV4cG9ydCBjbGFzcyBEZWZhdWx0cyB7XG4gIGNvbnN0cnVjdG9yKF9kZXNjcmlwdG9ycywgX2FwcGxpZXJzKSB7XG4gICAgdGhpcy5hbmltYXRpb24gPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5iYWNrZ3JvdW5kQ29sb3IgPSAncmdiYSgwLDAsMCwwLjEpJztcbiAgICB0aGlzLmJvcmRlckNvbG9yID0gJ3JnYmEoMCwwLDAsMC4xKSc7XG4gICAgdGhpcy5jb2xvciA9ICcjNjY2JztcbiAgICB0aGlzLmRhdGFzZXRzID0ge307XG4gICAgdGhpcy5kZXZpY2VQaXhlbFJhdGlvID0gKGNvbnRleHQpID0+IGNvbnRleHQuY2hhcnQucGxhdGZvcm0uZ2V0RGV2aWNlUGl4ZWxSYXRpbygpO1xuICAgIHRoaXMuZWxlbWVudHMgPSB7fTtcbiAgICB0aGlzLmV2ZW50cyA9IFtcbiAgICAgICdtb3VzZW1vdmUnLFxuICAgICAgJ21vdXNlb3V0JyxcbiAgICAgICdjbGljaycsXG4gICAgICAndG91Y2hzdGFydCcsXG4gICAgICAndG91Y2htb3ZlJ1xuICAgIF07XG4gICAgdGhpcy5mb250ID0ge1xuICAgICAgZmFtaWx5OiBcIidIZWx2ZXRpY2EgTmV1ZScsICdIZWx2ZXRpY2EnLCAnQXJpYWwnLCBzYW5zLXNlcmlmXCIsXG4gICAgICBzaXplOiAxMixcbiAgICAgIHN0eWxlOiAnbm9ybWFsJyxcbiAgICAgIGxpbmVIZWlnaHQ6IDEuMixcbiAgICAgIHdlaWdodDogbnVsbFxuICAgIH07XG4gICAgdGhpcy5ob3ZlciA9IHt9O1xuICAgIHRoaXMuaG92ZXJCYWNrZ3JvdW5kQ29sb3IgPSAoY3R4LCBvcHRpb25zKSA9PiBnZXRIb3ZlckNvbG9yKG9wdGlvbnMuYmFja2dyb3VuZENvbG9yKTtcbiAgICB0aGlzLmhvdmVyQm9yZGVyQ29sb3IgPSAoY3R4LCBvcHRpb25zKSA9PiBnZXRIb3ZlckNvbG9yKG9wdGlvbnMuYm9yZGVyQ29sb3IpO1xuICAgIHRoaXMuaG92ZXJDb2xvciA9IChjdHgsIG9wdGlvbnMpID0+IGdldEhvdmVyQ29sb3Iob3B0aW9ucy5jb2xvcik7XG4gICAgdGhpcy5pbmRleEF4aXMgPSAneCc7XG4gICAgdGhpcy5pbnRlcmFjdGlvbiA9IHtcbiAgICAgIG1vZGU6ICduZWFyZXN0JyxcbiAgICAgIGludGVyc2VjdDogdHJ1ZSxcbiAgICAgIGluY2x1ZGVJbnZpc2libGU6IGZhbHNlXG4gICAgfTtcbiAgICB0aGlzLm1haW50YWluQXNwZWN0UmF0aW8gPSB0cnVlO1xuICAgIHRoaXMub25Ib3ZlciA9IG51bGw7XG4gICAgdGhpcy5vbkNsaWNrID0gbnVsbDtcbiAgICB0aGlzLnBhcnNpbmcgPSB0cnVlO1xuICAgIHRoaXMucGx1Z2lucyA9IHt9O1xuICAgIHRoaXMucmVzcG9uc2l2ZSA9IHRydWU7XG4gICAgdGhpcy5zY2FsZSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnNjYWxlcyA9IHt9O1xuICAgIHRoaXMuc2hvd0xpbmUgPSB0cnVlO1xuICAgIHRoaXMuZHJhd0FjdGl2ZUVsZW1lbnRzT25Ub3AgPSB0cnVlO1xuXG4gICAgdGhpcy5kZXNjcmliZShfZGVzY3JpcHRvcnMpO1xuICAgIHRoaXMuYXBwbHkoX2FwcGxpZXJzKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcGFyYW0ge3N0cmluZ3xvYmplY3R9IHNjb3BlXG5cdCAqIEBwYXJhbSB7b2JqZWN0fSBbdmFsdWVzXVxuXHQgKi9cbiAgc2V0KHNjb3BlLCB2YWx1ZXMpIHtcbiAgICByZXR1cm4gc2V0KHRoaXMsIHNjb3BlLCB2YWx1ZXMpO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBzY29wZVxuXHQgKi9cbiAgZ2V0KHNjb3BlKSB7XG4gICAgcmV0dXJuIGdldFNjb3BlKHRoaXMsIHNjb3BlKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcGFyYW0ge3N0cmluZ3xvYmplY3R9IHNjb3BlXG5cdCAqIEBwYXJhbSB7b2JqZWN0fSBbdmFsdWVzXVxuXHQgKi9cbiAgZGVzY3JpYmUoc2NvcGUsIHZhbHVlcykge1xuICAgIHJldHVybiBzZXQoZGVzY3JpcHRvcnMsIHNjb3BlLCB2YWx1ZXMpO1xuICB9XG5cbiAgb3ZlcnJpZGUoc2NvcGUsIHZhbHVlcykge1xuICAgIHJldHVybiBzZXQob3ZlcnJpZGVzLCBzY29wZSwgdmFsdWVzKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBSb3V0ZXMgdGhlIG5hbWVkIGRlZmF1bHRzIHRvIGZhbGxiYWNrIHRvIGFub3RoZXIgc2NvcGUvbmFtZS5cblx0ICogVGhpcyByb3V0aW5nIGlzIHVzZWZ1bCB3aGVuIHRob3NlIHRhcmdldCB2YWx1ZXMsIGxpa2UgZGVmYXVsdHMuY29sb3IsIGFyZSBjaGFuZ2VkIHJ1bnRpbWUuXG5cdCAqIElmIHRoZSB2YWx1ZXMgd291bGQgYmUgY29waWVkLCB0aGUgcnVudGltZSBjaGFuZ2Ugd291bGQgbm90IHRha2UgZWZmZWN0LiBCeSByb3V0aW5nLCB0aGVcblx0ICogZmFsbGJhY2sgaXMgZXZhbHVhdGVkIGF0IGVhY2ggYWNjZXNzLCBzbyBpdHMgYWx3YXlzIHVwIHRvIGRhdGUuXG5cdCAqXG5cdCAqIEV4YW1wbGU6XG5cdCAqXG5cdCAqIFx0ZGVmYXVsdHMucm91dGUoJ2VsZW1lbnRzLmFyYycsICdiYWNrZ3JvdW5kQ29sb3InLCAnJywgJ2NvbG9yJylcblx0ICogICAtIHJlYWRzIHRoZSBiYWNrZ3JvdW5kQ29sb3IgZnJvbSBkZWZhdWx0cy5jb2xvciB3aGVuIHVuZGVmaW5lZCBsb2NhbGx5XG5cdCAqXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBzY29wZSBTY29wZSB0aGlzIHJvdXRlIGFwcGxpZXMgdG8uXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIFByb3BlcnR5IG5hbWUgdGhhdCBzaG91bGQgYmUgcm91dGVkIHRvIGRpZmZlcmVudCBuYW1lc3BhY2Ugd2hlbiBub3QgZGVmaW5lZCBoZXJlLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gdGFyZ2V0U2NvcGUgVGhlIG5hbWVzcGFjZSB3aGVyZSB0aG9zZSBwcm9wZXJ0aWVzIHNob3VsZCBiZSByb3V0ZWQgdG8uXG5cdCAqIEVtcHR5IHN0cmluZyAoJycpIGlzIHRoZSByb290IG9mIGRlZmF1bHRzLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gdGFyZ2V0TmFtZSBUaGUgdGFyZ2V0IG5hbWUgaW4gdGhlIHRhcmdldCBzY29wZSB0aGUgcHJvcGVydHkgc2hvdWxkIGJlIHJvdXRlZCB0by5cblx0ICovXG4gIHJvdXRlKHNjb3BlLCBuYW1lLCB0YXJnZXRTY29wZSwgdGFyZ2V0TmFtZSkge1xuICAgIGNvbnN0IHNjb3BlT2JqZWN0ID0gZ2V0U2NvcGUodGhpcywgc2NvcGUpO1xuICAgIGNvbnN0IHRhcmdldFNjb3BlT2JqZWN0ID0gZ2V0U2NvcGUodGhpcywgdGFyZ2V0U2NvcGUpO1xuICAgIGNvbnN0IHByaXZhdGVOYW1lID0gJ18nICsgbmFtZTtcblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHNjb3BlT2JqZWN0LCB7XG4gICAgICAvLyBBIHByaXZhdGUgcHJvcGVydHkgaXMgZGVmaW5lZCB0byBob2xkIHRoZSBhY3R1YWwgdmFsdWUsIHdoZW4gdGhpcyBwcm9wZXJ0eSBpcyBzZXQgaW4gaXRzIHNjb3BlIChzZXQgaW4gdGhlIHNldHRlcilcbiAgICAgIFtwcml2YXRlTmFtZV06IHtcbiAgICAgICAgdmFsdWU6IHNjb3BlT2JqZWN0W25hbWVdLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgfSxcbiAgICAgIC8vIFRoZSBhY3R1YWwgcHJvcGVydHkgaXMgZGVmaW5lZCBhcyBnZXR0ZXIvc2V0dGVyIHNvIHdlIGNhbiBkbyB0aGUgcm91dGluZyB3aGVuIHZhbHVlIGlzIG5vdCBsb2NhbGx5IHNldC5cbiAgICAgIFtuYW1lXToge1xuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBnZXQoKSB7XG4gICAgICAgICAgY29uc3QgbG9jYWwgPSB0aGlzW3ByaXZhdGVOYW1lXTtcbiAgICAgICAgICBjb25zdCB0YXJnZXQgPSB0YXJnZXRTY29wZU9iamVjdFt0YXJnZXROYW1lXTtcbiAgICAgICAgICBpZiAoaXNPYmplY3QobG9jYWwpKSB7XG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgdGFyZ2V0LCBsb2NhbCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB2YWx1ZU9yRGVmYXVsdChsb2NhbCwgdGFyZ2V0KTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0KHZhbHVlKSB7XG4gICAgICAgICAgdGhpc1twcml2YXRlTmFtZV0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgYXBwbHkoYXBwbGllcnMpIHtcbiAgICBhcHBsaWVycy5mb3JFYWNoKChhcHBseSkgPT4gYXBwbHkodGhpcykpO1xuICB9XG59XG5cbi8vIHNpbmdsZXRvbiBpbnN0YW5jZVxuZXhwb3J0IGRlZmF1bHQgLyogI19fUFVSRV9fICovIG5ldyBEZWZhdWx0cyh7XG4gIF9zY3JpcHRhYmxlOiAobmFtZSkgPT4gIW5hbWUuc3RhcnRzV2l0aCgnb24nKSxcbiAgX2luZGV4YWJsZTogKG5hbWUpID0+IG5hbWUgIT09ICdldmVudHMnLFxuICBob3Zlcjoge1xuICAgIF9mYWxsYmFjazogJ2ludGVyYWN0aW9uJ1xuICB9LFxuICBpbnRlcmFjdGlvbjoge1xuICAgIF9zY3JpcHRhYmxlOiBmYWxzZSxcbiAgICBfaW5kZXhhYmxlOiBmYWxzZSxcbiAgfVxufSwgW2FwcGx5QW5pbWF0aW9uc0RlZmF1bHRzLCBhcHBseUxheW91dHNEZWZhdWx0cywgYXBwbHlTY2FsZURlZmF1bHRzXSk7XG4iLCAiaW1wb3J0IHR5cGUge1xuICBDaGFydCxcbiAgUG9pbnQsXG4gIEZvbnRTcGVjLFxuICBDYW52YXNGb250U3BlYyxcbiAgUG9pbnRTdHlsZSxcbiAgUmVuZGVyVGV4dE9wdHMsXG4gIEJhY2tkcm9wT3B0aW9uc1xufSBmcm9tICcuLi90eXBlcy9pbmRleC5qcyc7XG5pbXBvcnQgdHlwZSB7XG4gIFRSQkwsXG4gIFNwbGluZVBvaW50LFxuICBSb3VuZGVkUmVjdCxcbiAgVFJCTENvcm5lcnNcbn0gZnJvbSAnLi4vdHlwZXMvZ2VvbWV0cmljLmpzJztcbmltcG9ydCB7aXNBcnJheSwgaXNOdWxsT3JVbmRlZn0gZnJvbSAnLi9oZWxwZXJzLmNvcmUuanMnO1xuaW1wb3J0IHtQSSwgVEFVLCBIQUxGX1BJLCBRVUFSVEVSX1BJLCBUV09fVEhJUkRTX1BJLCBSQURfUEVSX0RFR30gZnJvbSAnLi9oZWxwZXJzLm1hdGguanMnO1xuXG4vKipcbiAqIENvbnZlcnRzIHRoZSBnaXZlbiBmb250IG9iamVjdCBpbnRvIGEgQ1NTIGZvbnQgc3RyaW5nLlxuICogQHBhcmFtIGZvbnQgLSBBIGZvbnQgb2JqZWN0LlxuICogQHJldHVybiBUaGUgQ1NTIGZvbnQgc3RyaW5nLiBTZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQ1NTL2ZvbnRcbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b0ZvbnRTdHJpbmcoZm9udDogRm9udFNwZWMpIHtcbiAgaWYgKCFmb250IHx8IGlzTnVsbE9yVW5kZWYoZm9udC5zaXplKSB8fCBpc051bGxPclVuZGVmKGZvbnQuZmFtaWx5KSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgcmV0dXJuIChmb250LnN0eWxlID8gZm9udC5zdHlsZSArICcgJyA6ICcnKVxuXHRcdCsgKGZvbnQud2VpZ2h0ID8gZm9udC53ZWlnaHQgKyAnICcgOiAnJylcblx0XHQrIGZvbnQuc2l6ZSArICdweCAnXG5cdFx0KyBmb250LmZhbWlseTtcbn1cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gX21lYXN1cmVUZXh0KFxuICBjdHg6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCxcbiAgZGF0YTogUmVjb3JkPHN0cmluZywgbnVtYmVyPixcbiAgZ2M6IHN0cmluZ1tdLFxuICBsb25nZXN0OiBudW1iZXIsXG4gIHN0cmluZzogc3RyaW5nXG4pIHtcbiAgbGV0IHRleHRXaWR0aCA9IGRhdGFbc3RyaW5nXTtcbiAgaWYgKCF0ZXh0V2lkdGgpIHtcbiAgICB0ZXh0V2lkdGggPSBkYXRhW3N0cmluZ10gPSBjdHgubWVhc3VyZVRleHQoc3RyaW5nKS53aWR0aDtcbiAgICBnYy5wdXNoKHN0cmluZyk7XG4gIH1cbiAgaWYgKHRleHRXaWR0aCA+IGxvbmdlc3QpIHtcbiAgICBsb25nZXN0ID0gdGV4dFdpZHRoO1xuICB9XG4gIHJldHVybiBsb25nZXN0O1xufVxuXG50eXBlIFRoaW5nID0gc3RyaW5nIHwgdW5kZWZpbmVkIHwgbnVsbFxudHlwZSBUaGluZ3MgPSAoVGhpbmcgfCBUaGluZ1tdKVtdXG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNvbXBsZXhpdHlcbmV4cG9ydCBmdW5jdGlvbiBfbG9uZ2VzdFRleHQoXG4gIGN0eDogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJELFxuICBmb250OiBzdHJpbmcsXG4gIGFycmF5T2ZUaGluZ3M6IFRoaW5ncyxcbiAgY2FjaGU/OiB7ZGF0YT86IFJlY29yZDxzdHJpbmcsIG51bWJlcj4sIGdhcmJhZ2VDb2xsZWN0Pzogc3RyaW5nW10sIGZvbnQ/OiBzdHJpbmd9XG4pIHtcbiAgY2FjaGUgPSBjYWNoZSB8fCB7fTtcbiAgbGV0IGRhdGEgPSBjYWNoZS5kYXRhID0gY2FjaGUuZGF0YSB8fCB7fTtcbiAgbGV0IGdjID0gY2FjaGUuZ2FyYmFnZUNvbGxlY3QgPSBjYWNoZS5nYXJiYWdlQ29sbGVjdCB8fCBbXTtcblxuICBpZiAoY2FjaGUuZm9udCAhPT0gZm9udCkge1xuICAgIGRhdGEgPSBjYWNoZS5kYXRhID0ge307XG4gICAgZ2MgPSBjYWNoZS5nYXJiYWdlQ29sbGVjdCA9IFtdO1xuICAgIGNhY2hlLmZvbnQgPSBmb250O1xuICB9XG5cbiAgY3R4LnNhdmUoKTtcblxuICBjdHguZm9udCA9IGZvbnQ7XG4gIGxldCBsb25nZXN0ID0gMDtcbiAgY29uc3QgaWxlbiA9IGFycmF5T2ZUaGluZ3MubGVuZ3RoO1xuICBsZXQgaTogbnVtYmVyLCBqOiBudW1iZXIsIGpsZW46IG51bWJlciwgdGhpbmc6IFRoaW5nIHwgVGhpbmdbXSwgbmVzdGVkVGhpbmc6IFRoaW5nIHwgVGhpbmdbXTtcbiAgZm9yIChpID0gMDsgaSA8IGlsZW47IGkrKykge1xuICAgIHRoaW5nID0gYXJyYXlPZlRoaW5nc1tpXTtcblxuICAgIC8vIFVuZGVmaW5lZCBzdHJpbmdzIGFuZCBhcnJheXMgc2hvdWxkIG5vdCBiZSBtZWFzdXJlZFxuICAgIGlmICh0aGluZyAhPT0gdW5kZWZpbmVkICYmIHRoaW5nICE9PSBudWxsICYmICFpc0FycmF5KHRoaW5nKSkge1xuICAgICAgbG9uZ2VzdCA9IF9tZWFzdXJlVGV4dChjdHgsIGRhdGEsIGdjLCBsb25nZXN0LCB0aGluZyk7XG4gICAgfSBlbHNlIGlmIChpc0FycmF5KHRoaW5nKSkge1xuICAgICAgLy8gaWYgaXQgaXMgYW4gYXJyYXkgbGV0cyBtZWFzdXJlIGVhY2ggZWxlbWVudFxuICAgICAgLy8gdG8gZG8gbWF5YmUgc2ltcGxpZnkgdGhpcyBmdW5jdGlvbiBhIGJpdCBzbyB3ZSBjYW4gZG8gdGhpcyBtb3JlIHJlY3Vyc2l2ZWx5P1xuICAgICAgZm9yIChqID0gMCwgamxlbiA9IHRoaW5nLmxlbmd0aDsgaiA8IGpsZW47IGorKykge1xuICAgICAgICBuZXN0ZWRUaGluZyA9IHRoaW5nW2pdO1xuICAgICAgICAvLyBVbmRlZmluZWQgc3RyaW5ncyBhbmQgYXJyYXlzIHNob3VsZCBub3QgYmUgbWVhc3VyZWRcbiAgICAgICAgaWYgKG5lc3RlZFRoaW5nICE9PSB1bmRlZmluZWQgJiYgbmVzdGVkVGhpbmcgIT09IG51bGwgJiYgIWlzQXJyYXkobmVzdGVkVGhpbmcpKSB7XG4gICAgICAgICAgbG9uZ2VzdCA9IF9tZWFzdXJlVGV4dChjdHgsIGRhdGEsIGdjLCBsb25nZXN0LCBuZXN0ZWRUaGluZyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBjdHgucmVzdG9yZSgpO1xuXG4gIGNvbnN0IGdjTGVuID0gZ2MubGVuZ3RoIC8gMjtcbiAgaWYgKGdjTGVuID4gYXJyYXlPZlRoaW5ncy5sZW5ndGgpIHtcbiAgICBmb3IgKGkgPSAwOyBpIDwgZ2NMZW47IGkrKykge1xuICAgICAgZGVsZXRlIGRhdGFbZ2NbaV1dO1xuICAgIH1cbiAgICBnYy5zcGxpY2UoMCwgZ2NMZW4pO1xuICB9XG4gIHJldHVybiBsb25nZXN0O1xufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIGFsaWduZWQgcGl4ZWwgdmFsdWUgdG8gYXZvaWQgYW50aS1hbGlhc2luZyBibHVyXG4gKiBAcGFyYW0gY2hhcnQgLSBUaGUgY2hhcnQgaW5zdGFuY2UuXG4gKiBAcGFyYW0gcGl4ZWwgLSBBIHBpeGVsIHZhbHVlLlxuICogQHBhcmFtIHdpZHRoIC0gVGhlIHdpZHRoIG9mIHRoZSBlbGVtZW50LlxuICogQHJldHVybnMgVGhlIGFsaWduZWQgcGl4ZWwgdmFsdWUuXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gX2FsaWduUGl4ZWwoY2hhcnQ6IENoYXJ0LCBwaXhlbDogbnVtYmVyLCB3aWR0aDogbnVtYmVyKSB7XG4gIGNvbnN0IGRldmljZVBpeGVsUmF0aW8gPSBjaGFydC5jdXJyZW50RGV2aWNlUGl4ZWxSYXRpbztcbiAgY29uc3QgaGFsZldpZHRoID0gd2lkdGggIT09IDAgPyBNYXRoLm1heCh3aWR0aCAvIDIsIDAuNSkgOiAwO1xuICByZXR1cm4gTWF0aC5yb3VuZCgocGl4ZWwgLSBoYWxmV2lkdGgpICogZGV2aWNlUGl4ZWxSYXRpbykgLyBkZXZpY2VQaXhlbFJhdGlvICsgaGFsZldpZHRoO1xufVxuXG4vKipcbiAqIENsZWFycyB0aGUgZW50aXJlIGNhbnZhcy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNsZWFyQ2FudmFzKGNhbnZhcz86IEhUTUxDYW52YXNFbGVtZW50LCBjdHg/OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQpIHtcbiAgaWYgKCFjdHggJiYgIWNhbnZhcykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGN0eCA9IGN0eCB8fCBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcblxuICBjdHguc2F2ZSgpO1xuICAvLyBjYW52YXMud2lkdGggYW5kIGNhbnZhcy5oZWlnaHQgZG8gbm90IGNvbnNpZGVyIHRoZSBjYW52YXMgdHJhbnNmb3JtLFxuICAvLyB3aGlsZSBjbGVhclJlY3QgZG9lc1xuICBjdHgucmVzZXRUcmFuc2Zvcm0oKTtcbiAgY3R4LmNsZWFyUmVjdCgwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xuICBjdHgucmVzdG9yZSgpO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIERyYXdQb2ludE9wdGlvbnMge1xuICBwb2ludFN0eWxlOiBQb2ludFN0eWxlO1xuICByb3RhdGlvbj86IG51bWJlcjtcbiAgcmFkaXVzOiBudW1iZXI7XG4gIGJvcmRlcldpZHRoOiBudW1iZXI7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBkcmF3UG9pbnQoXG4gIGN0eDogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJELFxuICBvcHRpb25zOiBEcmF3UG9pbnRPcHRpb25zLFxuICB4OiBudW1iZXIsXG4gIHk6IG51bWJlclxuKSB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdXNlLWJlZm9yZS1kZWZpbmVcbiAgZHJhd1BvaW50TGVnZW5kKGN0eCwgb3B0aW9ucywgeCwgeSwgbnVsbCk7XG59XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjb21wbGV4aXR5XG5leHBvcnQgZnVuY3Rpb24gZHJhd1BvaW50TGVnZW5kKFxuICBjdHg6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCxcbiAgb3B0aW9uczogRHJhd1BvaW50T3B0aW9ucyxcbiAgeDogbnVtYmVyLFxuICB5OiBudW1iZXIsXG4gIHc6IG51bWJlclxuKSB7XG4gIGxldCB0eXBlOiBzdHJpbmcsIHhPZmZzZXQ6IG51bWJlciwgeU9mZnNldDogbnVtYmVyLCBzaXplOiBudW1iZXIsIGNvcm5lclJhZGl1czogbnVtYmVyLCB3aWR0aDogbnVtYmVyLCB4T2Zmc2V0VzogbnVtYmVyLCB5T2Zmc2V0VzogbnVtYmVyO1xuICBjb25zdCBzdHlsZSA9IG9wdGlvbnMucG9pbnRTdHlsZTtcbiAgY29uc3Qgcm90YXRpb24gPSBvcHRpb25zLnJvdGF0aW9uO1xuICBjb25zdCByYWRpdXMgPSBvcHRpb25zLnJhZGl1cztcbiAgbGV0IHJhZCA9IChyb3RhdGlvbiB8fCAwKSAqIFJBRF9QRVJfREVHO1xuXG4gIGlmIChzdHlsZSAmJiB0eXBlb2Ygc3R5bGUgPT09ICdvYmplY3QnKSB7XG4gICAgdHlwZSA9IHN0eWxlLnRvU3RyaW5nKCk7XG4gICAgaWYgKHR5cGUgPT09ICdbb2JqZWN0IEhUTUxJbWFnZUVsZW1lbnRdJyB8fCB0eXBlID09PSAnW29iamVjdCBIVE1MQ2FudmFzRWxlbWVudF0nKSB7XG4gICAgICBjdHguc2F2ZSgpO1xuICAgICAgY3R4LnRyYW5zbGF0ZSh4LCB5KTtcbiAgICAgIGN0eC5yb3RhdGUocmFkKTtcbiAgICAgIGN0eC5kcmF3SW1hZ2Uoc3R5bGUsIC1zdHlsZS53aWR0aCAvIDIsIC1zdHlsZS5oZWlnaHQgLyAyLCBzdHlsZS53aWR0aCwgc3R5bGUuaGVpZ2h0KTtcbiAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9XG5cbiAgaWYgKGlzTmFOKHJhZGl1cykgfHwgcmFkaXVzIDw9IDApIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBjdHguYmVnaW5QYXRoKCk7XG5cbiAgc3dpdGNoIChzdHlsZSkge1xuICAvLyBEZWZhdWx0IGluY2x1ZGVzIGNpcmNsZVxuICAgIGRlZmF1bHQ6XG4gICAgICBpZiAodykge1xuICAgICAgICBjdHguZWxsaXBzZSh4LCB5LCB3IC8gMiwgcmFkaXVzLCAwLCAwLCBUQVUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY3R4LmFyYyh4LCB5LCByYWRpdXMsIDAsIFRBVSk7XG4gICAgICB9XG4gICAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICd0cmlhbmdsZSc6XG4gICAgICB3aWR0aCA9IHcgPyB3IC8gMiA6IHJhZGl1cztcbiAgICAgIGN0eC5tb3ZlVG8oeCArIE1hdGguc2luKHJhZCkgKiB3aWR0aCwgeSAtIE1hdGguY29zKHJhZCkgKiByYWRpdXMpO1xuICAgICAgcmFkICs9IFRXT19USElSRFNfUEk7XG4gICAgICBjdHgubGluZVRvKHggKyBNYXRoLnNpbihyYWQpICogd2lkdGgsIHkgLSBNYXRoLmNvcyhyYWQpICogcmFkaXVzKTtcbiAgICAgIHJhZCArPSBUV09fVEhJUkRTX1BJO1xuICAgICAgY3R4LmxpbmVUbyh4ICsgTWF0aC5zaW4ocmFkKSAqIHdpZHRoLCB5IC0gTWF0aC5jb3MocmFkKSAqIHJhZGl1cyk7XG4gICAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdyZWN0Um91bmRlZCc6XG4gICAgLy8gTk9URTogdGhlIHJvdW5kZWQgcmVjdCBpbXBsZW1lbnRhdGlvbiBjaGFuZ2VkIHRvIHVzZSBgYXJjYCBpbnN0ZWFkIG9mXG4gICAgLy8gYHF1YWRyYXRpY0N1cnZlVG9gIHNpbmNlIGl0IGdlbmVyYXRlcyBiZXR0ZXIgcmVzdWx0cyB3aGVuIHJlY3QgaXNcbiAgICAvLyBhbG1vc3QgYSBjaXJjbGUuIDAuNTE2IChpbnN0ZWFkIG9mIDAuNSkgcHJvZHVjZXMgcmVzdWx0cyB3aXRoIHZpc3VhbGx5XG4gICAgLy8gY2xvc2VyIHByb3BvcnRpb24gdG8gdGhlIHByZXZpb3VzIGltcGwgYW5kIGl0IGlzIGluc2NyaWJlZCBpbiB0aGVcbiAgICAvLyBjaXJjbGUgd2l0aCBgcmFkaXVzYC4gRm9yIG1vcmUgZGV0YWlscywgc2VlIHRoZSBmb2xsb3dpbmcgUFJzOlxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9jaGFydGpzL0NoYXJ0LmpzL2lzc3Vlcy81NTk3XG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2NoYXJ0anMvQ2hhcnQuanMvaXNzdWVzLzU4NThcbiAgICAgIGNvcm5lclJhZGl1cyA9IHJhZGl1cyAqIDAuNTE2O1xuICAgICAgc2l6ZSA9IHJhZGl1cyAtIGNvcm5lclJhZGl1cztcbiAgICAgIHhPZmZzZXQgPSBNYXRoLmNvcyhyYWQgKyBRVUFSVEVSX1BJKSAqIHNpemU7XG4gICAgICB4T2Zmc2V0VyA9IE1hdGguY29zKHJhZCArIFFVQVJURVJfUEkpICogKHcgPyB3IC8gMiAtIGNvcm5lclJhZGl1cyA6IHNpemUpO1xuICAgICAgeU9mZnNldCA9IE1hdGguc2luKHJhZCArIFFVQVJURVJfUEkpICogc2l6ZTtcbiAgICAgIHlPZmZzZXRXID0gTWF0aC5zaW4ocmFkICsgUVVBUlRFUl9QSSkgKiAodyA/IHcgLyAyIC0gY29ybmVyUmFkaXVzIDogc2l6ZSk7XG4gICAgICBjdHguYXJjKHggLSB4T2Zmc2V0VywgeSAtIHlPZmZzZXQsIGNvcm5lclJhZGl1cywgcmFkIC0gUEksIHJhZCAtIEhBTEZfUEkpO1xuICAgICAgY3R4LmFyYyh4ICsgeU9mZnNldFcsIHkgLSB4T2Zmc2V0LCBjb3JuZXJSYWRpdXMsIHJhZCAtIEhBTEZfUEksIHJhZCk7XG4gICAgICBjdHguYXJjKHggKyB4T2Zmc2V0VywgeSArIHlPZmZzZXQsIGNvcm5lclJhZGl1cywgcmFkLCByYWQgKyBIQUxGX1BJKTtcbiAgICAgIGN0eC5hcmMoeCAtIHlPZmZzZXRXLCB5ICsgeE9mZnNldCwgY29ybmVyUmFkaXVzLCByYWQgKyBIQUxGX1BJLCByYWQgKyBQSSk7XG4gICAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdyZWN0JzpcbiAgICAgIGlmICghcm90YXRpb24pIHtcbiAgICAgICAgc2l6ZSA9IE1hdGguU1FSVDFfMiAqIHJhZGl1cztcbiAgICAgICAgd2lkdGggPSB3ID8gdyAvIDIgOiBzaXplO1xuICAgICAgICBjdHgucmVjdCh4IC0gd2lkdGgsIHkgLSBzaXplLCAyICogd2lkdGgsIDIgKiBzaXplKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICByYWQgKz0gUVVBUlRFUl9QSTtcbiAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgY2FzZSAncmVjdFJvdCc6XG4gICAgICB4T2Zmc2V0VyA9IE1hdGguY29zKHJhZCkgKiAodyA/IHcgLyAyIDogcmFkaXVzKTtcbiAgICAgIHhPZmZzZXQgPSBNYXRoLmNvcyhyYWQpICogcmFkaXVzO1xuICAgICAgeU9mZnNldCA9IE1hdGguc2luKHJhZCkgKiByYWRpdXM7XG4gICAgICB5T2Zmc2V0VyA9IE1hdGguc2luKHJhZCkgKiAodyA/IHcgLyAyIDogcmFkaXVzKTtcbiAgICAgIGN0eC5tb3ZlVG8oeCAtIHhPZmZzZXRXLCB5IC0geU9mZnNldCk7XG4gICAgICBjdHgubGluZVRvKHggKyB5T2Zmc2V0VywgeSAtIHhPZmZzZXQpO1xuICAgICAgY3R4LmxpbmVUbyh4ICsgeE9mZnNldFcsIHkgKyB5T2Zmc2V0KTtcbiAgICAgIGN0eC5saW5lVG8oeCAtIHlPZmZzZXRXLCB5ICsgeE9mZnNldCk7XG4gICAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdjcm9zc1JvdCc6XG4gICAgICByYWQgKz0gUVVBUlRFUl9QSTtcbiAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgY2FzZSAnY3Jvc3MnOlxuICAgICAgeE9mZnNldFcgPSBNYXRoLmNvcyhyYWQpICogKHcgPyB3IC8gMiA6IHJhZGl1cyk7XG4gICAgICB4T2Zmc2V0ID0gTWF0aC5jb3MocmFkKSAqIHJhZGl1cztcbiAgICAgIHlPZmZzZXQgPSBNYXRoLnNpbihyYWQpICogcmFkaXVzO1xuICAgICAgeU9mZnNldFcgPSBNYXRoLnNpbihyYWQpICogKHcgPyB3IC8gMiA6IHJhZGl1cyk7XG4gICAgICBjdHgubW92ZVRvKHggLSB4T2Zmc2V0VywgeSAtIHlPZmZzZXQpO1xuICAgICAgY3R4LmxpbmVUbyh4ICsgeE9mZnNldFcsIHkgKyB5T2Zmc2V0KTtcbiAgICAgIGN0eC5tb3ZlVG8oeCArIHlPZmZzZXRXLCB5IC0geE9mZnNldCk7XG4gICAgICBjdHgubGluZVRvKHggLSB5T2Zmc2V0VywgeSArIHhPZmZzZXQpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnc3Rhcic6XG4gICAgICB4T2Zmc2V0VyA9IE1hdGguY29zKHJhZCkgKiAodyA/IHcgLyAyIDogcmFkaXVzKTtcbiAgICAgIHhPZmZzZXQgPSBNYXRoLmNvcyhyYWQpICogcmFkaXVzO1xuICAgICAgeU9mZnNldCA9IE1hdGguc2luKHJhZCkgKiByYWRpdXM7XG4gICAgICB5T2Zmc2V0VyA9IE1hdGguc2luKHJhZCkgKiAodyA/IHcgLyAyIDogcmFkaXVzKTtcbiAgICAgIGN0eC5tb3ZlVG8oeCAtIHhPZmZzZXRXLCB5IC0geU9mZnNldCk7XG4gICAgICBjdHgubGluZVRvKHggKyB4T2Zmc2V0VywgeSArIHlPZmZzZXQpO1xuICAgICAgY3R4Lm1vdmVUbyh4ICsgeU9mZnNldFcsIHkgLSB4T2Zmc2V0KTtcbiAgICAgIGN0eC5saW5lVG8oeCAtIHlPZmZzZXRXLCB5ICsgeE9mZnNldCk7XG4gICAgICByYWQgKz0gUVVBUlRFUl9QSTtcbiAgICAgIHhPZmZzZXRXID0gTWF0aC5jb3MocmFkKSAqICh3ID8gdyAvIDIgOiByYWRpdXMpO1xuICAgICAgeE9mZnNldCA9IE1hdGguY29zKHJhZCkgKiByYWRpdXM7XG4gICAgICB5T2Zmc2V0ID0gTWF0aC5zaW4ocmFkKSAqIHJhZGl1cztcbiAgICAgIHlPZmZzZXRXID0gTWF0aC5zaW4ocmFkKSAqICh3ID8gdyAvIDIgOiByYWRpdXMpO1xuICAgICAgY3R4Lm1vdmVUbyh4IC0geE9mZnNldFcsIHkgLSB5T2Zmc2V0KTtcbiAgICAgIGN0eC5saW5lVG8oeCArIHhPZmZzZXRXLCB5ICsgeU9mZnNldCk7XG4gICAgICBjdHgubW92ZVRvKHggKyB5T2Zmc2V0VywgeSAtIHhPZmZzZXQpO1xuICAgICAgY3R4LmxpbmVUbyh4IC0geU9mZnNldFcsIHkgKyB4T2Zmc2V0KTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2xpbmUnOlxuICAgICAgeE9mZnNldCA9IHcgPyB3IC8gMiA6IE1hdGguY29zKHJhZCkgKiByYWRpdXM7XG4gICAgICB5T2Zmc2V0ID0gTWF0aC5zaW4ocmFkKSAqIHJhZGl1cztcbiAgICAgIGN0eC5tb3ZlVG8oeCAtIHhPZmZzZXQsIHkgLSB5T2Zmc2V0KTtcbiAgICAgIGN0eC5saW5lVG8oeCArIHhPZmZzZXQsIHkgKyB5T2Zmc2V0KTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2Rhc2gnOlxuICAgICAgY3R4Lm1vdmVUbyh4LCB5KTtcbiAgICAgIGN0eC5saW5lVG8oeCArIE1hdGguY29zKHJhZCkgKiAodyA/IHcgLyAyIDogcmFkaXVzKSwgeSArIE1hdGguc2luKHJhZCkgKiByYWRpdXMpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBmYWxzZTpcbiAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICAgIGJyZWFrO1xuICB9XG5cbiAgY3R4LmZpbGwoKTtcbiAgaWYgKG9wdGlvbnMuYm9yZGVyV2lkdGggPiAwKSB7XG4gICAgY3R4LnN0cm9rZSgpO1xuICB9XG59XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBwb2ludCBpcyBpbnNpZGUgdGhlIHJlY3RhbmdsZVxuICogQHBhcmFtIHBvaW50IC0gVGhlIHBvaW50IHRvIHRlc3RcbiAqIEBwYXJhbSBhcmVhIC0gVGhlIHJlY3RhbmdsZVxuICogQHBhcmFtIG1hcmdpbiAtIGFsbG93ZWQgbWFyZ2luXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gX2lzUG9pbnRJbkFyZWEoXG4gIHBvaW50OiBQb2ludCxcbiAgYXJlYTogVFJCTCxcbiAgbWFyZ2luPzogbnVtYmVyXG4pIHtcbiAgbWFyZ2luID0gbWFyZ2luIHx8IDAuNTsgLy8gbWFyZ2luIC0gZGVmYXVsdCBpcyB0byBtYXRjaCByb3VuZGVkIGRlY2ltYWxzXG5cbiAgcmV0dXJuICFhcmVhIHx8IChwb2ludCAmJiBwb2ludC54ID4gYXJlYS5sZWZ0IC0gbWFyZ2luICYmIHBvaW50LnggPCBhcmVhLnJpZ2h0ICsgbWFyZ2luICYmXG5cdFx0cG9pbnQueSA+IGFyZWEudG9wIC0gbWFyZ2luICYmIHBvaW50LnkgPCBhcmVhLmJvdHRvbSArIG1hcmdpbik7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjbGlwQXJlYShjdHg6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCwgYXJlYTogVFJCTCkge1xuICBjdHguc2F2ZSgpO1xuICBjdHguYmVnaW5QYXRoKCk7XG4gIGN0eC5yZWN0KGFyZWEubGVmdCwgYXJlYS50b3AsIGFyZWEucmlnaHQgLSBhcmVhLmxlZnQsIGFyZWEuYm90dG9tIC0gYXJlYS50b3ApO1xuICBjdHguY2xpcCgpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdW5jbGlwQXJlYShjdHg6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCkge1xuICBjdHgucmVzdG9yZSgpO1xufVxuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBfc3RlcHBlZExpbmVUbyhcbiAgY3R4OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQsXG4gIHByZXZpb3VzOiBQb2ludCxcbiAgdGFyZ2V0OiBQb2ludCxcbiAgZmxpcD86IGJvb2xlYW4sXG4gIG1vZGU/OiBzdHJpbmdcbikge1xuICBpZiAoIXByZXZpb3VzKSB7XG4gICAgcmV0dXJuIGN0eC5saW5lVG8odGFyZ2V0LngsIHRhcmdldC55KTtcbiAgfVxuICBpZiAobW9kZSA9PT0gJ21pZGRsZScpIHtcbiAgICBjb25zdCBtaWRwb2ludCA9IChwcmV2aW91cy54ICsgdGFyZ2V0LngpIC8gMi4wO1xuICAgIGN0eC5saW5lVG8obWlkcG9pbnQsIHByZXZpb3VzLnkpO1xuICAgIGN0eC5saW5lVG8obWlkcG9pbnQsIHRhcmdldC55KTtcbiAgfSBlbHNlIGlmIChtb2RlID09PSAnYWZ0ZXInICE9PSAhIWZsaXApIHtcbiAgICBjdHgubGluZVRvKHByZXZpb3VzLngsIHRhcmdldC55KTtcbiAgfSBlbHNlIHtcbiAgICBjdHgubGluZVRvKHRhcmdldC54LCBwcmV2aW91cy55KTtcbiAgfVxuICBjdHgubGluZVRvKHRhcmdldC54LCB0YXJnZXQueSk7XG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIF9iZXppZXJDdXJ2ZVRvKFxuICBjdHg6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCxcbiAgcHJldmlvdXM6IFNwbGluZVBvaW50LFxuICB0YXJnZXQ6IFNwbGluZVBvaW50LFxuICBmbGlwPzogYm9vbGVhblxuKSB7XG4gIGlmICghcHJldmlvdXMpIHtcbiAgICByZXR1cm4gY3R4LmxpbmVUbyh0YXJnZXQueCwgdGFyZ2V0LnkpO1xuICB9XG4gIGN0eC5iZXppZXJDdXJ2ZVRvKFxuICAgIGZsaXAgPyBwcmV2aW91cy5jcDF4IDogcHJldmlvdXMuY3AyeCxcbiAgICBmbGlwID8gcHJldmlvdXMuY3AxeSA6IHByZXZpb3VzLmNwMnksXG4gICAgZmxpcCA/IHRhcmdldC5jcDJ4IDogdGFyZ2V0LmNwMXgsXG4gICAgZmxpcCA/IHRhcmdldC5jcDJ5IDogdGFyZ2V0LmNwMXksXG4gICAgdGFyZ2V0LngsXG4gICAgdGFyZ2V0LnkpO1xufVxuXG5mdW5jdGlvbiBzZXRSZW5kZXJPcHRzKGN0eDogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJELCBvcHRzOiBSZW5kZXJUZXh0T3B0cykge1xuICBpZiAob3B0cy50cmFuc2xhdGlvbikge1xuICAgIGN0eC50cmFuc2xhdGUob3B0cy50cmFuc2xhdGlvblswXSwgb3B0cy50cmFuc2xhdGlvblsxXSk7XG4gIH1cblxuICBpZiAoIWlzTnVsbE9yVW5kZWYob3B0cy5yb3RhdGlvbikpIHtcbiAgICBjdHgucm90YXRlKG9wdHMucm90YXRpb24pO1xuICB9XG5cbiAgaWYgKG9wdHMuY29sb3IpIHtcbiAgICBjdHguZmlsbFN0eWxlID0gb3B0cy5jb2xvcjtcbiAgfVxuXG4gIGlmIChvcHRzLnRleHRBbGlnbikge1xuICAgIGN0eC50ZXh0QWxpZ24gPSBvcHRzLnRleHRBbGlnbjtcbiAgfVxuXG4gIGlmIChvcHRzLnRleHRCYXNlbGluZSkge1xuICAgIGN0eC50ZXh0QmFzZWxpbmUgPSBvcHRzLnRleHRCYXNlbGluZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBkZWNvcmF0ZVRleHQoXG4gIGN0eDogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJELFxuICB4OiBudW1iZXIsXG4gIHk6IG51bWJlcixcbiAgbGluZTogc3RyaW5nLFxuICBvcHRzOiBSZW5kZXJUZXh0T3B0c1xuKSB7XG4gIGlmIChvcHRzLnN0cmlrZXRocm91Z2ggfHwgb3B0cy51bmRlcmxpbmUpIHtcbiAgICAvKipcbiAgICAgKiBOb3cgdGhhdCBJRTExIHN1cHBvcnQgaGFzIGJlZW4gZHJvcHBlZCwgd2UgY2FuIHVzZSBtb3JlXG4gICAgICogb2YgdGhlIFRleHRNZXRyaWNzIG9iamVjdC4gVGhlIGFjdHVhbCBib3VuZGluZyBib3hlc1xuICAgICAqIGFyZSB1bmZsYWdnZWQgaW4gQ2hyb21lLCBGaXJlZm94LCBFZGdlLCBhbmQgU2FmYXJpIHNvIHRoZXlcbiAgICAgKiBjYW4gYmUgc2FmZWx5IHVzZWQuXG4gICAgICogU2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9UZXh0TWV0cmljcyNCcm93c2VyX2NvbXBhdGliaWxpdHlcbiAgICAgKi9cbiAgICBjb25zdCBtZXRyaWNzID0gY3R4Lm1lYXN1cmVUZXh0KGxpbmUpO1xuICAgIGNvbnN0IGxlZnQgPSB4IC0gbWV0cmljcy5hY3R1YWxCb3VuZGluZ0JveExlZnQ7XG4gICAgY29uc3QgcmlnaHQgPSB4ICsgbWV0cmljcy5hY3R1YWxCb3VuZGluZ0JveFJpZ2h0O1xuICAgIGNvbnN0IHRvcCA9IHkgLSBtZXRyaWNzLmFjdHVhbEJvdW5kaW5nQm94QXNjZW50O1xuICAgIGNvbnN0IGJvdHRvbSA9IHkgKyBtZXRyaWNzLmFjdHVhbEJvdW5kaW5nQm94RGVzY2VudDtcbiAgICBjb25zdCB5RGVjb3JhdGlvbiA9IG9wdHMuc3RyaWtldGhyb3VnaCA/ICh0b3AgKyBib3R0b20pIC8gMiA6IGJvdHRvbTtcblxuICAgIGN0eC5zdHJva2VTdHlsZSA9IGN0eC5maWxsU3R5bGU7XG4gICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgIGN0eC5saW5lV2lkdGggPSBvcHRzLmRlY29yYXRpb25XaWR0aCB8fCAyO1xuICAgIGN0eC5tb3ZlVG8obGVmdCwgeURlY29yYXRpb24pO1xuICAgIGN0eC5saW5lVG8ocmlnaHQsIHlEZWNvcmF0aW9uKTtcbiAgICBjdHguc3Ryb2tlKCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZHJhd0JhY2tkcm9wKGN0eDogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJELCBvcHRzOiBCYWNrZHJvcE9wdGlvbnMpIHtcbiAgY29uc3Qgb2xkQ29sb3IgPSBjdHguZmlsbFN0eWxlO1xuXG4gIGN0eC5maWxsU3R5bGUgPSBvcHRzLmNvbG9yIGFzIHN0cmluZztcbiAgY3R4LmZpbGxSZWN0KG9wdHMubGVmdCwgb3B0cy50b3AsIG9wdHMud2lkdGgsIG9wdHMuaGVpZ2h0KTtcbiAgY3R4LmZpbGxTdHlsZSA9IG9sZENvbG9yO1xufVxuXG4vKipcbiAqIFJlbmRlciB0ZXh0IG9udG8gdGhlIGNhbnZhc1xuICovXG5leHBvcnQgZnVuY3Rpb24gcmVuZGVyVGV4dChcbiAgY3R4OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQsXG4gIHRleHQ6IHN0cmluZyB8IHN0cmluZ1tdLFxuICB4OiBudW1iZXIsXG4gIHk6IG51bWJlcixcbiAgZm9udDogQ2FudmFzRm9udFNwZWMsXG4gIG9wdHM6IFJlbmRlclRleHRPcHRzID0ge31cbikge1xuICBjb25zdCBsaW5lcyA9IGlzQXJyYXkodGV4dCkgPyB0ZXh0IDogW3RleHRdO1xuICBjb25zdCBzdHJva2UgPSBvcHRzLnN0cm9rZVdpZHRoID4gMCAmJiBvcHRzLnN0cm9rZUNvbG9yICE9PSAnJztcbiAgbGV0IGk6IG51bWJlciwgbGluZTogc3RyaW5nO1xuXG4gIGN0eC5zYXZlKCk7XG4gIGN0eC5mb250ID0gZm9udC5zdHJpbmc7XG4gIHNldFJlbmRlck9wdHMoY3R4LCBvcHRzKTtcblxuICBmb3IgKGkgPSAwOyBpIDwgbGluZXMubGVuZ3RoOyArK2kpIHtcbiAgICBsaW5lID0gbGluZXNbaV07XG5cbiAgICBpZiAob3B0cy5iYWNrZHJvcCkge1xuICAgICAgZHJhd0JhY2tkcm9wKGN0eCwgb3B0cy5iYWNrZHJvcCk7XG4gICAgfVxuXG4gICAgaWYgKHN0cm9rZSkge1xuICAgICAgaWYgKG9wdHMuc3Ryb2tlQ29sb3IpIHtcbiAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gb3B0cy5zdHJva2VDb2xvcjtcbiAgICAgIH1cblxuICAgICAgaWYgKCFpc051bGxPclVuZGVmKG9wdHMuc3Ryb2tlV2lkdGgpKSB7XG4gICAgICAgIGN0eC5saW5lV2lkdGggPSBvcHRzLnN0cm9rZVdpZHRoO1xuICAgICAgfVxuXG4gICAgICBjdHguc3Ryb2tlVGV4dChsaW5lLCB4LCB5LCBvcHRzLm1heFdpZHRoKTtcbiAgICB9XG5cbiAgICBjdHguZmlsbFRleHQobGluZSwgeCwgeSwgb3B0cy5tYXhXaWR0aCk7XG4gICAgZGVjb3JhdGVUZXh0KGN0eCwgeCwgeSwgbGluZSwgb3B0cyk7XG5cbiAgICB5ICs9IE51bWJlcihmb250LmxpbmVIZWlnaHQpO1xuICB9XG5cbiAgY3R4LnJlc3RvcmUoKTtcbn1cblxuLyoqXG4gKiBBZGQgYSBwYXRoIG9mIGEgcmVjdGFuZ2xlIHdpdGggcm91bmRlZCBjb3JuZXJzIHRvIHRoZSBjdXJyZW50IHN1Yi1wYXRoXG4gKiBAcGFyYW0gY3R4IC0gQ29udGV4dFxuICogQHBhcmFtIHJlY3QgLSBCb3VuZGluZyByZWN0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhZGRSb3VuZGVkUmVjdFBhdGgoXG4gIGN0eDogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJELFxuICByZWN0OiBSb3VuZGVkUmVjdCAmIHsgcmFkaXVzOiBUUkJMQ29ybmVycyB9XG4pIHtcbiAgY29uc3Qge3gsIHksIHcsIGgsIHJhZGl1c30gPSByZWN0O1xuXG4gIC8vIHRvcCBsZWZ0IGFyY1xuICBjdHguYXJjKHggKyByYWRpdXMudG9wTGVmdCwgeSArIHJhZGl1cy50b3BMZWZ0LCByYWRpdXMudG9wTGVmdCwgMS41ICogUEksIFBJLCB0cnVlKTtcblxuICAvLyBsaW5lIGZyb20gdG9wIGxlZnQgdG8gYm90dG9tIGxlZnRcbiAgY3R4LmxpbmVUbyh4LCB5ICsgaCAtIHJhZGl1cy5ib3R0b21MZWZ0KTtcblxuICAvLyBib3R0b20gbGVmdCBhcmNcbiAgY3R4LmFyYyh4ICsgcmFkaXVzLmJvdHRvbUxlZnQsIHkgKyBoIC0gcmFkaXVzLmJvdHRvbUxlZnQsIHJhZGl1cy5ib3R0b21MZWZ0LCBQSSwgSEFMRl9QSSwgdHJ1ZSk7XG5cbiAgLy8gbGluZSBmcm9tIGJvdHRvbSBsZWZ0IHRvIGJvdHRvbSByaWdodFxuICBjdHgubGluZVRvKHggKyB3IC0gcmFkaXVzLmJvdHRvbVJpZ2h0LCB5ICsgaCk7XG5cbiAgLy8gYm90dG9tIHJpZ2h0IGFyY1xuICBjdHguYXJjKHggKyB3IC0gcmFkaXVzLmJvdHRvbVJpZ2h0LCB5ICsgaCAtIHJhZGl1cy5ib3R0b21SaWdodCwgcmFkaXVzLmJvdHRvbVJpZ2h0LCBIQUxGX1BJLCAwLCB0cnVlKTtcblxuICAvLyBsaW5lIGZyb20gYm90dG9tIHJpZ2h0IHRvIHRvcCByaWdodFxuICBjdHgubGluZVRvKHggKyB3LCB5ICsgcmFkaXVzLnRvcFJpZ2h0KTtcblxuICAvLyB0b3AgcmlnaHQgYXJjXG4gIGN0eC5hcmMoeCArIHcgLSByYWRpdXMudG9wUmlnaHQsIHkgKyByYWRpdXMudG9wUmlnaHQsIHJhZGl1cy50b3BSaWdodCwgMCwgLUhBTEZfUEksIHRydWUpO1xuXG4gIC8vIGxpbmUgZnJvbSB0b3AgcmlnaHQgdG8gdG9wIGxlZnRcbiAgY3R4LmxpbmVUbyh4ICsgcmFkaXVzLnRvcExlZnQsIHkpO1xufVxuIiwgImltcG9ydCBkZWZhdWx0cyBmcm9tICcuLi9jb3JlL2NvcmUuZGVmYXVsdHMuanMnO1xuaW1wb3J0IHtpc0FycmF5LCBpc09iamVjdCwgdG9EaW1lbnNpb24sIHZhbHVlT3JEZWZhdWx0fSBmcm9tICcuL2hlbHBlcnMuY29yZS5qcyc7XG5pbXBvcnQge3RvRm9udFN0cmluZ30gZnJvbSAnLi9oZWxwZXJzLmNhbnZhcy5qcyc7XG5pbXBvcnQgdHlwZSB7Q2hhcnRBcmVhLCBGb250U3BlYywgUG9pbnR9IGZyb20gJy4uL3R5cGVzL2luZGV4LmpzJztcbmltcG9ydCB0eXBlIHtUUkJMLCBUUkJMQ29ybmVyc30gZnJvbSAnLi4vdHlwZXMvZ2VvbWV0cmljLmpzJztcblxuY29uc3QgTElORV9IRUlHSFQgPSAvXihub3JtYWx8KFxcZCsoPzpcXC5cXGQrKT8pKHB4fGVtfCUpPykkLztcbmNvbnN0IEZPTlRfU1RZTEUgPSAvXihub3JtYWx8aXRhbGljfGluaXRpYWx8aW5oZXJpdHx1bnNldHwob2JsaXF1ZSggLT9bMC05XT9bMC05XWRlZyk/KSkkLztcblxuLyoqXG4gKiBAYWxpYXMgQ2hhcnQuaGVscGVycy5vcHRpb25zXG4gKiBAbmFtZXNwYWNlXG4gKi9cbi8qKlxuICogQ29udmVydHMgdGhlIGdpdmVuIGxpbmUgaGVpZ2h0IGB2YWx1ZWAgaW4gcGl4ZWxzIGZvciBhIHNwZWNpZmljIGZvbnQgYHNpemVgLlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIGxpbmVIZWlnaHQgdG8gcGFyc2UgKGVnLiAxLjYsICcxNHB4JywgJzc1JScsICcxLjZlbScpLlxuICogQHBhcmFtIHNpemUgLSBUaGUgZm9udCBzaXplIChpbiBwaXhlbHMpIHVzZWQgdG8gcmVzb2x2ZSByZWxhdGl2ZSBgdmFsdWVgLlxuICogQHJldHVybnMgVGhlIGVmZmVjdGl2ZSBsaW5lIGhlaWdodCBpbiBwaXhlbHMgKHNpemUgKiAxLjIgaWYgdmFsdWUgaXMgaW52YWxpZCkuXG4gKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0NTUy9saW5lLWhlaWdodFxuICogQHNpbmNlIDIuNy4wXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b0xpbmVIZWlnaHQodmFsdWU6IG51bWJlciB8IHN0cmluZywgc2l6ZTogbnVtYmVyKTogbnVtYmVyIHtcbiAgY29uc3QgbWF0Y2hlcyA9ICgnJyArIHZhbHVlKS5tYXRjaChMSU5FX0hFSUdIVCk7XG4gIGlmICghbWF0Y2hlcyB8fCBtYXRjaGVzWzFdID09PSAnbm9ybWFsJykge1xuICAgIHJldHVybiBzaXplICogMS4yO1xuICB9XG5cbiAgdmFsdWUgPSArbWF0Y2hlc1syXTtcblxuICBzd2l0Y2ggKG1hdGNoZXNbM10pIHtcbiAgICBjYXNlICdweCc6XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgY2FzZSAnJSc6XG4gICAgICB2YWx1ZSAvPSAxMDA7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgYnJlYWs7XG4gIH1cblxuICByZXR1cm4gc2l6ZSAqIHZhbHVlO1xufVxuXG5jb25zdCBudW1iZXJPclplcm8gPSAodjogdW5rbm93bikgPT4gK3YgfHwgMDtcblxuLyoqXG4gKiBAcGFyYW0gdmFsdWVcbiAqIEBwYXJhbSBwcm9wc1xuICovXG5leHBvcnQgZnVuY3Rpb24gX3JlYWRWYWx1ZVRvUHJvcHM8SyBleHRlbmRzIHN0cmluZz4odmFsdWU6IG51bWJlciB8IFJlY29yZDxLLCBudW1iZXI+LCBwcm9wczogS1tdKTogUmVjb3JkPEssIG51bWJlcj47XG5leHBvcnQgZnVuY3Rpb24gX3JlYWRWYWx1ZVRvUHJvcHM8SyBleHRlbmRzIHN0cmluZywgVCBleHRlbmRzIHN0cmluZz4odmFsdWU6IG51bWJlciB8IFJlY29yZDxLICYgVCwgbnVtYmVyPiwgcHJvcHM6IFJlY29yZDxULCBLPik6IFJlY29yZDxULCBudW1iZXI+O1xuZXhwb3J0IGZ1bmN0aW9uIF9yZWFkVmFsdWVUb1Byb3BzKHZhbHVlOiBudW1iZXIgfCBSZWNvcmQ8c3RyaW5nLCBudW1iZXI+LCBwcm9wczogc3RyaW5nW10gfCBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+KSB7XG4gIGNvbnN0IHJldCA9IHt9O1xuICBjb25zdCBvYmpQcm9wcyA9IGlzT2JqZWN0KHByb3BzKTtcbiAgY29uc3Qga2V5cyA9IG9ialByb3BzID8gT2JqZWN0LmtleXMocHJvcHMpIDogcHJvcHM7XG4gIGNvbnN0IHJlYWQgPSBpc09iamVjdCh2YWx1ZSlcbiAgICA/IG9ialByb3BzXG4gICAgICA/IHByb3AgPT4gdmFsdWVPckRlZmF1bHQodmFsdWVbcHJvcF0sIHZhbHVlW3Byb3BzW3Byb3BdXSlcbiAgICAgIDogcHJvcCA9PiB2YWx1ZVtwcm9wXVxuICAgIDogKCkgPT4gdmFsdWU7XG5cbiAgZm9yIChjb25zdCBwcm9wIG9mIGtleXMpIHtcbiAgICByZXRbcHJvcF0gPSBudW1iZXJPclplcm8ocmVhZChwcm9wKSk7XG4gIH1cbiAgcmV0dXJuIHJldDtcbn1cblxuLyoqXG4gKiBDb252ZXJ0cyB0aGUgZ2l2ZW4gdmFsdWUgaW50byBhIFRSQkwgb2JqZWN0LlxuICogQHBhcmFtIHZhbHVlIC0gSWYgYSBudW1iZXIsIHNldCB0aGUgdmFsdWUgdG8gYWxsIFRSQkwgY29tcG9uZW50LFxuICogIGVsc2UsIGlmIGFuIG9iamVjdCwgdXNlIGRlZmluZWQgcHJvcGVydGllcyBhbmQgc2V0cyB1bmRlZmluZWQgb25lcyB0byAwLlxuICogIHggLyB5IGFyZSBzaG9ydGhhbmRzIGZvciBzYW1lIHZhbHVlIGZvciBsZWZ0L3JpZ2h0IGFuZCB0b3AvYm90dG9tLlxuICogQHJldHVybnMgVGhlIHBhZGRpbmcgdmFsdWVzICh0b3AsIHJpZ2h0LCBib3R0b20sIGxlZnQpXG4gKiBAc2luY2UgMy4wLjBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvVFJCTCh2YWx1ZTogbnVtYmVyIHwgVFJCTCB8IFBvaW50KSB7XG4gIHJldHVybiBfcmVhZFZhbHVlVG9Qcm9wcyh2YWx1ZSwge3RvcDogJ3knLCByaWdodDogJ3gnLCBib3R0b206ICd5JywgbGVmdDogJ3gnfSk7XG59XG5cbi8qKlxuICogQ29udmVydHMgdGhlIGdpdmVuIHZhbHVlIGludG8gYSBUUkJMIGNvcm5lcnMgb2JqZWN0IChzaW1pbGFyIHdpdGggY3NzIGJvcmRlci1yYWRpdXMpLlxuICogQHBhcmFtIHZhbHVlIC0gSWYgYSBudW1iZXIsIHNldCB0aGUgdmFsdWUgdG8gYWxsIFRSQkwgY29ybmVyIGNvbXBvbmVudHMsXG4gKiAgZWxzZSwgaWYgYW4gb2JqZWN0LCB1c2UgZGVmaW5lZCBwcm9wZXJ0aWVzIGFuZCBzZXRzIHVuZGVmaW5lZCBvbmVzIHRvIDAuXG4gKiBAcmV0dXJucyBUaGUgVFJCTCBjb3JuZXIgdmFsdWVzICh0b3BMZWZ0LCB0b3BSaWdodCwgYm90dG9tTGVmdCwgYm90dG9tUmlnaHQpXG4gKiBAc2luY2UgMy4wLjBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvVFJCTENvcm5lcnModmFsdWU6IG51bWJlciB8IFRSQkxDb3JuZXJzKSB7XG4gIHJldHVybiBfcmVhZFZhbHVlVG9Qcm9wcyh2YWx1ZSwgWyd0b3BMZWZ0JywgJ3RvcFJpZ2h0JywgJ2JvdHRvbUxlZnQnLCAnYm90dG9tUmlnaHQnXSk7XG59XG5cbi8qKlxuICogQ29udmVydHMgdGhlIGdpdmVuIHZhbHVlIGludG8gYSBwYWRkaW5nIG9iamVjdCB3aXRoIHByZS1jb21wdXRlZCB3aWR0aC9oZWlnaHQuXG4gKiBAcGFyYW0gdmFsdWUgLSBJZiBhIG51bWJlciwgc2V0IHRoZSB2YWx1ZSB0byBhbGwgVFJCTCBjb21wb25lbnQsXG4gKiAgZWxzZSwgaWYgYW4gb2JqZWN0LCB1c2UgZGVmaW5lZCBwcm9wZXJ0aWVzIGFuZCBzZXRzIHVuZGVmaW5lZCBvbmVzIHRvIDAuXG4gKiAgeCAvIHkgYXJlIHNob3J0aGFuZHMgZm9yIHNhbWUgdmFsdWUgZm9yIGxlZnQvcmlnaHQgYW5kIHRvcC9ib3R0b20uXG4gKiBAcmV0dXJucyBUaGUgcGFkZGluZyB2YWx1ZXMgKHRvcCwgcmlnaHQsIGJvdHRvbSwgbGVmdCwgd2lkdGgsIGhlaWdodClcbiAqIEBzaW5jZSAyLjcuMFxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9QYWRkaW5nKHZhbHVlPzogbnVtYmVyIHwgVFJCTCk6IENoYXJ0QXJlYSB7XG4gIGNvbnN0IG9iaiA9IHRvVFJCTCh2YWx1ZSkgYXMgQ2hhcnRBcmVhO1xuXG4gIG9iai53aWR0aCA9IG9iai5sZWZ0ICsgb2JqLnJpZ2h0O1xuICBvYmouaGVpZ2h0ID0gb2JqLnRvcCArIG9iai5ib3R0b207XG5cbiAgcmV0dXJuIG9iajtcbn1cblxuLyoqXG4gKiBQYXJzZXMgZm9udCBvcHRpb25zIGFuZCByZXR1cm5zIHRoZSBmb250IG9iamVjdC5cbiAqIEBwYXJhbSBvcHRpb25zIC0gQSBvYmplY3QgdGhhdCBjb250YWlucyBmb250IG9wdGlvbnMgdG8gYmUgcGFyc2VkLlxuICogQHBhcmFtIGZhbGxiYWNrIC0gQSBvYmplY3QgdGhhdCBjb250YWlucyBmYWxsYmFjayBmb250IG9wdGlvbnMuXG4gKiBAcmV0dXJuIFRoZSBmb250IG9iamVjdC5cbiAqIEBwcml2YXRlXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHRvRm9udChvcHRpb25zOiBQYXJ0aWFsPEZvbnRTcGVjPiwgZmFsbGJhY2s/OiBQYXJ0aWFsPEZvbnRTcGVjPikge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgZmFsbGJhY2sgPSBmYWxsYmFjayB8fCBkZWZhdWx0cy5mb250IGFzIEZvbnRTcGVjO1xuXG4gIGxldCBzaXplID0gdmFsdWVPckRlZmF1bHQob3B0aW9ucy5zaXplLCBmYWxsYmFjay5zaXplKTtcblxuICBpZiAodHlwZW9mIHNpemUgPT09ICdzdHJpbmcnKSB7XG4gICAgc2l6ZSA9IHBhcnNlSW50KHNpemUsIDEwKTtcbiAgfVxuICBsZXQgc3R5bGUgPSB2YWx1ZU9yRGVmYXVsdChvcHRpb25zLnN0eWxlLCBmYWxsYmFjay5zdHlsZSk7XG4gIGlmIChzdHlsZSAmJiAhKCcnICsgc3R5bGUpLm1hdGNoKEZPTlRfU1RZTEUpKSB7XG4gICAgY29uc29sZS53YXJuKCdJbnZhbGlkIGZvbnQgc3R5bGUgc3BlY2lmaWVkOiBcIicgKyBzdHlsZSArICdcIicpO1xuICAgIHN0eWxlID0gdW5kZWZpbmVkO1xuICB9XG5cbiAgY29uc3QgZm9udCA9IHtcbiAgICBmYW1pbHk6IHZhbHVlT3JEZWZhdWx0KG9wdGlvbnMuZmFtaWx5LCBmYWxsYmFjay5mYW1pbHkpLFxuICAgIGxpbmVIZWlnaHQ6IHRvTGluZUhlaWdodCh2YWx1ZU9yRGVmYXVsdChvcHRpb25zLmxpbmVIZWlnaHQsIGZhbGxiYWNrLmxpbmVIZWlnaHQpLCBzaXplKSxcbiAgICBzaXplLFxuICAgIHN0eWxlLFxuICAgIHdlaWdodDogdmFsdWVPckRlZmF1bHQob3B0aW9ucy53ZWlnaHQsIGZhbGxiYWNrLndlaWdodCksXG4gICAgc3RyaW5nOiAnJ1xuICB9O1xuXG4gIGZvbnQuc3RyaW5nID0gdG9Gb250U3RyaW5nKGZvbnQpO1xuICByZXR1cm4gZm9udDtcbn1cblxuLyoqXG4gKiBFdmFsdWF0ZXMgdGhlIGdpdmVuIGBpbnB1dHNgIHNlcXVlbnRpYWxseSBhbmQgcmV0dXJucyB0aGUgZmlyc3QgZGVmaW5lZCB2YWx1ZS5cbiAqIEBwYXJhbSBpbnB1dHMgLSBBbiBhcnJheSBvZiB2YWx1ZXMsIGZhbGxpbmcgYmFjayB0byB0aGUgbGFzdCB2YWx1ZS5cbiAqIEBwYXJhbSBjb250ZXh0IC0gSWYgZGVmaW5lZCBhbmQgdGhlIGN1cnJlbnQgdmFsdWUgaXMgYSBmdW5jdGlvbiwgdGhlIHZhbHVlXG4gKiBpcyBjYWxsZWQgd2l0aCBgY29udGV4dGAgYXMgZmlyc3QgYXJndW1lbnQgYW5kIHRoZSByZXN1bHQgYmVjb21lcyB0aGUgbmV3IGlucHV0LlxuICogQHBhcmFtIGluZGV4IC0gSWYgZGVmaW5lZCBhbmQgdGhlIGN1cnJlbnQgdmFsdWUgaXMgYW4gYXJyYXksIHRoZSB2YWx1ZVxuICogYXQgYGluZGV4YCBiZWNvbWUgdGhlIG5ldyBpbnB1dC5cbiAqIEBwYXJhbSBpbmZvIC0gb2JqZWN0IHRvIHJldHVybiBpbmZvcm1hdGlvbiBhYm91dCByZXNvbHV0aW9uIGluXG4gKiBAcGFyYW0gaW5mby5jYWNoZWFibGUgLSBXaWxsIGJlIHNldCB0byBgZmFsc2VgIGlmIG9wdGlvbiBpcyBub3QgY2FjaGVhYmxlLlxuICogQHNpbmNlIDIuNy4wXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZXNvbHZlKGlucHV0czogQXJyYXk8dW5rbm93bj4sIGNvbnRleHQ/OiBvYmplY3QsIGluZGV4PzogbnVtYmVyLCBpbmZvPzogeyBjYWNoZWFibGU6IGJvb2xlYW4gfSkge1xuICBsZXQgY2FjaGVhYmxlID0gdHJ1ZTtcbiAgbGV0IGk6IG51bWJlciwgaWxlbjogbnVtYmVyLCB2YWx1ZTogdW5rbm93bjtcblxuICBmb3IgKGkgPSAwLCBpbGVuID0gaW5wdXRzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgIHZhbHVlID0gaW5wdXRzW2ldO1xuICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKGNvbnRleHQgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHZhbHVlID0gdmFsdWUoY29udGV4dCk7XG4gICAgICBjYWNoZWFibGUgPSBmYWxzZTtcbiAgICB9XG4gICAgaWYgKGluZGV4ICE9PSB1bmRlZmluZWQgJiYgaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgIHZhbHVlID0gdmFsdWVbaW5kZXggJSB2YWx1ZS5sZW5ndGhdO1xuICAgICAgY2FjaGVhYmxlID0gZmFsc2U7XG4gICAgfVxuICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAoaW5mbyAmJiAhY2FjaGVhYmxlKSB7XG4gICAgICAgIGluZm8uY2FjaGVhYmxlID0gZmFsc2U7XG4gICAgICB9XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIG1pbm1heFxuICogQHBhcmFtIGdyYWNlXG4gKiBAcGFyYW0gYmVnaW5BdFplcm9cbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBfYWRkR3JhY2UobWlubWF4OiB7IG1pbjogbnVtYmVyOyBtYXg6IG51bWJlcjsgfSwgZ3JhY2U6IG51bWJlciB8IHN0cmluZywgYmVnaW5BdFplcm86IGJvb2xlYW4pIHtcbiAgY29uc3Qge21pbiwgbWF4fSA9IG1pbm1heDtcbiAgY29uc3QgY2hhbmdlID0gdG9EaW1lbnNpb24oZ3JhY2UsIChtYXggLSBtaW4pIC8gMik7XG4gIGNvbnN0IGtlZXBaZXJvID0gKHZhbHVlOiBudW1iZXIsIGFkZDogbnVtYmVyKSA9PiBiZWdpbkF0WmVybyAmJiB2YWx1ZSA9PT0gMCA/IDAgOiB2YWx1ZSArIGFkZDtcbiAgcmV0dXJuIHtcbiAgICBtaW46IGtlZXBaZXJvKG1pbiwgLU1hdGguYWJzKGNoYW5nZSkpLFxuICAgIG1heDoga2VlcFplcm8obWF4LCBjaGFuZ2UpXG4gIH07XG59XG5cbi8qKlxuICogQ3JlYXRlIGEgY29udGV4dCBpbmhlcml0aW5nIHBhcmVudENvbnRleHRcbiAqIEBwYXJhbSBwYXJlbnRDb250ZXh0XG4gKiBAcGFyYW0gY29udGV4dFxuICogQHJldHVybnNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUNvbnRleHQ8VCBleHRlbmRzIG9iamVjdD4ocGFyZW50Q29udGV4dDogbnVsbCwgY29udGV4dDogVCk6IFQ7XG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlQ29udGV4dDxUIGV4dGVuZHMgb2JqZWN0LCBQIGV4dGVuZHMgVD4ocGFyZW50Q29udGV4dDogUCwgY29udGV4dDogVCk6IFAgJiBUO1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUNvbnRleHQocGFyZW50Q29udGV4dDogb2JqZWN0LCBjb250ZXh0OiBvYmplY3QpIHtcbiAgcmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmNyZWF0ZShwYXJlbnRDb250ZXh0KSwgY29udGV4dCk7XG59XG4iLCAiLyogZXNsaW50LWRpc2FibGUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVzZS1iZWZvcmUtZGVmaW5lICovXG5pbXBvcnQgdHlwZSB7QW55T2JqZWN0fSBmcm9tICcuLi90eXBlcy9iYXNpYy5qcyc7XG5pbXBvcnQgdHlwZSB7Q2hhcnRNZXRhfSBmcm9tICcuLi90eXBlcy9pbmRleC5qcyc7XG5pbXBvcnQgdHlwZSB7XG4gIFJlc29sdmVyT2JqZWN0S2V5LFxuICBSZXNvbHZlckNhY2hlLFxuICBSZXNvbHZlclByb3h5LFxuICBEZXNjcmlwdG9yRGVmYXVsdHMsXG4gIERlc2NyaXB0b3IsXG4gIENvbnRleHRDYWNoZSxcbiAgQ29udGV4dFByb3h5XG59IGZyb20gJy4vaGVscGVycy5jb25maWcudHlwZXMuanMnO1xuaW1wb3J0IHtpc0FycmF5LCBpc0Z1bmN0aW9uLCBpc09iamVjdCwgcmVzb2x2ZU9iamVjdEtleSwgX2NhcGl0YWxpemV9IGZyb20gJy4vaGVscGVycy5jb3JlLmpzJztcblxuZXhwb3J0ICogZnJvbSAnLi9oZWxwZXJzLmNvbmZpZy50eXBlcy5qcyc7XG5cbi8qKlxuICogQ3JlYXRlcyBhIFByb3h5IGZvciByZXNvbHZpbmcgcmF3IHZhbHVlcyBmb3Igb3B0aW9ucy5cbiAqIEBwYXJhbSBzY29wZXMgLSBUaGUgb3B0aW9uIHNjb3BlcyB0byBsb29rIGZvciB2YWx1ZXMsIGluIHJlc29sdXRpb24gb3JkZXJcbiAqIEBwYXJhbSBwcmVmaXhlcyAtIFRoZSBwcmVmaXhlcyBmb3IgdmFsdWVzLCBpbiByZXNvbHV0aW9uIG9yZGVyLlxuICogQHBhcmFtIHJvb3RTY29wZXMgLSBUaGUgcm9vdCBvcHRpb24gc2NvcGVzXG4gKiBAcGFyYW0gZmFsbGJhY2sgLSBQYXJlbnQgc2NvcGVzIGZhbGxiYWNrXG4gKiBAcGFyYW0gZ2V0VGFyZ2V0IC0gY2FsbGJhY2sgZm9yIGdldHRpbmcgdGhlIHRhcmdldCBmb3IgY2hhbmdlZCB2YWx1ZXNcbiAqIEByZXR1cm5zIFByb3h5XG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gX2NyZWF0ZVJlc29sdmVyPFxuICBUIGV4dGVuZHMgQW55T2JqZWN0W10gPSBBbnlPYmplY3RbXSxcbiAgUiBleHRlbmRzIEFueU9iamVjdFtdID0gVFxuPihcbiAgc2NvcGVzOiBULFxuICBwcmVmaXhlcyA9IFsnJ10sXG4gIHJvb3RTY29wZXM/OiBSLFxuICBmYWxsYmFjaz86IFJlc29sdmVyT2JqZWN0S2V5LFxuICBnZXRUYXJnZXQgPSAoKSA9PiBzY29wZXNbMF1cbikge1xuICBjb25zdCBmaW5hbFJvb3RTY29wZXMgPSByb290U2NvcGVzIHx8IHNjb3BlcztcbiAgaWYgKHR5cGVvZiBmYWxsYmFjayA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBmYWxsYmFjayA9IF9yZXNvbHZlKCdfZmFsbGJhY2snLCBzY29wZXMpO1xuICB9XG4gIGNvbnN0IGNhY2hlOiBSZXNvbHZlckNhY2hlPFQsIFI+ID0ge1xuICAgIFtTeW1ib2wudG9TdHJpbmdUYWddOiAnT2JqZWN0JyxcbiAgICBfY2FjaGVhYmxlOiB0cnVlLFxuICAgIF9zY29wZXM6IHNjb3BlcyxcbiAgICBfcm9vdFNjb3BlczogZmluYWxSb290U2NvcGVzLFxuICAgIF9mYWxsYmFjazogZmFsbGJhY2ssXG4gICAgX2dldFRhcmdldDogZ2V0VGFyZ2V0LFxuICAgIG92ZXJyaWRlOiAoc2NvcGU6IEFueU9iamVjdCkgPT4gX2NyZWF0ZVJlc29sdmVyKFtzY29wZSwgLi4uc2NvcGVzXSwgcHJlZml4ZXMsIGZpbmFsUm9vdFNjb3BlcywgZmFsbGJhY2spLFxuICB9O1xuICByZXR1cm4gbmV3IFByb3h5KGNhY2hlLCB7XG4gICAgLyoqXG4gICAgICogQSB0cmFwIGZvciB0aGUgZGVsZXRlIG9wZXJhdG9yLlxuICAgICAqL1xuICAgIGRlbGV0ZVByb3BlcnR5KHRhcmdldCwgcHJvcDogc3RyaW5nKSB7XG4gICAgICBkZWxldGUgdGFyZ2V0W3Byb3BdOyAvLyByZW1vdmUgZnJvbSBjYWNoZVxuICAgICAgZGVsZXRlIHRhcmdldC5fa2V5czsgLy8gcmVtb3ZlIGNhY2hlZCBrZXlzXG4gICAgICBkZWxldGUgc2NvcGVzWzBdW3Byb3BdOyAvLyByZW1vdmUgZnJvbSB0b3AgbGV2ZWwgc2NvcGVcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBIHRyYXAgZm9yIGdldHRpbmcgcHJvcGVydHkgdmFsdWVzLlxuICAgICAqL1xuICAgIGdldCh0YXJnZXQsIHByb3A6IHN0cmluZykge1xuICAgICAgcmV0dXJuIF9jYWNoZWQodGFyZ2V0LCBwcm9wLFxuICAgICAgICAoKSA9PiBfcmVzb2x2ZVdpdGhQcmVmaXhlcyhwcm9wLCBwcmVmaXhlcywgc2NvcGVzLCB0YXJnZXQpKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQSB0cmFwIGZvciBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yLlxuICAgICAqIEFsc28gdXNlZCBieSBPYmplY3QuaGFzT3duUHJvcGVydHkuXG4gICAgICovXG4gICAgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwgcHJvcCkge1xuICAgICAgcmV0dXJuIFJlZmxlY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldC5fc2NvcGVzWzBdLCBwcm9wKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQSB0cmFwIGZvciBPYmplY3QuZ2V0UHJvdG90eXBlT2YuXG4gICAgICovXG4gICAgZ2V0UHJvdG90eXBlT2YoKSB7XG4gICAgICByZXR1cm4gUmVmbGVjdC5nZXRQcm90b3R5cGVPZihzY29wZXNbMF0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBIHRyYXAgZm9yIHRoZSBpbiBvcGVyYXRvci5cbiAgICAgKi9cbiAgICBoYXModGFyZ2V0LCBwcm9wOiBzdHJpbmcpIHtcbiAgICAgIHJldHVybiBnZXRLZXlzRnJvbUFsbFNjb3Blcyh0YXJnZXQpLmluY2x1ZGVzKHByb3ApO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBIHRyYXAgZm9yIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzIGFuZCBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzLlxuICAgICAqL1xuICAgIG93bktleXModGFyZ2V0KSB7XG4gICAgICByZXR1cm4gZ2V0S2V5c0Zyb21BbGxTY29wZXModGFyZ2V0KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQSB0cmFwIGZvciBzZXR0aW5nIHByb3BlcnR5IHZhbHVlcy5cbiAgICAgKi9cbiAgICBzZXQodGFyZ2V0LCBwcm9wOiBzdHJpbmcsIHZhbHVlKSB7XG4gICAgICBjb25zdCBzdG9yYWdlID0gdGFyZ2V0Ll9zdG9yYWdlIHx8ICh0YXJnZXQuX3N0b3JhZ2UgPSBnZXRUYXJnZXQoKSk7XG4gICAgICB0YXJnZXRbcHJvcF0gPSBzdG9yYWdlW3Byb3BdID0gdmFsdWU7IC8vIHNldCB0byB0b3AgbGV2ZWwgc2NvcGUgKyBjYWNoZVxuICAgICAgZGVsZXRlIHRhcmdldC5fa2V5czsgLy8gcmVtb3ZlIGNhY2hlZCBrZXlzXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH0pIGFzIFJlc29sdmVyUHJveHk8VCwgUj47XG59XG5cbi8qKlxuICogUmV0dXJucyBhbiBQcm94eSBmb3IgcmVzb2x2aW5nIG9wdGlvbiB2YWx1ZXMgd2l0aCBjb250ZXh0LlxuICogQHBhcmFtIHByb3h5IC0gVGhlIFByb3h5IHJldHVybmVkIGJ5IGBfY3JlYXRlUmVzb2x2ZXJgXG4gKiBAcGFyYW0gY29udGV4dCAtIENvbnRleHQgb2JqZWN0IGZvciBzY3JpcHRhYmxlL2luZGV4YWJsZSBvcHRpb25zXG4gKiBAcGFyYW0gc3ViUHJveHkgLSBUaGUgcHJveHkgcHJvdmlkZWQgZm9yIHNjcmlwdGFibGUgb3B0aW9uc1xuICogQHBhcmFtIGRlc2NyaXB0b3JEZWZhdWx0cyAtIERlZmF1bHRzIGZvciBkZXNjcmlwdG9yc1xuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIF9hdHRhY2hDb250ZXh0PFxuICBUIGV4dGVuZHMgQW55T2JqZWN0W10gPSBBbnlPYmplY3RbXSxcbiAgUiBleHRlbmRzIEFueU9iamVjdFtdID0gVFxuPihcbiAgcHJveHk6IFJlc29sdmVyUHJveHk8VCwgUj4sXG4gIGNvbnRleHQ6IEFueU9iamVjdCxcbiAgc3ViUHJveHk/OiBSZXNvbHZlclByb3h5PFQsIFI+LFxuICBkZXNjcmlwdG9yRGVmYXVsdHM/OiBEZXNjcmlwdG9yRGVmYXVsdHNcbikge1xuICBjb25zdCBjYWNoZTogQ29udGV4dENhY2hlPFQsIFI+ID0ge1xuICAgIF9jYWNoZWFibGU6IGZhbHNlLFxuICAgIF9wcm94eTogcHJveHksXG4gICAgX2NvbnRleHQ6IGNvbnRleHQsXG4gICAgX3N1YlByb3h5OiBzdWJQcm94eSxcbiAgICBfc3RhY2s6IG5ldyBTZXQoKSxcbiAgICBfZGVzY3JpcHRvcnM6IF9kZXNjcmlwdG9ycyhwcm94eSwgZGVzY3JpcHRvckRlZmF1bHRzKSxcbiAgICBzZXRDb250ZXh0OiAoY3R4OiBBbnlPYmplY3QpID0+IF9hdHRhY2hDb250ZXh0KHByb3h5LCBjdHgsIHN1YlByb3h5LCBkZXNjcmlwdG9yRGVmYXVsdHMpLFxuICAgIG92ZXJyaWRlOiAoc2NvcGU6IEFueU9iamVjdCkgPT4gX2F0dGFjaENvbnRleHQocHJveHkub3ZlcnJpZGUoc2NvcGUpLCBjb250ZXh0LCBzdWJQcm94eSwgZGVzY3JpcHRvckRlZmF1bHRzKVxuICB9O1xuICByZXR1cm4gbmV3IFByb3h5KGNhY2hlLCB7XG4gICAgLyoqXG4gICAgICogQSB0cmFwIGZvciB0aGUgZGVsZXRlIG9wZXJhdG9yLlxuICAgICAqL1xuICAgIGRlbGV0ZVByb3BlcnR5KHRhcmdldCwgcHJvcCkge1xuICAgICAgZGVsZXRlIHRhcmdldFtwcm9wXTsgLy8gcmVtb3ZlIGZyb20gY2FjaGVcbiAgICAgIGRlbGV0ZSBwcm94eVtwcm9wXTsgLy8gcmVtb3ZlIGZyb20gcHJveHlcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBIHRyYXAgZm9yIGdldHRpbmcgcHJvcGVydHkgdmFsdWVzLlxuICAgICAqL1xuICAgIGdldCh0YXJnZXQsIHByb3A6IHN0cmluZywgcmVjZWl2ZXIpIHtcbiAgICAgIHJldHVybiBfY2FjaGVkKHRhcmdldCwgcHJvcCxcbiAgICAgICAgKCkgPT4gX3Jlc29sdmVXaXRoQ29udGV4dCh0YXJnZXQsIHByb3AsIHJlY2VpdmVyKSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEEgdHJhcCBmb3IgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvci5cbiAgICAgKiBBbHNvIHVzZWQgYnkgT2JqZWN0Lmhhc093blByb3BlcnR5LlxuICAgICAqL1xuICAgIGdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIHByb3ApIHtcbiAgICAgIHJldHVybiB0YXJnZXQuX2Rlc2NyaXB0b3JzLmFsbEtleXNcbiAgICAgICAgPyBSZWZsZWN0Lmhhcyhwcm94eSwgcHJvcCkgPyB7ZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlfSA6IHVuZGVmaW5lZFxuICAgICAgICA6IFJlZmxlY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHByb3h5LCBwcm9wKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQSB0cmFwIGZvciBPYmplY3QuZ2V0UHJvdG90eXBlT2YuXG4gICAgICovXG4gICAgZ2V0UHJvdG90eXBlT2YoKSB7XG4gICAgICByZXR1cm4gUmVmbGVjdC5nZXRQcm90b3R5cGVPZihwcm94eSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEEgdHJhcCBmb3IgdGhlIGluIG9wZXJhdG9yLlxuICAgICAqL1xuICAgIGhhcyh0YXJnZXQsIHByb3ApIHtcbiAgICAgIHJldHVybiBSZWZsZWN0Lmhhcyhwcm94eSwgcHJvcCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEEgdHJhcCBmb3IgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMgYW5kIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMuXG4gICAgICovXG4gICAgb3duS2V5cygpIHtcbiAgICAgIHJldHVybiBSZWZsZWN0Lm93bktleXMocHJveHkpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBIHRyYXAgZm9yIHNldHRpbmcgcHJvcGVydHkgdmFsdWVzLlxuICAgICAqL1xuICAgIHNldCh0YXJnZXQsIHByb3AsIHZhbHVlKSB7XG4gICAgICBwcm94eVtwcm9wXSA9IHZhbHVlOyAvLyBzZXQgdG8gcHJveHlcbiAgICAgIGRlbGV0ZSB0YXJnZXRbcHJvcF07IC8vIHJlbW92ZSBmcm9tIGNhY2hlXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH0pIGFzIENvbnRleHRQcm94eTxULCBSPjtcbn1cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gX2Rlc2NyaXB0b3JzKFxuICBwcm94eTogUmVzb2x2ZXJDYWNoZSxcbiAgZGVmYXVsdHM6IERlc2NyaXB0b3JEZWZhdWx0cyA9IHtzY3JpcHRhYmxlOiB0cnVlLCBpbmRleGFibGU6IHRydWV9XG4pOiBEZXNjcmlwdG9yIHtcbiAgY29uc3Qge19zY3JpcHRhYmxlID0gZGVmYXVsdHMuc2NyaXB0YWJsZSwgX2luZGV4YWJsZSA9IGRlZmF1bHRzLmluZGV4YWJsZSwgX2FsbEtleXMgPSBkZWZhdWx0cy5hbGxLZXlzfSA9IHByb3h5O1xuICByZXR1cm4ge1xuICAgIGFsbEtleXM6IF9hbGxLZXlzLFxuICAgIHNjcmlwdGFibGU6IF9zY3JpcHRhYmxlLFxuICAgIGluZGV4YWJsZTogX2luZGV4YWJsZSxcbiAgICBpc1NjcmlwdGFibGU6IGlzRnVuY3Rpb24oX3NjcmlwdGFibGUpID8gX3NjcmlwdGFibGUgOiAoKSA9PiBfc2NyaXB0YWJsZSxcbiAgICBpc0luZGV4YWJsZTogaXNGdW5jdGlvbihfaW5kZXhhYmxlKSA/IF9pbmRleGFibGUgOiAoKSA9PiBfaW5kZXhhYmxlXG4gIH07XG59XG5cbmNvbnN0IHJlYWRLZXkgPSAocHJlZml4OiBzdHJpbmcsIG5hbWU6IHN0cmluZykgPT4gcHJlZml4ID8gcHJlZml4ICsgX2NhcGl0YWxpemUobmFtZSkgOiBuYW1lO1xuY29uc3QgbmVlZHNTdWJSZXNvbHZlciA9IChwcm9wOiBzdHJpbmcsIHZhbHVlOiB1bmtub3duKSA9PiBpc09iamVjdCh2YWx1ZSkgJiYgcHJvcCAhPT0gJ2FkYXB0ZXJzJyAmJlxuICAoT2JqZWN0LmdldFByb3RvdHlwZU9mKHZhbHVlKSA9PT0gbnVsbCB8fCB2YWx1ZS5jb25zdHJ1Y3RvciA9PT0gT2JqZWN0KTtcblxuZnVuY3Rpb24gX2NhY2hlZChcbiAgdGFyZ2V0OiBBbnlPYmplY3QsXG4gIHByb3A6IHN0cmluZyxcbiAgcmVzb2x2ZTogKCkgPT4gdW5rbm93blxuKSB7XG4gIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGFyZ2V0LCBwcm9wKSB8fCBwcm9wID09PSAnY29uc3RydWN0b3InKSB7XG4gICAgcmV0dXJuIHRhcmdldFtwcm9wXTtcbiAgfVxuXG4gIGNvbnN0IHZhbHVlID0gcmVzb2x2ZSgpO1xuICAvLyBjYWNoZSB0aGUgcmVzb2x2ZWQgdmFsdWVcbiAgdGFyZ2V0W3Byb3BdID0gdmFsdWU7XG4gIHJldHVybiB2YWx1ZTtcbn1cblxuZnVuY3Rpb24gX3Jlc29sdmVXaXRoQ29udGV4dChcbiAgdGFyZ2V0OiBDb250ZXh0Q2FjaGUsXG4gIHByb3A6IHN0cmluZyxcbiAgcmVjZWl2ZXI6IEFueU9iamVjdFxuKSB7XG4gIGNvbnN0IHtfcHJveHksIF9jb250ZXh0LCBfc3ViUHJveHksIF9kZXNjcmlwdG9yczogZGVzY3JpcHRvcnN9ID0gdGFyZ2V0O1xuICBsZXQgdmFsdWUgPSBfcHJveHlbcHJvcF07IC8vIHJlc29sdmUgZnJvbSBwcm94eVxuXG4gIC8vIHJlc29sdmUgd2l0aCBjb250ZXh0XG4gIGlmIChpc0Z1bmN0aW9uKHZhbHVlKSAmJiBkZXNjcmlwdG9ycy5pc1NjcmlwdGFibGUocHJvcCkpIHtcbiAgICB2YWx1ZSA9IF9yZXNvbHZlU2NyaXB0YWJsZShwcm9wLCB2YWx1ZSwgdGFyZ2V0LCByZWNlaXZlcik7XG4gIH1cbiAgaWYgKGlzQXJyYXkodmFsdWUpICYmIHZhbHVlLmxlbmd0aCkge1xuICAgIHZhbHVlID0gX3Jlc29sdmVBcnJheShwcm9wLCB2YWx1ZSwgdGFyZ2V0LCBkZXNjcmlwdG9ycy5pc0luZGV4YWJsZSk7XG4gIH1cbiAgaWYgKG5lZWRzU3ViUmVzb2x2ZXIocHJvcCwgdmFsdWUpKSB7XG4gICAgLy8gaWYgdGhlIHJlc29sdmVkIHZhbHVlIGlzIGFuIG9iamVjdCwgY3JlYXRlIGEgc3ViIHJlc29sdmVyIGZvciBpdFxuICAgIHZhbHVlID0gX2F0dGFjaENvbnRleHQodmFsdWUsIF9jb250ZXh0LCBfc3ViUHJveHkgJiYgX3N1YlByb3h5W3Byb3BdLCBkZXNjcmlwdG9ycyk7XG4gIH1cbiAgcmV0dXJuIHZhbHVlO1xufVxuXG5mdW5jdGlvbiBfcmVzb2x2ZVNjcmlwdGFibGUoXG4gIHByb3A6IHN0cmluZyxcbiAgZ2V0VmFsdWU6IChjdHg6IEFueU9iamVjdCwgc3ViOiBBbnlPYmplY3QpID0+IHVua25vd24sXG4gIHRhcmdldDogQ29udGV4dENhY2hlLFxuICByZWNlaXZlcjogQW55T2JqZWN0XG4pIHtcbiAgY29uc3Qge19wcm94eSwgX2NvbnRleHQsIF9zdWJQcm94eSwgX3N0YWNrfSA9IHRhcmdldDtcbiAgaWYgKF9zdGFjay5oYXMocHJvcCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1JlY3Vyc2lvbiBkZXRlY3RlZDogJyArIEFycmF5LmZyb20oX3N0YWNrKS5qb2luKCctPicpICsgJy0+JyArIHByb3ApO1xuICB9XG4gIF9zdGFjay5hZGQocHJvcCk7XG4gIGxldCB2YWx1ZSA9IGdldFZhbHVlKF9jb250ZXh0LCBfc3ViUHJveHkgfHwgcmVjZWl2ZXIpO1xuICBfc3RhY2suZGVsZXRlKHByb3ApO1xuICBpZiAobmVlZHNTdWJSZXNvbHZlcihwcm9wLCB2YWx1ZSkpIHtcbiAgICAvLyBXaGVuIHNjcmlwdGFibGUgb3B0aW9uIHJldHVybnMgYW4gb2JqZWN0LCBjcmVhdGUgYSByZXNvbHZlciBvbiB0aGF0LlxuICAgIHZhbHVlID0gY3JlYXRlU3ViUmVzb2x2ZXIoX3Byb3h5Ll9zY29wZXMsIF9wcm94eSwgcHJvcCwgdmFsdWUpO1xuICB9XG4gIHJldHVybiB2YWx1ZTtcbn1cblxuZnVuY3Rpb24gX3Jlc29sdmVBcnJheShcbiAgcHJvcDogc3RyaW5nLFxuICB2YWx1ZTogdW5rbm93bltdLFxuICB0YXJnZXQ6IENvbnRleHRDYWNoZSxcbiAgaXNJbmRleGFibGU6IChrZXk6IHN0cmluZykgPT4gYm9vbGVhblxuKSB7XG4gIGNvbnN0IHtfcHJveHksIF9jb250ZXh0LCBfc3ViUHJveHksIF9kZXNjcmlwdG9yczogZGVzY3JpcHRvcnN9ID0gdGFyZ2V0O1xuXG4gIGlmICh0eXBlb2YgX2NvbnRleHQuaW5kZXggIT09ICd1bmRlZmluZWQnICYmIGlzSW5kZXhhYmxlKHByb3ApKSB7XG4gICAgcmV0dXJuIHZhbHVlW19jb250ZXh0LmluZGV4ICUgdmFsdWUubGVuZ3RoXTtcbiAgfSBlbHNlIGlmIChpc09iamVjdCh2YWx1ZVswXSkpIHtcbiAgICAvLyBBcnJheSBvZiBvYmplY3RzLCByZXR1cm4gYXJyYXkgb3IgcmVzb2x2ZXJzXG4gICAgY29uc3QgYXJyID0gdmFsdWU7XG4gICAgY29uc3Qgc2NvcGVzID0gX3Byb3h5Ll9zY29wZXMuZmlsdGVyKHMgPT4gcyAhPT0gYXJyKTtcbiAgICB2YWx1ZSA9IFtdO1xuICAgIGZvciAoY29uc3QgaXRlbSBvZiBhcnIpIHtcbiAgICAgIGNvbnN0IHJlc29sdmVyID0gY3JlYXRlU3ViUmVzb2x2ZXIoc2NvcGVzLCBfcHJveHksIHByb3AsIGl0ZW0pO1xuICAgICAgdmFsdWUucHVzaChfYXR0YWNoQ29udGV4dChyZXNvbHZlciwgX2NvbnRleHQsIF9zdWJQcm94eSAmJiBfc3ViUHJveHlbcHJvcF0sIGRlc2NyaXB0b3JzKSk7XG4gICAgfVxuICB9XG4gIHJldHVybiB2YWx1ZTtcbn1cblxuZnVuY3Rpb24gcmVzb2x2ZUZhbGxiYWNrKFxuICBmYWxsYmFjazogUmVzb2x2ZXJPYmplY3RLZXkgfCAoKHByb3A6IFJlc29sdmVyT2JqZWN0S2V5LCB2YWx1ZTogdW5rbm93bikgPT4gUmVzb2x2ZXJPYmplY3RLZXkpLFxuICBwcm9wOiBSZXNvbHZlck9iamVjdEtleSxcbiAgdmFsdWU6IHVua25vd25cbikge1xuICByZXR1cm4gaXNGdW5jdGlvbihmYWxsYmFjaykgPyBmYWxsYmFjayhwcm9wLCB2YWx1ZSkgOiBmYWxsYmFjaztcbn1cblxuY29uc3QgZ2V0U2NvcGUgPSAoa2V5OiBSZXNvbHZlck9iamVjdEtleSwgcGFyZW50OiBBbnlPYmplY3QpID0+IGtleSA9PT0gdHJ1ZSA/IHBhcmVudFxuICA6IHR5cGVvZiBrZXkgPT09ICdzdHJpbmcnID8gcmVzb2x2ZU9iamVjdEtleShwYXJlbnQsIGtleSkgOiB1bmRlZmluZWQ7XG5cbmZ1bmN0aW9uIGFkZFNjb3BlcyhcbiAgc2V0OiBTZXQ8QW55T2JqZWN0PixcbiAgcGFyZW50U2NvcGVzOiBBbnlPYmplY3RbXSxcbiAga2V5OiBSZXNvbHZlck9iamVjdEtleSxcbiAgcGFyZW50RmFsbGJhY2s6IFJlc29sdmVyT2JqZWN0S2V5LFxuICB2YWx1ZTogdW5rbm93blxuKSB7XG4gIGZvciAoY29uc3QgcGFyZW50IG9mIHBhcmVudFNjb3Blcykge1xuICAgIGNvbnN0IHNjb3BlID0gZ2V0U2NvcGUoa2V5LCBwYXJlbnQpO1xuICAgIGlmIChzY29wZSkge1xuICAgICAgc2V0LmFkZChzY29wZSk7XG4gICAgICBjb25zdCBmYWxsYmFjayA9IHJlc29sdmVGYWxsYmFjayhzY29wZS5fZmFsbGJhY2ssIGtleSwgdmFsdWUpO1xuICAgICAgaWYgKHR5cGVvZiBmYWxsYmFjayAhPT0gJ3VuZGVmaW5lZCcgJiYgZmFsbGJhY2sgIT09IGtleSAmJiBmYWxsYmFjayAhPT0gcGFyZW50RmFsbGJhY2spIHtcbiAgICAgICAgLy8gV2hlbiB3ZSByZWFjaCB0aGUgZGVzY3JpcHRvciB0aGF0IGRlZmluZXMgYSBuZXcgX2ZhbGxiYWNrLCByZXR1cm4gdGhhdC5cbiAgICAgICAgLy8gVGhlIGZhbGxiYWNrIHdpbGwgcmVzdW1lIHRvIHRoYXQgbmV3IHNjb3BlLlxuICAgICAgICByZXR1cm4gZmFsbGJhY2s7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChzY29wZSA9PT0gZmFsc2UgJiYgdHlwZW9mIHBhcmVudEZhbGxiYWNrICE9PSAndW5kZWZpbmVkJyAmJiBrZXkgIT09IHBhcmVudEZhbGxiYWNrKSB7XG4gICAgICAvLyBGYWxsYmFjayB0byBgZmFsc2VgIHJlc3VsdHMgdG8gYGZhbHNlYCwgd2hlbiBmYWxsaW5nIGJhY2sgdG8gZGlmZmVyZW50IGtleS5cbiAgICAgIC8vIEZvciBleGFtcGxlIGBpbnRlcmFjdGlvbmAgZnJvbSBgaG92ZXJgIG9yIGBwbHVnaW5zLnRvb2x0aXBgIGFuZCBgYW5pbWF0aW9uYCBmcm9tIGBhbmltYXRpb25zYFxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlU3ViUmVzb2x2ZXIoXG4gIHBhcmVudFNjb3BlczogQW55T2JqZWN0W10sXG4gIHJlc29sdmVyOiBSZXNvbHZlckNhY2hlLFxuICBwcm9wOiBSZXNvbHZlck9iamVjdEtleSxcbiAgdmFsdWU6IHVua25vd25cbikge1xuICBjb25zdCByb290U2NvcGVzID0gcmVzb2x2ZXIuX3Jvb3RTY29wZXM7XG4gIGNvbnN0IGZhbGxiYWNrID0gcmVzb2x2ZUZhbGxiYWNrKHJlc29sdmVyLl9mYWxsYmFjaywgcHJvcCwgdmFsdWUpO1xuICBjb25zdCBhbGxTY29wZXMgPSBbLi4ucGFyZW50U2NvcGVzLCAuLi5yb290U2NvcGVzXTtcbiAgY29uc3Qgc2V0ID0gbmV3IFNldDxBbnlPYmplY3Q+KCk7XG4gIHNldC5hZGQodmFsdWUpO1xuICBsZXQga2V5ID0gYWRkU2NvcGVzRnJvbUtleShzZXQsIGFsbFNjb3BlcywgcHJvcCwgZmFsbGJhY2sgfHwgcHJvcCwgdmFsdWUpO1xuICBpZiAoa2V5ID09PSBudWxsKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmICh0eXBlb2YgZmFsbGJhY2sgIT09ICd1bmRlZmluZWQnICYmIGZhbGxiYWNrICE9PSBwcm9wKSB7XG4gICAga2V5ID0gYWRkU2NvcGVzRnJvbUtleShzZXQsIGFsbFNjb3BlcywgZmFsbGJhY2ssIGtleSwgdmFsdWUpO1xuICAgIGlmIChrZXkgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIF9jcmVhdGVSZXNvbHZlcihBcnJheS5mcm9tKHNldCksIFsnJ10sIHJvb3RTY29wZXMsIGZhbGxiYWNrLFxuICAgICgpID0+IHN1YkdldFRhcmdldChyZXNvbHZlciwgcHJvcCBhcyBzdHJpbmcsIHZhbHVlKSk7XG59XG5cbmZ1bmN0aW9uIGFkZFNjb3Blc0Zyb21LZXkoXG4gIHNldDogU2V0PEFueU9iamVjdD4sXG4gIGFsbFNjb3BlczogQW55T2JqZWN0W10sXG4gIGtleTogUmVzb2x2ZXJPYmplY3RLZXksXG4gIGZhbGxiYWNrOiBSZXNvbHZlck9iamVjdEtleSxcbiAgaXRlbTogdW5rbm93blxuKSB7XG4gIHdoaWxlIChrZXkpIHtcbiAgICBrZXkgPSBhZGRTY29wZXMoc2V0LCBhbGxTY29wZXMsIGtleSwgZmFsbGJhY2ssIGl0ZW0pO1xuICB9XG4gIHJldHVybiBrZXk7XG59XG5cbmZ1bmN0aW9uIHN1YkdldFRhcmdldChcbiAgcmVzb2x2ZXI6IFJlc29sdmVyQ2FjaGUsXG4gIHByb3A6IHN0cmluZyxcbiAgdmFsdWU6IHVua25vd25cbikge1xuICBjb25zdCBwYXJlbnQgPSByZXNvbHZlci5fZ2V0VGFyZ2V0KCk7XG4gIGlmICghKHByb3AgaW4gcGFyZW50KSkge1xuICAgIHBhcmVudFtwcm9wXSA9IHt9O1xuICB9XG4gIGNvbnN0IHRhcmdldCA9IHBhcmVudFtwcm9wXTtcbiAgaWYgKGlzQXJyYXkodGFyZ2V0KSAmJiBpc09iamVjdCh2YWx1ZSkpIHtcbiAgICAvLyBGb3IgYXJyYXkgb2Ygb2JqZWN0cywgdGhlIG9iamVjdCBpcyB1c2VkIHRvIHN0b3JlIHVwZGF0ZWQgdmFsdWVzXG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIHJldHVybiB0YXJnZXQgfHwge307XG59XG5cbmZ1bmN0aW9uIF9yZXNvbHZlV2l0aFByZWZpeGVzKFxuICBwcm9wOiBzdHJpbmcsXG4gIHByZWZpeGVzOiBzdHJpbmdbXSxcbiAgc2NvcGVzOiBBbnlPYmplY3RbXSxcbiAgcHJveHk6IFJlc29sdmVyUHJveHlcbikge1xuICBsZXQgdmFsdWU6IHVua25vd247XG4gIGZvciAoY29uc3QgcHJlZml4IG9mIHByZWZpeGVzKSB7XG4gICAgdmFsdWUgPSBfcmVzb2x2ZShyZWFkS2V5KHByZWZpeCwgcHJvcCksIHNjb3Blcyk7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHJldHVybiBuZWVkc1N1YlJlc29sdmVyKHByb3AsIHZhbHVlKVxuICAgICAgICA/IGNyZWF0ZVN1YlJlc29sdmVyKHNjb3BlcywgcHJveHksIHByb3AsIHZhbHVlKVxuICAgICAgICA6IHZhbHVlO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBfcmVzb2x2ZShrZXk6IHN0cmluZywgc2NvcGVzOiBBbnlPYmplY3RbXSkge1xuICBmb3IgKGNvbnN0IHNjb3BlIG9mIHNjb3Blcykge1xuICAgIGlmICghc2NvcGUpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBjb25zdCB2YWx1ZSA9IHNjb3BlW2tleV07XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0S2V5c0Zyb21BbGxTY29wZXModGFyZ2V0OiBSZXNvbHZlckNhY2hlKSB7XG4gIGxldCBrZXlzID0gdGFyZ2V0Ll9rZXlzO1xuICBpZiAoIWtleXMpIHtcbiAgICBrZXlzID0gdGFyZ2V0Ll9rZXlzID0gcmVzb2x2ZUtleXNGcm9tQWxsU2NvcGVzKHRhcmdldC5fc2NvcGVzKTtcbiAgfVxuICByZXR1cm4ga2V5cztcbn1cblxuZnVuY3Rpb24gcmVzb2x2ZUtleXNGcm9tQWxsU2NvcGVzKHNjb3BlczogQW55T2JqZWN0W10pIHtcbiAgY29uc3Qgc2V0ID0gbmV3IFNldDxzdHJpbmc+KCk7XG4gIGZvciAoY29uc3Qgc2NvcGUgb2Ygc2NvcGVzKSB7XG4gICAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXMoc2NvcGUpLmZpbHRlcihrID0+ICFrLnN0YXJ0c1dpdGgoJ18nKSkpIHtcbiAgICAgIHNldC5hZGQoa2V5KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIEFycmF5LmZyb20oc2V0KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIF9wYXJzZU9iamVjdERhdGFSYWRpYWxTY2FsZShcbiAgbWV0YTogQ2hhcnRNZXRhPCdsaW5lJyB8ICdzY2F0dGVyJz4sXG4gIGRhdGE6IEFueU9iamVjdFtdLFxuICBzdGFydDogbnVtYmVyLFxuICBjb3VudDogbnVtYmVyXG4pIHtcbiAgY29uc3Qge2lTY2FsZX0gPSBtZXRhO1xuICBjb25zdCB7a2V5ID0gJ3InfSA9IHRoaXMuX3BhcnNpbmc7XG4gIGNvbnN0IHBhcnNlZCA9IG5ldyBBcnJheTx7cjogdW5rbm93bn0+KGNvdW50KTtcbiAgbGV0IGk6IG51bWJlciwgaWxlbjogbnVtYmVyLCBpbmRleDogbnVtYmVyLCBpdGVtOiBBbnlPYmplY3Q7XG5cbiAgZm9yIChpID0gMCwgaWxlbiA9IGNvdW50OyBpIDwgaWxlbjsgKytpKSB7XG4gICAgaW5kZXggPSBpICsgc3RhcnQ7XG4gICAgaXRlbSA9IGRhdGFbaW5kZXhdO1xuICAgIHBhcnNlZFtpXSA9IHtcbiAgICAgIHI6IGlTY2FsZS5wYXJzZShyZXNvbHZlT2JqZWN0S2V5KGl0ZW0sIGtleSksIGluZGV4KVxuICAgIH07XG4gIH1cbiAgcmV0dXJuIHBhcnNlZDtcbn1cbiIsICJpbXBvcnQge2FsbW9zdEVxdWFscywgZGlzdGFuY2VCZXR3ZWVuUG9pbnRzLCBzaWdufSBmcm9tICcuL2hlbHBlcnMubWF0aC5qcyc7XG5pbXBvcnQge19pc1BvaW50SW5BcmVhfSBmcm9tICcuL2hlbHBlcnMuY2FudmFzLmpzJztcbmltcG9ydCB0eXBlIHtDaGFydEFyZWF9IGZyb20gJy4uL3R5cGVzL2luZGV4LmpzJztcbmltcG9ydCB0eXBlIHtTcGxpbmVQb2ludH0gZnJvbSAnLi4vdHlwZXMvZ2VvbWV0cmljLmpzJztcblxuY29uc3QgRVBTSUxPTiA9IE51bWJlci5FUFNJTE9OIHx8IDFlLTE0O1xuXG50eXBlIE9wdGlvbmFsU3BsaW5lUG9pbnQgPSBTcGxpbmVQb2ludCB8IGZhbHNlXG5jb25zdCBnZXRQb2ludCA9IChwb2ludHM6IFNwbGluZVBvaW50W10sIGk6IG51bWJlcik6IE9wdGlvbmFsU3BsaW5lUG9pbnQgPT4gaSA8IHBvaW50cy5sZW5ndGggJiYgIXBvaW50c1tpXS5za2lwICYmIHBvaW50c1tpXTtcbmNvbnN0IGdldFZhbHVlQXhpcyA9IChpbmRleEF4aXM6ICd4JyB8ICd5JykgPT4gaW5kZXhBeGlzID09PSAneCcgPyAneScgOiAneCc7XG5cbmV4cG9ydCBmdW5jdGlvbiBzcGxpbmVDdXJ2ZShcbiAgZmlyc3RQb2ludDogU3BsaW5lUG9pbnQsXG4gIG1pZGRsZVBvaW50OiBTcGxpbmVQb2ludCxcbiAgYWZ0ZXJQb2ludDogU3BsaW5lUG9pbnQsXG4gIHQ6IG51bWJlclxuKToge1xuICAgIHByZXZpb3VzOiBTcGxpbmVQb2ludFxuICAgIG5leHQ6IFNwbGluZVBvaW50XG4gIH0ge1xuICAvLyBQcm9wcyB0byBSb2IgU3BlbmNlciBhdCBzY2FsZWQgaW5ub3ZhdGlvbiBmb3IgaGlzIHBvc3Qgb24gc3BsaW5pbmcgYmV0d2VlbiBwb2ludHNcbiAgLy8gaHR0cDovL3NjYWxlZGlubm92YXRpb24uY29tL2FuYWx5dGljcy9zcGxpbmVzL2Fib3V0U3BsaW5lcy5odG1sXG5cbiAgLy8gVGhpcyBmdW5jdGlvbiBtdXN0IGFsc28gcmVzcGVjdCBcInNraXBwZWRcIiBwb2ludHNcblxuICBjb25zdCBwcmV2aW91cyA9IGZpcnN0UG9pbnQuc2tpcCA/IG1pZGRsZVBvaW50IDogZmlyc3RQb2ludDtcbiAgY29uc3QgY3VycmVudCA9IG1pZGRsZVBvaW50O1xuICBjb25zdCBuZXh0ID0gYWZ0ZXJQb2ludC5za2lwID8gbWlkZGxlUG9pbnQgOiBhZnRlclBvaW50O1xuICBjb25zdCBkMDEgPSBkaXN0YW5jZUJldHdlZW5Qb2ludHMoY3VycmVudCwgcHJldmlvdXMpO1xuICBjb25zdCBkMTIgPSBkaXN0YW5jZUJldHdlZW5Qb2ludHMobmV4dCwgY3VycmVudCk7XG5cbiAgbGV0IHMwMSA9IGQwMSAvIChkMDEgKyBkMTIpO1xuICBsZXQgczEyID0gZDEyIC8gKGQwMSArIGQxMik7XG5cbiAgLy8gSWYgYWxsIHBvaW50cyBhcmUgdGhlIHNhbWUsIHMwMSAmIHMwMiB3aWxsIGJlIGluZlxuICBzMDEgPSBpc05hTihzMDEpID8gMCA6IHMwMTtcbiAgczEyID0gaXNOYU4oczEyKSA/IDAgOiBzMTI7XG5cbiAgY29uc3QgZmEgPSB0ICogczAxOyAvLyBzY2FsaW5nIGZhY3RvciBmb3IgdHJpYW5nbGUgVGFcbiAgY29uc3QgZmIgPSB0ICogczEyO1xuXG4gIHJldHVybiB7XG4gICAgcHJldmlvdXM6IHtcbiAgICAgIHg6IGN1cnJlbnQueCAtIGZhICogKG5leHQueCAtIHByZXZpb3VzLngpLFxuICAgICAgeTogY3VycmVudC55IC0gZmEgKiAobmV4dC55IC0gcHJldmlvdXMueSlcbiAgICB9LFxuICAgIG5leHQ6IHtcbiAgICAgIHg6IGN1cnJlbnQueCArIGZiICogKG5leHQueCAtIHByZXZpb3VzLngpLFxuICAgICAgeTogY3VycmVudC55ICsgZmIgKiAobmV4dC55IC0gcHJldmlvdXMueSlcbiAgICB9XG4gIH07XG59XG5cbi8qKlxuICogQWRqdXN0IHRhbmdlbnRzIHRvIGVuc3VyZSBtb25vdG9uaWMgcHJvcGVydGllc1xuICovXG5mdW5jdGlvbiBtb25vdG9uZUFkanVzdChwb2ludHM6IFNwbGluZVBvaW50W10sIGRlbHRhSzogbnVtYmVyW10sIG1LOiBudW1iZXJbXSkge1xuICBjb25zdCBwb2ludHNMZW4gPSBwb2ludHMubGVuZ3RoO1xuXG4gIGxldCBhbHBoYUs6IG51bWJlciwgYmV0YUs6IG51bWJlciwgdGF1SzogbnVtYmVyLCBzcXVhcmVkTWFnbml0dWRlOiBudW1iZXIsIHBvaW50Q3VycmVudDogT3B0aW9uYWxTcGxpbmVQb2ludDtcbiAgbGV0IHBvaW50QWZ0ZXIgPSBnZXRQb2ludChwb2ludHMsIDApO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHBvaW50c0xlbiAtIDE7ICsraSkge1xuICAgIHBvaW50Q3VycmVudCA9IHBvaW50QWZ0ZXI7XG4gICAgcG9pbnRBZnRlciA9IGdldFBvaW50KHBvaW50cywgaSArIDEpO1xuICAgIGlmICghcG9pbnRDdXJyZW50IHx8ICFwb2ludEFmdGVyKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBpZiAoYWxtb3N0RXF1YWxzKGRlbHRhS1tpXSwgMCwgRVBTSUxPTikpIHtcbiAgICAgIG1LW2ldID0gbUtbaSArIDFdID0gMDtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGFscGhhSyA9IG1LW2ldIC8gZGVsdGFLW2ldO1xuICAgIGJldGFLID0gbUtbaSArIDFdIC8gZGVsdGFLW2ldO1xuICAgIHNxdWFyZWRNYWduaXR1ZGUgPSBNYXRoLnBvdyhhbHBoYUssIDIpICsgTWF0aC5wb3coYmV0YUssIDIpO1xuICAgIGlmIChzcXVhcmVkTWFnbml0dWRlIDw9IDkpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIHRhdUsgPSAzIC8gTWF0aC5zcXJ0KHNxdWFyZWRNYWduaXR1ZGUpO1xuICAgIG1LW2ldID0gYWxwaGFLICogdGF1SyAqIGRlbHRhS1tpXTtcbiAgICBtS1tpICsgMV0gPSBiZXRhSyAqIHRhdUsgKiBkZWx0YUtbaV07XG4gIH1cbn1cblxuZnVuY3Rpb24gbW9ub3RvbmVDb21wdXRlKHBvaW50czogU3BsaW5lUG9pbnRbXSwgbUs6IG51bWJlcltdLCBpbmRleEF4aXM6ICd4JyB8ICd5JyA9ICd4Jykge1xuICBjb25zdCB2YWx1ZUF4aXMgPSBnZXRWYWx1ZUF4aXMoaW5kZXhBeGlzKTtcbiAgY29uc3QgcG9pbnRzTGVuID0gcG9pbnRzLmxlbmd0aDtcbiAgbGV0IGRlbHRhOiBudW1iZXIsIHBvaW50QmVmb3JlOiBPcHRpb25hbFNwbGluZVBvaW50LCBwb2ludEN1cnJlbnQ6IE9wdGlvbmFsU3BsaW5lUG9pbnQ7XG4gIGxldCBwb2ludEFmdGVyID0gZ2V0UG9pbnQocG9pbnRzLCAwKTtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IHBvaW50c0xlbjsgKytpKSB7XG4gICAgcG9pbnRCZWZvcmUgPSBwb2ludEN1cnJlbnQ7XG4gICAgcG9pbnRDdXJyZW50ID0gcG9pbnRBZnRlcjtcbiAgICBwb2ludEFmdGVyID0gZ2V0UG9pbnQocG9pbnRzLCBpICsgMSk7XG4gICAgaWYgKCFwb2ludEN1cnJlbnQpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGNvbnN0IGlQaXhlbCA9IHBvaW50Q3VycmVudFtpbmRleEF4aXNdO1xuICAgIGNvbnN0IHZQaXhlbCA9IHBvaW50Q3VycmVudFt2YWx1ZUF4aXNdO1xuICAgIGlmIChwb2ludEJlZm9yZSkge1xuICAgICAgZGVsdGEgPSAoaVBpeGVsIC0gcG9pbnRCZWZvcmVbaW5kZXhBeGlzXSkgLyAzO1xuICAgICAgcG9pbnRDdXJyZW50W2BjcDEke2luZGV4QXhpc31gXSA9IGlQaXhlbCAtIGRlbHRhO1xuICAgICAgcG9pbnRDdXJyZW50W2BjcDEke3ZhbHVlQXhpc31gXSA9IHZQaXhlbCAtIGRlbHRhICogbUtbaV07XG4gICAgfVxuICAgIGlmIChwb2ludEFmdGVyKSB7XG4gICAgICBkZWx0YSA9IChwb2ludEFmdGVyW2luZGV4QXhpc10gLSBpUGl4ZWwpIC8gMztcbiAgICAgIHBvaW50Q3VycmVudFtgY3AyJHtpbmRleEF4aXN9YF0gPSBpUGl4ZWwgKyBkZWx0YTtcbiAgICAgIHBvaW50Q3VycmVudFtgY3AyJHt2YWx1ZUF4aXN9YF0gPSB2UGl4ZWwgKyBkZWx0YSAqIG1LW2ldO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIFRoaXMgZnVuY3Rpb24gY2FsY3VsYXRlcyBCw6l6aWVyIGNvbnRyb2wgcG9pbnRzIGluIGEgc2ltaWxhciB3YXkgdGhhbiB8c3BsaW5lQ3VydmV8LFxuICogYnV0IHByZXNlcnZlcyBtb25vdG9uaWNpdHkgb2YgdGhlIHByb3ZpZGVkIGRhdGEgYW5kIGVuc3VyZXMgbm8gbG9jYWwgZXh0cmVtdW1zIGFyZSBhZGRlZFxuICogYmV0d2VlbiB0aGUgZGF0YXNldCBkaXNjcmV0ZSBwb2ludHMgZHVlIHRvIHRoZSBpbnRlcnBvbGF0aW9uLlxuICogU2VlIDogaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTW9ub3RvbmVfY3ViaWNfaW50ZXJwb2xhdGlvblxuICovXG5leHBvcnQgZnVuY3Rpb24gc3BsaW5lQ3VydmVNb25vdG9uZShwb2ludHM6IFNwbGluZVBvaW50W10sIGluZGV4QXhpczogJ3gnIHwgJ3knID0gJ3gnKSB7XG4gIGNvbnN0IHZhbHVlQXhpcyA9IGdldFZhbHVlQXhpcyhpbmRleEF4aXMpO1xuICBjb25zdCBwb2ludHNMZW4gPSBwb2ludHMubGVuZ3RoO1xuICBjb25zdCBkZWx0YUs6IG51bWJlcltdID0gQXJyYXkocG9pbnRzTGVuKS5maWxsKDApO1xuICBjb25zdCBtSzogbnVtYmVyW10gPSBBcnJheShwb2ludHNMZW4pO1xuXG4gIC8vIENhbGN1bGF0ZSBzbG9wZXMgKGRlbHRhSykgYW5kIGluaXRpYWxpemUgdGFuZ2VudHMgKG1LKVxuICBsZXQgaSwgcG9pbnRCZWZvcmU6IE9wdGlvbmFsU3BsaW5lUG9pbnQsIHBvaW50Q3VycmVudDogT3B0aW9uYWxTcGxpbmVQb2ludDtcbiAgbGV0IHBvaW50QWZ0ZXIgPSBnZXRQb2ludChwb2ludHMsIDApO1xuXG4gIGZvciAoaSA9IDA7IGkgPCBwb2ludHNMZW47ICsraSkge1xuICAgIHBvaW50QmVmb3JlID0gcG9pbnRDdXJyZW50O1xuICAgIHBvaW50Q3VycmVudCA9IHBvaW50QWZ0ZXI7XG4gICAgcG9pbnRBZnRlciA9IGdldFBvaW50KHBvaW50cywgaSArIDEpO1xuICAgIGlmICghcG9pbnRDdXJyZW50KSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBpZiAocG9pbnRBZnRlcikge1xuICAgICAgY29uc3Qgc2xvcGVEZWx0YSA9IHBvaW50QWZ0ZXJbaW5kZXhBeGlzXSAtIHBvaW50Q3VycmVudFtpbmRleEF4aXNdO1xuXG4gICAgICAvLyBJbiB0aGUgY2FzZSBvZiB0d28gcG9pbnRzIHRoYXQgYXBwZWFyIGF0IHRoZSBzYW1lIHggcGl4ZWwsIHNsb3BlRGVsdGFYIGlzIDBcbiAgICAgIGRlbHRhS1tpXSA9IHNsb3BlRGVsdGEgIT09IDAgPyAocG9pbnRBZnRlclt2YWx1ZUF4aXNdIC0gcG9pbnRDdXJyZW50W3ZhbHVlQXhpc10pIC8gc2xvcGVEZWx0YSA6IDA7XG4gICAgfVxuICAgIG1LW2ldID0gIXBvaW50QmVmb3JlID8gZGVsdGFLW2ldXG4gICAgICA6ICFwb2ludEFmdGVyID8gZGVsdGFLW2kgLSAxXVxuICAgICAgICA6IChzaWduKGRlbHRhS1tpIC0gMV0pICE9PSBzaWduKGRlbHRhS1tpXSkpID8gMFxuICAgICAgICAgIDogKGRlbHRhS1tpIC0gMV0gKyBkZWx0YUtbaV0pIC8gMjtcbiAgfVxuXG4gIG1vbm90b25lQWRqdXN0KHBvaW50cywgZGVsdGFLLCBtSyk7XG5cbiAgbW9ub3RvbmVDb21wdXRlKHBvaW50cywgbUssIGluZGV4QXhpcyk7XG59XG5cbmZ1bmN0aW9uIGNhcENvbnRyb2xQb2ludChwdDogbnVtYmVyLCBtaW46IG51bWJlciwgbWF4OiBudW1iZXIpIHtcbiAgcmV0dXJuIE1hdGgubWF4KE1hdGgubWluKHB0LCBtYXgpLCBtaW4pO1xufVxuXG5mdW5jdGlvbiBjYXBCZXppZXJQb2ludHMocG9pbnRzOiBTcGxpbmVQb2ludFtdLCBhcmVhOiBDaGFydEFyZWEpIHtcbiAgbGV0IGksIGlsZW4sIHBvaW50LCBpbkFyZWEsIGluQXJlYVByZXY7XG4gIGxldCBpbkFyZWFOZXh0ID0gX2lzUG9pbnRJbkFyZWEocG9pbnRzWzBdLCBhcmVhKTtcbiAgZm9yIChpID0gMCwgaWxlbiA9IHBvaW50cy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICBpbkFyZWFQcmV2ID0gaW5BcmVhO1xuICAgIGluQXJlYSA9IGluQXJlYU5leHQ7XG4gICAgaW5BcmVhTmV4dCA9IGkgPCBpbGVuIC0gMSAmJiBfaXNQb2ludEluQXJlYShwb2ludHNbaSArIDFdLCBhcmVhKTtcbiAgICBpZiAoIWluQXJlYSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIHBvaW50ID0gcG9pbnRzW2ldO1xuICAgIGlmIChpbkFyZWFQcmV2KSB7XG4gICAgICBwb2ludC5jcDF4ID0gY2FwQ29udHJvbFBvaW50KHBvaW50LmNwMXgsIGFyZWEubGVmdCwgYXJlYS5yaWdodCk7XG4gICAgICBwb2ludC5jcDF5ID0gY2FwQ29udHJvbFBvaW50KHBvaW50LmNwMXksIGFyZWEudG9wLCBhcmVhLmJvdHRvbSk7XG4gICAgfVxuICAgIGlmIChpbkFyZWFOZXh0KSB7XG4gICAgICBwb2ludC5jcDJ4ID0gY2FwQ29udHJvbFBvaW50KHBvaW50LmNwMngsIGFyZWEubGVmdCwgYXJlYS5yaWdodCk7XG4gICAgICBwb2ludC5jcDJ5ID0gY2FwQ29udHJvbFBvaW50KHBvaW50LmNwMnksIGFyZWEudG9wLCBhcmVhLmJvdHRvbSk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIF91cGRhdGVCZXppZXJDb250cm9sUG9pbnRzKFxuICBwb2ludHM6IFNwbGluZVBvaW50W10sXG4gIG9wdGlvbnMsXG4gIGFyZWE6IENoYXJ0QXJlYSxcbiAgbG9vcDogYm9vbGVhbixcbiAgaW5kZXhBeGlzOiAneCcgfCAneSdcbikge1xuICBsZXQgaTogbnVtYmVyLCBpbGVuOiBudW1iZXIsIHBvaW50OiBTcGxpbmVQb2ludCwgY29udHJvbFBvaW50czogUmV0dXJuVHlwZTx0eXBlb2Ygc3BsaW5lQ3VydmU+O1xuXG4gIC8vIE9ubHkgY29uc2lkZXIgcG9pbnRzIHRoYXQgYXJlIGRyYXduIGluIGNhc2UgdGhlIHNwYW5HYXBzIG9wdGlvbiBpcyB1c2VkXG4gIGlmIChvcHRpb25zLnNwYW5HYXBzKSB7XG4gICAgcG9pbnRzID0gcG9pbnRzLmZpbHRlcigocHQpID0+ICFwdC5za2lwKTtcbiAgfVxuXG4gIGlmIChvcHRpb25zLmN1YmljSW50ZXJwb2xhdGlvbk1vZGUgPT09ICdtb25vdG9uZScpIHtcbiAgICBzcGxpbmVDdXJ2ZU1vbm90b25lKHBvaW50cywgaW5kZXhBeGlzKTtcbiAgfSBlbHNlIHtcbiAgICBsZXQgcHJldiA9IGxvb3AgPyBwb2ludHNbcG9pbnRzLmxlbmd0aCAtIDFdIDogcG9pbnRzWzBdO1xuICAgIGZvciAoaSA9IDAsIGlsZW4gPSBwb2ludHMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgICBwb2ludCA9IHBvaW50c1tpXTtcbiAgICAgIGNvbnRyb2xQb2ludHMgPSBzcGxpbmVDdXJ2ZShcbiAgICAgICAgcHJldixcbiAgICAgICAgcG9pbnQsXG4gICAgICAgIHBvaW50c1tNYXRoLm1pbihpICsgMSwgaWxlbiAtIChsb29wID8gMCA6IDEpKSAlIGlsZW5dLFxuICAgICAgICBvcHRpb25zLnRlbnNpb25cbiAgICAgICk7XG4gICAgICBwb2ludC5jcDF4ID0gY29udHJvbFBvaW50cy5wcmV2aW91cy54O1xuICAgICAgcG9pbnQuY3AxeSA9IGNvbnRyb2xQb2ludHMucHJldmlvdXMueTtcbiAgICAgIHBvaW50LmNwMnggPSBjb250cm9sUG9pbnRzLm5leHQueDtcbiAgICAgIHBvaW50LmNwMnkgPSBjb250cm9sUG9pbnRzLm5leHQueTtcbiAgICAgIHByZXYgPSBwb2ludDtcbiAgICB9XG4gIH1cblxuICBpZiAob3B0aW9ucy5jYXBCZXppZXJQb2ludHMpIHtcbiAgICBjYXBCZXppZXJQb2ludHMocG9pbnRzLCBhcmVhKTtcbiAgfVxufVxuIiwgImltcG9ydCB0eXBlIHtDaGFydEFyZWEsIFNjYWxlfSBmcm9tICcuLi90eXBlcy9pbmRleC5qcyc7XG5pbXBvcnQgdHlwZSBDaGFydCBmcm9tICcuLi9jb3JlL2NvcmUuY29udHJvbGxlci5qcyc7XG5pbXBvcnQgdHlwZSB7Q2hhcnRFdmVudH0gZnJvbSAnLi4vdHlwZXMuanMnO1xuaW1wb3J0IHtJTkZJTklUWX0gZnJvbSAnLi9oZWxwZXJzLm1hdGguanMnO1xuXG4vKipcbiAqIE5vdGU6IHR5cGVkZWZzIGFyZSBhdXRvLWV4cG9ydGVkLCBzbyB1c2UgYSBtYWRlLXVwIGBkb21gIG5hbWVzcGFjZSB3aGVyZVxuICogbmVjZXNzYXJ5IHRvIGF2b2lkIGR1cGxpY2F0ZXMgd2l0aCBgZXhwb3J0ICogZnJvbSAnLi9oZWxwZXJzYDsgc2VlXG4gKiBodHRwczovL2dpdGh1Yi5jb20vbWljcm9zb2Z0L1R5cGVTY3JpcHQvaXNzdWVzLzQ2MDExXG4gKiBAdHlwZWRlZiB7IGltcG9ydCgnLi4vY29yZS9jb3JlLmNvbnRyb2xsZXIuanMnKS5kZWZhdWx0IH0gZG9tLkNoYXJ0XG4gKiBAdHlwZWRlZiB7IGltcG9ydCgnLi4vLi4vdHlwZXMnKS5DaGFydEV2ZW50IH0gQ2hhcnRFdmVudFxuICovXG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIF9pc0RvbVN1cHBvcnRlZCgpOiBib29sZWFuIHtcbiAgcmV0dXJuIHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCc7XG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIF9nZXRQYXJlbnROb2RlKGRvbU5vZGU6IEhUTUxDYW52YXNFbGVtZW50KTogSFRNTENhbnZhc0VsZW1lbnQge1xuICBsZXQgcGFyZW50ID0gZG9tTm9kZS5wYXJlbnROb2RlO1xuICBpZiAocGFyZW50ICYmIHBhcmVudC50b1N0cmluZygpID09PSAnW29iamVjdCBTaGFkb3dSb290XScpIHtcbiAgICBwYXJlbnQgPSAocGFyZW50IGFzIFNoYWRvd1Jvb3QpLmhvc3Q7XG4gIH1cbiAgcmV0dXJuIHBhcmVudCBhcyBIVE1MQ2FudmFzRWxlbWVudDtcbn1cblxuLyoqXG4gKiBjb252ZXJ0IG1heC13aWR0aC9tYXgtaGVpZ2h0IHZhbHVlcyB0aGF0IG1heSBiZSBwZXJjZW50YWdlcyBpbnRvIGEgbnVtYmVyXG4gKiBAcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIHBhcnNlTWF4U3R5bGUoc3R5bGVWYWx1ZTogc3RyaW5nIHwgbnVtYmVyLCBub2RlOiBIVE1MRWxlbWVudCwgcGFyZW50UHJvcGVydHk6IHN0cmluZykge1xuICBsZXQgdmFsdWVJblBpeGVsczogbnVtYmVyO1xuICBpZiAodHlwZW9mIHN0eWxlVmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgdmFsdWVJblBpeGVscyA9IHBhcnNlSW50KHN0eWxlVmFsdWUsIDEwKTtcblxuICAgIGlmIChzdHlsZVZhbHVlLmluZGV4T2YoJyUnKSAhPT0gLTEpIHtcbiAgICAgIC8vIHBlcmNlbnRhZ2UgKiBzaXplIGluIGRpbWVuc2lvblxuICAgICAgdmFsdWVJblBpeGVscyA9ICh2YWx1ZUluUGl4ZWxzIC8gMTAwKSAqIG5vZGUucGFyZW50Tm9kZVtwYXJlbnRQcm9wZXJ0eV07XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhbHVlSW5QaXhlbHMgPSBzdHlsZVZhbHVlO1xuICB9XG5cbiAgcmV0dXJuIHZhbHVlSW5QaXhlbHM7XG59XG5cbmNvbnN0IGdldENvbXB1dGVkU3R5bGUgPSAoZWxlbWVudDogSFRNTEVsZW1lbnQpOiBDU1NTdHlsZURlY2xhcmF0aW9uID0+XG4gIGVsZW1lbnQub3duZXJEb2N1bWVudC5kZWZhdWx0Vmlldy5nZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQsIG51bGwpO1xuXG5leHBvcnQgZnVuY3Rpb24gZ2V0U3R5bGUoZWw6IEhUTUxFbGVtZW50LCBwcm9wZXJ0eTogc3RyaW5nKTogc3RyaW5nIHtcbiAgcmV0dXJuIGdldENvbXB1dGVkU3R5bGUoZWwpLmdldFByb3BlcnR5VmFsdWUocHJvcGVydHkpO1xufVxuXG5jb25zdCBwb3NpdGlvbnMgPSBbJ3RvcCcsICdyaWdodCcsICdib3R0b20nLCAnbGVmdCddO1xuZnVuY3Rpb24gZ2V0UG9zaXRpb25lZFN0eWxlKHN0eWxlczogQ1NTU3R5bGVEZWNsYXJhdGlvbiwgc3R5bGU6IHN0cmluZywgc3VmZml4Pzogc3RyaW5nKTogQ2hhcnRBcmVhIHtcbiAgY29uc3QgcmVzdWx0ID0ge30gYXMgQ2hhcnRBcmVhO1xuICBzdWZmaXggPSBzdWZmaXggPyAnLScgKyBzdWZmaXggOiAnJztcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCA0OyBpKyspIHtcbiAgICBjb25zdCBwb3MgPSBwb3NpdGlvbnNbaV07XG4gICAgcmVzdWx0W3Bvc10gPSBwYXJzZUZsb2F0KHN0eWxlc1tzdHlsZSArICctJyArIHBvcyArIHN1ZmZpeF0pIHx8IDA7XG4gIH1cbiAgcmVzdWx0LndpZHRoID0gcmVzdWx0LmxlZnQgKyByZXN1bHQucmlnaHQ7XG4gIHJlc3VsdC5oZWlnaHQgPSByZXN1bHQudG9wICsgcmVzdWx0LmJvdHRvbTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuY29uc3QgdXNlT2Zmc2V0UG9zID0gKHg6IG51bWJlciwgeTogbnVtYmVyLCB0YXJnZXQ6IEhUTUxFbGVtZW50IHwgRXZlbnRUYXJnZXQpID0+XG4gICh4ID4gMCB8fCB5ID4gMCkgJiYgKCF0YXJnZXQgfHwgISh0YXJnZXQgYXMgSFRNTEVsZW1lbnQpLnNoYWRvd1Jvb3QpO1xuXG4vKipcbiAqIEBwYXJhbSBlXG4gKiBAcGFyYW0gY2FudmFzXG4gKiBAcmV0dXJucyBDYW52YXMgcG9zaXRpb25cbiAqL1xuZnVuY3Rpb24gZ2V0Q2FudmFzUG9zaXRpb24oXG4gIGU6IEV2ZW50IHwgVG91Y2hFdmVudCB8IE1vdXNlRXZlbnQsXG4gIGNhbnZhczogSFRNTENhbnZhc0VsZW1lbnRcbik6IHtcbiAgICB4OiBudW1iZXI7XG4gICAgeTogbnVtYmVyO1xuICAgIGJveDogYm9vbGVhbjtcbiAgfSB7XG4gIGNvbnN0IHRvdWNoZXMgPSAoZSBhcyBUb3VjaEV2ZW50KS50b3VjaGVzO1xuICBjb25zdCBzb3VyY2UgPSAodG91Y2hlcyAmJiB0b3VjaGVzLmxlbmd0aCA/IHRvdWNoZXNbMF0gOiBlKSBhcyBNb3VzZUV2ZW50O1xuICBjb25zdCB7b2Zmc2V0WCwgb2Zmc2V0WX0gPSBzb3VyY2UgYXMgTW91c2VFdmVudDtcbiAgbGV0IGJveCA9IGZhbHNlO1xuICBsZXQgeCwgeTtcbiAgaWYgKHVzZU9mZnNldFBvcyhvZmZzZXRYLCBvZmZzZXRZLCBlLnRhcmdldCkpIHtcbiAgICB4ID0gb2Zmc2V0WDtcbiAgICB5ID0gb2Zmc2V0WTtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCByZWN0ID0gY2FudmFzLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIHggPSBzb3VyY2UuY2xpZW50WCAtIHJlY3QubGVmdDtcbiAgICB5ID0gc291cmNlLmNsaWVudFkgLSByZWN0LnRvcDtcbiAgICBib3ggPSB0cnVlO1xuICB9XG4gIHJldHVybiB7eCwgeSwgYm94fTtcbn1cblxuLyoqXG4gKiBHZXRzIGFuIGV2ZW50J3MgeCwgeSBjb29yZGluYXRlcywgcmVsYXRpdmUgdG8gdGhlIGNoYXJ0IGFyZWFcbiAqIEBwYXJhbSBldmVudFxuICogQHBhcmFtIGNoYXJ0XG4gKiBAcmV0dXJucyB4IGFuZCB5IGNvb3JkaW5hdGVzIG9mIHRoZSBldmVudFxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRSZWxhdGl2ZVBvc2l0aW9uKFxuICBldmVudDogRXZlbnQgfCBDaGFydEV2ZW50IHwgVG91Y2hFdmVudCB8IE1vdXNlRXZlbnQsXG4gIGNoYXJ0OiBDaGFydFxuKTogeyB4OiBudW1iZXI7IHk6IG51bWJlciB9IHtcbiAgaWYgKCduYXRpdmUnIGluIGV2ZW50KSB7XG4gICAgcmV0dXJuIGV2ZW50O1xuICB9XG5cbiAgY29uc3Qge2NhbnZhcywgY3VycmVudERldmljZVBpeGVsUmF0aW99ID0gY2hhcnQ7XG4gIGNvbnN0IHN0eWxlID0gZ2V0Q29tcHV0ZWRTdHlsZShjYW52YXMpO1xuICBjb25zdCBib3JkZXJCb3ggPSBzdHlsZS5ib3hTaXppbmcgPT09ICdib3JkZXItYm94JztcbiAgY29uc3QgcGFkZGluZ3MgPSBnZXRQb3NpdGlvbmVkU3R5bGUoc3R5bGUsICdwYWRkaW5nJyk7XG4gIGNvbnN0IGJvcmRlcnMgPSBnZXRQb3NpdGlvbmVkU3R5bGUoc3R5bGUsICdib3JkZXInLCAnd2lkdGgnKTtcbiAgY29uc3Qge3gsIHksIGJveH0gPSBnZXRDYW52YXNQb3NpdGlvbihldmVudCwgY2FudmFzKTtcbiAgY29uc3QgeE9mZnNldCA9IHBhZGRpbmdzLmxlZnQgKyAoYm94ICYmIGJvcmRlcnMubGVmdCk7XG4gIGNvbnN0IHlPZmZzZXQgPSBwYWRkaW5ncy50b3AgKyAoYm94ICYmIGJvcmRlcnMudG9wKTtcblxuICBsZXQge3dpZHRoLCBoZWlnaHR9ID0gY2hhcnQ7XG4gIGlmIChib3JkZXJCb3gpIHtcbiAgICB3aWR0aCAtPSBwYWRkaW5ncy53aWR0aCArIGJvcmRlcnMud2lkdGg7XG4gICAgaGVpZ2h0IC09IHBhZGRpbmdzLmhlaWdodCArIGJvcmRlcnMuaGVpZ2h0O1xuICB9XG4gIHJldHVybiB7XG4gICAgeDogTWF0aC5yb3VuZCgoeCAtIHhPZmZzZXQpIC8gd2lkdGggKiBjYW52YXMud2lkdGggLyBjdXJyZW50RGV2aWNlUGl4ZWxSYXRpbyksXG4gICAgeTogTWF0aC5yb3VuZCgoeSAtIHlPZmZzZXQpIC8gaGVpZ2h0ICogY2FudmFzLmhlaWdodCAvIGN1cnJlbnREZXZpY2VQaXhlbFJhdGlvKVxuICB9O1xufVxuXG5mdW5jdGlvbiBnZXRDb250YWluZXJTaXplKGNhbnZhczogSFRNTENhbnZhc0VsZW1lbnQsIHdpZHRoOiBudW1iZXIsIGhlaWdodDogbnVtYmVyKTogUGFydGlhbDxTY2FsZT4ge1xuICBsZXQgbWF4V2lkdGg6IG51bWJlciwgbWF4SGVpZ2h0OiBudW1iZXI7XG5cbiAgaWYgKHdpZHRoID09PSB1bmRlZmluZWQgfHwgaGVpZ2h0ID09PSB1bmRlZmluZWQpIHtcbiAgICBjb25zdCBjb250YWluZXIgPSBjYW52YXMgJiYgX2dldFBhcmVudE5vZGUoY2FudmFzKTtcbiAgICBpZiAoIWNvbnRhaW5lcikge1xuICAgICAgd2lkdGggPSBjYW52YXMuY2xpZW50V2lkdGg7XG4gICAgICBoZWlnaHQgPSBjYW52YXMuY2xpZW50SGVpZ2h0O1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCByZWN0ID0gY29udGFpbmVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpOyAvLyB0aGlzIGlzIHRoZSBib3JkZXIgYm94IG9mIHRoZSBjb250YWluZXJcbiAgICAgIGNvbnN0IGNvbnRhaW5lclN0eWxlID0gZ2V0Q29tcHV0ZWRTdHlsZShjb250YWluZXIpO1xuICAgICAgY29uc3QgY29udGFpbmVyQm9yZGVyID0gZ2V0UG9zaXRpb25lZFN0eWxlKGNvbnRhaW5lclN0eWxlLCAnYm9yZGVyJywgJ3dpZHRoJyk7XG4gICAgICBjb25zdCBjb250YWluZXJQYWRkaW5nID0gZ2V0UG9zaXRpb25lZFN0eWxlKGNvbnRhaW5lclN0eWxlLCAncGFkZGluZycpO1xuICAgICAgd2lkdGggPSByZWN0LndpZHRoIC0gY29udGFpbmVyUGFkZGluZy53aWR0aCAtIGNvbnRhaW5lckJvcmRlci53aWR0aDtcbiAgICAgIGhlaWdodCA9IHJlY3QuaGVpZ2h0IC0gY29udGFpbmVyUGFkZGluZy5oZWlnaHQgLSBjb250YWluZXJCb3JkZXIuaGVpZ2h0O1xuICAgICAgbWF4V2lkdGggPSBwYXJzZU1heFN0eWxlKGNvbnRhaW5lclN0eWxlLm1heFdpZHRoLCBjb250YWluZXIsICdjbGllbnRXaWR0aCcpO1xuICAgICAgbWF4SGVpZ2h0ID0gcGFyc2VNYXhTdHlsZShjb250YWluZXJTdHlsZS5tYXhIZWlnaHQsIGNvbnRhaW5lciwgJ2NsaWVudEhlaWdodCcpO1xuICAgIH1cbiAgfVxuICByZXR1cm4ge1xuICAgIHdpZHRoLFxuICAgIGhlaWdodCxcbiAgICBtYXhXaWR0aDogbWF4V2lkdGggfHwgSU5GSU5JVFksXG4gICAgbWF4SGVpZ2h0OiBtYXhIZWlnaHQgfHwgSU5GSU5JVFlcbiAgfTtcbn1cblxuY29uc3Qgcm91bmQxID0gKHY6IG51bWJlcikgPT4gTWF0aC5yb3VuZCh2ICogMTApIC8gMTA7XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjb21wbGV4aXR5XG5leHBvcnQgZnVuY3Rpb24gZ2V0TWF4aW11bVNpemUoXG4gIGNhbnZhczogSFRNTENhbnZhc0VsZW1lbnQsXG4gIGJiV2lkdGg/OiBudW1iZXIsXG4gIGJiSGVpZ2h0PzogbnVtYmVyLFxuICBhc3BlY3RSYXRpbz86IG51bWJlclxuKTogeyB3aWR0aDogbnVtYmVyOyBoZWlnaHQ6IG51bWJlciB9IHtcbiAgY29uc3Qgc3R5bGUgPSBnZXRDb21wdXRlZFN0eWxlKGNhbnZhcyk7XG4gIGNvbnN0IG1hcmdpbnMgPSBnZXRQb3NpdGlvbmVkU3R5bGUoc3R5bGUsICdtYXJnaW4nKTtcbiAgY29uc3QgbWF4V2lkdGggPSBwYXJzZU1heFN0eWxlKHN0eWxlLm1heFdpZHRoLCBjYW52YXMsICdjbGllbnRXaWR0aCcpIHx8IElORklOSVRZO1xuICBjb25zdCBtYXhIZWlnaHQgPSBwYXJzZU1heFN0eWxlKHN0eWxlLm1heEhlaWdodCwgY2FudmFzLCAnY2xpZW50SGVpZ2h0JykgfHwgSU5GSU5JVFk7XG4gIGNvbnN0IGNvbnRhaW5lclNpemUgPSBnZXRDb250YWluZXJTaXplKGNhbnZhcywgYmJXaWR0aCwgYmJIZWlnaHQpO1xuICBsZXQge3dpZHRoLCBoZWlnaHR9ID0gY29udGFpbmVyU2l6ZTtcblxuICBpZiAoc3R5bGUuYm94U2l6aW5nID09PSAnY29udGVudC1ib3gnKSB7XG4gICAgY29uc3QgYm9yZGVycyA9IGdldFBvc2l0aW9uZWRTdHlsZShzdHlsZSwgJ2JvcmRlcicsICd3aWR0aCcpO1xuICAgIGNvbnN0IHBhZGRpbmdzID0gZ2V0UG9zaXRpb25lZFN0eWxlKHN0eWxlLCAncGFkZGluZycpO1xuICAgIHdpZHRoIC09IHBhZGRpbmdzLndpZHRoICsgYm9yZGVycy53aWR0aDtcbiAgICBoZWlnaHQgLT0gcGFkZGluZ3MuaGVpZ2h0ICsgYm9yZGVycy5oZWlnaHQ7XG4gIH1cbiAgd2lkdGggPSBNYXRoLm1heCgwLCB3aWR0aCAtIG1hcmdpbnMud2lkdGgpO1xuICBoZWlnaHQgPSBNYXRoLm1heCgwLCBhc3BlY3RSYXRpbyA/IHdpZHRoIC8gYXNwZWN0UmF0aW8gOiBoZWlnaHQgLSBtYXJnaW5zLmhlaWdodCk7XG4gIHdpZHRoID0gcm91bmQxKE1hdGgubWluKHdpZHRoLCBtYXhXaWR0aCwgY29udGFpbmVyU2l6ZS5tYXhXaWR0aCkpO1xuICBoZWlnaHQgPSByb3VuZDEoTWF0aC5taW4oaGVpZ2h0LCBtYXhIZWlnaHQsIGNvbnRhaW5lclNpemUubWF4SGVpZ2h0KSk7XG4gIGlmICh3aWR0aCAmJiAhaGVpZ2h0KSB7XG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2NoYXJ0anMvQ2hhcnQuanMvaXNzdWVzLzQ2NTlcbiAgICAvLyBJZiB0aGUgY2FudmFzIGhhcyB3aWR0aCwgYnV0IG5vIGhlaWdodCwgZGVmYXVsdCB0byBhc3BlY3RSYXRpbyBvZiAyIChjYW52YXMgZGVmYXVsdClcbiAgICBoZWlnaHQgPSByb3VuZDEod2lkdGggLyAyKTtcbiAgfVxuXG4gIGNvbnN0IG1haW50YWluSGVpZ2h0ID0gYmJXaWR0aCAhPT0gdW5kZWZpbmVkIHx8IGJiSGVpZ2h0ICE9PSB1bmRlZmluZWQ7XG5cbiAgaWYgKG1haW50YWluSGVpZ2h0ICYmIGFzcGVjdFJhdGlvICYmIGNvbnRhaW5lclNpemUuaGVpZ2h0ICYmIGhlaWdodCA+IGNvbnRhaW5lclNpemUuaGVpZ2h0KSB7XG4gICAgaGVpZ2h0ID0gY29udGFpbmVyU2l6ZS5oZWlnaHQ7XG4gICAgd2lkdGggPSByb3VuZDEoTWF0aC5mbG9vcihoZWlnaHQgKiBhc3BlY3RSYXRpbykpO1xuICB9XG5cbiAgcmV0dXJuIHt3aWR0aCwgaGVpZ2h0fTtcbn1cblxuLyoqXG4gKiBAcGFyYW0gY2hhcnRcbiAqIEBwYXJhbSBmb3JjZVJhdGlvXG4gKiBAcGFyYW0gZm9yY2VTdHlsZVxuICogQHJldHVybnMgVHJ1ZSBpZiB0aGUgY2FudmFzIGNvbnRleHQgc2l6ZSBvciB0cmFuc2Zvcm1hdGlvbiBoYXMgY2hhbmdlZC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJldGluYVNjYWxlKFxuICBjaGFydDogQ2hhcnQsXG4gIGZvcmNlUmF0aW86IG51bWJlcixcbiAgZm9yY2VTdHlsZT86IGJvb2xlYW5cbik6IGJvb2xlYW4gfCB2b2lkIHtcbiAgY29uc3QgcGl4ZWxSYXRpbyA9IGZvcmNlUmF0aW8gfHwgMTtcbiAgY29uc3QgZGV2aWNlSGVpZ2h0ID0gTWF0aC5mbG9vcihjaGFydC5oZWlnaHQgKiBwaXhlbFJhdGlvKTtcbiAgY29uc3QgZGV2aWNlV2lkdGggPSBNYXRoLmZsb29yKGNoYXJ0LndpZHRoICogcGl4ZWxSYXRpbyk7XG5cbiAgY2hhcnQuaGVpZ2h0ID0gTWF0aC5mbG9vcihjaGFydC5oZWlnaHQpO1xuICBjaGFydC53aWR0aCA9IE1hdGguZmxvb3IoY2hhcnQud2lkdGgpO1xuXG4gIGNvbnN0IGNhbnZhcyA9IGNoYXJ0LmNhbnZhcztcblxuICAvLyBJZiBubyBzdHlsZSBoYXMgYmVlbiBzZXQgb24gdGhlIGNhbnZhcywgdGhlIHJlbmRlciBzaXplIGlzIHVzZWQgYXMgZGlzcGxheSBzaXplLFxuICAvLyBtYWtpbmcgdGhlIGNoYXJ0IHZpc3VhbGx5IGJpZ2dlciwgc28gbGV0J3MgZW5mb3JjZSBpdCB0byB0aGUgXCJjb3JyZWN0XCIgdmFsdWVzLlxuICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2NoYXJ0anMvQ2hhcnQuanMvaXNzdWVzLzM1NzVcbiAgaWYgKGNhbnZhcy5zdHlsZSAmJiAoZm9yY2VTdHlsZSB8fCAoIWNhbnZhcy5zdHlsZS5oZWlnaHQgJiYgIWNhbnZhcy5zdHlsZS53aWR0aCkpKSB7XG4gICAgY2FudmFzLnN0eWxlLmhlaWdodCA9IGAke2NoYXJ0LmhlaWdodH1weGA7XG4gICAgY2FudmFzLnN0eWxlLndpZHRoID0gYCR7Y2hhcnQud2lkdGh9cHhgO1xuICB9XG5cbiAgaWYgKGNoYXJ0LmN1cnJlbnREZXZpY2VQaXhlbFJhdGlvICE9PSBwaXhlbFJhdGlvXG4gICAgICB8fCBjYW52YXMuaGVpZ2h0ICE9PSBkZXZpY2VIZWlnaHRcbiAgICAgIHx8IGNhbnZhcy53aWR0aCAhPT0gZGV2aWNlV2lkdGgpIHtcbiAgICBjaGFydC5jdXJyZW50RGV2aWNlUGl4ZWxSYXRpbyA9IHBpeGVsUmF0aW87XG4gICAgY2FudmFzLmhlaWdodCA9IGRldmljZUhlaWdodDtcbiAgICBjYW52YXMud2lkdGggPSBkZXZpY2VXaWR0aDtcbiAgICBjaGFydC5jdHguc2V0VHJhbnNmb3JtKHBpeGVsUmF0aW8sIDAsIDAsIHBpeGVsUmF0aW8sIDAsIDApO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuLyoqXG4gKiBEZXRlY3RzIHN1cHBvcnQgZm9yIG9wdGlvbnMgb2JqZWN0IGFyZ3VtZW50IGluIGFkZEV2ZW50TGlzdGVuZXIuXG4gKiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvRXZlbnRUYXJnZXQvYWRkRXZlbnRMaXN0ZW5lciNTYWZlbHlfZGV0ZWN0aW5nX29wdGlvbl9zdXBwb3J0XG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgY29uc3Qgc3VwcG9ydHNFdmVudExpc3RlbmVyT3B0aW9ucyA9IChmdW5jdGlvbigpIHtcbiAgbGV0IHBhc3NpdmVTdXBwb3J0ZWQgPSBmYWxzZTtcbiAgdHJ5IHtcbiAgICBjb25zdCBvcHRpb25zID0ge1xuICAgICAgZ2V0IHBhc3NpdmUoKSB7IC8vIFRoaXMgZnVuY3Rpb24gd2lsbCBiZSBjYWxsZWQgd2hlbiB0aGUgYnJvd3NlciBhdHRlbXB0cyB0byBhY2Nlc3MgdGhlIHBhc3NpdmUgcHJvcGVydHkuXG4gICAgICAgIHBhc3NpdmVTdXBwb3J0ZWQgPSB0cnVlO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfSBhcyBFdmVudExpc3RlbmVyT3B0aW9ucztcblxuICAgIGlmIChfaXNEb21TdXBwb3J0ZWQoKSkge1xuICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Rlc3QnLCBudWxsLCBvcHRpb25zKTtcbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCd0ZXN0JywgbnVsbCwgb3B0aW9ucyk7XG4gICAgfVxuICB9IGNhdGNoIChlKSB7XG4gICAgLy8gY29udGludWUgcmVnYXJkbGVzcyBvZiBlcnJvclxuICB9XG4gIHJldHVybiBwYXNzaXZlU3VwcG9ydGVkO1xufSgpKTtcblxuLyoqXG4gKiBUaGUgXCJ1c2VkXCIgc2l6ZSBpcyB0aGUgZmluYWwgdmFsdWUgb2YgYSBkaW1lbnNpb24gcHJvcGVydHkgYWZ0ZXIgYWxsIGNhbGN1bGF0aW9ucyBoYXZlXG4gKiBiZWVuIHBlcmZvcm1lZC4gVGhpcyBtZXRob2QgdXNlcyB0aGUgY29tcHV0ZWQgc3R5bGUgb2YgYGVsZW1lbnRgIGJ1dCByZXR1cm5zIHVuZGVmaW5lZFxuICogaWYgdGhlIGNvbXB1dGVkIHN0eWxlIGlzIG5vdCBleHByZXNzZWQgaW4gcGl4ZWxzLiBUaGF0IGNhbiBoYXBwZW4gaW4gc29tZSBjYXNlcyB3aGVyZVxuICogYGVsZW1lbnRgIGhhcyBhIHNpemUgcmVsYXRpdmUgdG8gaXRzIHBhcmVudCBhbmQgdGhpcyBsYXN0IG9uZSBpcyBub3QgeWV0IGRpc3BsYXllZCxcbiAqIGZvciBleGFtcGxlIGJlY2F1c2Ugb2YgYGRpc3BsYXk6IG5vbmVgIG9uIGEgcGFyZW50IG5vZGUuXG4gKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0NTUy91c2VkX3ZhbHVlXG4gKiBAcmV0dXJucyBTaXplIGluIHBpeGVscyBvciB1bmRlZmluZWQgaWYgdW5rbm93bi5cbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gcmVhZFVzZWRTaXplKFxuICBlbGVtZW50OiBIVE1MRWxlbWVudCxcbiAgcHJvcGVydHk6ICd3aWR0aCcgfCAnaGVpZ2h0J1xuKTogbnVtYmVyIHwgdW5kZWZpbmVkIHtcbiAgY29uc3QgdmFsdWUgPSBnZXRTdHlsZShlbGVtZW50LCBwcm9wZXJ0eSk7XG4gIGNvbnN0IG1hdGNoZXMgPSB2YWx1ZSAmJiB2YWx1ZS5tYXRjaCgvXihcXGQrKShcXC5cXGQrKT9weCQvKTtcbiAgcmV0dXJuIG1hdGNoZXMgPyArbWF0Y2hlc1sxXSA6IHVuZGVmaW5lZDtcbn1cbiIsICJpbXBvcnQgdHlwZSB7UG9pbnQsIFNwbGluZVBvaW50fSBmcm9tICcuLi90eXBlcy9nZW9tZXRyaWMuanMnO1xuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBfcG9pbnRJbkxpbmUocDE6IFBvaW50LCBwMjogUG9pbnQsIHQ6IG51bWJlciwgbW9kZT8pIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnNcbiAgcmV0dXJuIHtcbiAgICB4OiBwMS54ICsgdCAqIChwMi54IC0gcDEueCksXG4gICAgeTogcDEueSArIHQgKiAocDIueSAtIHAxLnkpXG4gIH07XG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIF9zdGVwcGVkSW50ZXJwb2xhdGlvbihcbiAgcDE6IFBvaW50LFxuICBwMjogUG9pbnQsXG4gIHQ6IG51bWJlciwgbW9kZTogJ21pZGRsZScgfCAnYWZ0ZXInIHwgdW5rbm93blxuKSB7XG4gIHJldHVybiB7XG4gICAgeDogcDEueCArIHQgKiAocDIueCAtIHAxLngpLFxuICAgIHk6IG1vZGUgPT09ICdtaWRkbGUnID8gdCA8IDAuNSA/IHAxLnkgOiBwMi55XG4gICAgICA6IG1vZGUgPT09ICdhZnRlcicgPyB0IDwgMSA/IHAxLnkgOiBwMi55XG4gICAgICAgIDogdCA+IDAgPyBwMi55IDogcDEueVxuICB9O1xufVxuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBfYmV6aWVySW50ZXJwb2xhdGlvbihwMTogU3BsaW5lUG9pbnQsIHAyOiBTcGxpbmVQb2ludCwgdDogbnVtYmVyLCBtb2RlPykgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFyc1xuICBjb25zdCBjcDEgPSB7eDogcDEuY3AyeCwgeTogcDEuY3AyeX07XG4gIGNvbnN0IGNwMiA9IHt4OiBwMi5jcDF4LCB5OiBwMi5jcDF5fTtcbiAgY29uc3QgYSA9IF9wb2ludEluTGluZShwMSwgY3AxLCB0KTtcbiAgY29uc3QgYiA9IF9wb2ludEluTGluZShjcDEsIGNwMiwgdCk7XG4gIGNvbnN0IGMgPSBfcG9pbnRJbkxpbmUoY3AyLCBwMiwgdCk7XG4gIGNvbnN0IGQgPSBfcG9pbnRJbkxpbmUoYSwgYiwgdCk7XG4gIGNvbnN0IGUgPSBfcG9pbnRJbkxpbmUoYiwgYywgdCk7XG4gIHJldHVybiBfcG9pbnRJbkxpbmUoZCwgZSwgdCk7XG59XG4iLCAiZXhwb3J0IGludGVyZmFjZSBSVExBZGFwdGVyIHtcbiAgeCh4OiBudW1iZXIpOiBudW1iZXI7XG4gIHNldFdpZHRoKHc6IG51bWJlcik6IHZvaWQ7XG4gIHRleHRBbGlnbihhbGlnbjogJ2NlbnRlcicgfCAnbGVmdCcgfCAncmlnaHQnKTogJ2NlbnRlcicgfCAnbGVmdCcgfCAncmlnaHQnO1xuICB4UGx1cyh4OiBudW1iZXIsIHZhbHVlOiBudW1iZXIpOiBudW1iZXI7XG4gIGxlZnRGb3JMdHIoeDogbnVtYmVyLCBpdGVtV2lkdGg6IG51bWJlcik6IG51bWJlcjtcbn1cblxuY29uc3QgZ2V0UmlnaHRUb0xlZnRBZGFwdGVyID0gZnVuY3Rpb24ocmVjdFg6IG51bWJlciwgd2lkdGg6IG51bWJlcik6IFJUTEFkYXB0ZXIge1xuICByZXR1cm4ge1xuICAgIHgoeCkge1xuICAgICAgcmV0dXJuIHJlY3RYICsgcmVjdFggKyB3aWR0aCAtIHg7XG4gICAgfSxcbiAgICBzZXRXaWR0aCh3KSB7XG4gICAgICB3aWR0aCA9IHc7XG4gICAgfSxcbiAgICB0ZXh0QWxpZ24oYWxpZ24pIHtcbiAgICAgIGlmIChhbGlnbiA9PT0gJ2NlbnRlcicpIHtcbiAgICAgICAgcmV0dXJuIGFsaWduO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGFsaWduID09PSAncmlnaHQnID8gJ2xlZnQnIDogJ3JpZ2h0JztcbiAgICB9LFxuICAgIHhQbHVzKHgsIHZhbHVlKSB7XG4gICAgICByZXR1cm4geCAtIHZhbHVlO1xuICAgIH0sXG4gICAgbGVmdEZvckx0cih4LCBpdGVtV2lkdGgpIHtcbiAgICAgIHJldHVybiB4IC0gaXRlbVdpZHRoO1xuICAgIH0sXG4gIH07XG59O1xuXG5jb25zdCBnZXRMZWZ0VG9SaWdodEFkYXB0ZXIgPSBmdW5jdGlvbigpOiBSVExBZGFwdGVyIHtcbiAgcmV0dXJuIHtcbiAgICB4KHgpIHtcbiAgICAgIHJldHVybiB4O1xuICAgIH0sXG4gICAgc2V0V2lkdGgodykgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gICAgfSxcbiAgICB0ZXh0QWxpZ24oYWxpZ24pIHtcbiAgICAgIHJldHVybiBhbGlnbjtcbiAgICB9LFxuICAgIHhQbHVzKHgsIHZhbHVlKSB7XG4gICAgICByZXR1cm4geCArIHZhbHVlO1xuICAgIH0sXG4gICAgbGVmdEZvckx0cih4LCBfaXRlbVdpZHRoKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzXG4gICAgICByZXR1cm4geDtcbiAgICB9LFxuICB9O1xufTtcblxuZXhwb3J0IGZ1bmN0aW9uIGdldFJ0bEFkYXB0ZXIocnRsOiBib29sZWFuLCByZWN0WDogbnVtYmVyLCB3aWR0aDogbnVtYmVyKSB7XG4gIHJldHVybiBydGwgPyBnZXRSaWdodFRvTGVmdEFkYXB0ZXIocmVjdFgsIHdpZHRoKSA6IGdldExlZnRUb1JpZ2h0QWRhcHRlcigpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gb3ZlcnJpZGVUZXh0RGlyZWN0aW9uKGN0eDogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJELCBkaXJlY3Rpb246ICdsdHInIHwgJ3J0bCcpIHtcbiAgbGV0IHN0eWxlOiBDU1NTdHlsZURlY2xhcmF0aW9uLCBvcmlnaW5hbDogW3N0cmluZywgc3RyaW5nXTtcbiAgaWYgKGRpcmVjdGlvbiA9PT0gJ2x0cicgfHwgZGlyZWN0aW9uID09PSAncnRsJykge1xuICAgIHN0eWxlID0gY3R4LmNhbnZhcy5zdHlsZTtcbiAgICBvcmlnaW5hbCA9IFtcbiAgICAgIHN0eWxlLmdldFByb3BlcnR5VmFsdWUoJ2RpcmVjdGlvbicpLFxuICAgICAgc3R5bGUuZ2V0UHJvcGVydHlQcmlvcml0eSgnZGlyZWN0aW9uJyksXG4gICAgXTtcblxuICAgIHN0eWxlLnNldFByb3BlcnR5KCdkaXJlY3Rpb24nLCBkaXJlY3Rpb24sICdpbXBvcnRhbnQnKTtcbiAgICAoY3R4IGFzIHsgcHJldlRleHREaXJlY3Rpb24/OiBbc3RyaW5nLCBzdHJpbmddIH0pLnByZXZUZXh0RGlyZWN0aW9uID0gb3JpZ2luYWw7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJlc3RvcmVUZXh0RGlyZWN0aW9uKGN0eDogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJELCBvcmlnaW5hbD86IFtzdHJpbmcsIHN0cmluZ10pIHtcbiAgaWYgKG9yaWdpbmFsICE9PSB1bmRlZmluZWQpIHtcbiAgICBkZWxldGUgKGN0eCBhcyB7IHByZXZUZXh0RGlyZWN0aW9uPzogW3N0cmluZywgc3RyaW5nXSB9KS5wcmV2VGV4dERpcmVjdGlvbjtcbiAgICBjdHguY2FudmFzLnN0eWxlLnNldFByb3BlcnR5KCdkaXJlY3Rpb24nLCBvcmlnaW5hbFswXSwgb3JpZ2luYWxbMV0pO1xuICB9XG59XG4iLCAiaW1wb3J0IHtfYW5nbGVCZXR3ZWVuLCBfYW5nbGVEaWZmLCBfaXNCZXR3ZWVuLCBfbm9ybWFsaXplQW5nbGV9IGZyb20gJy4vaGVscGVycy5tYXRoLmpzJztcbmltcG9ydCB7Y3JlYXRlQ29udGV4dH0gZnJvbSAnLi9oZWxwZXJzLm9wdGlvbnMuanMnO1xuaW1wb3J0IHtpc1BhdHRlcm5PckdyYWRpZW50fSBmcm9tICcuL2hlbHBlcnMuY29sb3IuanMnO1xuXG4vKipcbiAqIEB0eXBlZGVmIHsgaW1wb3J0KCcuLi9lbGVtZW50cy9lbGVtZW50LmxpbmUuanMnKS5kZWZhdWx0IH0gTGluZUVsZW1lbnRcbiAqIEB0eXBlZGVmIHsgaW1wb3J0KCcuLi9lbGVtZW50cy9lbGVtZW50LnBvaW50LmpzJykuZGVmYXVsdCB9IFBvaW50RWxlbWVudFxuICogQHR5cGVkZWYge3tzdGFydDogbnVtYmVyLCBlbmQ6IG51bWJlciwgbG9vcDogYm9vbGVhbiwgc3R5bGU/OiBhbnl9fSBTZWdtZW50XG4gKi9cblxuZnVuY3Rpb24gcHJvcGVydHlGbihwcm9wZXJ0eSkge1xuICBpZiAocHJvcGVydHkgPT09ICdhbmdsZScpIHtcbiAgICByZXR1cm4ge1xuICAgICAgYmV0d2VlbjogX2FuZ2xlQmV0d2VlbixcbiAgICAgIGNvbXBhcmU6IF9hbmdsZURpZmYsXG4gICAgICBub3JtYWxpemU6IF9ub3JtYWxpemVBbmdsZSxcbiAgICB9O1xuICB9XG4gIHJldHVybiB7XG4gICAgYmV0d2VlbjogX2lzQmV0d2VlbixcbiAgICBjb21wYXJlOiAoYSwgYikgPT4gYSAtIGIsXG4gICAgbm9ybWFsaXplOiB4ID0+IHhcbiAgfTtcbn1cblxuZnVuY3Rpb24gbm9ybWFsaXplU2VnbWVudCh7c3RhcnQsIGVuZCwgY291bnQsIGxvb3AsIHN0eWxlfSkge1xuICByZXR1cm4ge1xuICAgIHN0YXJ0OiBzdGFydCAlIGNvdW50LFxuICAgIGVuZDogZW5kICUgY291bnQsXG4gICAgbG9vcDogbG9vcCAmJiAoZW5kIC0gc3RhcnQgKyAxKSAlIGNvdW50ID09PSAwLFxuICAgIHN0eWxlXG4gIH07XG59XG5cbmZ1bmN0aW9uIGdldFNlZ21lbnQoc2VnbWVudCwgcG9pbnRzLCBib3VuZHMpIHtcbiAgY29uc3Qge3Byb3BlcnR5LCBzdGFydDogc3RhcnRCb3VuZCwgZW5kOiBlbmRCb3VuZH0gPSBib3VuZHM7XG4gIGNvbnN0IHtiZXR3ZWVuLCBub3JtYWxpemV9ID0gcHJvcGVydHlGbihwcm9wZXJ0eSk7XG4gIGNvbnN0IGNvdW50ID0gcG9pbnRzLmxlbmd0aDtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHByZWZlci1jb25zdFxuICBsZXQge3N0YXJ0LCBlbmQsIGxvb3B9ID0gc2VnbWVudDtcbiAgbGV0IGksIGlsZW47XG5cbiAgaWYgKGxvb3ApIHtcbiAgICBzdGFydCArPSBjb3VudDtcbiAgICBlbmQgKz0gY291bnQ7XG4gICAgZm9yIChpID0gMCwgaWxlbiA9IGNvdW50OyBpIDwgaWxlbjsgKytpKSB7XG4gICAgICBpZiAoIWJldHdlZW4obm9ybWFsaXplKHBvaW50c1tzdGFydCAlIGNvdW50XVtwcm9wZXJ0eV0pLCBzdGFydEJvdW5kLCBlbmRCb3VuZCkpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBzdGFydC0tO1xuICAgICAgZW5kLS07XG4gICAgfVxuICAgIHN0YXJ0ICU9IGNvdW50O1xuICAgIGVuZCAlPSBjb3VudDtcbiAgfVxuXG4gIGlmIChlbmQgPCBzdGFydCkge1xuICAgIGVuZCArPSBjb3VudDtcbiAgfVxuICByZXR1cm4ge3N0YXJ0LCBlbmQsIGxvb3AsIHN0eWxlOiBzZWdtZW50LnN0eWxlfTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBzdWItc2VnbWVudChzKSBvZiBhIGxpbmUgc2VnbWVudCB0aGF0IGZhbGwgaW4gdGhlIGdpdmVuIGJvdW5kc1xuICogQHBhcmFtIHtvYmplY3R9IHNlZ21lbnRcbiAqIEBwYXJhbSB7bnVtYmVyfSBzZWdtZW50LnN0YXJ0IC0gc3RhcnQgaW5kZXggb2YgdGhlIHNlZ21lbnQsIHJlZmVycmluZyB0aGUgcG9pbnRzIGFycmF5XG4gKiBAcGFyYW0ge251bWJlcn0gc2VnbWVudC5lbmQgLSBlbmQgaW5kZXggb2YgdGhlIHNlZ21lbnQsIHJlZmVycmluZyB0aGUgcG9pbnRzIGFycmF5XG4gKiBAcGFyYW0ge2Jvb2xlYW59IHNlZ21lbnQubG9vcCAtIGluZGljYXRlcyB0aGF0IHRoZSBzZWdtZW50IGlzIGEgbG9vcFxuICogQHBhcmFtIHtvYmplY3R9IFtzZWdtZW50LnN0eWxlXSAtIHNlZ21lbnQgc3R5bGVcbiAqIEBwYXJhbSB7UG9pbnRFbGVtZW50W119IHBvaW50cyAtIHRoZSBwb2ludHMgdGhhdCB0aGlzIHNlZ21lbnQgcmVmZXJzIHRvXG4gKiBAcGFyYW0ge29iamVjdH0gW2JvdW5kc11cbiAqIEBwYXJhbSB7c3RyaW5nfSBib3VuZHMucHJvcGVydHkgLSB0aGUgcHJvcGVydHkgb2YgYSBgUG9pbnRFbGVtZW50YCB3ZSBhcmUgYm91bmRpbmcuIGB4YCwgYHlgIG9yIGBhbmdsZWAuXG4gKiBAcGFyYW0ge251bWJlcn0gYm91bmRzLnN0YXJ0IC0gc3RhcnQgdmFsdWUgb2YgdGhlIHByb3BlcnR5XG4gKiBAcGFyYW0ge251bWJlcn0gYm91bmRzLmVuZCAtIGVuZCB2YWx1ZSBvZiB0aGUgcHJvcGVydHlcbiAqIEBwcml2YXRlXG4gKiovXG5leHBvcnQgZnVuY3Rpb24gX2JvdW5kU2VnbWVudChzZWdtZW50LCBwb2ludHMsIGJvdW5kcykge1xuICBpZiAoIWJvdW5kcykge1xuICAgIHJldHVybiBbc2VnbWVudF07XG4gIH1cblxuICBjb25zdCB7cHJvcGVydHksIHN0YXJ0OiBzdGFydEJvdW5kLCBlbmQ6IGVuZEJvdW5kfSA9IGJvdW5kcztcbiAgY29uc3QgY291bnQgPSBwb2ludHMubGVuZ3RoO1xuICBjb25zdCB7Y29tcGFyZSwgYmV0d2Vlbiwgbm9ybWFsaXplfSA9IHByb3BlcnR5Rm4ocHJvcGVydHkpO1xuICBjb25zdCB7c3RhcnQsIGVuZCwgbG9vcCwgc3R5bGV9ID0gZ2V0U2VnbWVudChzZWdtZW50LCBwb2ludHMsIGJvdW5kcyk7XG5cbiAgY29uc3QgcmVzdWx0ID0gW107XG4gIGxldCBpbnNpZGUgPSBmYWxzZTtcbiAgbGV0IHN1YlN0YXJ0ID0gbnVsbDtcbiAgbGV0IHZhbHVlLCBwb2ludCwgcHJldlZhbHVlO1xuXG4gIGNvbnN0IHN0YXJ0SXNCZWZvcmUgPSAoKSA9PiBiZXR3ZWVuKHN0YXJ0Qm91bmQsIHByZXZWYWx1ZSwgdmFsdWUpICYmIGNvbXBhcmUoc3RhcnRCb3VuZCwgcHJldlZhbHVlKSAhPT0gMDtcbiAgY29uc3QgZW5kSXNCZWZvcmUgPSAoKSA9PiBjb21wYXJlKGVuZEJvdW5kLCB2YWx1ZSkgPT09IDAgfHwgYmV0d2VlbihlbmRCb3VuZCwgcHJldlZhbHVlLCB2YWx1ZSk7XG4gIGNvbnN0IHNob3VsZFN0YXJ0ID0gKCkgPT4gaW5zaWRlIHx8IHN0YXJ0SXNCZWZvcmUoKTtcbiAgY29uc3Qgc2hvdWxkU3RvcCA9ICgpID0+ICFpbnNpZGUgfHwgZW5kSXNCZWZvcmUoKTtcblxuICBmb3IgKGxldCBpID0gc3RhcnQsIHByZXYgPSBzdGFydDsgaSA8PSBlbmQ7ICsraSkge1xuICAgIHBvaW50ID0gcG9pbnRzW2kgJSBjb3VudF07XG5cbiAgICBpZiAocG9pbnQuc2tpcCkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgdmFsdWUgPSBub3JtYWxpemUocG9pbnRbcHJvcGVydHldKTtcblxuICAgIGlmICh2YWx1ZSA9PT0gcHJldlZhbHVlKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBpbnNpZGUgPSBiZXR3ZWVuKHZhbHVlLCBzdGFydEJvdW5kLCBlbmRCb3VuZCk7XG5cbiAgICBpZiAoc3ViU3RhcnQgPT09IG51bGwgJiYgc2hvdWxkU3RhcnQoKSkge1xuICAgICAgc3ViU3RhcnQgPSBjb21wYXJlKHZhbHVlLCBzdGFydEJvdW5kKSA9PT0gMCA/IGkgOiBwcmV2O1xuICAgIH1cblxuICAgIGlmIChzdWJTdGFydCAhPT0gbnVsbCAmJiBzaG91bGRTdG9wKCkpIHtcbiAgICAgIHJlc3VsdC5wdXNoKG5vcm1hbGl6ZVNlZ21lbnQoe3N0YXJ0OiBzdWJTdGFydCwgZW5kOiBpLCBsb29wLCBjb3VudCwgc3R5bGV9KSk7XG4gICAgICBzdWJTdGFydCA9IG51bGw7XG4gICAgfVxuICAgIHByZXYgPSBpO1xuICAgIHByZXZWYWx1ZSA9IHZhbHVlO1xuICB9XG5cbiAgaWYgKHN1YlN0YXJ0ICE9PSBudWxsKSB7XG4gICAgcmVzdWx0LnB1c2gobm9ybWFsaXplU2VnbWVudCh7c3RhcnQ6IHN1YlN0YXJ0LCBlbmQsIGxvb3AsIGNvdW50LCBzdHlsZX0pKTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBzZWdtZW50cyBvZiB0aGUgbGluZSB0aGF0IGFyZSBpbnNpZGUgZ2l2ZW4gYm91bmRzXG4gKiBAcGFyYW0ge0xpbmVFbGVtZW50fSBsaW5lXG4gKiBAcGFyYW0ge29iamVjdH0gW2JvdW5kc11cbiAqIEBwYXJhbSB7c3RyaW5nfSBib3VuZHMucHJvcGVydHkgLSB0aGUgcHJvcGVydHkgd2UgYXJlIGJvdW5kaW5nIHdpdGguIGB4YCwgYHlgIG9yIGBhbmdsZWAuXG4gKiBAcGFyYW0ge251bWJlcn0gYm91bmRzLnN0YXJ0IC0gc3RhcnQgdmFsdWUgb2YgdGhlIGBwcm9wZXJ0eWBcbiAqIEBwYXJhbSB7bnVtYmVyfSBib3VuZHMuZW5kIC0gZW5kIHZhbHVlIG9mIHRoZSBgcHJvcGVydHlgXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gX2JvdW5kU2VnbWVudHMobGluZSwgYm91bmRzKSB7XG4gIGNvbnN0IHJlc3VsdCA9IFtdO1xuICBjb25zdCBzZWdtZW50cyA9IGxpbmUuc2VnbWVudHM7XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzZWdtZW50cy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IHN1YiA9IF9ib3VuZFNlZ21lbnQoc2VnbWVudHNbaV0sIGxpbmUucG9pbnRzLCBib3VuZHMpO1xuICAgIGlmIChzdWIubGVuZ3RoKSB7XG4gICAgICByZXN1bHQucHVzaCguLi5zdWIpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIEZpbmQgc3RhcnQgYW5kIGVuZCBpbmRleCBvZiBhIGxpbmUuXG4gKi9cbmZ1bmN0aW9uIGZpbmRTdGFydEFuZEVuZChwb2ludHMsIGNvdW50LCBsb29wLCBzcGFuR2Fwcykge1xuICBsZXQgc3RhcnQgPSAwO1xuICBsZXQgZW5kID0gY291bnQgLSAxO1xuXG4gIGlmIChsb29wICYmICFzcGFuR2Fwcykge1xuICAgIC8vIGxvb3AgYW5kIG5vdCBzcGFubmluZyBnYXBzLCBmaXJzdCBmaW5kIGEgZ2FwIHRvIHN0YXJ0IGZyb21cbiAgICB3aGlsZSAoc3RhcnQgPCBjb3VudCAmJiAhcG9pbnRzW3N0YXJ0XS5za2lwKSB7XG4gICAgICBzdGFydCsrO1xuICAgIH1cbiAgfVxuXG4gIC8vIGZpbmQgZmlyc3Qgbm9uIHNraXBwZWQgcG9pbnQgKGFmdGVyIHRoZSBmaXJzdCBnYXAgcG9zc2libHkpXG4gIHdoaWxlIChzdGFydCA8IGNvdW50ICYmIHBvaW50c1tzdGFydF0uc2tpcCkge1xuICAgIHN0YXJ0Kys7XG4gIH1cblxuICAvLyBpZiB3ZSBsb29wZWQgdG8gY291bnQsIHN0YXJ0IG5lZWRzIHRvIGJlIDBcbiAgc3RhcnQgJT0gY291bnQ7XG5cbiAgaWYgKGxvb3ApIHtcbiAgICAvLyBsb29wIHdpbGwgZ28gcGFzdCBjb3VudCwgaWYgc3RhcnQgPiAwXG4gICAgZW5kICs9IHN0YXJ0O1xuICB9XG5cbiAgd2hpbGUgKGVuZCA+IHN0YXJ0ICYmIHBvaW50c1tlbmQgJSBjb3VudF0uc2tpcCkge1xuICAgIGVuZC0tO1xuICB9XG5cbiAgLy8gZW5kIGNvdWxkIGJlIG1vcmUgdGhhbiBjb3VudCwgbm9ybWFsaXplXG4gIGVuZCAlPSBjb3VudDtcblxuICByZXR1cm4ge3N0YXJ0LCBlbmR9O1xufVxuXG4vKipcbiAqIENvbXB1dGUgc29saWQgc2VnbWVudHMgZnJvbSBQb2ludHMsIHdoZW4gc3BhbkdhcHMgPT09IGZhbHNlXG4gKiBAcGFyYW0ge1BvaW50RWxlbWVudFtdfSBwb2ludHMgLSB0aGUgcG9pbnRzXG4gKiBAcGFyYW0ge251bWJlcn0gc3RhcnQgLSBzdGFydCBpbmRleFxuICogQHBhcmFtIHtudW1iZXJ9IG1heCAtIG1heCBpbmRleCAoY2FuIGdvIHBhc3QgY291bnQgb24gYSBsb29wKVxuICogQHBhcmFtIHtib29sZWFufSBsb29wIC0gYm9vbGVhbiBpbmRpY2F0aW5nIHRoYXQgdGhpcyB3b3VsZCBiZSBhIGxvb3AgaWYgbm8gZ2FwcyBhcmUgZm91bmRcbiAqL1xuZnVuY3Rpb24gc29saWRTZWdtZW50cyhwb2ludHMsIHN0YXJ0LCBtYXgsIGxvb3ApIHtcbiAgY29uc3QgY291bnQgPSBwb2ludHMubGVuZ3RoO1xuICBjb25zdCByZXN1bHQgPSBbXTtcbiAgbGV0IGxhc3QgPSBzdGFydDtcbiAgbGV0IHByZXYgPSBwb2ludHNbc3RhcnRdO1xuICBsZXQgZW5kO1xuXG4gIGZvciAoZW5kID0gc3RhcnQgKyAxOyBlbmQgPD0gbWF4OyArK2VuZCkge1xuICAgIGNvbnN0IGN1ciA9IHBvaW50c1tlbmQgJSBjb3VudF07XG4gICAgaWYgKGN1ci5za2lwIHx8IGN1ci5zdG9wKSB7XG4gICAgICBpZiAoIXByZXYuc2tpcCkge1xuICAgICAgICBsb29wID0gZmFsc2U7XG4gICAgICAgIHJlc3VsdC5wdXNoKHtzdGFydDogc3RhcnQgJSBjb3VudCwgZW5kOiAoZW5kIC0gMSkgJSBjb3VudCwgbG9vcH0pO1xuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIHN0YXJ0ID0gbGFzdCA9IGN1ci5zdG9wID8gZW5kIDogbnVsbDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgbGFzdCA9IGVuZDtcbiAgICAgIGlmIChwcmV2LnNraXApIHtcbiAgICAgICAgc3RhcnQgPSBlbmQ7XG4gICAgICB9XG4gICAgfVxuICAgIHByZXYgPSBjdXI7XG4gIH1cblxuICBpZiAobGFzdCAhPT0gbnVsbCkge1xuICAgIHJlc3VsdC5wdXNoKHtzdGFydDogc3RhcnQgJSBjb3VudCwgZW5kOiBsYXN0ICUgY291bnQsIGxvb3B9KTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogQ29tcHV0ZSB0aGUgY29udGludW91cyBzZWdtZW50cyB0aGF0IGRlZmluZSB0aGUgd2hvbGUgbGluZVxuICogVGhlcmUgY2FuIGJlIHNraXBwZWQgcG9pbnRzIHdpdGhpbiBhIHNlZ21lbnQsIGlmIHNwYW5HYXBzIGlzIHRydWUuXG4gKiBAcGFyYW0ge0xpbmVFbGVtZW50fSBsaW5lXG4gKiBAcGFyYW0ge29iamVjdH0gW3NlZ21lbnRPcHRpb25zXVxuICogQHJldHVybiB7U2VnbWVudFtdfVxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIF9jb21wdXRlU2VnbWVudHMobGluZSwgc2VnbWVudE9wdGlvbnMpIHtcbiAgY29uc3QgcG9pbnRzID0gbGluZS5wb2ludHM7XG4gIGNvbnN0IHNwYW5HYXBzID0gbGluZS5vcHRpb25zLnNwYW5HYXBzO1xuICBjb25zdCBjb3VudCA9IHBvaW50cy5sZW5ndGg7XG5cbiAgaWYgKCFjb3VudCkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuXG4gIGNvbnN0IGxvb3AgPSAhIWxpbmUuX2xvb3A7XG4gIGNvbnN0IHtzdGFydCwgZW5kfSA9IGZpbmRTdGFydEFuZEVuZChwb2ludHMsIGNvdW50LCBsb29wLCBzcGFuR2Fwcyk7XG5cbiAgaWYgKHNwYW5HYXBzID09PSB0cnVlKSB7XG4gICAgcmV0dXJuIHNwbGl0QnlTdHlsZXMobGluZSwgW3tzdGFydCwgZW5kLCBsb29wfV0sIHBvaW50cywgc2VnbWVudE9wdGlvbnMpO1xuICB9XG5cbiAgY29uc3QgbWF4ID0gZW5kIDwgc3RhcnQgPyBlbmQgKyBjb3VudCA6IGVuZDtcbiAgY29uc3QgY29tcGxldGVMb29wID0gISFsaW5lLl9mdWxsTG9vcCAmJiBzdGFydCA9PT0gMCAmJiBlbmQgPT09IGNvdW50IC0gMTtcbiAgcmV0dXJuIHNwbGl0QnlTdHlsZXMobGluZSwgc29saWRTZWdtZW50cyhwb2ludHMsIHN0YXJ0LCBtYXgsIGNvbXBsZXRlTG9vcCksIHBvaW50cywgc2VnbWVudE9wdGlvbnMpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7U2VnbWVudFtdfSBzZWdtZW50c1xuICogQHBhcmFtIHtQb2ludEVsZW1lbnRbXX0gcG9pbnRzXG4gKiBAcGFyYW0ge29iamVjdH0gW3NlZ21lbnRPcHRpb25zXVxuICogQHJldHVybiB7U2VnbWVudFtdfVxuICovXG5mdW5jdGlvbiBzcGxpdEJ5U3R5bGVzKGxpbmUsIHNlZ21lbnRzLCBwb2ludHMsIHNlZ21lbnRPcHRpb25zKSB7XG4gIGlmICghc2VnbWVudE9wdGlvbnMgfHwgIXNlZ21lbnRPcHRpb25zLnNldENvbnRleHQgfHwgIXBvaW50cykge1xuICAgIHJldHVybiBzZWdtZW50cztcbiAgfVxuICByZXR1cm4gZG9TcGxpdEJ5U3R5bGVzKGxpbmUsIHNlZ21lbnRzLCBwb2ludHMsIHNlZ21lbnRPcHRpb25zKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0xpbmVFbGVtZW50fSBsaW5lXG4gKiBAcGFyYW0ge1NlZ21lbnRbXX0gc2VnbWVudHNcbiAqIEBwYXJhbSB7UG9pbnRFbGVtZW50W119IHBvaW50c1xuICogQHBhcmFtIHtvYmplY3R9IFtzZWdtZW50T3B0aW9uc11cbiAqIEByZXR1cm4ge1NlZ21lbnRbXX1cbiAqL1xuZnVuY3Rpb24gZG9TcGxpdEJ5U3R5bGVzKGxpbmUsIHNlZ21lbnRzLCBwb2ludHMsIHNlZ21lbnRPcHRpb25zKSB7XG4gIGNvbnN0IGNoYXJ0Q29udGV4dCA9IGxpbmUuX2NoYXJ0LmdldENvbnRleHQoKTtcbiAgY29uc3QgYmFzZVN0eWxlID0gcmVhZFN0eWxlKGxpbmUub3B0aW9ucyk7XG4gIGNvbnN0IHtfZGF0YXNldEluZGV4OiBkYXRhc2V0SW5kZXgsIG9wdGlvbnM6IHtzcGFuR2Fwc319ID0gbGluZTtcbiAgY29uc3QgY291bnQgPSBwb2ludHMubGVuZ3RoO1xuICBjb25zdCByZXN1bHQgPSBbXTtcbiAgbGV0IHByZXZTdHlsZSA9IGJhc2VTdHlsZTtcbiAgbGV0IHN0YXJ0ID0gc2VnbWVudHNbMF0uc3RhcnQ7XG4gIGxldCBpID0gc3RhcnQ7XG5cbiAgZnVuY3Rpb24gYWRkU3R5bGUocywgZSwgbCwgc3QpIHtcbiAgICBjb25zdCBkaXIgPSBzcGFuR2FwcyA/IC0xIDogMTtcbiAgICBpZiAocyA9PT0gZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBTdHlsZSBjYW4gbm90IHN0YXJ0L2VuZCBvbiBhIHNraXBwZWQgcG9pbnQsIGFkanVzdCBpbmRpY2VzIGFjY29yZGluZ2x5XG4gICAgcyArPSBjb3VudDtcbiAgICB3aGlsZSAocG9pbnRzW3MgJSBjb3VudF0uc2tpcCkge1xuICAgICAgcyAtPSBkaXI7XG4gICAgfVxuICAgIHdoaWxlIChwb2ludHNbZSAlIGNvdW50XS5za2lwKSB7XG4gICAgICBlICs9IGRpcjtcbiAgICB9XG4gICAgaWYgKHMgJSBjb3VudCAhPT0gZSAlIGNvdW50KSB7XG4gICAgICByZXN1bHQucHVzaCh7c3RhcnQ6IHMgJSBjb3VudCwgZW5kOiBlICUgY291bnQsIGxvb3A6IGwsIHN0eWxlOiBzdH0pO1xuICAgICAgcHJldlN0eWxlID0gc3Q7XG4gICAgICBzdGFydCA9IGUgJSBjb3VudDtcbiAgICB9XG4gIH1cblxuICBmb3IgKGNvbnN0IHNlZ21lbnQgb2Ygc2VnbWVudHMpIHtcbiAgICBzdGFydCA9IHNwYW5HYXBzID8gc3RhcnQgOiBzZWdtZW50LnN0YXJ0O1xuICAgIGxldCBwcmV2ID0gcG9pbnRzW3N0YXJ0ICUgY291bnRdO1xuICAgIGxldCBzdHlsZTtcbiAgICBmb3IgKGkgPSBzdGFydCArIDE7IGkgPD0gc2VnbWVudC5lbmQ7IGkrKykge1xuICAgICAgY29uc3QgcHQgPSBwb2ludHNbaSAlIGNvdW50XTtcbiAgICAgIHN0eWxlID0gcmVhZFN0eWxlKHNlZ21lbnRPcHRpb25zLnNldENvbnRleHQoY3JlYXRlQ29udGV4dChjaGFydENvbnRleHQsIHtcbiAgICAgICAgdHlwZTogJ3NlZ21lbnQnLFxuICAgICAgICBwMDogcHJldixcbiAgICAgICAgcDE6IHB0LFxuICAgICAgICBwMERhdGFJbmRleDogKGkgLSAxKSAlIGNvdW50LFxuICAgICAgICBwMURhdGFJbmRleDogaSAlIGNvdW50LFxuICAgICAgICBkYXRhc2V0SW5kZXhcbiAgICAgIH0pKSk7XG4gICAgICBpZiAoc3R5bGVDaGFuZ2VkKHN0eWxlLCBwcmV2U3R5bGUpKSB7XG4gICAgICAgIGFkZFN0eWxlKHN0YXJ0LCBpIC0gMSwgc2VnbWVudC5sb29wLCBwcmV2U3R5bGUpO1xuICAgICAgfVxuICAgICAgcHJldiA9IHB0O1xuICAgICAgcHJldlN0eWxlID0gc3R5bGU7XG4gICAgfVxuICAgIGlmIChzdGFydCA8IGkgLSAxKSB7XG4gICAgICBhZGRTdHlsZShzdGFydCwgaSAtIDEsIHNlZ21lbnQubG9vcCwgcHJldlN0eWxlKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiByZWFkU3R5bGUob3B0aW9ucykge1xuICByZXR1cm4ge1xuICAgIGJhY2tncm91bmRDb2xvcjogb3B0aW9ucy5iYWNrZ3JvdW5kQ29sb3IsXG4gICAgYm9yZGVyQ2FwU3R5bGU6IG9wdGlvbnMuYm9yZGVyQ2FwU3R5bGUsXG4gICAgYm9yZGVyRGFzaDogb3B0aW9ucy5ib3JkZXJEYXNoLFxuICAgIGJvcmRlckRhc2hPZmZzZXQ6IG9wdGlvbnMuYm9yZGVyRGFzaE9mZnNldCxcbiAgICBib3JkZXJKb2luU3R5bGU6IG9wdGlvbnMuYm9yZGVySm9pblN0eWxlLFxuICAgIGJvcmRlcldpZHRoOiBvcHRpb25zLmJvcmRlcldpZHRoLFxuICAgIGJvcmRlckNvbG9yOiBvcHRpb25zLmJvcmRlckNvbG9yXG4gIH07XG59XG5cbmZ1bmN0aW9uIHN0eWxlQ2hhbmdlZChzdHlsZSwgcHJldlN0eWxlKSB7XG4gIGlmICghcHJldlN0eWxlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNvbnN0IGNhY2hlID0gW107XG4gIGNvbnN0IHJlcGxhY2VyID0gZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xuICAgIGlmICghaXNQYXR0ZXJuT3JHcmFkaWVudCh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgaWYgKCFjYWNoZS5pbmNsdWRlcyh2YWx1ZSkpIHtcbiAgICAgIGNhY2hlLnB1c2godmFsdWUpO1xuICAgIH1cbiAgICByZXR1cm4gY2FjaGUuaW5kZXhPZih2YWx1ZSk7XG4gIH07XG4gIHJldHVybiBKU09OLnN0cmluZ2lmeShzdHlsZSwgcmVwbGFjZXIpICE9PSBKU09OLnN0cmluZ2lmeShwcmV2U3R5bGUsIHJlcGxhY2VyKTtcbn1cbiIsICJpbXBvcnQge3JlcXVlc3RBbmltRnJhbWV9IGZyb20gJy4uL2hlbHBlcnMvaGVscGVycy5leHRyYXMuanMnO1xuXG4vKipcbiAqIEB0eXBlZGVmIHsgaW1wb3J0KCcuL2NvcmUuYW5pbWF0aW9uLmpzJykuZGVmYXVsdCB9IEFuaW1hdGlvblxuICogQHR5cGVkZWYgeyBpbXBvcnQoJy4vY29yZS5jb250cm9sbGVyLmpzJykuZGVmYXVsdCB9IENoYXJ0XG4gKi9cblxuLyoqXG4gKiBQbGVhc2UgdXNlIHRoZSBtb2R1bGUncyBkZWZhdWx0IGV4cG9ydCB3aGljaCBwcm92aWRlcyBhIHNpbmdsZXRvbiBpbnN0YW5jZVxuICogTm90ZTogY2xhc3MgaXMgZXhwb3J0IGZvciB0eXBlZG9jXG4gKi9cbmV4cG9ydCBjbGFzcyBBbmltYXRvciB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuX3JlcXVlc3QgPSBudWxsO1xuICAgIHRoaXMuX2NoYXJ0cyA9IG5ldyBNYXAoKTtcbiAgICB0aGlzLl9ydW5uaW5nID0gZmFsc2U7XG4gICAgdGhpcy5fbGFzdERhdGUgPSB1bmRlZmluZWQ7XG4gIH1cblxuICAvKipcblx0ICogQHByaXZhdGVcblx0ICovXG4gIF9ub3RpZnkoY2hhcnQsIGFuaW1zLCBkYXRlLCB0eXBlKSB7XG4gICAgY29uc3QgY2FsbGJhY2tzID0gYW5pbXMubGlzdGVuZXJzW3R5cGVdO1xuICAgIGNvbnN0IG51bVN0ZXBzID0gYW5pbXMuZHVyYXRpb247XG5cbiAgICBjYWxsYmFja3MuZm9yRWFjaChmbiA9PiBmbih7XG4gICAgICBjaGFydCxcbiAgICAgIGluaXRpYWw6IGFuaW1zLmluaXRpYWwsXG4gICAgICBudW1TdGVwcyxcbiAgICAgIGN1cnJlbnRTdGVwOiBNYXRoLm1pbihkYXRlIC0gYW5pbXMuc3RhcnQsIG51bVN0ZXBzKVxuICAgIH0pKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgX3JlZnJlc2goKSB7XG4gICAgaWYgKHRoaXMuX3JlcXVlc3QpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5fcnVubmluZyA9IHRydWU7XG5cbiAgICB0aGlzLl9yZXF1ZXN0ID0gcmVxdWVzdEFuaW1GcmFtZS5jYWxsKHdpbmRvdywgKCkgPT4ge1xuICAgICAgdGhpcy5fdXBkYXRlKCk7XG4gICAgICB0aGlzLl9yZXF1ZXN0ID0gbnVsbDtcblxuICAgICAgaWYgKHRoaXMuX3J1bm5pbmcpIHtcbiAgICAgICAgdGhpcy5fcmVmcmVzaCgpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfdXBkYXRlKGRhdGUgPSBEYXRlLm5vdygpKSB7XG4gICAgbGV0IHJlbWFpbmluZyA9IDA7XG5cbiAgICB0aGlzLl9jaGFydHMuZm9yRWFjaCgoYW5pbXMsIGNoYXJ0KSA9PiB7XG4gICAgICBpZiAoIWFuaW1zLnJ1bm5pbmcgfHwgIWFuaW1zLml0ZW1zLmxlbmd0aCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBpdGVtcyA9IGFuaW1zLml0ZW1zO1xuICAgICAgbGV0IGkgPSBpdGVtcy5sZW5ndGggLSAxO1xuICAgICAgbGV0IGRyYXcgPSBmYWxzZTtcbiAgICAgIGxldCBpdGVtO1xuXG4gICAgICBmb3IgKDsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgaXRlbSA9IGl0ZW1zW2ldO1xuXG4gICAgICAgIGlmIChpdGVtLl9hY3RpdmUpIHtcbiAgICAgICAgICBpZiAoaXRlbS5fdG90YWwgPiBhbmltcy5kdXJhdGlvbikge1xuICAgICAgICAgICAgLy8gaWYgdGhlIGFuaW1hdGlvbiBoYXMgYmVlbiB1cGRhdGVkIGFuZCBpdHMgZHVyYXRpb24gcHJvbG9uZ2VkLFxuICAgICAgICAgICAgLy8gdXBkYXRlIHRvIHRvdGFsIGR1cmF0aW9uIG9mIGN1cnJlbnQgYW5pbWF0aW9ucyBydW4gKGZvciBwcm9ncmVzcyBldmVudClcbiAgICAgICAgICAgIGFuaW1zLmR1cmF0aW9uID0gaXRlbS5fdG90YWw7XG4gICAgICAgICAgfVxuICAgICAgICAgIGl0ZW0udGljayhkYXRlKTtcbiAgICAgICAgICBkcmF3ID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBSZW1vdmUgdGhlIGl0ZW0gYnkgcmVwbGFjaW5nIGl0IHdpdGggbGFzdCBpdGVtIGFuZCByZW1vdmluZyB0aGUgbGFzdFxuICAgICAgICAgIC8vIEEgbG90IGZhc3RlciB0aGFuIHNwbGljZS5cbiAgICAgICAgICBpdGVtc1tpXSA9IGl0ZW1zW2l0ZW1zLmxlbmd0aCAtIDFdO1xuICAgICAgICAgIGl0ZW1zLnBvcCgpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChkcmF3KSB7XG4gICAgICAgIGNoYXJ0LmRyYXcoKTtcbiAgICAgICAgdGhpcy5fbm90aWZ5KGNoYXJ0LCBhbmltcywgZGF0ZSwgJ3Byb2dyZXNzJyk7XG4gICAgICB9XG5cbiAgICAgIGlmICghaXRlbXMubGVuZ3RoKSB7XG4gICAgICAgIGFuaW1zLnJ1bm5pbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fbm90aWZ5KGNoYXJ0LCBhbmltcywgZGF0ZSwgJ2NvbXBsZXRlJyk7XG4gICAgICAgIGFuaW1zLmluaXRpYWwgPSBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgcmVtYWluaW5nICs9IGl0ZW1zLmxlbmd0aDtcbiAgICB9KTtcblxuICAgIHRoaXMuX2xhc3REYXRlID0gZGF0ZTtcblxuICAgIGlmIChyZW1haW5pbmcgPT09IDApIHtcbiAgICAgIHRoaXMuX3J1bm5pbmcgPSBmYWxzZTtcbiAgICB9XG4gIH1cblxuICAvKipcblx0ICogQHByaXZhdGVcblx0ICovXG4gIF9nZXRBbmltcyhjaGFydCkge1xuICAgIGNvbnN0IGNoYXJ0cyA9IHRoaXMuX2NoYXJ0cztcbiAgICBsZXQgYW5pbXMgPSBjaGFydHMuZ2V0KGNoYXJ0KTtcbiAgICBpZiAoIWFuaW1zKSB7XG4gICAgICBhbmltcyA9IHtcbiAgICAgICAgcnVubmluZzogZmFsc2UsXG4gICAgICAgIGluaXRpYWw6IHRydWUsXG4gICAgICAgIGl0ZW1zOiBbXSxcbiAgICAgICAgbGlzdGVuZXJzOiB7XG4gICAgICAgICAgY29tcGxldGU6IFtdLFxuICAgICAgICAgIHByb2dyZXNzOiBbXVxuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgY2hhcnRzLnNldChjaGFydCwgYW5pbXMpO1xuICAgIH1cbiAgICByZXR1cm4gYW5pbXM7XG4gIH1cblxuICAvKipcblx0ICogQHBhcmFtIHtDaGFydH0gY2hhcnRcblx0ICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50IC0gZXZlbnQgbmFtZVxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYiAtIGNhbGxiYWNrXG5cdCAqL1xuICBsaXN0ZW4oY2hhcnQsIGV2ZW50LCBjYikge1xuICAgIHRoaXMuX2dldEFuaW1zKGNoYXJ0KS5saXN0ZW5lcnNbZXZlbnRdLnB1c2goY2IpO1xuICB9XG5cbiAgLyoqXG5cdCAqIEFkZCBhbmltYXRpb25zXG5cdCAqIEBwYXJhbSB7Q2hhcnR9IGNoYXJ0XG5cdCAqIEBwYXJhbSB7QW5pbWF0aW9uW119IGl0ZW1zIC0gYW5pbWF0aW9uc1xuXHQgKi9cbiAgYWRkKGNoYXJ0LCBpdGVtcykge1xuICAgIGlmICghaXRlbXMgfHwgIWl0ZW1zLmxlbmd0aCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLl9nZXRBbmltcyhjaGFydCkuaXRlbXMucHVzaCguLi5pdGVtcyk7XG4gIH1cblxuICAvKipcblx0ICogQ291bnRzIG51bWJlciBvZiBhY3RpdmUgYW5pbWF0aW9ucyBmb3IgdGhlIGNoYXJ0XG5cdCAqIEBwYXJhbSB7Q2hhcnR9IGNoYXJ0XG5cdCAqL1xuICBoYXMoY2hhcnQpIHtcbiAgICByZXR1cm4gdGhpcy5fZ2V0QW5pbXMoY2hhcnQpLml0ZW1zLmxlbmd0aCA+IDA7XG4gIH1cblxuICAvKipcblx0ICogU3RhcnQgYW5pbWF0aW5nIChhbGwgY2hhcnRzKVxuXHQgKiBAcGFyYW0ge0NoYXJ0fSBjaGFydFxuXHQgKi9cbiAgc3RhcnQoY2hhcnQpIHtcbiAgICBjb25zdCBhbmltcyA9IHRoaXMuX2NoYXJ0cy5nZXQoY2hhcnQpO1xuICAgIGlmICghYW5pbXMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgYW5pbXMucnVubmluZyA9IHRydWU7XG4gICAgYW5pbXMuc3RhcnQgPSBEYXRlLm5vdygpO1xuICAgIGFuaW1zLmR1cmF0aW9uID0gYW5pbXMuaXRlbXMucmVkdWNlKChhY2MsIGN1cikgPT4gTWF0aC5tYXgoYWNjLCBjdXIuX2R1cmF0aW9uKSwgMCk7XG4gICAgdGhpcy5fcmVmcmVzaCgpO1xuICB9XG5cbiAgcnVubmluZyhjaGFydCkge1xuICAgIGlmICghdGhpcy5fcnVubmluZykge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCBhbmltcyA9IHRoaXMuX2NoYXJ0cy5nZXQoY2hhcnQpO1xuICAgIGlmICghYW5pbXMgfHwgIWFuaW1zLnJ1bm5pbmcgfHwgIWFuaW1zLml0ZW1zLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBTdG9wIGFsbCBhbmltYXRpb25zIGZvciB0aGUgY2hhcnRcblx0ICogQHBhcmFtIHtDaGFydH0gY2hhcnRcblx0ICovXG4gIHN0b3AoY2hhcnQpIHtcbiAgICBjb25zdCBhbmltcyA9IHRoaXMuX2NoYXJ0cy5nZXQoY2hhcnQpO1xuICAgIGlmICghYW5pbXMgfHwgIWFuaW1zLml0ZW1zLmxlbmd0aCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBpdGVtcyA9IGFuaW1zLml0ZW1zO1xuICAgIGxldCBpID0gaXRlbXMubGVuZ3RoIC0gMTtcblxuICAgIGZvciAoOyBpID49IDA7IC0taSkge1xuICAgICAgaXRlbXNbaV0uY2FuY2VsKCk7XG4gICAgfVxuICAgIGFuaW1zLml0ZW1zID0gW107XG4gICAgdGhpcy5fbm90aWZ5KGNoYXJ0LCBhbmltcywgRGF0ZS5ub3coKSwgJ2NvbXBsZXRlJyk7XG4gIH1cblxuICAvKipcblx0ICogUmVtb3ZlIGNoYXJ0IGZyb20gQW5pbWF0b3Jcblx0ICogQHBhcmFtIHtDaGFydH0gY2hhcnRcblx0ICovXG4gIHJlbW92ZShjaGFydCkge1xuICAgIHJldHVybiB0aGlzLl9jaGFydHMuZGVsZXRlKGNoYXJ0KTtcbiAgfVxufVxuXG4vLyBzaW5nbGV0b24gaW5zdGFuY2VcbmV4cG9ydCBkZWZhdWx0IC8qICNfX1BVUkVfXyAqLyBuZXcgQW5pbWF0b3IoKTtcbiIsICJpbXBvcnQgZWZmZWN0cyBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMuZWFzaW5nLmpzJztcbmltcG9ydCB7cmVzb2x2ZX0gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLm9wdGlvbnMuanMnO1xuaW1wb3J0IHtjb2xvciBhcyBoZWxwZXJzQ29sb3J9IGZyb20gJy4uL2hlbHBlcnMvaGVscGVycy5jb2xvci5qcyc7XG5cbmNvbnN0IHRyYW5zcGFyZW50ID0gJ3RyYW5zcGFyZW50JztcbmNvbnN0IGludGVycG9sYXRvcnMgPSB7XG4gIGJvb2xlYW4oZnJvbSwgdG8sIGZhY3Rvcikge1xuICAgIHJldHVybiBmYWN0b3IgPiAwLjUgPyB0byA6IGZyb207XG4gIH0sXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZnJvbVxuICAgKiBAcGFyYW0ge3N0cmluZ30gdG9cbiAgICogQHBhcmFtIHtudW1iZXJ9IGZhY3RvclxuICAgKi9cbiAgY29sb3IoZnJvbSwgdG8sIGZhY3Rvcikge1xuICAgIGNvbnN0IGMwID0gaGVscGVyc0NvbG9yKGZyb20gfHwgdHJhbnNwYXJlbnQpO1xuICAgIGNvbnN0IGMxID0gYzAudmFsaWQgJiYgaGVscGVyc0NvbG9yKHRvIHx8IHRyYW5zcGFyZW50KTtcbiAgICByZXR1cm4gYzEgJiYgYzEudmFsaWRcbiAgICAgID8gYzEubWl4KGMwLCBmYWN0b3IpLmhleFN0cmluZygpXG4gICAgICA6IHRvO1xuICB9LFxuICBudW1iZXIoZnJvbSwgdG8sIGZhY3Rvcikge1xuICAgIHJldHVybiBmcm9tICsgKHRvIC0gZnJvbSkgKiBmYWN0b3I7XG4gIH1cbn07XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEFuaW1hdGlvbiB7XG4gIGNvbnN0cnVjdG9yKGNmZywgdGFyZ2V0LCBwcm9wLCB0bykge1xuICAgIGNvbnN0IGN1cnJlbnRWYWx1ZSA9IHRhcmdldFtwcm9wXTtcblxuICAgIHRvID0gcmVzb2x2ZShbY2ZnLnRvLCB0bywgY3VycmVudFZhbHVlLCBjZmcuZnJvbV0pO1xuICAgIGNvbnN0IGZyb20gPSByZXNvbHZlKFtjZmcuZnJvbSwgY3VycmVudFZhbHVlLCB0b10pO1xuXG4gICAgdGhpcy5fYWN0aXZlID0gdHJ1ZTtcbiAgICB0aGlzLl9mbiA9IGNmZy5mbiB8fCBpbnRlcnBvbGF0b3JzW2NmZy50eXBlIHx8IHR5cGVvZiBmcm9tXTtcbiAgICB0aGlzLl9lYXNpbmcgPSBlZmZlY3RzW2NmZy5lYXNpbmddIHx8IGVmZmVjdHMubGluZWFyO1xuICAgIHRoaXMuX3N0YXJ0ID0gTWF0aC5mbG9vcihEYXRlLm5vdygpICsgKGNmZy5kZWxheSB8fCAwKSk7XG4gICAgdGhpcy5fZHVyYXRpb24gPSB0aGlzLl90b3RhbCA9IE1hdGguZmxvb3IoY2ZnLmR1cmF0aW9uKTtcbiAgICB0aGlzLl9sb29wID0gISFjZmcubG9vcDtcbiAgICB0aGlzLl90YXJnZXQgPSB0YXJnZXQ7XG4gICAgdGhpcy5fcHJvcCA9IHByb3A7XG4gICAgdGhpcy5fZnJvbSA9IGZyb207XG4gICAgdGhpcy5fdG8gPSB0bztcbiAgICB0aGlzLl9wcm9taXNlcyA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIGFjdGl2ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fYWN0aXZlO1xuICB9XG5cbiAgdXBkYXRlKGNmZywgdG8sIGRhdGUpIHtcbiAgICBpZiAodGhpcy5fYWN0aXZlKSB7XG4gICAgICB0aGlzLl9ub3RpZnkoZmFsc2UpO1xuXG4gICAgICBjb25zdCBjdXJyZW50VmFsdWUgPSB0aGlzLl90YXJnZXRbdGhpcy5fcHJvcF07XG4gICAgICBjb25zdCBlbGFwc2VkID0gZGF0ZSAtIHRoaXMuX3N0YXJ0O1xuICAgICAgY29uc3QgcmVtYWluID0gdGhpcy5fZHVyYXRpb24gLSBlbGFwc2VkO1xuICAgICAgdGhpcy5fc3RhcnQgPSBkYXRlO1xuICAgICAgdGhpcy5fZHVyYXRpb24gPSBNYXRoLmZsb29yKE1hdGgubWF4KHJlbWFpbiwgY2ZnLmR1cmF0aW9uKSk7XG4gICAgICB0aGlzLl90b3RhbCArPSBlbGFwc2VkO1xuICAgICAgdGhpcy5fbG9vcCA9ICEhY2ZnLmxvb3A7XG4gICAgICB0aGlzLl90byA9IHJlc29sdmUoW2NmZy50bywgdG8sIGN1cnJlbnRWYWx1ZSwgY2ZnLmZyb21dKTtcbiAgICAgIHRoaXMuX2Zyb20gPSByZXNvbHZlKFtjZmcuZnJvbSwgY3VycmVudFZhbHVlLCB0b10pO1xuICAgIH1cbiAgfVxuXG4gIGNhbmNlbCgpIHtcbiAgICBpZiAodGhpcy5fYWN0aXZlKSB7XG4gICAgICAvLyB1cGRhdGUgY3VycmVudCBldmFsdWF0ZWQgdmFsdWUsIGZvciBzbW9vdGhlciBhbmltYXRpb25zXG4gICAgICB0aGlzLnRpY2soRGF0ZS5ub3coKSk7XG4gICAgICB0aGlzLl9hY3RpdmUgPSBmYWxzZTtcbiAgICAgIHRoaXMuX25vdGlmeShmYWxzZSk7XG4gICAgfVxuICB9XG5cbiAgdGljayhkYXRlKSB7XG4gICAgY29uc3QgZWxhcHNlZCA9IGRhdGUgLSB0aGlzLl9zdGFydDtcbiAgICBjb25zdCBkdXJhdGlvbiA9IHRoaXMuX2R1cmF0aW9uO1xuICAgIGNvbnN0IHByb3AgPSB0aGlzLl9wcm9wO1xuICAgIGNvbnN0IGZyb20gPSB0aGlzLl9mcm9tO1xuICAgIGNvbnN0IGxvb3AgPSB0aGlzLl9sb29wO1xuICAgIGNvbnN0IHRvID0gdGhpcy5fdG87XG4gICAgbGV0IGZhY3RvcjtcblxuICAgIHRoaXMuX2FjdGl2ZSA9IGZyb20gIT09IHRvICYmIChsb29wIHx8IChlbGFwc2VkIDwgZHVyYXRpb24pKTtcblxuICAgIGlmICghdGhpcy5fYWN0aXZlKSB7XG4gICAgICB0aGlzLl90YXJnZXRbcHJvcF0gPSB0bztcbiAgICAgIHRoaXMuX25vdGlmeSh0cnVlKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoZWxhcHNlZCA8IDApIHtcbiAgICAgIHRoaXMuX3RhcmdldFtwcm9wXSA9IGZyb207XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZmFjdG9yID0gKGVsYXBzZWQgLyBkdXJhdGlvbikgJSAyO1xuICAgIGZhY3RvciA9IGxvb3AgJiYgZmFjdG9yID4gMSA/IDIgLSBmYWN0b3IgOiBmYWN0b3I7XG4gICAgZmFjdG9yID0gdGhpcy5fZWFzaW5nKE1hdGgubWluKDEsIE1hdGgubWF4KDAsIGZhY3RvcikpKTtcblxuICAgIHRoaXMuX3RhcmdldFtwcm9wXSA9IHRoaXMuX2ZuKGZyb20sIHRvLCBmYWN0b3IpO1xuICB9XG5cbiAgd2FpdCgpIHtcbiAgICBjb25zdCBwcm9taXNlcyA9IHRoaXMuX3Byb21pc2VzIHx8ICh0aGlzLl9wcm9taXNlcyA9IFtdKTtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlcywgcmVqKSA9PiB7XG4gICAgICBwcm9taXNlcy5wdXNoKHtyZXMsIHJlan0pO1xuICAgIH0pO1xuICB9XG5cbiAgX25vdGlmeShyZXNvbHZlZCkge1xuICAgIGNvbnN0IG1ldGhvZCA9IHJlc29sdmVkID8gJ3JlcycgOiAncmVqJztcbiAgICBjb25zdCBwcm9taXNlcyA9IHRoaXMuX3Byb21pc2VzIHx8IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcHJvbWlzZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHByb21pc2VzW2ldW21ldGhvZF0oKTtcbiAgICB9XG4gIH1cbn1cbiIsICJpbXBvcnQgYW5pbWF0b3IgZnJvbSAnLi9jb3JlLmFuaW1hdG9yLmpzJztcbmltcG9ydCBBbmltYXRpb24gZnJvbSAnLi9jb3JlLmFuaW1hdGlvbi5qcyc7XG5pbXBvcnQgZGVmYXVsdHMgZnJvbSAnLi9jb3JlLmRlZmF1bHRzLmpzJztcbmltcG9ydCB7aXNBcnJheSwgaXNPYmplY3R9IGZyb20gJy4uL2hlbHBlcnMvaGVscGVycy5jb3JlLmpzJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQW5pbWF0aW9ucyB7XG4gIGNvbnN0cnVjdG9yKGNoYXJ0LCBjb25maWcpIHtcbiAgICB0aGlzLl9jaGFydCA9IGNoYXJ0O1xuICAgIHRoaXMuX3Byb3BlcnRpZXMgPSBuZXcgTWFwKCk7XG4gICAgdGhpcy5jb25maWd1cmUoY29uZmlnKTtcbiAgfVxuXG4gIGNvbmZpZ3VyZShjb25maWcpIHtcbiAgICBpZiAoIWlzT2JqZWN0KGNvbmZpZykpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBhbmltYXRpb25PcHRpb25zID0gT2JqZWN0LmtleXMoZGVmYXVsdHMuYW5pbWF0aW9uKTtcbiAgICBjb25zdCBhbmltYXRlZFByb3BzID0gdGhpcy5fcHJvcGVydGllcztcblxuICAgIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKGNvbmZpZykuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgY29uc3QgY2ZnID0gY29uZmlnW2tleV07XG4gICAgICBpZiAoIWlzT2JqZWN0KGNmZykpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgcmVzb2x2ZWQgPSB7fTtcbiAgICAgIGZvciAoY29uc3Qgb3B0aW9uIG9mIGFuaW1hdGlvbk9wdGlvbnMpIHtcbiAgICAgICAgcmVzb2x2ZWRbb3B0aW9uXSA9IGNmZ1tvcHRpb25dO1xuICAgICAgfVxuXG4gICAgICAoaXNBcnJheShjZmcucHJvcGVydGllcykgJiYgY2ZnLnByb3BlcnRpZXMgfHwgW2tleV0pLmZvckVhY2goKHByb3ApID0+IHtcbiAgICAgICAgaWYgKHByb3AgPT09IGtleSB8fCAhYW5pbWF0ZWRQcm9wcy5oYXMocHJvcCkpIHtcbiAgICAgICAgICBhbmltYXRlZFByb3BzLnNldChwcm9wLCByZXNvbHZlZCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG5cdCAqIFV0aWxpdHkgdG8gaGFuZGxlIGFuaW1hdGlvbiBvZiBgb3B0aW9uc2AuXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfYW5pbWF0ZU9wdGlvbnModGFyZ2V0LCB2YWx1ZXMpIHtcbiAgICBjb25zdCBuZXdPcHRpb25zID0gdmFsdWVzLm9wdGlvbnM7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHJlc29sdmVUYXJnZXRPcHRpb25zKHRhcmdldCwgbmV3T3B0aW9ucyk7XG4gICAgaWYgKCFvcHRpb25zKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuXG4gICAgY29uc3QgYW5pbWF0aW9ucyA9IHRoaXMuX2NyZWF0ZUFuaW1hdGlvbnMob3B0aW9ucywgbmV3T3B0aW9ucyk7XG4gICAgaWYgKG5ld09wdGlvbnMuJHNoYXJlZCkge1xuICAgICAgLy8gR29pbmcgdG8gc2hhcmVkIG9wdGlvbnM6XG4gICAgICAvLyBBZnRlciBhbGwgYW5pbWF0aW9ucyBhcmUgZG9uZSwgYXNzaWduIHRoZSBzaGFyZWQgb3B0aW9ucyBvYmplY3QgdG8gdGhlIGVsZW1lbnRcbiAgICAgIC8vIFNvIGFueSBuZXcgdXBkYXRlcyB0byB0aGUgc2hhcmVkIG9wdGlvbnMgYXJlIG9ic2VydmVkXG4gICAgICBhd2FpdEFsbCh0YXJnZXQub3B0aW9ucy4kYW5pbWF0aW9ucywgbmV3T3B0aW9ucykudGhlbigoKSA9PiB7XG4gICAgICAgIHRhcmdldC5vcHRpb25zID0gbmV3T3B0aW9ucztcbiAgICAgIH0sICgpID0+IHtcbiAgICAgICAgLy8gcmVqZWN0ZWQsIG5vb3BcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiBhbmltYXRpb25zO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfY3JlYXRlQW5pbWF0aW9ucyh0YXJnZXQsIHZhbHVlcykge1xuICAgIGNvbnN0IGFuaW1hdGVkUHJvcHMgPSB0aGlzLl9wcm9wZXJ0aWVzO1xuICAgIGNvbnN0IGFuaW1hdGlvbnMgPSBbXTtcbiAgICBjb25zdCBydW5uaW5nID0gdGFyZ2V0LiRhbmltYXRpb25zIHx8ICh0YXJnZXQuJGFuaW1hdGlvbnMgPSB7fSk7XG4gICAgY29uc3QgcHJvcHMgPSBPYmplY3Qua2V5cyh2YWx1ZXMpO1xuICAgIGNvbnN0IGRhdGUgPSBEYXRlLm5vdygpO1xuICAgIGxldCBpO1xuXG4gICAgZm9yIChpID0gcHJvcHMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgIGNvbnN0IHByb3AgPSBwcm9wc1tpXTtcbiAgICAgIGlmIChwcm9wLmNoYXJBdCgwKSA9PT0gJyQnKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAocHJvcCA9PT0gJ29wdGlvbnMnKSB7XG4gICAgICAgIGFuaW1hdGlvbnMucHVzaCguLi50aGlzLl9hbmltYXRlT3B0aW9ucyh0YXJnZXQsIHZhbHVlcykpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHZhbHVlID0gdmFsdWVzW3Byb3BdO1xuICAgICAgbGV0IGFuaW1hdGlvbiA9IHJ1bm5pbmdbcHJvcF07XG4gICAgICBjb25zdCBjZmcgPSBhbmltYXRlZFByb3BzLmdldChwcm9wKTtcblxuICAgICAgaWYgKGFuaW1hdGlvbikge1xuICAgICAgICBpZiAoY2ZnICYmIGFuaW1hdGlvbi5hY3RpdmUoKSkge1xuICAgICAgICAgIC8vIFRoZXJlIGlzIGFuIGV4aXN0aW5nIGFjdGl2ZSBhbmltYXRpb24sIGxldCdzIHVwZGF0ZSB0aGF0XG4gICAgICAgICAgYW5pbWF0aW9uLnVwZGF0ZShjZmcsIHZhbHVlLCBkYXRlKTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhbmltYXRpb24uY2FuY2VsKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICghY2ZnIHx8ICFjZmcuZHVyYXRpb24pIHtcbiAgICAgICAgLy8gbm90IGFuaW1hdGVkLCBzZXQgZGlyZWN0bHkgdG8gbmV3IHZhbHVlXG4gICAgICAgIHRhcmdldFtwcm9wXSA9IHZhbHVlO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgcnVubmluZ1twcm9wXSA9IGFuaW1hdGlvbiA9IG5ldyBBbmltYXRpb24oY2ZnLCB0YXJnZXQsIHByb3AsIHZhbHVlKTtcbiAgICAgIGFuaW1hdGlvbnMucHVzaChhbmltYXRpb24pO1xuICAgIH1cbiAgICByZXR1cm4gYW5pbWF0aW9ucztcbiAgfVxuXG5cbiAgLyoqXG5cdCAqIFVwZGF0ZSBgdGFyZ2V0YCBwcm9wZXJ0aWVzIHRvIG5ldyB2YWx1ZXMsIHVzaW5nIGNvbmZpZ3VyZWQgYW5pbWF0aW9uc1xuXHQgKiBAcGFyYW0ge29iamVjdH0gdGFyZ2V0IC0gb2JqZWN0IHRvIHVwZGF0ZVxuXHQgKiBAcGFyYW0ge29iamVjdH0gdmFsdWVzIC0gbmV3IHRhcmdldCBwcm9wZXJ0aWVzXG5cdCAqIEByZXR1cm5zIHtib29sZWFufHVuZGVmaW5lZH0gLSBgdHJ1ZWAgaWYgYW5pbWF0aW9ucyB3ZXJlIHN0YXJ0ZWRcblx0ICoqL1xuICB1cGRhdGUodGFyZ2V0LCB2YWx1ZXMpIHtcbiAgICBpZiAodGhpcy5fcHJvcGVydGllcy5zaXplID09PSAwKSB7XG4gICAgICAvLyBOb3RoaW5nIGlzIGFuaW1hdGVkLCBqdXN0IGFwcGx5IHRoZSBuZXcgdmFsdWVzLlxuICAgICAgT2JqZWN0LmFzc2lnbih0YXJnZXQsIHZhbHVlcyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgYW5pbWF0aW9ucyA9IHRoaXMuX2NyZWF0ZUFuaW1hdGlvbnModGFyZ2V0LCB2YWx1ZXMpO1xuXG4gICAgaWYgKGFuaW1hdGlvbnMubGVuZ3RoKSB7XG4gICAgICBhbmltYXRvci5hZGQodGhpcy5fY2hhcnQsIGFuaW1hdGlvbnMpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGF3YWl0QWxsKGFuaW1hdGlvbnMsIHByb3BlcnRpZXMpIHtcbiAgY29uc3QgcnVubmluZyA9IFtdO1xuICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMocHJvcGVydGllcyk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGFuaW0gPSBhbmltYXRpb25zW2tleXNbaV1dO1xuICAgIGlmIChhbmltICYmIGFuaW0uYWN0aXZlKCkpIHtcbiAgICAgIHJ1bm5pbmcucHVzaChhbmltLndhaXQoKSk7XG4gICAgfVxuICB9XG4gIC8vIEB0cy1pZ25vcmVcbiAgcmV0dXJuIFByb21pc2UuYWxsKHJ1bm5pbmcpO1xufVxuXG5mdW5jdGlvbiByZXNvbHZlVGFyZ2V0T3B0aW9ucyh0YXJnZXQsIG5ld09wdGlvbnMpIHtcbiAgaWYgKCFuZXdPcHRpb25zKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGxldCBvcHRpb25zID0gdGFyZ2V0Lm9wdGlvbnM7XG4gIGlmICghb3B0aW9ucykge1xuICAgIHRhcmdldC5vcHRpb25zID0gbmV3T3B0aW9ucztcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKG9wdGlvbnMuJHNoYXJlZCkge1xuICAgIC8vIEdvaW5nIGZyb20gc2hhcmVkIG9wdGlvbnMgdG8gZGlzdGluY3Qgb25lOlxuICAgIC8vIENyZWF0ZSBuZXcgb3B0aW9ucyBvYmplY3QgY29udGFpbmluZyB0aGUgb2xkIHNoYXJlZCB2YWx1ZXMgYW5kIHN0YXJ0IHVwZGF0aW5nIHRoYXQuXG4gICAgdGFyZ2V0Lm9wdGlvbnMgPSBvcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucywgeyRzaGFyZWQ6IGZhbHNlLCAkYW5pbWF0aW9uczoge319KTtcbiAgfVxuICByZXR1cm4gb3B0aW9ucztcbn1cbiIsICJpbXBvcnQgQW5pbWF0aW9ucyBmcm9tICcuL2NvcmUuYW5pbWF0aW9ucy5qcyc7XG5pbXBvcnQgZGVmYXVsdHMgZnJvbSAnLi9jb3JlLmRlZmF1bHRzLmpzJztcbmltcG9ydCB7aXNBcnJheSwgaXNGaW5pdGUsIGlzT2JqZWN0LCB2YWx1ZU9yRGVmYXVsdCwgcmVzb2x2ZU9iamVjdEtleSwgZGVmaW5lZH0gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLmNvcmUuanMnO1xuaW1wb3J0IHtsaXN0ZW5BcnJheUV2ZW50cywgdW5saXN0ZW5BcnJheUV2ZW50c30gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLmNvbGxlY3Rpb24uanMnO1xuaW1wb3J0IHtjcmVhdGVDb250ZXh0LCBzaWdufSBmcm9tICcuLi9oZWxwZXJzL2luZGV4LmpzJztcblxuLyoqXG4gKiBAdHlwZWRlZiB7IGltcG9ydCgnLi9jb3JlLmNvbnRyb2xsZXIuanMnKS5kZWZhdWx0IH0gQ2hhcnRcbiAqIEB0eXBlZGVmIHsgaW1wb3J0KCcuL2NvcmUuc2NhbGUuanMnKS5kZWZhdWx0IH0gU2NhbGVcbiAqL1xuXG5mdW5jdGlvbiBzY2FsZUNsaXAoc2NhbGUsIGFsbG93ZWRPdmVyZmxvdykge1xuICBjb25zdCBvcHRzID0gc2NhbGUgJiYgc2NhbGUub3B0aW9ucyB8fCB7fTtcbiAgY29uc3QgcmV2ZXJzZSA9IG9wdHMucmV2ZXJzZTtcbiAgY29uc3QgbWluID0gb3B0cy5taW4gPT09IHVuZGVmaW5lZCA/IGFsbG93ZWRPdmVyZmxvdyA6IDA7XG4gIGNvbnN0IG1heCA9IG9wdHMubWF4ID09PSB1bmRlZmluZWQgPyBhbGxvd2VkT3ZlcmZsb3cgOiAwO1xuICByZXR1cm4ge1xuICAgIHN0YXJ0OiByZXZlcnNlID8gbWF4IDogbWluLFxuICAgIGVuZDogcmV2ZXJzZSA/IG1pbiA6IG1heFxuICB9O1xufVxuXG5mdW5jdGlvbiBkZWZhdWx0Q2xpcCh4U2NhbGUsIHlTY2FsZSwgYWxsb3dlZE92ZXJmbG93KSB7XG4gIGlmIChhbGxvd2VkT3ZlcmZsb3cgPT09IGZhbHNlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNvbnN0IHggPSBzY2FsZUNsaXAoeFNjYWxlLCBhbGxvd2VkT3ZlcmZsb3cpO1xuICBjb25zdCB5ID0gc2NhbGVDbGlwKHlTY2FsZSwgYWxsb3dlZE92ZXJmbG93KTtcblxuICByZXR1cm4ge1xuICAgIHRvcDogeS5lbmQsXG4gICAgcmlnaHQ6IHguZW5kLFxuICAgIGJvdHRvbTogeS5zdGFydCxcbiAgICBsZWZ0OiB4LnN0YXJ0XG4gIH07XG59XG5cbmZ1bmN0aW9uIHRvQ2xpcCh2YWx1ZSkge1xuICBsZXQgdCwgciwgYiwgbDtcblxuICBpZiAoaXNPYmplY3QodmFsdWUpKSB7XG4gICAgdCA9IHZhbHVlLnRvcDtcbiAgICByID0gdmFsdWUucmlnaHQ7XG4gICAgYiA9IHZhbHVlLmJvdHRvbTtcbiAgICBsID0gdmFsdWUubGVmdDtcbiAgfSBlbHNlIHtcbiAgICB0ID0gciA9IGIgPSBsID0gdmFsdWU7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHRvcDogdCxcbiAgICByaWdodDogcixcbiAgICBib3R0b206IGIsXG4gICAgbGVmdDogbCxcbiAgICBkaXNhYmxlZDogdmFsdWUgPT09IGZhbHNlXG4gIH07XG59XG5cbmZ1bmN0aW9uIGdldFNvcnRlZERhdGFzZXRJbmRpY2VzKGNoYXJ0LCBmaWx0ZXJWaXNpYmxlKSB7XG4gIGNvbnN0IGtleXMgPSBbXTtcbiAgY29uc3QgbWV0YXNldHMgPSBjaGFydC5fZ2V0U29ydGVkRGF0YXNldE1ldGFzKGZpbHRlclZpc2libGUpO1xuICBsZXQgaSwgaWxlbjtcblxuICBmb3IgKGkgPSAwLCBpbGVuID0gbWV0YXNldHMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAga2V5cy5wdXNoKG1ldGFzZXRzW2ldLmluZGV4KTtcbiAgfVxuICByZXR1cm4ga2V5cztcbn1cblxuZnVuY3Rpb24gYXBwbHlTdGFjayhzdGFjaywgdmFsdWUsIGRzSW5kZXgsIG9wdGlvbnMgPSB7fSkge1xuICBjb25zdCBrZXlzID0gc3RhY2sua2V5cztcbiAgY29uc3Qgc2luZ2xlTW9kZSA9IG9wdGlvbnMubW9kZSA9PT0gJ3NpbmdsZSc7XG4gIGxldCBpLCBpbGVuLCBkYXRhc2V0SW5kZXgsIG90aGVyVmFsdWU7XG5cbiAgaWYgKHZhbHVlID09PSBudWxsKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgZm9yIChpID0gMCwgaWxlbiA9IGtleXMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgZGF0YXNldEluZGV4ID0gK2tleXNbaV07XG4gICAgaWYgKGRhdGFzZXRJbmRleCA9PT0gZHNJbmRleCkge1xuICAgICAgaWYgKG9wdGlvbnMuYWxsKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIG90aGVyVmFsdWUgPSBzdGFjay52YWx1ZXNbZGF0YXNldEluZGV4XTtcbiAgICBpZiAoaXNGaW5pdGUob3RoZXJWYWx1ZSkgJiYgKHNpbmdsZU1vZGUgfHwgKHZhbHVlID09PSAwIHx8IHNpZ24odmFsdWUpID09PSBzaWduKG90aGVyVmFsdWUpKSkpIHtcbiAgICAgIHZhbHVlICs9IG90aGVyVmFsdWU7XG4gICAgfVxuICB9XG4gIHJldHVybiB2YWx1ZTtcbn1cblxuZnVuY3Rpb24gY29udmVydE9iamVjdERhdGFUb0FycmF5KGRhdGEsIG1ldGEpIHtcbiAgY29uc3Qge2lTY2FsZSwgdlNjYWxlfSA9IG1ldGE7XG4gIGNvbnN0IGlBeGlzS2V5ID0gaVNjYWxlLmF4aXMgPT09ICd4JyA/ICd4JyA6ICd5JztcbiAgY29uc3QgdkF4aXNLZXkgPSB2U2NhbGUuYXhpcyA9PT0gJ3gnID8gJ3gnIDogJ3knO1xuICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMoZGF0YSk7XG4gIGNvbnN0IGFkYXRhID0gbmV3IEFycmF5KGtleXMubGVuZ3RoKTtcbiAgbGV0IGksIGlsZW4sIGtleTtcbiAgZm9yIChpID0gMCwgaWxlbiA9IGtleXMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAga2V5ID0ga2V5c1tpXTtcbiAgICBhZGF0YVtpXSA9IHtcbiAgICAgIFtpQXhpc0tleV06IGtleSxcbiAgICAgIFt2QXhpc0tleV06IGRhdGFba2V5XVxuICAgIH07XG4gIH1cbiAgcmV0dXJuIGFkYXRhO1xufVxuXG5mdW5jdGlvbiBpc1N0YWNrZWQoc2NhbGUsIG1ldGEpIHtcbiAgY29uc3Qgc3RhY2tlZCA9IHNjYWxlICYmIHNjYWxlLm9wdGlvbnMuc3RhY2tlZDtcbiAgcmV0dXJuIHN0YWNrZWQgfHwgKHN0YWNrZWQgPT09IHVuZGVmaW5lZCAmJiBtZXRhLnN0YWNrICE9PSB1bmRlZmluZWQpO1xufVxuXG5mdW5jdGlvbiBnZXRTdGFja0tleShpbmRleFNjYWxlLCB2YWx1ZVNjYWxlLCBtZXRhKSB7XG4gIHJldHVybiBgJHtpbmRleFNjYWxlLmlkfS4ke3ZhbHVlU2NhbGUuaWR9LiR7bWV0YS5zdGFjayB8fCBtZXRhLnR5cGV9YDtcbn1cblxuZnVuY3Rpb24gZ2V0VXNlckJvdW5kcyhzY2FsZSkge1xuICBjb25zdCB7bWluLCBtYXgsIG1pbkRlZmluZWQsIG1heERlZmluZWR9ID0gc2NhbGUuZ2V0VXNlckJvdW5kcygpO1xuICByZXR1cm4ge1xuICAgIG1pbjogbWluRGVmaW5lZCA/IG1pbiA6IE51bWJlci5ORUdBVElWRV9JTkZJTklUWSxcbiAgICBtYXg6IG1heERlZmluZWQgPyBtYXggOiBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFlcbiAgfTtcbn1cblxuZnVuY3Rpb24gZ2V0T3JDcmVhdGVTdGFjayhzdGFja3MsIHN0YWNrS2V5LCBpbmRleFZhbHVlKSB7XG4gIGNvbnN0IHN1YlN0YWNrID0gc3RhY2tzW3N0YWNrS2V5XSB8fCAoc3RhY2tzW3N0YWNrS2V5XSA9IHt9KTtcbiAgcmV0dXJuIHN1YlN0YWNrW2luZGV4VmFsdWVdIHx8IChzdWJTdGFja1tpbmRleFZhbHVlXSA9IHt9KTtcbn1cblxuZnVuY3Rpb24gZ2V0TGFzdEluZGV4SW5TdGFjayhzdGFjaywgdlNjYWxlLCBwb3NpdGl2ZSwgdHlwZSkge1xuICBmb3IgKGNvbnN0IG1ldGEgb2YgdlNjYWxlLmdldE1hdGNoaW5nVmlzaWJsZU1ldGFzKHR5cGUpLnJldmVyc2UoKSkge1xuICAgIGNvbnN0IHZhbHVlID0gc3RhY2tbbWV0YS5pbmRleF07XG4gICAgaWYgKChwb3NpdGl2ZSAmJiB2YWx1ZSA+IDApIHx8ICghcG9zaXRpdmUgJiYgdmFsdWUgPCAwKSkge1xuICAgICAgcmV0dXJuIG1ldGEuaW5kZXg7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZVN0YWNrcyhjb250cm9sbGVyLCBwYXJzZWQpIHtcbiAgY29uc3Qge2NoYXJ0LCBfY2FjaGVkTWV0YTogbWV0YX0gPSBjb250cm9sbGVyO1xuICBjb25zdCBzdGFja3MgPSBjaGFydC5fc3RhY2tzIHx8IChjaGFydC5fc3RhY2tzID0ge30pOyAvLyBtYXAgc3RydWN0dXJlIGlzIHtzdGFja0tleToge2RhdGFzZXRJbmRleDogdmFsdWV9fVxuICBjb25zdCB7aVNjYWxlLCB2U2NhbGUsIGluZGV4OiBkYXRhc2V0SW5kZXh9ID0gbWV0YTtcbiAgY29uc3QgaUF4aXMgPSBpU2NhbGUuYXhpcztcbiAgY29uc3QgdkF4aXMgPSB2U2NhbGUuYXhpcztcbiAgY29uc3Qga2V5ID0gZ2V0U3RhY2tLZXkoaVNjYWxlLCB2U2NhbGUsIG1ldGEpO1xuICBjb25zdCBpbGVuID0gcGFyc2VkLmxlbmd0aDtcbiAgbGV0IHN0YWNrO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgY29uc3QgaXRlbSA9IHBhcnNlZFtpXTtcbiAgICBjb25zdCB7W2lBeGlzXTogaW5kZXgsIFt2QXhpc106IHZhbHVlfSA9IGl0ZW07XG4gICAgY29uc3QgaXRlbVN0YWNrcyA9IGl0ZW0uX3N0YWNrcyB8fCAoaXRlbS5fc3RhY2tzID0ge30pO1xuICAgIHN0YWNrID0gaXRlbVN0YWNrc1t2QXhpc10gPSBnZXRPckNyZWF0ZVN0YWNrKHN0YWNrcywga2V5LCBpbmRleCk7XG4gICAgc3RhY2tbZGF0YXNldEluZGV4XSA9IHZhbHVlO1xuXG4gICAgc3RhY2suX3RvcCA9IGdldExhc3RJbmRleEluU3RhY2soc3RhY2ssIHZTY2FsZSwgdHJ1ZSwgbWV0YS50eXBlKTtcbiAgICBzdGFjay5fYm90dG9tID0gZ2V0TGFzdEluZGV4SW5TdGFjayhzdGFjaywgdlNjYWxlLCBmYWxzZSwgbWV0YS50eXBlKTtcblxuICAgIGNvbnN0IHZpc3VhbFZhbHVlcyA9IHN0YWNrLl92aXN1YWxWYWx1ZXMgfHwgKHN0YWNrLl92aXN1YWxWYWx1ZXMgPSB7fSk7XG4gICAgdmlzdWFsVmFsdWVzW2RhdGFzZXRJbmRleF0gPSB2YWx1ZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRGaXJzdFNjYWxlSWQoY2hhcnQsIGF4aXMpIHtcbiAgY29uc3Qgc2NhbGVzID0gY2hhcnQuc2NhbGVzO1xuICByZXR1cm4gT2JqZWN0LmtleXMoc2NhbGVzKS5maWx0ZXIoa2V5ID0+IHNjYWxlc1trZXldLmF4aXMgPT09IGF4aXMpLnNoaWZ0KCk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZURhdGFzZXRDb250ZXh0KHBhcmVudCwgaW5kZXgpIHtcbiAgcmV0dXJuIGNyZWF0ZUNvbnRleHQocGFyZW50LFxuICAgIHtcbiAgICAgIGFjdGl2ZTogZmFsc2UsXG4gICAgICBkYXRhc2V0OiB1bmRlZmluZWQsXG4gICAgICBkYXRhc2V0SW5kZXg6IGluZGV4LFxuICAgICAgaW5kZXgsXG4gICAgICBtb2RlOiAnZGVmYXVsdCcsXG4gICAgICB0eXBlOiAnZGF0YXNldCdcbiAgICB9XG4gICk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZURhdGFDb250ZXh0KHBhcmVudCwgaW5kZXgsIGVsZW1lbnQpIHtcbiAgcmV0dXJuIGNyZWF0ZUNvbnRleHQocGFyZW50LCB7XG4gICAgYWN0aXZlOiBmYWxzZSxcbiAgICBkYXRhSW5kZXg6IGluZGV4LFxuICAgIHBhcnNlZDogdW5kZWZpbmVkLFxuICAgIHJhdzogdW5kZWZpbmVkLFxuICAgIGVsZW1lbnQsXG4gICAgaW5kZXgsXG4gICAgbW9kZTogJ2RlZmF1bHQnLFxuICAgIHR5cGU6ICdkYXRhJ1xuICB9KTtcbn1cblxuZnVuY3Rpb24gY2xlYXJTdGFja3MobWV0YSwgaXRlbXMpIHtcbiAgLy8gTm90IHVzaW5nIG1ldGEuaW5kZXggaGVyZSwgYmVjYXVzZSBpdCBtaWdodCBiZSBhbHJlYWR5IHVwZGF0ZWQgaWYgdGhlIGRhdGFzZXQgY2hhbmdlZCBsb2NhdGlvblxuICBjb25zdCBkYXRhc2V0SW5kZXggPSBtZXRhLmNvbnRyb2xsZXIuaW5kZXg7XG4gIGNvbnN0IGF4aXMgPSBtZXRhLnZTY2FsZSAmJiBtZXRhLnZTY2FsZS5heGlzO1xuICBpZiAoIWF4aXMpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBpdGVtcyA9IGl0ZW1zIHx8IG1ldGEuX3BhcnNlZDtcbiAgZm9yIChjb25zdCBwYXJzZWQgb2YgaXRlbXMpIHtcbiAgICBjb25zdCBzdGFja3MgPSBwYXJzZWQuX3N0YWNrcztcbiAgICBpZiAoIXN0YWNrcyB8fCBzdGFja3NbYXhpc10gPT09IHVuZGVmaW5lZCB8fCBzdGFja3NbYXhpc11bZGF0YXNldEluZGV4XSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGRlbGV0ZSBzdGFja3NbYXhpc11bZGF0YXNldEluZGV4XTtcbiAgICBpZiAoc3RhY2tzW2F4aXNdLl92aXN1YWxWYWx1ZXMgIT09IHVuZGVmaW5lZCAmJiBzdGFja3NbYXhpc10uX3Zpc3VhbFZhbHVlc1tkYXRhc2V0SW5kZXhdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGRlbGV0ZSBzdGFja3NbYXhpc10uX3Zpc3VhbFZhbHVlc1tkYXRhc2V0SW5kZXhdO1xuICAgIH1cbiAgfVxufVxuXG5jb25zdCBpc0RpcmVjdFVwZGF0ZU1vZGUgPSAobW9kZSkgPT4gbW9kZSA9PT0gJ3Jlc2V0JyB8fCBtb2RlID09PSAnbm9uZSc7XG5jb25zdCBjbG9uZUlmTm90U2hhcmVkID0gKGNhY2hlZCwgc2hhcmVkKSA9PiBzaGFyZWQgPyBjYWNoZWQgOiBPYmplY3QuYXNzaWduKHt9LCBjYWNoZWQpO1xuY29uc3QgY3JlYXRlU3RhY2sgPSAoY2FuU3RhY2ssIG1ldGEsIGNoYXJ0KSA9PiBjYW5TdGFjayAmJiAhbWV0YS5oaWRkZW4gJiYgbWV0YS5fc3RhY2tlZFxuICAmJiB7a2V5czogZ2V0U29ydGVkRGF0YXNldEluZGljZXMoY2hhcnQsIHRydWUpLCB2YWx1ZXM6IG51bGx9O1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBEYXRhc2V0Q29udHJvbGxlciB7XG5cbiAgLyoqXG4gICAqIEB0eXBlIHthbnl9XG4gICAqL1xuICBzdGF0aWMgZGVmYXVsdHMgPSB7fTtcblxuICAvKipcbiAgICogRWxlbWVudCB0eXBlIHVzZWQgdG8gZ2VuZXJhdGUgYSBtZXRhIGRhdGFzZXQgKGUuZy4gQ2hhcnQuZWxlbWVudC5MaW5lRWxlbWVudCkuXG4gICAqL1xuICBzdGF0aWMgZGF0YXNldEVsZW1lbnRUeXBlID0gbnVsbDtcblxuICAvKipcbiAgICogRWxlbWVudCB0eXBlIHVzZWQgdG8gZ2VuZXJhdGUgYSBtZXRhIGRhdGEgKGUuZy4gQ2hhcnQuZWxlbWVudC5Qb2ludEVsZW1lbnQpLlxuICAgKi9cbiAgc3RhdGljIGRhdGFFbGVtZW50VHlwZSA9IG51bGw7XG5cbiAgLyoqXG5cdCAqIEBwYXJhbSB7Q2hhcnR9IGNoYXJ0XG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBkYXRhc2V0SW5kZXhcblx0ICovXG4gIGNvbnN0cnVjdG9yKGNoYXJ0LCBkYXRhc2V0SW5kZXgpIHtcbiAgICB0aGlzLmNoYXJ0ID0gY2hhcnQ7XG4gICAgdGhpcy5fY3R4ID0gY2hhcnQuY3R4O1xuICAgIHRoaXMuaW5kZXggPSBkYXRhc2V0SW5kZXg7XG4gICAgdGhpcy5fY2FjaGVkRGF0YU9wdHMgPSB7fTtcbiAgICB0aGlzLl9jYWNoZWRNZXRhID0gdGhpcy5nZXRNZXRhKCk7XG4gICAgdGhpcy5fdHlwZSA9IHRoaXMuX2NhY2hlZE1ldGEudHlwZTtcbiAgICB0aGlzLm9wdGlvbnMgPSB1bmRlZmluZWQ7XG4gICAgLyoqIEB0eXBlIHtib29sZWFuIHwgb2JqZWN0fSAqL1xuICAgIHRoaXMuX3BhcnNpbmcgPSBmYWxzZTtcbiAgICB0aGlzLl9kYXRhID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX29iamVjdERhdGEgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fc2hhcmVkT3B0aW9ucyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9kcmF3U3RhcnQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fZHJhd0NvdW50ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuZW5hYmxlT3B0aW9uU2hhcmluZyA9IGZhbHNlO1xuICAgIHRoaXMuc3VwcG9ydHNEZWNpbWF0aW9uID0gZmFsc2U7XG4gICAgdGhpcy4kY29udGV4dCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9zeW5jTGlzdCA9IFtdO1xuICAgIHRoaXMuZGF0YXNldEVsZW1lbnRUeXBlID0gbmV3LnRhcmdldC5kYXRhc2V0RWxlbWVudFR5cGU7XG4gICAgdGhpcy5kYXRhRWxlbWVudFR5cGUgPSBuZXcudGFyZ2V0LmRhdGFFbGVtZW50VHlwZTtcblxuICAgIHRoaXMuaW5pdGlhbGl6ZSgpO1xuICB9XG5cbiAgaW5pdGlhbGl6ZSgpIHtcbiAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICB0aGlzLmNvbmZpZ3VyZSgpO1xuICAgIHRoaXMubGlua1NjYWxlcygpO1xuICAgIG1ldGEuX3N0YWNrZWQgPSBpc1N0YWNrZWQobWV0YS52U2NhbGUsIG1ldGEpO1xuICAgIHRoaXMuYWRkRWxlbWVudHMoKTtcblxuICAgIGlmICh0aGlzLm9wdGlvbnMuZmlsbCAmJiAhdGhpcy5jaGFydC5pc1BsdWdpbkVuYWJsZWQoJ2ZpbGxlcicpKSB7XG4gICAgICBjb25zb2xlLndhcm4oXCJUcmllZCB0byB1c2UgdGhlICdmaWxsJyBvcHRpb24gd2l0aG91dCB0aGUgJ0ZpbGxlcicgcGx1Z2luIGVuYWJsZWQuIFBsZWFzZSBpbXBvcnQgYW5kIHJlZ2lzdGVyIHRoZSAnRmlsbGVyJyBwbHVnaW4gYW5kIG1ha2Ugc3VyZSBpdCBpcyBub3QgZGlzYWJsZWQgaW4gdGhlIG9wdGlvbnNcIik7XG4gICAgfVxuICB9XG5cbiAgdXBkYXRlSW5kZXgoZGF0YXNldEluZGV4KSB7XG4gICAgaWYgKHRoaXMuaW5kZXggIT09IGRhdGFzZXRJbmRleCkge1xuICAgICAgY2xlYXJTdGFja3ModGhpcy5fY2FjaGVkTWV0YSk7XG4gICAgfVxuICAgIHRoaXMuaW5kZXggPSBkYXRhc2V0SW5kZXg7XG4gIH1cblxuICBsaW5rU2NhbGVzKCkge1xuICAgIGNvbnN0IGNoYXJ0ID0gdGhpcy5jaGFydDtcbiAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICBjb25zdCBkYXRhc2V0ID0gdGhpcy5nZXREYXRhc2V0KCk7XG5cbiAgICBjb25zdCBjaG9vc2VJZCA9IChheGlzLCB4LCB5LCByKSA9PiBheGlzID09PSAneCcgPyB4IDogYXhpcyA9PT0gJ3InID8gciA6IHk7XG5cbiAgICBjb25zdCB4aWQgPSBtZXRhLnhBeGlzSUQgPSB2YWx1ZU9yRGVmYXVsdChkYXRhc2V0LnhBeGlzSUQsIGdldEZpcnN0U2NhbGVJZChjaGFydCwgJ3gnKSk7XG4gICAgY29uc3QgeWlkID0gbWV0YS55QXhpc0lEID0gdmFsdWVPckRlZmF1bHQoZGF0YXNldC55QXhpc0lELCBnZXRGaXJzdFNjYWxlSWQoY2hhcnQsICd5JykpO1xuICAgIGNvbnN0IHJpZCA9IG1ldGEuckF4aXNJRCA9IHZhbHVlT3JEZWZhdWx0KGRhdGFzZXQuckF4aXNJRCwgZ2V0Rmlyc3RTY2FsZUlkKGNoYXJ0LCAncicpKTtcbiAgICBjb25zdCBpbmRleEF4aXMgPSBtZXRhLmluZGV4QXhpcztcbiAgICBjb25zdCBpaWQgPSBtZXRhLmlBeGlzSUQgPSBjaG9vc2VJZChpbmRleEF4aXMsIHhpZCwgeWlkLCByaWQpO1xuICAgIGNvbnN0IHZpZCA9IG1ldGEudkF4aXNJRCA9IGNob29zZUlkKGluZGV4QXhpcywgeWlkLCB4aWQsIHJpZCk7XG4gICAgbWV0YS54U2NhbGUgPSB0aGlzLmdldFNjYWxlRm9ySWQoeGlkKTtcbiAgICBtZXRhLnlTY2FsZSA9IHRoaXMuZ2V0U2NhbGVGb3JJZCh5aWQpO1xuICAgIG1ldGEuclNjYWxlID0gdGhpcy5nZXRTY2FsZUZvcklkKHJpZCk7XG4gICAgbWV0YS5pU2NhbGUgPSB0aGlzLmdldFNjYWxlRm9ySWQoaWlkKTtcbiAgICBtZXRhLnZTY2FsZSA9IHRoaXMuZ2V0U2NhbGVGb3JJZCh2aWQpO1xuICB9XG5cbiAgZ2V0RGF0YXNldCgpIHtcbiAgICByZXR1cm4gdGhpcy5jaGFydC5kYXRhLmRhdGFzZXRzW3RoaXMuaW5kZXhdO1xuICB9XG5cbiAgZ2V0TWV0YSgpIHtcbiAgICByZXR1cm4gdGhpcy5jaGFydC5nZXREYXRhc2V0TWV0YSh0aGlzLmluZGV4KTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gc2NhbGVJRFxuXHQgKiBAcmV0dXJuIHtTY2FsZX1cblx0ICovXG4gIGdldFNjYWxlRm9ySWQoc2NhbGVJRCkge1xuICAgIHJldHVybiB0aGlzLmNoYXJ0LnNjYWxlc1tzY2FsZUlEXTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgX2dldE90aGVyU2NhbGUoc2NhbGUpIHtcbiAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICByZXR1cm4gc2NhbGUgPT09IG1ldGEuaVNjYWxlXG4gICAgICA/IG1ldGEudlNjYWxlXG4gICAgICA6IG1ldGEuaVNjYWxlO1xuICB9XG5cbiAgcmVzZXQoKSB7XG4gICAgdGhpcy5fdXBkYXRlKCdyZXNldCcpO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfZGVzdHJveSgpIHtcbiAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICBpZiAodGhpcy5fZGF0YSkge1xuICAgICAgdW5saXN0ZW5BcnJheUV2ZW50cyh0aGlzLl9kYXRhLCB0aGlzKTtcbiAgICB9XG4gICAgaWYgKG1ldGEuX3N0YWNrZWQpIHtcbiAgICAgIGNsZWFyU3RhY2tzKG1ldGEpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgX2RhdGFDaGVjaygpIHtcbiAgICBjb25zdCBkYXRhc2V0ID0gdGhpcy5nZXREYXRhc2V0KCk7XG4gICAgY29uc3QgZGF0YSA9IGRhdGFzZXQuZGF0YSB8fCAoZGF0YXNldC5kYXRhID0gW10pO1xuICAgIGNvbnN0IF9kYXRhID0gdGhpcy5fZGF0YTtcblxuICAgIC8vIEluIG9yZGVyIHRvIGNvcnJlY3RseSBoYW5kbGUgZGF0YSBhZGRpdGlvbi9kZWxldGlvbiBhbmltYXRpb24gKGFuZCB0aHVzIHNpbXVsYXRlXG4gICAgLy8gcmVhbC10aW1lIGNoYXJ0cyksIHdlIG5lZWQgdG8gbW9uaXRvciB0aGVzZSBkYXRhIG1vZGlmaWNhdGlvbnMgYW5kIHN5bmNocm9uaXplXG4gICAgLy8gdGhlIGludGVybmFsIG1ldGFkYXRhIGFjY29yZGluZ2x5LlxuXG4gICAgaWYgKGlzT2JqZWN0KGRhdGEpKSB7XG4gICAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICAgIHRoaXMuX2RhdGEgPSBjb252ZXJ0T2JqZWN0RGF0YVRvQXJyYXkoZGF0YSwgbWV0YSk7XG4gICAgfSBlbHNlIGlmIChfZGF0YSAhPT0gZGF0YSkge1xuICAgICAgaWYgKF9kYXRhKSB7XG4gICAgICAgIC8vIFRoaXMgY2FzZSBoYXBwZW5zIHdoZW4gdGhlIHVzZXIgcmVwbGFjZWQgdGhlIGRhdGEgYXJyYXkgaW5zdGFuY2UuXG4gICAgICAgIHVubGlzdGVuQXJyYXlFdmVudHMoX2RhdGEsIHRoaXMpO1xuICAgICAgICAvLyBEaXNjYXJkIG9sZCBwYXJzZWQgZGF0YSBhbmQgc3RhY2tzXG4gICAgICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgICAgICBjbGVhclN0YWNrcyhtZXRhKTtcbiAgICAgICAgbWV0YS5fcGFyc2VkID0gW107XG4gICAgICB9XG4gICAgICBpZiAoZGF0YSAmJiBPYmplY3QuaXNFeHRlbnNpYmxlKGRhdGEpKSB7XG4gICAgICAgIGxpc3RlbkFycmF5RXZlbnRzKGRhdGEsIHRoaXMpO1xuICAgICAgfVxuICAgICAgdGhpcy5fc3luY0xpc3QgPSBbXTtcbiAgICAgIHRoaXMuX2RhdGEgPSBkYXRhO1xuICAgIH1cbiAgfVxuXG4gIGFkZEVsZW1lbnRzKCkge1xuICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9jYWNoZWRNZXRhO1xuXG4gICAgdGhpcy5fZGF0YUNoZWNrKCk7XG5cbiAgICBpZiAodGhpcy5kYXRhc2V0RWxlbWVudFR5cGUpIHtcbiAgICAgIG1ldGEuZGF0YXNldCA9IG5ldyB0aGlzLmRhdGFzZXRFbGVtZW50VHlwZSgpO1xuICAgIH1cbiAgfVxuXG4gIGJ1aWxkT3JVcGRhdGVFbGVtZW50cyhyZXNldE5ld0VsZW1lbnRzKSB7XG4gICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgY29uc3QgZGF0YXNldCA9IHRoaXMuZ2V0RGF0YXNldCgpO1xuICAgIGxldCBzdGFja0NoYW5nZWQgPSBmYWxzZTtcblxuICAgIHRoaXMuX2RhdGFDaGVjaygpO1xuXG4gICAgLy8gbWFrZSBzdXJlIGNhY2hlZCBfc3RhY2tlZCBzdGF0dXMgaXMgY3VycmVudFxuICAgIGNvbnN0IG9sZFN0YWNrZWQgPSBtZXRhLl9zdGFja2VkO1xuICAgIG1ldGEuX3N0YWNrZWQgPSBpc1N0YWNrZWQobWV0YS52U2NhbGUsIG1ldGEpO1xuXG4gICAgLy8gZGV0ZWN0IGNoYW5nZSBpbiBzdGFjayBvcHRpb25cbiAgICBpZiAobWV0YS5zdGFjayAhPT0gZGF0YXNldC5zdGFjaykge1xuICAgICAgc3RhY2tDaGFuZ2VkID0gdHJ1ZTtcbiAgICAgIC8vIHJlbW92ZSB2YWx1ZXMgZnJvbSBvbGQgc3RhY2tcbiAgICAgIGNsZWFyU3RhY2tzKG1ldGEpO1xuICAgICAgbWV0YS5zdGFjayA9IGRhdGFzZXQuc3RhY2s7XG4gICAgfVxuXG4gICAgLy8gUmUtc3luYyBtZXRhIGRhdGEgaW4gY2FzZSB0aGUgdXNlciByZXBsYWNlZCB0aGUgZGF0YSBhcnJheSBvciBpZiB3ZSBtaXNzZWRcbiAgICAvLyBhbnkgdXBkYXRlcyBhbmQgc28gbWFrZSBzdXJlIHRoYXQgd2UgaGFuZGxlIG51bWJlciBvZiBkYXRhcG9pbnRzIGNoYW5naW5nLlxuICAgIHRoaXMuX3Jlc3luY0VsZW1lbnRzKHJlc2V0TmV3RWxlbWVudHMpO1xuXG4gICAgLy8gaWYgc3RhY2sgY2hhbmdlZCwgdXBkYXRlIHN0YWNrIHZhbHVlcyBmb3IgdGhlIHdob2xlIGRhdGFzZXRcbiAgICBpZiAoc3RhY2tDaGFuZ2VkIHx8IG9sZFN0YWNrZWQgIT09IG1ldGEuX3N0YWNrZWQpIHtcbiAgICAgIHVwZGF0ZVN0YWNrcyh0aGlzLCBtZXRhLl9wYXJzZWQpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuXHQgKiBNZXJnZXMgdXNlci1zdXBwbGllZCBhbmQgZGVmYXVsdCBkYXRhc2V0LWxldmVsIG9wdGlvbnNcblx0ICogQHByaXZhdGVcblx0ICovXG4gIGNvbmZpZ3VyZSgpIHtcbiAgICBjb25zdCBjb25maWcgPSB0aGlzLmNoYXJ0LmNvbmZpZztcbiAgICBjb25zdCBzY29wZUtleXMgPSBjb25maWcuZGF0YXNldFNjb3BlS2V5cyh0aGlzLl90eXBlKTtcbiAgICBjb25zdCBzY29wZXMgPSBjb25maWcuZ2V0T3B0aW9uU2NvcGVzKHRoaXMuZ2V0RGF0YXNldCgpLCBzY29wZUtleXMsIHRydWUpO1xuICAgIHRoaXMub3B0aW9ucyA9IGNvbmZpZy5jcmVhdGVSZXNvbHZlcihzY29wZXMsIHRoaXMuZ2V0Q29udGV4dCgpKTtcbiAgICB0aGlzLl9wYXJzaW5nID0gdGhpcy5vcHRpb25zLnBhcnNpbmc7XG4gICAgdGhpcy5fY2FjaGVkRGF0YU9wdHMgPSB7fTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcGFyYW0ge251bWJlcn0gc3RhcnRcblx0ICogQHBhcmFtIHtudW1iZXJ9IGNvdW50XG5cdCAqL1xuICBwYXJzZShzdGFydCwgY291bnQpIHtcbiAgICBjb25zdCB7X2NhY2hlZE1ldGE6IG1ldGEsIF9kYXRhOiBkYXRhfSA9IHRoaXM7XG4gICAgY29uc3Qge2lTY2FsZSwgX3N0YWNrZWR9ID0gbWV0YTtcbiAgICBjb25zdCBpQXhpcyA9IGlTY2FsZS5heGlzO1xuXG4gICAgbGV0IHNvcnRlZCA9IHN0YXJ0ID09PSAwICYmIGNvdW50ID09PSBkYXRhLmxlbmd0aCA/IHRydWUgOiBtZXRhLl9zb3J0ZWQ7XG4gICAgbGV0IHByZXYgPSBzdGFydCA+IDAgJiYgbWV0YS5fcGFyc2VkW3N0YXJ0IC0gMV07XG4gICAgbGV0IGksIGN1ciwgcGFyc2VkO1xuXG4gICAgaWYgKHRoaXMuX3BhcnNpbmcgPT09IGZhbHNlKSB7XG4gICAgICBtZXRhLl9wYXJzZWQgPSBkYXRhO1xuICAgICAgbWV0YS5fc29ydGVkID0gdHJ1ZTtcbiAgICAgIHBhcnNlZCA9IGRhdGE7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChpc0FycmF5KGRhdGFbc3RhcnRdKSkge1xuICAgICAgICBwYXJzZWQgPSB0aGlzLnBhcnNlQXJyYXlEYXRhKG1ldGEsIGRhdGEsIHN0YXJ0LCBjb3VudCk7XG4gICAgICB9IGVsc2UgaWYgKGlzT2JqZWN0KGRhdGFbc3RhcnRdKSkge1xuICAgICAgICBwYXJzZWQgPSB0aGlzLnBhcnNlT2JqZWN0RGF0YShtZXRhLCBkYXRhLCBzdGFydCwgY291bnQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGFyc2VkID0gdGhpcy5wYXJzZVByaW1pdGl2ZURhdGEobWV0YSwgZGF0YSwgc3RhcnQsIGNvdW50KTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgaXNOb3RJbk9yZGVyQ29tcGFyZWRUb1ByZXYgPSAoKSA9PiBjdXJbaUF4aXNdID09PSBudWxsIHx8IChwcmV2ICYmIGN1cltpQXhpc10gPCBwcmV2W2lBeGlzXSk7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgY291bnQ7ICsraSkge1xuICAgICAgICBtZXRhLl9wYXJzZWRbaSArIHN0YXJ0XSA9IGN1ciA9IHBhcnNlZFtpXTtcbiAgICAgICAgaWYgKHNvcnRlZCkge1xuICAgICAgICAgIGlmIChpc05vdEluT3JkZXJDb21wYXJlZFRvUHJldigpKSB7XG4gICAgICAgICAgICBzb3J0ZWQgPSBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcHJldiA9IGN1cjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgbWV0YS5fc29ydGVkID0gc29ydGVkO1xuICAgIH1cblxuICAgIGlmIChfc3RhY2tlZCkge1xuICAgICAgdXBkYXRlU3RhY2tzKHRoaXMsIHBhcnNlZCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG5cdCAqIFBhcnNlIGFycmF5IG9mIHByaW1pdGl2ZSB2YWx1ZXNcblx0ICogQHBhcmFtIHtvYmplY3R9IG1ldGEgLSBkYXRhc2V0IG1ldGFcblx0ICogQHBhcmFtIHthcnJheX0gZGF0YSAtIGRhdGEgYXJyYXkuIEV4YW1wbGUgWzEsMyw0XVxuXHQgKiBAcGFyYW0ge251bWJlcn0gc3RhcnQgLSBzdGFydCBpbmRleFxuXHQgKiBAcGFyYW0ge251bWJlcn0gY291bnQgLSBudW1iZXIgb2YgaXRlbXMgdG8gcGFyc2Vcblx0ICogQHJldHVybnMge29iamVjdH0gcGFyc2VkIGl0ZW0gLSBpdGVtIGNvbnRhaW5pbmcgaW5kZXggYW5kIGEgcGFyc2VkIHZhbHVlXG5cdCAqIGZvciBlYWNoIHNjYWxlIGlkLlxuXHQgKiBFeGFtcGxlOiB7eFNjYWxlMDogMCwgeVNjYWxlMDogMX1cblx0ICogQHByb3RlY3RlZFxuXHQgKi9cbiAgcGFyc2VQcmltaXRpdmVEYXRhKG1ldGEsIGRhdGEsIHN0YXJ0LCBjb3VudCkge1xuICAgIGNvbnN0IHtpU2NhbGUsIHZTY2FsZX0gPSBtZXRhO1xuICAgIGNvbnN0IGlBeGlzID0gaVNjYWxlLmF4aXM7XG4gICAgY29uc3QgdkF4aXMgPSB2U2NhbGUuYXhpcztcbiAgICBjb25zdCBsYWJlbHMgPSBpU2NhbGUuZ2V0TGFiZWxzKCk7XG4gICAgY29uc3Qgc2luZ2xlU2NhbGUgPSBpU2NhbGUgPT09IHZTY2FsZTtcbiAgICBjb25zdCBwYXJzZWQgPSBuZXcgQXJyYXkoY291bnQpO1xuICAgIGxldCBpLCBpbGVuLCBpbmRleDtcblxuICAgIGZvciAoaSA9IDAsIGlsZW4gPSBjb3VudDsgaSA8IGlsZW47ICsraSkge1xuICAgICAgaW5kZXggPSBpICsgc3RhcnQ7XG4gICAgICBwYXJzZWRbaV0gPSB7XG4gICAgICAgIFtpQXhpc106IHNpbmdsZVNjYWxlIHx8IGlTY2FsZS5wYXJzZShsYWJlbHNbaW5kZXhdLCBpbmRleCksXG4gICAgICAgIFt2QXhpc106IHZTY2FsZS5wYXJzZShkYXRhW2luZGV4XSwgaW5kZXgpXG4gICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gcGFyc2VkO1xuICB9XG5cbiAgLyoqXG5cdCAqIFBhcnNlIGFycmF5IG9mIGFycmF5c1xuXHQgKiBAcGFyYW0ge29iamVjdH0gbWV0YSAtIGRhdGFzZXQgbWV0YVxuXHQgKiBAcGFyYW0ge2FycmF5fSBkYXRhIC0gZGF0YSBhcnJheS4gRXhhbXBsZSBbWzEsMl0sWzMsNF1dXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydCAtIHN0YXJ0IGluZGV4XG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBjb3VudCAtIG51bWJlciBvZiBpdGVtcyB0byBwYXJzZVxuXHQgKiBAcmV0dXJucyB7b2JqZWN0fSBwYXJzZWQgaXRlbSAtIGl0ZW0gY29udGFpbmluZyBpbmRleCBhbmQgYSBwYXJzZWQgdmFsdWVcblx0ICogZm9yIGVhY2ggc2NhbGUgaWQuXG5cdCAqIEV4YW1wbGU6IHt4OiAwLCB5OiAxfVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuICBwYXJzZUFycmF5RGF0YShtZXRhLCBkYXRhLCBzdGFydCwgY291bnQpIHtcbiAgICBjb25zdCB7eFNjYWxlLCB5U2NhbGV9ID0gbWV0YTtcbiAgICBjb25zdCBwYXJzZWQgPSBuZXcgQXJyYXkoY291bnQpO1xuICAgIGxldCBpLCBpbGVuLCBpbmRleCwgaXRlbTtcblxuICAgIGZvciAoaSA9IDAsIGlsZW4gPSBjb3VudDsgaSA8IGlsZW47ICsraSkge1xuICAgICAgaW5kZXggPSBpICsgc3RhcnQ7XG4gICAgICBpdGVtID0gZGF0YVtpbmRleF07XG4gICAgICBwYXJzZWRbaV0gPSB7XG4gICAgICAgIHg6IHhTY2FsZS5wYXJzZShpdGVtWzBdLCBpbmRleCksXG4gICAgICAgIHk6IHlTY2FsZS5wYXJzZShpdGVtWzFdLCBpbmRleClcbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiBwYXJzZWQ7XG4gIH1cblxuICAvKipcblx0ICogUGFyc2UgYXJyYXkgb2Ygb2JqZWN0c1xuXHQgKiBAcGFyYW0ge29iamVjdH0gbWV0YSAtIGRhdGFzZXQgbWV0YVxuXHQgKiBAcGFyYW0ge2FycmF5fSBkYXRhIC0gZGF0YSBhcnJheS4gRXhhbXBsZSBbe3g6MSwgeTo1fSwge3g6MiwgeToxMH1dXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydCAtIHN0YXJ0IGluZGV4XG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBjb3VudCAtIG51bWJlciBvZiBpdGVtcyB0byBwYXJzZVxuXHQgKiBAcmV0dXJucyB7b2JqZWN0fSBwYXJzZWQgaXRlbSAtIGl0ZW0gY29udGFpbmluZyBpbmRleCBhbmQgYSBwYXJzZWQgdmFsdWVcblx0ICogZm9yIGVhY2ggc2NhbGUgaWQuIF9jdXN0b20gaXMgb3B0aW9uYWxcblx0ICogRXhhbXBsZToge3hTY2FsZTA6IDAsIHlTY2FsZTA6IDEsIF9jdXN0b206IHtyOiAxMCwgZm9vOiAnYmFyJ319XG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG4gIHBhcnNlT2JqZWN0RGF0YShtZXRhLCBkYXRhLCBzdGFydCwgY291bnQpIHtcbiAgICBjb25zdCB7eFNjYWxlLCB5U2NhbGV9ID0gbWV0YTtcbiAgICBjb25zdCB7eEF4aXNLZXkgPSAneCcsIHlBeGlzS2V5ID0gJ3knfSA9IHRoaXMuX3BhcnNpbmc7XG4gICAgY29uc3QgcGFyc2VkID0gbmV3IEFycmF5KGNvdW50KTtcbiAgICBsZXQgaSwgaWxlbiwgaW5kZXgsIGl0ZW07XG5cbiAgICBmb3IgKGkgPSAwLCBpbGVuID0gY291bnQ7IGkgPCBpbGVuOyArK2kpIHtcbiAgICAgIGluZGV4ID0gaSArIHN0YXJ0O1xuICAgICAgaXRlbSA9IGRhdGFbaW5kZXhdO1xuICAgICAgcGFyc2VkW2ldID0ge1xuICAgICAgICB4OiB4U2NhbGUucGFyc2UocmVzb2x2ZU9iamVjdEtleShpdGVtLCB4QXhpc0tleSksIGluZGV4KSxcbiAgICAgICAgeTogeVNjYWxlLnBhcnNlKHJlc29sdmVPYmplY3RLZXkoaXRlbSwgeUF4aXNLZXkpLCBpbmRleClcbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiBwYXJzZWQ7XG4gIH1cblxuICAvKipcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cbiAgZ2V0UGFyc2VkKGluZGV4KSB7XG4gICAgcmV0dXJuIHRoaXMuX2NhY2hlZE1ldGEuX3BhcnNlZFtpbmRleF07XG4gIH1cblxuICAvKipcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cbiAgZ2V0RGF0YUVsZW1lbnQoaW5kZXgpIHtcbiAgICByZXR1cm4gdGhpcy5fY2FjaGVkTWV0YS5kYXRhW2luZGV4XTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuICBhcHBseVN0YWNrKHNjYWxlLCBwYXJzZWQsIG1vZGUpIHtcbiAgICBjb25zdCBjaGFydCA9IHRoaXMuY2hhcnQ7XG4gICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgY29uc3QgdmFsdWUgPSBwYXJzZWRbc2NhbGUuYXhpc107XG4gICAgY29uc3Qgc3RhY2sgPSB7XG4gICAgICBrZXlzOiBnZXRTb3J0ZWREYXRhc2V0SW5kaWNlcyhjaGFydCwgdHJ1ZSksXG4gICAgICB2YWx1ZXM6IHBhcnNlZC5fc3RhY2tzW3NjYWxlLmF4aXNdLl92aXN1YWxWYWx1ZXNcbiAgICB9O1xuICAgIHJldHVybiBhcHBseVN0YWNrKHN0YWNrLCB2YWx1ZSwgbWV0YS5pbmRleCwge21vZGV9KTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuICB1cGRhdGVSYW5nZUZyb21QYXJzZWQocmFuZ2UsIHNjYWxlLCBwYXJzZWQsIHN0YWNrKSB7XG4gICAgY29uc3QgcGFyc2VkVmFsdWUgPSBwYXJzZWRbc2NhbGUuYXhpc107XG4gICAgbGV0IHZhbHVlID0gcGFyc2VkVmFsdWUgPT09IG51bGwgPyBOYU4gOiBwYXJzZWRWYWx1ZTtcbiAgICBjb25zdCB2YWx1ZXMgPSBzdGFjayAmJiBwYXJzZWQuX3N0YWNrc1tzY2FsZS5heGlzXTtcbiAgICBpZiAoc3RhY2sgJiYgdmFsdWVzKSB7XG4gICAgICBzdGFjay52YWx1ZXMgPSB2YWx1ZXM7XG4gICAgICB2YWx1ZSA9IGFwcGx5U3RhY2soc3RhY2ssIHBhcnNlZFZhbHVlLCB0aGlzLl9jYWNoZWRNZXRhLmluZGV4KTtcbiAgICB9XG4gICAgcmFuZ2UubWluID0gTWF0aC5taW4ocmFuZ2UubWluLCB2YWx1ZSk7XG4gICAgcmFuZ2UubWF4ID0gTWF0aC5tYXgocmFuZ2UubWF4LCB2YWx1ZSk7XG4gIH1cblxuICAvKipcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cbiAgZ2V0TWluTWF4KHNjYWxlLCBjYW5TdGFjaykge1xuICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgIGNvbnN0IF9wYXJzZWQgPSBtZXRhLl9wYXJzZWQ7XG4gICAgY29uc3Qgc29ydGVkID0gbWV0YS5fc29ydGVkICYmIHNjYWxlID09PSBtZXRhLmlTY2FsZTtcbiAgICBjb25zdCBpbGVuID0gX3BhcnNlZC5sZW5ndGg7XG4gICAgY29uc3Qgb3RoZXJTY2FsZSA9IHRoaXMuX2dldE90aGVyU2NhbGUoc2NhbGUpO1xuICAgIGNvbnN0IHN0YWNrID0gY3JlYXRlU3RhY2soY2FuU3RhY2ssIG1ldGEsIHRoaXMuY2hhcnQpO1xuICAgIGNvbnN0IHJhbmdlID0ge21pbjogTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZLCBtYXg6IE51bWJlci5ORUdBVElWRV9JTkZJTklUWX07XG4gICAgY29uc3Qge21pbjogb3RoZXJNaW4sIG1heDogb3RoZXJNYXh9ID0gZ2V0VXNlckJvdW5kcyhvdGhlclNjYWxlKTtcbiAgICBsZXQgaSwgcGFyc2VkO1xuXG4gICAgZnVuY3Rpb24gX3NraXAoKSB7XG4gICAgICBwYXJzZWQgPSBfcGFyc2VkW2ldO1xuICAgICAgY29uc3Qgb3RoZXJWYWx1ZSA9IHBhcnNlZFtvdGhlclNjYWxlLmF4aXNdO1xuICAgICAgcmV0dXJuICFpc0Zpbml0ZShwYXJzZWRbc2NhbGUuYXhpc10pIHx8IG90aGVyTWluID4gb3RoZXJWYWx1ZSB8fCBvdGhlck1heCA8IG90aGVyVmFsdWU7XG4gICAgfVxuXG4gICAgZm9yIChpID0gMDsgaSA8IGlsZW47ICsraSkge1xuICAgICAgaWYgKF9za2lwKCkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICB0aGlzLnVwZGF0ZVJhbmdlRnJvbVBhcnNlZChyYW5nZSwgc2NhbGUsIHBhcnNlZCwgc3RhY2spO1xuICAgICAgaWYgKHNvcnRlZCkge1xuICAgICAgICAvLyBpZiB0aGUgZGF0YSBpcyBzb3J0ZWQsIHdlIGRvbid0IG5lZWQgdG8gY2hlY2sgZnVydGhlciBmcm9tIHRoaXMgZW5kIG9mIGFycmF5XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoc29ydGVkKSB7XG4gICAgICAvLyBpbiB0aGUgc29ydGVkIGNhc2UsIGZpbmQgZmlyc3Qgbm9uLXNraXBwZWQgdmFsdWUgZnJvbSBvdGhlciBlbmQgb2YgYXJyYXlcbiAgICAgIGZvciAoaSA9IGlsZW4gLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICBpZiAoX3NraXAoKSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudXBkYXRlUmFuZ2VGcm9tUGFyc2VkKHJhbmdlLCBzY2FsZSwgcGFyc2VkLCBzdGFjayk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmFuZ2U7XG4gIH1cblxuICBnZXRBbGxQYXJzZWRWYWx1ZXMoc2NhbGUpIHtcbiAgICBjb25zdCBwYXJzZWQgPSB0aGlzLl9jYWNoZWRNZXRhLl9wYXJzZWQ7XG4gICAgY29uc3QgdmFsdWVzID0gW107XG4gICAgbGV0IGksIGlsZW4sIHZhbHVlO1xuXG4gICAgZm9yIChpID0gMCwgaWxlbiA9IHBhcnNlZC5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICAgIHZhbHVlID0gcGFyc2VkW2ldW3NjYWxlLmF4aXNdO1xuICAgICAgaWYgKGlzRmluaXRlKHZhbHVlKSkge1xuICAgICAgICB2YWx1ZXMucHVzaCh2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZXM7XG4gIH1cblxuICAvKipcblx0ICogQHJldHVybiB7bnVtYmVyfGJvb2xlYW59XG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG4gIGdldE1heE92ZXJmbG93KCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuICBnZXRMYWJlbEFuZFZhbHVlKGluZGV4KSB7XG4gICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgY29uc3QgaVNjYWxlID0gbWV0YS5pU2NhbGU7XG4gICAgY29uc3QgdlNjYWxlID0gbWV0YS52U2NhbGU7XG4gICAgY29uc3QgcGFyc2VkID0gdGhpcy5nZXRQYXJzZWQoaW5kZXgpO1xuICAgIHJldHVybiB7XG4gICAgICBsYWJlbDogaVNjYWxlID8gJycgKyBpU2NhbGUuZ2V0TGFiZWxGb3JWYWx1ZShwYXJzZWRbaVNjYWxlLmF4aXNdKSA6ICcnLFxuICAgICAgdmFsdWU6IHZTY2FsZSA/ICcnICsgdlNjYWxlLmdldExhYmVsRm9yVmFsdWUocGFyc2VkW3ZTY2FsZS5heGlzXSkgOiAnJ1xuICAgIH07XG4gIH1cblxuICAvKipcblx0ICogQHByaXZhdGVcblx0ICovXG4gIF91cGRhdGUobW9kZSkge1xuICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgIHRoaXMudXBkYXRlKG1vZGUgfHwgJ2RlZmF1bHQnKTtcbiAgICBtZXRhLl9jbGlwID0gdG9DbGlwKHZhbHVlT3JEZWZhdWx0KHRoaXMub3B0aW9ucy5jbGlwLCBkZWZhdWx0Q2xpcChtZXRhLnhTY2FsZSwgbWV0YS55U2NhbGUsIHRoaXMuZ2V0TWF4T3ZlcmZsb3coKSkpKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gbW9kZVxuXHQgKi9cbiAgdXBkYXRlKG1vZGUpIHt9IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcblxuICBkcmF3KCkge1xuICAgIGNvbnN0IGN0eCA9IHRoaXMuX2N0eDtcbiAgICBjb25zdCBjaGFydCA9IHRoaXMuY2hhcnQ7XG4gICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgY29uc3QgZWxlbWVudHMgPSBtZXRhLmRhdGEgfHwgW107XG4gICAgY29uc3QgYXJlYSA9IGNoYXJ0LmNoYXJ0QXJlYTtcbiAgICBjb25zdCBhY3RpdmUgPSBbXTtcbiAgICBjb25zdCBzdGFydCA9IHRoaXMuX2RyYXdTdGFydCB8fCAwO1xuICAgIGNvbnN0IGNvdW50ID0gdGhpcy5fZHJhd0NvdW50IHx8IChlbGVtZW50cy5sZW5ndGggLSBzdGFydCk7XG4gICAgY29uc3QgZHJhd0FjdGl2ZUVsZW1lbnRzT25Ub3AgPSB0aGlzLm9wdGlvbnMuZHJhd0FjdGl2ZUVsZW1lbnRzT25Ub3A7XG4gICAgbGV0IGk7XG5cbiAgICBpZiAobWV0YS5kYXRhc2V0KSB7XG4gICAgICBtZXRhLmRhdGFzZXQuZHJhdyhjdHgsIGFyZWEsIHN0YXJ0LCBjb3VudCk7XG4gICAgfVxuXG4gICAgZm9yIChpID0gc3RhcnQ7IGkgPCBzdGFydCArIGNvdW50OyArK2kpIHtcbiAgICAgIGNvbnN0IGVsZW1lbnQgPSBlbGVtZW50c1tpXTtcbiAgICAgIGlmIChlbGVtZW50LmhpZGRlbikge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmIChlbGVtZW50LmFjdGl2ZSAmJiBkcmF3QWN0aXZlRWxlbWVudHNPblRvcCkge1xuICAgICAgICBhY3RpdmUucHVzaChlbGVtZW50KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVsZW1lbnQuZHJhdyhjdHgsIGFyZWEpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZvciAoaSA9IDA7IGkgPCBhY3RpdmUubGVuZ3RoOyArK2kpIHtcbiAgICAgIGFjdGl2ZVtpXS5kcmF3KGN0eCwgYXJlYSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG5cdCAqIFJldHVybnMgYSBzZXQgb2YgcHJlZGVmaW5lZCBzdHlsZSBwcm9wZXJ0aWVzIHRoYXQgc2hvdWxkIGJlIHVzZWQgdG8gcmVwcmVzZW50IHRoZSBkYXRhc2V0XG5cdCAqIG9yIHRoZSBkYXRhIGlmIHRoZSBpbmRleCBpcyBzcGVjaWZpZWRcblx0ICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IC0gZGF0YSBpbmRleFxuXHQgKiBAcGFyYW0ge2Jvb2xlYW59IFthY3RpdmVdIC0gdHJ1ZSBpZiBob3ZlclxuXHQgKiBAcmV0dXJuIHtvYmplY3R9IHN0eWxlIG9iamVjdFxuXHQgKi9cbiAgZ2V0U3R5bGUoaW5kZXgsIGFjdGl2ZSkge1xuICAgIGNvbnN0IG1vZGUgPSBhY3RpdmUgPyAnYWN0aXZlJyA6ICdkZWZhdWx0JztcbiAgICByZXR1cm4gaW5kZXggPT09IHVuZGVmaW5lZCAmJiB0aGlzLl9jYWNoZWRNZXRhLmRhdGFzZXRcbiAgICAgID8gdGhpcy5yZXNvbHZlRGF0YXNldEVsZW1lbnRPcHRpb25zKG1vZGUpXG4gICAgICA6IHRoaXMucmVzb2x2ZURhdGFFbGVtZW50T3B0aW9ucyhpbmRleCB8fCAwLCBtb2RlKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuICBnZXRDb250ZXh0KGluZGV4LCBhY3RpdmUsIG1vZGUpIHtcbiAgICBjb25zdCBkYXRhc2V0ID0gdGhpcy5nZXREYXRhc2V0KCk7XG4gICAgbGV0IGNvbnRleHQ7XG4gICAgaWYgKGluZGV4ID49IDAgJiYgaW5kZXggPCB0aGlzLl9jYWNoZWRNZXRhLmRhdGEubGVuZ3RoKSB7XG4gICAgICBjb25zdCBlbGVtZW50ID0gdGhpcy5fY2FjaGVkTWV0YS5kYXRhW2luZGV4XTtcbiAgICAgIGNvbnRleHQgPSBlbGVtZW50LiRjb250ZXh0IHx8XG4gICAgICAgIChlbGVtZW50LiRjb250ZXh0ID0gY3JlYXRlRGF0YUNvbnRleHQodGhpcy5nZXRDb250ZXh0KCksIGluZGV4LCBlbGVtZW50KSk7XG4gICAgICBjb250ZXh0LnBhcnNlZCA9IHRoaXMuZ2V0UGFyc2VkKGluZGV4KTtcbiAgICAgIGNvbnRleHQucmF3ID0gZGF0YXNldC5kYXRhW2luZGV4XTtcbiAgICAgIGNvbnRleHQuaW5kZXggPSBjb250ZXh0LmRhdGFJbmRleCA9IGluZGV4O1xuICAgIH0gZWxzZSB7XG4gICAgICBjb250ZXh0ID0gdGhpcy4kY29udGV4dCB8fFxuICAgICAgICAodGhpcy4kY29udGV4dCA9IGNyZWF0ZURhdGFzZXRDb250ZXh0KHRoaXMuY2hhcnQuZ2V0Q29udGV4dCgpLCB0aGlzLmluZGV4KSk7XG4gICAgICBjb250ZXh0LmRhdGFzZXQgPSBkYXRhc2V0O1xuICAgICAgY29udGV4dC5pbmRleCA9IGNvbnRleHQuZGF0YXNldEluZGV4ID0gdGhpcy5pbmRleDtcbiAgICB9XG5cbiAgICBjb250ZXh0LmFjdGl2ZSA9ICEhYWN0aXZlO1xuICAgIGNvbnRleHQubW9kZSA9IG1vZGU7XG4gICAgcmV0dXJuIGNvbnRleHQ7XG4gIH1cblxuICAvKipcblx0ICogQHBhcmFtIHtzdHJpbmd9IFttb2RlXVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuICByZXNvbHZlRGF0YXNldEVsZW1lbnRPcHRpb25zKG1vZGUpIHtcbiAgICByZXR1cm4gdGhpcy5fcmVzb2x2ZUVsZW1lbnRPcHRpb25zKHRoaXMuZGF0YXNldEVsZW1lbnRUeXBlLmlkLCBtb2RlKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcGFyYW0ge251bWJlcn0gaW5kZXhcblx0ICogQHBhcmFtIHtzdHJpbmd9IFttb2RlXVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuICByZXNvbHZlRGF0YUVsZW1lbnRPcHRpb25zKGluZGV4LCBtb2RlKSB7XG4gICAgcmV0dXJuIHRoaXMuX3Jlc29sdmVFbGVtZW50T3B0aW9ucyh0aGlzLmRhdGFFbGVtZW50VHlwZS5pZCwgbW9kZSwgaW5kZXgpO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfcmVzb2x2ZUVsZW1lbnRPcHRpb25zKGVsZW1lbnRUeXBlLCBtb2RlID0gJ2RlZmF1bHQnLCBpbmRleCkge1xuICAgIGNvbnN0IGFjdGl2ZSA9IG1vZGUgPT09ICdhY3RpdmUnO1xuICAgIGNvbnN0IGNhY2hlID0gdGhpcy5fY2FjaGVkRGF0YU9wdHM7XG4gICAgY29uc3QgY2FjaGVLZXkgPSBlbGVtZW50VHlwZSArICctJyArIG1vZGU7XG4gICAgY29uc3QgY2FjaGVkID0gY2FjaGVbY2FjaGVLZXldO1xuICAgIGNvbnN0IHNoYXJpbmcgPSB0aGlzLmVuYWJsZU9wdGlvblNoYXJpbmcgJiYgZGVmaW5lZChpbmRleCk7XG4gICAgaWYgKGNhY2hlZCkge1xuICAgICAgcmV0dXJuIGNsb25lSWZOb3RTaGFyZWQoY2FjaGVkLCBzaGFyaW5nKTtcbiAgICB9XG4gICAgY29uc3QgY29uZmlnID0gdGhpcy5jaGFydC5jb25maWc7XG4gICAgY29uc3Qgc2NvcGVLZXlzID0gY29uZmlnLmRhdGFzZXRFbGVtZW50U2NvcGVLZXlzKHRoaXMuX3R5cGUsIGVsZW1lbnRUeXBlKTtcbiAgICBjb25zdCBwcmVmaXhlcyA9IGFjdGl2ZSA/IFtgJHtlbGVtZW50VHlwZX1Ib3ZlcmAsICdob3ZlcicsIGVsZW1lbnRUeXBlLCAnJ10gOiBbZWxlbWVudFR5cGUsICcnXTtcbiAgICBjb25zdCBzY29wZXMgPSBjb25maWcuZ2V0T3B0aW9uU2NvcGVzKHRoaXMuZ2V0RGF0YXNldCgpLCBzY29wZUtleXMpO1xuICAgIGNvbnN0IG5hbWVzID0gT2JqZWN0LmtleXMoZGVmYXVsdHMuZWxlbWVudHNbZWxlbWVudFR5cGVdKTtcbiAgICAvLyBjb250ZXh0IGlzIHByb3ZpZGVkIGFzIGEgZnVuY3Rpb24sIGFuZCBpcyBjYWxsZWQgb25seSBpZiBuZWVkZWQsXG4gICAgLy8gc28gd2UgZG9uJ3QgY3JlYXRlIGEgY29udGV4dCBmb3IgZWFjaCBlbGVtZW50IGlmIG5vdCBuZWVkZWQuXG4gICAgY29uc3QgY29udGV4dCA9ICgpID0+IHRoaXMuZ2V0Q29udGV4dChpbmRleCwgYWN0aXZlLCBtb2RlKTtcbiAgICBjb25zdCB2YWx1ZXMgPSBjb25maWcucmVzb2x2ZU5hbWVkT3B0aW9ucyhzY29wZXMsIG5hbWVzLCBjb250ZXh0LCBwcmVmaXhlcyk7XG5cbiAgICBpZiAodmFsdWVzLiRzaGFyZWQpIHtcbiAgICAgIC8vIGAkc2hhcmVkYCBpbmRpY2F0ZXMgdGhpcyBzZXQgb2Ygb3B0aW9ucyBjYW4gYmUgc2hhcmVkIGJldHdlZW4gbXVsdGlwbGUgZWxlbWVudHMuXG4gICAgICAvLyBTaGFyaW5nIGlzIHVzZWQgdG8gcmVkdWNlIG51bWJlciBvZiBwcm9wZXJ0aWVzIHRvIGNoYW5nZSBkdXJpbmcgYW5pbWF0aW9uLlxuICAgICAgdmFsdWVzLiRzaGFyZWQgPSBzaGFyaW5nO1xuXG4gICAgICAvLyBXZSBjYWNoZSBvcHRpb25zIGJ5IGBtb2RlYCwgd2hpY2ggY2FuIGJlICdhY3RpdmUnIGZvciBleGFtcGxlLiBUaGlzIGVuYWJsZXMgdXNcbiAgICAgIC8vIHRvIGhhdmUgdGhlICdhY3RpdmUnIGVsZW1lbnQgb3B0aW9ucyBhbmQgJ2RlZmF1bHQnIG9wdGlvbnMgdG8gc3dpdGNoIGJldHdlZW5cbiAgICAgIC8vIHdoZW4gaW50ZXJhY3RpbmcuXG4gICAgICBjYWNoZVtjYWNoZUtleV0gPSBPYmplY3QuZnJlZXplKGNsb25lSWZOb3RTaGFyZWQodmFsdWVzLCBzaGFyaW5nKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHZhbHVlcztcbiAgfVxuXG5cbiAgLyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfcmVzb2x2ZUFuaW1hdGlvbnMoaW5kZXgsIHRyYW5zaXRpb24sIGFjdGl2ZSkge1xuICAgIGNvbnN0IGNoYXJ0ID0gdGhpcy5jaGFydDtcbiAgICBjb25zdCBjYWNoZSA9IHRoaXMuX2NhY2hlZERhdGFPcHRzO1xuICAgIGNvbnN0IGNhY2hlS2V5ID0gYGFuaW1hdGlvbi0ke3RyYW5zaXRpb259YDtcbiAgICBjb25zdCBjYWNoZWQgPSBjYWNoZVtjYWNoZUtleV07XG4gICAgaWYgKGNhY2hlZCkge1xuICAgICAgcmV0dXJuIGNhY2hlZDtcbiAgICB9XG4gICAgbGV0IG9wdGlvbnM7XG4gICAgaWYgKGNoYXJ0Lm9wdGlvbnMuYW5pbWF0aW9uICE9PSBmYWxzZSkge1xuICAgICAgY29uc3QgY29uZmlnID0gdGhpcy5jaGFydC5jb25maWc7XG4gICAgICBjb25zdCBzY29wZUtleXMgPSBjb25maWcuZGF0YXNldEFuaW1hdGlvblNjb3BlS2V5cyh0aGlzLl90eXBlLCB0cmFuc2l0aW9uKTtcbiAgICAgIGNvbnN0IHNjb3BlcyA9IGNvbmZpZy5nZXRPcHRpb25TY29wZXModGhpcy5nZXREYXRhc2V0KCksIHNjb3BlS2V5cyk7XG4gICAgICBvcHRpb25zID0gY29uZmlnLmNyZWF0ZVJlc29sdmVyKHNjb3BlcywgdGhpcy5nZXRDb250ZXh0KGluZGV4LCBhY3RpdmUsIHRyYW5zaXRpb24pKTtcbiAgICB9XG4gICAgY29uc3QgYW5pbWF0aW9ucyA9IG5ldyBBbmltYXRpb25zKGNoYXJ0LCBvcHRpb25zICYmIG9wdGlvbnMuYW5pbWF0aW9ucyk7XG4gICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5fY2FjaGVhYmxlKSB7XG4gICAgICBjYWNoZVtjYWNoZUtleV0gPSBPYmplY3QuZnJlZXplKGFuaW1hdGlvbnMpO1xuICAgIH1cbiAgICByZXR1cm4gYW5pbWF0aW9ucztcbiAgfVxuXG4gIC8qKlxuXHQgKiBVdGlsaXR5IGZvciBnZXR0aW5nIHRoZSBvcHRpb25zIG9iamVjdCBzaGFyZWQgYmV0d2VlbiBlbGVtZW50c1xuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuICBnZXRTaGFyZWRPcHRpb25zKG9wdGlvbnMpIHtcbiAgICBpZiAoIW9wdGlvbnMuJHNoYXJlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fc2hhcmVkT3B0aW9ucyB8fCAodGhpcy5fc2hhcmVkT3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMpKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBVdGlsaXR5IGZvciBkZXRlcm1pbmluZyBpZiBgb3B0aW9uc2Agc2hvdWxkIGJlIGluY2x1ZGVkIGluIHRoZSB1cGRhdGVkIHByb3BlcnRpZXNcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cbiAgaW5jbHVkZU9wdGlvbnMobW9kZSwgc2hhcmVkT3B0aW9ucykge1xuICAgIHJldHVybiAhc2hhcmVkT3B0aW9ucyB8fCBpc0RpcmVjdFVwZGF0ZU1vZGUobW9kZSkgfHwgdGhpcy5jaGFydC5fYW5pbWF0aW9uc0Rpc2FibGVkO1xuICB9XG5cbiAgLyoqXG4gICAqIEB0b2RvIHY0LCByZW5hbWUgdG8gZ2V0U2hhcmVkT3B0aW9ucyBhbmQgcmVtb3ZlIGV4Y2VzcyBmdW5jdGlvbnNcbiAgICovXG4gIF9nZXRTaGFyZWRPcHRpb25zKHN0YXJ0LCBtb2RlKSB7XG4gICAgY29uc3QgZmlyc3RPcHRzID0gdGhpcy5yZXNvbHZlRGF0YUVsZW1lbnRPcHRpb25zKHN0YXJ0LCBtb2RlKTtcbiAgICBjb25zdCBwcmV2aW91c2x5U2hhcmVkT3B0aW9ucyA9IHRoaXMuX3NoYXJlZE9wdGlvbnM7XG4gICAgY29uc3Qgc2hhcmVkT3B0aW9ucyA9IHRoaXMuZ2V0U2hhcmVkT3B0aW9ucyhmaXJzdE9wdHMpO1xuICAgIGNvbnN0IGluY2x1ZGVPcHRpb25zID0gdGhpcy5pbmNsdWRlT3B0aW9ucyhtb2RlLCBzaGFyZWRPcHRpb25zKSB8fCAoc2hhcmVkT3B0aW9ucyAhPT0gcHJldmlvdXNseVNoYXJlZE9wdGlvbnMpO1xuICAgIHRoaXMudXBkYXRlU2hhcmVkT3B0aW9ucyhzaGFyZWRPcHRpb25zLCBtb2RlLCBmaXJzdE9wdHMpO1xuICAgIHJldHVybiB7c2hhcmVkT3B0aW9ucywgaW5jbHVkZU9wdGlvbnN9O1xuICB9XG5cbiAgLyoqXG5cdCAqIFV0aWxpdHkgZm9yIHVwZGF0aW5nIGFuIGVsZW1lbnQgd2l0aCBuZXcgcHJvcGVydGllcywgdXNpbmcgYW5pbWF0aW9ucyB3aGVuIGFwcHJvcHJpYXRlLlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuICB1cGRhdGVFbGVtZW50KGVsZW1lbnQsIGluZGV4LCBwcm9wZXJ0aWVzLCBtb2RlKSB7XG4gICAgaWYgKGlzRGlyZWN0VXBkYXRlTW9kZShtb2RlKSkge1xuICAgICAgT2JqZWN0LmFzc2lnbihlbGVtZW50LCBwcm9wZXJ0aWVzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fcmVzb2x2ZUFuaW1hdGlvbnMoaW5kZXgsIG1vZGUpLnVwZGF0ZShlbGVtZW50LCBwcm9wZXJ0aWVzKTtcbiAgICB9XG4gIH1cblxuICAvKipcblx0ICogVXRpbGl0eSB0byBhbmltYXRlIHRoZSBzaGFyZWQgb3B0aW9ucywgdGhhdCBhcmUgcG90ZW50aWFsbHkgYWZmZWN0aW5nIG11bHRpcGxlIGVsZW1lbnRzLlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuICB1cGRhdGVTaGFyZWRPcHRpb25zKHNoYXJlZE9wdGlvbnMsIG1vZGUsIG5ld09wdGlvbnMpIHtcbiAgICBpZiAoc2hhcmVkT3B0aW9ucyAmJiAhaXNEaXJlY3RVcGRhdGVNb2RlKG1vZGUpKSB7XG4gICAgICB0aGlzLl9yZXNvbHZlQW5pbWF0aW9ucyh1bmRlZmluZWQsIG1vZGUpLnVwZGF0ZShzaGFyZWRPcHRpb25zLCBuZXdPcHRpb25zKTtcbiAgICB9XG4gIH1cblxuICAvKipcblx0ICogQHByaXZhdGVcblx0ICovXG4gIF9zZXRTdHlsZShlbGVtZW50LCBpbmRleCwgbW9kZSwgYWN0aXZlKSB7XG4gICAgZWxlbWVudC5hY3RpdmUgPSBhY3RpdmU7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMuZ2V0U3R5bGUoaW5kZXgsIGFjdGl2ZSk7XG4gICAgdGhpcy5fcmVzb2x2ZUFuaW1hdGlvbnMoaW5kZXgsIG1vZGUsIGFjdGl2ZSkudXBkYXRlKGVsZW1lbnQsIHtcbiAgICAgIC8vIFdoZW4gZ29pbmcgZnJvbSBhY3RpdmUgdG8gaW5hY3RpdmUsIHdlIG5lZWQgdG8gdXBkYXRlIHRvIHRoZSBzaGFyZWQgb3B0aW9ucy5cbiAgICAgIC8vIFRoaXMgd2F5IHRoZSBvbmNlIGhvdmVyZWQgZWxlbWVudCB3aWxsIGVuZCB1cCB3aXRoIHRoZSBzYW1lIG9yaWdpbmFsIHNoYXJlZCBvcHRpb25zIGluc3RhbmNlLCBhZnRlciBhbmltYXRpb24uXG4gICAgICBvcHRpb25zOiAoIWFjdGl2ZSAmJiB0aGlzLmdldFNoYXJlZE9wdGlvbnMob3B0aW9ucykpIHx8IG9wdGlvbnNcbiAgICB9KTtcbiAgfVxuXG4gIHJlbW92ZUhvdmVyU3R5bGUoZWxlbWVudCwgZGF0YXNldEluZGV4LCBpbmRleCkge1xuICAgIHRoaXMuX3NldFN0eWxlKGVsZW1lbnQsIGluZGV4LCAnYWN0aXZlJywgZmFsc2UpO1xuICB9XG5cbiAgc2V0SG92ZXJTdHlsZShlbGVtZW50LCBkYXRhc2V0SW5kZXgsIGluZGV4KSB7XG4gICAgdGhpcy5fc2V0U3R5bGUoZWxlbWVudCwgaW5kZXgsICdhY3RpdmUnLCB0cnVlKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgX3JlbW92ZURhdGFzZXRIb3ZlclN0eWxlKCkge1xuICAgIGNvbnN0IGVsZW1lbnQgPSB0aGlzLl9jYWNoZWRNZXRhLmRhdGFzZXQ7XG5cbiAgICBpZiAoZWxlbWVudCkge1xuICAgICAgdGhpcy5fc2V0U3R5bGUoZWxlbWVudCwgdW5kZWZpbmVkLCAnYWN0aXZlJywgZmFsc2UpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgX3NldERhdGFzZXRIb3ZlclN0eWxlKCkge1xuICAgIGNvbnN0IGVsZW1lbnQgPSB0aGlzLl9jYWNoZWRNZXRhLmRhdGFzZXQ7XG5cbiAgICBpZiAoZWxlbWVudCkge1xuICAgICAgdGhpcy5fc2V0U3R5bGUoZWxlbWVudCwgdW5kZWZpbmVkLCAnYWN0aXZlJywgdHJ1ZSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfcmVzeW5jRWxlbWVudHMocmVzZXROZXdFbGVtZW50cykge1xuICAgIGNvbnN0IGRhdGEgPSB0aGlzLl9kYXRhO1xuICAgIGNvbnN0IGVsZW1lbnRzID0gdGhpcy5fY2FjaGVkTWV0YS5kYXRhO1xuXG4gICAgLy8gQXBwbHkgY2hhbmdlcyBkZXRlY3RlZCB0aHJvdWdoIGFycmF5IGxpc3RlbmVyc1xuICAgIGZvciAoY29uc3QgW21ldGhvZCwgYXJnMSwgYXJnMl0gb2YgdGhpcy5fc3luY0xpc3QpIHtcbiAgICAgIHRoaXNbbWV0aG9kXShhcmcxLCBhcmcyKTtcbiAgICB9XG4gICAgdGhpcy5fc3luY0xpc3QgPSBbXTtcblxuICAgIGNvbnN0IG51bU1ldGEgPSBlbGVtZW50cy5sZW5ndGg7XG4gICAgY29uc3QgbnVtRGF0YSA9IGRhdGEubGVuZ3RoO1xuICAgIGNvbnN0IGNvdW50ID0gTWF0aC5taW4obnVtRGF0YSwgbnVtTWV0YSk7XG5cbiAgICBpZiAoY291bnQpIHtcbiAgICAgIC8vIFRPRE86IEl0IGlzIG5vdCBvcHRpbWFsIHRvIGFsd2F5cyBwYXJzZSB0aGUgb2xkIGRhdGFcbiAgICAgIC8vIFRoaXMgaXMgZG9uZSBiZWNhdXNlIHdlIGFyZSBub3QgZGV0ZWN0aW5nIGRpcmVjdCBhc3NpZ25tZW50czpcbiAgICAgIC8vIGNoYXJ0LmRhdGEuZGF0YXNldHNbMF0uZGF0YVs1XSA9IDEwO1xuICAgICAgLy8gY2hhcnQuZGF0YS5kYXRhc2V0c1swXS5kYXRhWzVdLnkgPSAxMDtcbiAgICAgIHRoaXMucGFyc2UoMCwgY291bnQpO1xuICAgIH1cblxuICAgIGlmIChudW1EYXRhID4gbnVtTWV0YSkge1xuICAgICAgdGhpcy5faW5zZXJ0RWxlbWVudHMobnVtTWV0YSwgbnVtRGF0YSAtIG51bU1ldGEsIHJlc2V0TmV3RWxlbWVudHMpO1xuICAgIH0gZWxzZSBpZiAobnVtRGF0YSA8IG51bU1ldGEpIHtcbiAgICAgIHRoaXMuX3JlbW92ZUVsZW1lbnRzKG51bURhdGEsIG51bU1ldGEgLSBudW1EYXRhKTtcbiAgICB9XG4gIH1cblxuICAvKipcblx0ICogQHByaXZhdGVcblx0ICovXG4gIF9pbnNlcnRFbGVtZW50cyhzdGFydCwgY291bnQsIHJlc2V0TmV3RWxlbWVudHMgPSB0cnVlKSB7XG4gICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgY29uc3QgZGF0YSA9IG1ldGEuZGF0YTtcbiAgICBjb25zdCBlbmQgPSBzdGFydCArIGNvdW50O1xuICAgIGxldCBpO1xuXG4gICAgY29uc3QgbW92ZSA9IChhcnIpID0+IHtcbiAgICAgIGFyci5sZW5ndGggKz0gY291bnQ7XG4gICAgICBmb3IgKGkgPSBhcnIubGVuZ3RoIC0gMTsgaSA+PSBlbmQ7IGktLSkge1xuICAgICAgICBhcnJbaV0gPSBhcnJbaSAtIGNvdW50XTtcbiAgICAgIH1cbiAgICB9O1xuICAgIG1vdmUoZGF0YSk7XG5cbiAgICBmb3IgKGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgICBkYXRhW2ldID0gbmV3IHRoaXMuZGF0YUVsZW1lbnRUeXBlKCk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX3BhcnNpbmcpIHtcbiAgICAgIG1vdmUobWV0YS5fcGFyc2VkKTtcbiAgICB9XG4gICAgdGhpcy5wYXJzZShzdGFydCwgY291bnQpO1xuXG4gICAgaWYgKHJlc2V0TmV3RWxlbWVudHMpIHtcbiAgICAgIHRoaXMudXBkYXRlRWxlbWVudHMoZGF0YSwgc3RhcnQsIGNvdW50LCAncmVzZXQnKTtcbiAgICB9XG4gIH1cblxuICB1cGRhdGVFbGVtZW50cyhlbGVtZW50LCBzdGFydCwgY291bnQsIG1vZGUpIHt9IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcblxuICAvKipcblx0ICogQHByaXZhdGVcblx0ICovXG4gIF9yZW1vdmVFbGVtZW50cyhzdGFydCwgY291bnQpIHtcbiAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICBpZiAodGhpcy5fcGFyc2luZykge1xuICAgICAgY29uc3QgcmVtb3ZlZCA9IG1ldGEuX3BhcnNlZC5zcGxpY2Uoc3RhcnQsIGNvdW50KTtcbiAgICAgIGlmIChtZXRhLl9zdGFja2VkKSB7XG4gICAgICAgIGNsZWFyU3RhY2tzKG1ldGEsIHJlbW92ZWQpO1xuICAgICAgfVxuICAgIH1cbiAgICBtZXRhLmRhdGEuc3BsaWNlKHN0YXJ0LCBjb3VudCk7XG4gIH1cblxuICAvKipcblx0ICogQHByaXZhdGVcbiAgICovXG4gIF9zeW5jKGFyZ3MpIHtcbiAgICBpZiAodGhpcy5fcGFyc2luZykge1xuICAgICAgdGhpcy5fc3luY0xpc3QucHVzaChhcmdzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgW21ldGhvZCwgYXJnMSwgYXJnMl0gPSBhcmdzO1xuICAgICAgdGhpc1ttZXRob2RdKGFyZzEsIGFyZzIpO1xuICAgIH1cbiAgICB0aGlzLmNoYXJ0Ll9kYXRhQ2hhbmdlcy5wdXNoKFt0aGlzLmluZGV4LCAuLi5hcmdzXSk7XG4gIH1cblxuICBfb25EYXRhUHVzaCgpIHtcbiAgICBjb25zdCBjb3VudCA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgdGhpcy5fc3luYyhbJ19pbnNlcnRFbGVtZW50cycsIHRoaXMuZ2V0RGF0YXNldCgpLmRhdGEubGVuZ3RoIC0gY291bnQsIGNvdW50XSk7XG4gIH1cblxuICBfb25EYXRhUG9wKCkge1xuICAgIHRoaXMuX3N5bmMoWydfcmVtb3ZlRWxlbWVudHMnLCB0aGlzLl9jYWNoZWRNZXRhLmRhdGEubGVuZ3RoIC0gMSwgMV0pO1xuICB9XG5cbiAgX29uRGF0YVNoaWZ0KCkge1xuICAgIHRoaXMuX3N5bmMoWydfcmVtb3ZlRWxlbWVudHMnLCAwLCAxXSk7XG4gIH1cblxuICBfb25EYXRhU3BsaWNlKHN0YXJ0LCBjb3VudCkge1xuICAgIGlmIChjb3VudCkge1xuICAgICAgdGhpcy5fc3luYyhbJ19yZW1vdmVFbGVtZW50cycsIHN0YXJ0LCBjb3VudF0pO1xuICAgIH1cbiAgICBjb25zdCBuZXdDb3VudCA9IGFyZ3VtZW50cy5sZW5ndGggLSAyO1xuICAgIGlmIChuZXdDb3VudCkge1xuICAgICAgdGhpcy5fc3luYyhbJ19pbnNlcnRFbGVtZW50cycsIHN0YXJ0LCBuZXdDb3VudF0pO1xuICAgIH1cbiAgfVxuXG4gIF9vbkRhdGFVbnNoaWZ0KCkge1xuICAgIHRoaXMuX3N5bmMoWydfaW5zZXJ0RWxlbWVudHMnLCAwLCBhcmd1bWVudHMubGVuZ3RoXSk7XG4gIH1cbn1cbiIsICJpbXBvcnQgRGF0YXNldENvbnRyb2xsZXIgZnJvbSAnLi4vY29yZS9jb3JlLmRhdGFzZXRDb250cm9sbGVyLmpzJztcbmltcG9ydCB7XG4gIF9hcnJheVVuaXF1ZSwgaXNBcnJheSwgaXNOdWxsT3JVbmRlZixcbiAgdmFsdWVPckRlZmF1bHQsIHJlc29sdmVPYmplY3RLZXksIHNpZ24sIGRlZmluZWRcbn0gZnJvbSAnLi4vaGVscGVycy9pbmRleC5qcyc7XG5cbmZ1bmN0aW9uIGdldEFsbFNjYWxlVmFsdWVzKHNjYWxlLCB0eXBlKSB7XG4gIGlmICghc2NhbGUuX2NhY2hlLiRiYXIpIHtcbiAgICBjb25zdCB2aXNpYmxlTWV0YXMgPSBzY2FsZS5nZXRNYXRjaGluZ1Zpc2libGVNZXRhcyh0eXBlKTtcbiAgICBsZXQgdmFsdWVzID0gW107XG5cbiAgICBmb3IgKGxldCBpID0gMCwgaWxlbiA9IHZpc2libGVNZXRhcy5sZW5ndGg7IGkgPCBpbGVuOyBpKyspIHtcbiAgICAgIHZhbHVlcyA9IHZhbHVlcy5jb25jYXQodmlzaWJsZU1ldGFzW2ldLmNvbnRyb2xsZXIuZ2V0QWxsUGFyc2VkVmFsdWVzKHNjYWxlKSk7XG4gICAgfVxuICAgIHNjYWxlLl9jYWNoZS4kYmFyID0gX2FycmF5VW5pcXVlKHZhbHVlcy5zb3J0KChhLCBiKSA9PiBhIC0gYikpO1xuICB9XG4gIHJldHVybiBzY2FsZS5fY2FjaGUuJGJhcjtcbn1cblxuLyoqXG4gKiBDb21wdXRlcyB0aGUgXCJvcHRpbWFsXCIgc2FtcGxlIHNpemUgdG8gbWFpbnRhaW4gYmFycyBlcXVhbGx5IHNpemVkIHdoaWxlIHByZXZlbnRpbmcgb3ZlcmxhcC5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGNvbXB1dGVNaW5TYW1wbGVTaXplKG1ldGEpIHtcbiAgY29uc3Qgc2NhbGUgPSBtZXRhLmlTY2FsZTtcbiAgY29uc3QgdmFsdWVzID0gZ2V0QWxsU2NhbGVWYWx1ZXMoc2NhbGUsIG1ldGEudHlwZSk7XG4gIGxldCBtaW4gPSBzY2FsZS5fbGVuZ3RoO1xuICBsZXQgaSwgaWxlbiwgY3VyciwgcHJldjtcbiAgY29uc3QgdXBkYXRlTWluQW5kUHJldiA9ICgpID0+IHtcbiAgICBpZiAoY3VyciA9PT0gMzI3NjcgfHwgY3VyciA9PT0gLTMyNzY4KSB7XG4gICAgICAvLyBJZ25vcmUgdHJ1bmNhdGVkIHBpeGVsc1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoZGVmaW5lZChwcmV2KSkge1xuICAgICAgLy8gY3VyciAtIHByZXYgPT09IDAgaXMgaWdub3JlZFxuICAgICAgbWluID0gTWF0aC5taW4obWluLCBNYXRoLmFicyhjdXJyIC0gcHJldikgfHwgbWluKTtcbiAgICB9XG4gICAgcHJldiA9IGN1cnI7XG4gIH07XG5cbiAgZm9yIChpID0gMCwgaWxlbiA9IHZhbHVlcy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICBjdXJyID0gc2NhbGUuZ2V0UGl4ZWxGb3JWYWx1ZSh2YWx1ZXNbaV0pO1xuICAgIHVwZGF0ZU1pbkFuZFByZXYoKTtcbiAgfVxuXG4gIHByZXYgPSB1bmRlZmluZWQ7XG4gIGZvciAoaSA9IDAsIGlsZW4gPSBzY2FsZS50aWNrcy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICBjdXJyID0gc2NhbGUuZ2V0UGl4ZWxGb3JUaWNrKGkpO1xuICAgIHVwZGF0ZU1pbkFuZFByZXYoKTtcbiAgfVxuXG4gIHJldHVybiBtaW47XG59XG5cbi8qKlxuICogQ29tcHV0ZXMgYW4gXCJpZGVhbFwiIGNhdGVnb3J5IGJhc2VkIG9uIHRoZSBhYnNvbHV0ZSBiYXIgdGhpY2tuZXNzIG9yLCBpZiB1bmRlZmluZWQgb3IgbnVsbCxcbiAqIHVzZXMgdGhlIHNtYWxsZXN0IGludGVydmFsIChzZWUgY29tcHV0ZU1pblNhbXBsZVNpemUpIHRoYXQgcHJldmVudHMgYmFyIG92ZXJsYXBwaW5nLiBUaGlzXG4gKiBtb2RlIGN1cnJlbnRseSBhbHdheXMgZ2VuZXJhdGVzIGJhcnMgZXF1YWxseSBzaXplZCAodW50aWwgd2UgaW50cm9kdWNlIHNjcmlwdGFibGUgb3B0aW9ucz8pLlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gY29tcHV0ZUZpdENhdGVnb3J5VHJhaXRzKGluZGV4LCBydWxlciwgb3B0aW9ucywgc3RhY2tDb3VudCkge1xuICBjb25zdCB0aGlja25lc3MgPSBvcHRpb25zLmJhclRoaWNrbmVzcztcbiAgbGV0IHNpemUsIHJhdGlvO1xuXG4gIGlmIChpc051bGxPclVuZGVmKHRoaWNrbmVzcykpIHtcbiAgICBzaXplID0gcnVsZXIubWluICogb3B0aW9ucy5jYXRlZ29yeVBlcmNlbnRhZ2U7XG4gICAgcmF0aW8gPSBvcHRpb25zLmJhclBlcmNlbnRhZ2U7XG4gIH0gZWxzZSB7XG4gICAgLy8gV2hlbiBiYXIgdGhpY2tuZXNzIGlzIGVuZm9yY2VkLCBjYXRlZ29yeSBhbmQgYmFyIHBlcmNlbnRhZ2VzIGFyZSBpZ25vcmVkLlxuICAgIC8vIE5vdGUoU0IpOiB3ZSBjb3VsZCBhZGQgc3VwcG9ydCBmb3IgcmVsYXRpdmUgYmFyIHRoaWNrbmVzcyAoZS5nLiBiYXJUaGlja25lc3M6ICc1MCUnKVxuICAgIC8vIGFuZCBkZXByZWNhdGUgYmFyUGVyY2VudGFnZSBzaW5jZSB0aGlzIHZhbHVlIGlzIGlnbm9yZWQgd2hlbiB0aGlja25lc3MgaXMgYWJzb2x1dGUuXG4gICAgc2l6ZSA9IHRoaWNrbmVzcyAqIHN0YWNrQ291bnQ7XG4gICAgcmF0aW8gPSAxO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBjaHVuazogc2l6ZSAvIHN0YWNrQ291bnQsXG4gICAgcmF0aW8sXG4gICAgc3RhcnQ6IHJ1bGVyLnBpeGVsc1tpbmRleF0gLSAoc2l6ZSAvIDIpXG4gIH07XG59XG5cbi8qKlxuICogQ29tcHV0ZXMgYW4gXCJvcHRpbWFsXCIgY2F0ZWdvcnkgdGhhdCBnbG9iYWxseSBhcnJhbmdlcyBiYXJzIHNpZGUgYnkgc2lkZSAobm8gZ2FwIHdoZW5cbiAqIHBlcmNlbnRhZ2Ugb3B0aW9ucyBhcmUgMSksIGJhc2VkIG9uIHRoZSBwcmV2aW91cyBhbmQgZm9sbG93aW5nIGNhdGVnb3JpZXMuIFRoaXMgbW9kZVxuICogZ2VuZXJhdGVzIGJhcnMgd2l0aCBkaWZmZXJlbnQgd2lkdGhzIHdoZW4gZGF0YSBhcmUgbm90IGV2ZW5seSBzcGFjZWQuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBjb21wdXRlRmxleENhdGVnb3J5VHJhaXRzKGluZGV4LCBydWxlciwgb3B0aW9ucywgc3RhY2tDb3VudCkge1xuICBjb25zdCBwaXhlbHMgPSBydWxlci5waXhlbHM7XG4gIGNvbnN0IGN1cnIgPSBwaXhlbHNbaW5kZXhdO1xuICBsZXQgcHJldiA9IGluZGV4ID4gMCA/IHBpeGVsc1tpbmRleCAtIDFdIDogbnVsbDtcbiAgbGV0IG5leHQgPSBpbmRleCA8IHBpeGVscy5sZW5ndGggLSAxID8gcGl4ZWxzW2luZGV4ICsgMV0gOiBudWxsO1xuICBjb25zdCBwZXJjZW50ID0gb3B0aW9ucy5jYXRlZ29yeVBlcmNlbnRhZ2U7XG5cbiAgaWYgKHByZXYgPT09IG51bGwpIHtcbiAgICAvLyBmaXJzdCBkYXRhOiBpdHMgc2l6ZSBpcyBkb3VibGUgYmFzZWQgb24gdGhlIG5leHQgcG9pbnQgb3IsXG4gICAgLy8gaWYgaXQncyBhbHNvIHRoZSBsYXN0IGRhdGEsIHdlIHVzZSB0aGUgc2NhbGUgc2l6ZS5cbiAgICBwcmV2ID0gY3VyciAtIChuZXh0ID09PSBudWxsID8gcnVsZXIuZW5kIC0gcnVsZXIuc3RhcnQgOiBuZXh0IC0gY3Vycik7XG4gIH1cblxuICBpZiAobmV4dCA9PT0gbnVsbCkge1xuICAgIC8vIGxhc3QgZGF0YTogaXRzIHNpemUgaXMgYWxzbyBkb3VibGUgYmFzZWQgb24gdGhlIHByZXZpb3VzIHBvaW50LlxuICAgIG5leHQgPSBjdXJyICsgY3VyciAtIHByZXY7XG4gIH1cblxuICBjb25zdCBzdGFydCA9IGN1cnIgLSAoY3VyciAtIE1hdGgubWluKHByZXYsIG5leHQpKSAvIDIgKiBwZXJjZW50O1xuICBjb25zdCBzaXplID0gTWF0aC5hYnMobmV4dCAtIHByZXYpIC8gMiAqIHBlcmNlbnQ7XG5cbiAgcmV0dXJuIHtcbiAgICBjaHVuazogc2l6ZSAvIHN0YWNrQ291bnQsXG4gICAgcmF0aW86IG9wdGlvbnMuYmFyUGVyY2VudGFnZSxcbiAgICBzdGFydFxuICB9O1xufVxuXG5mdW5jdGlvbiBwYXJzZUZsb2F0QmFyKGVudHJ5LCBpdGVtLCB2U2NhbGUsIGkpIHtcbiAgY29uc3Qgc3RhcnRWYWx1ZSA9IHZTY2FsZS5wYXJzZShlbnRyeVswXSwgaSk7XG4gIGNvbnN0IGVuZFZhbHVlID0gdlNjYWxlLnBhcnNlKGVudHJ5WzFdLCBpKTtcbiAgY29uc3QgbWluID0gTWF0aC5taW4oc3RhcnRWYWx1ZSwgZW5kVmFsdWUpO1xuICBjb25zdCBtYXggPSBNYXRoLm1heChzdGFydFZhbHVlLCBlbmRWYWx1ZSk7XG4gIGxldCBiYXJTdGFydCA9IG1pbjtcbiAgbGV0IGJhckVuZCA9IG1heDtcblxuICBpZiAoTWF0aC5hYnMobWluKSA+IE1hdGguYWJzKG1heCkpIHtcbiAgICBiYXJTdGFydCA9IG1heDtcbiAgICBiYXJFbmQgPSBtaW47XG4gIH1cblxuICAvLyBTdG9yZSBgYmFyRW5kYCAoZnVydGhlc3QgYXdheSBmcm9tIG9yaWdpbikgYXMgcGFyc2VkIHZhbHVlLFxuICAvLyB0byBtYWtlIHN0YWNraW5nIHN0cmFpZ2h0IGZvcndhcmRcbiAgaXRlbVt2U2NhbGUuYXhpc10gPSBiYXJFbmQ7XG5cbiAgaXRlbS5fY3VzdG9tID0ge1xuICAgIGJhclN0YXJ0LFxuICAgIGJhckVuZCxcbiAgICBzdGFydDogc3RhcnRWYWx1ZSxcbiAgICBlbmQ6IGVuZFZhbHVlLFxuICAgIG1pbixcbiAgICBtYXhcbiAgfTtcbn1cblxuZnVuY3Rpb24gcGFyc2VWYWx1ZShlbnRyeSwgaXRlbSwgdlNjYWxlLCBpKSB7XG4gIGlmIChpc0FycmF5KGVudHJ5KSkge1xuICAgIHBhcnNlRmxvYXRCYXIoZW50cnksIGl0ZW0sIHZTY2FsZSwgaSk7XG4gIH0gZWxzZSB7XG4gICAgaXRlbVt2U2NhbGUuYXhpc10gPSB2U2NhbGUucGFyc2UoZW50cnksIGkpO1xuICB9XG4gIHJldHVybiBpdGVtO1xufVxuXG5mdW5jdGlvbiBwYXJzZUFycmF5T3JQcmltaXRpdmUobWV0YSwgZGF0YSwgc3RhcnQsIGNvdW50KSB7XG4gIGNvbnN0IGlTY2FsZSA9IG1ldGEuaVNjYWxlO1xuICBjb25zdCB2U2NhbGUgPSBtZXRhLnZTY2FsZTtcbiAgY29uc3QgbGFiZWxzID0gaVNjYWxlLmdldExhYmVscygpO1xuICBjb25zdCBzaW5nbGVTY2FsZSA9IGlTY2FsZSA9PT0gdlNjYWxlO1xuICBjb25zdCBwYXJzZWQgPSBbXTtcbiAgbGV0IGksIGlsZW4sIGl0ZW0sIGVudHJ5O1xuXG4gIGZvciAoaSA9IHN0YXJ0LCBpbGVuID0gc3RhcnQgKyBjb3VudDsgaSA8IGlsZW47ICsraSkge1xuICAgIGVudHJ5ID0gZGF0YVtpXTtcbiAgICBpdGVtID0ge307XG4gICAgaXRlbVtpU2NhbGUuYXhpc10gPSBzaW5nbGVTY2FsZSB8fCBpU2NhbGUucGFyc2UobGFiZWxzW2ldLCBpKTtcbiAgICBwYXJzZWQucHVzaChwYXJzZVZhbHVlKGVudHJ5LCBpdGVtLCB2U2NhbGUsIGkpKTtcbiAgfVxuICByZXR1cm4gcGFyc2VkO1xufVxuXG5mdW5jdGlvbiBpc0Zsb2F0QmFyKGN1c3RvbSkge1xuICByZXR1cm4gY3VzdG9tICYmIGN1c3RvbS5iYXJTdGFydCAhPT0gdW5kZWZpbmVkICYmIGN1c3RvbS5iYXJFbmQgIT09IHVuZGVmaW5lZDtcbn1cblxuZnVuY3Rpb24gYmFyU2lnbihzaXplLCB2U2NhbGUsIGFjdHVhbEJhc2UpIHtcbiAgaWYgKHNpemUgIT09IDApIHtcbiAgICByZXR1cm4gc2lnbihzaXplKTtcbiAgfVxuICByZXR1cm4gKHZTY2FsZS5pc0hvcml6b250YWwoKSA/IDEgOiAtMSkgKiAodlNjYWxlLm1pbiA+PSBhY3R1YWxCYXNlID8gMSA6IC0xKTtcbn1cblxuZnVuY3Rpb24gYm9yZGVyUHJvcHMocHJvcGVydGllcykge1xuICBsZXQgcmV2ZXJzZSwgc3RhcnQsIGVuZCwgdG9wLCBib3R0b207XG4gIGlmIChwcm9wZXJ0aWVzLmhvcml6b250YWwpIHtcbiAgICByZXZlcnNlID0gcHJvcGVydGllcy5iYXNlID4gcHJvcGVydGllcy54O1xuICAgIHN0YXJ0ID0gJ2xlZnQnO1xuICAgIGVuZCA9ICdyaWdodCc7XG4gIH0gZWxzZSB7XG4gICAgcmV2ZXJzZSA9IHByb3BlcnRpZXMuYmFzZSA8IHByb3BlcnRpZXMueTtcbiAgICBzdGFydCA9ICdib3R0b20nO1xuICAgIGVuZCA9ICd0b3AnO1xuICB9XG4gIGlmIChyZXZlcnNlKSB7XG4gICAgdG9wID0gJ2VuZCc7XG4gICAgYm90dG9tID0gJ3N0YXJ0JztcbiAgfSBlbHNlIHtcbiAgICB0b3AgPSAnc3RhcnQnO1xuICAgIGJvdHRvbSA9ICdlbmQnO1xuICB9XG4gIHJldHVybiB7c3RhcnQsIGVuZCwgcmV2ZXJzZSwgdG9wLCBib3R0b219O1xufVxuXG5mdW5jdGlvbiBzZXRCb3JkZXJTa2lwcGVkKHByb3BlcnRpZXMsIG9wdGlvbnMsIHN0YWNrLCBpbmRleCkge1xuICBsZXQgZWRnZSA9IG9wdGlvbnMuYm9yZGVyU2tpcHBlZDtcbiAgY29uc3QgcmVzID0ge307XG5cbiAgaWYgKCFlZGdlKSB7XG4gICAgcHJvcGVydGllcy5ib3JkZXJTa2lwcGVkID0gcmVzO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChlZGdlID09PSB0cnVlKSB7XG4gICAgcHJvcGVydGllcy5ib3JkZXJTa2lwcGVkID0ge3RvcDogdHJ1ZSwgcmlnaHQ6IHRydWUsIGJvdHRvbTogdHJ1ZSwgbGVmdDogdHJ1ZX07XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgY29uc3Qge3N0YXJ0LCBlbmQsIHJldmVyc2UsIHRvcCwgYm90dG9tfSA9IGJvcmRlclByb3BzKHByb3BlcnRpZXMpO1xuXG4gIGlmIChlZGdlID09PSAnbWlkZGxlJyAmJiBzdGFjaykge1xuICAgIHByb3BlcnRpZXMuZW5hYmxlQm9yZGVyUmFkaXVzID0gdHJ1ZTtcbiAgICBpZiAoKHN0YWNrLl90b3AgfHwgMCkgPT09IGluZGV4KSB7XG4gICAgICBlZGdlID0gdG9wO1xuICAgIH0gZWxzZSBpZiAoKHN0YWNrLl9ib3R0b20gfHwgMCkgPT09IGluZGV4KSB7XG4gICAgICBlZGdlID0gYm90dG9tO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXNbcGFyc2VFZGdlKGJvdHRvbSwgc3RhcnQsIGVuZCwgcmV2ZXJzZSldID0gdHJ1ZTtcbiAgICAgIGVkZ2UgPSB0b3A7XG4gICAgfVxuICB9XG5cbiAgcmVzW3BhcnNlRWRnZShlZGdlLCBzdGFydCwgZW5kLCByZXZlcnNlKV0gPSB0cnVlO1xuICBwcm9wZXJ0aWVzLmJvcmRlclNraXBwZWQgPSByZXM7XG59XG5cbmZ1bmN0aW9uIHBhcnNlRWRnZShlZGdlLCBhLCBiLCByZXZlcnNlKSB7XG4gIGlmIChyZXZlcnNlKSB7XG4gICAgZWRnZSA9IHN3YXAoZWRnZSwgYSwgYik7XG4gICAgZWRnZSA9IHN0YXJ0RW5kKGVkZ2UsIGIsIGEpO1xuICB9IGVsc2Uge1xuICAgIGVkZ2UgPSBzdGFydEVuZChlZGdlLCBhLCBiKTtcbiAgfVxuICByZXR1cm4gZWRnZTtcbn1cblxuZnVuY3Rpb24gc3dhcChvcmlnLCB2MSwgdjIpIHtcbiAgcmV0dXJuIG9yaWcgPT09IHYxID8gdjIgOiBvcmlnID09PSB2MiA/IHYxIDogb3JpZztcbn1cblxuZnVuY3Rpb24gc3RhcnRFbmQodiwgc3RhcnQsIGVuZCkge1xuICByZXR1cm4gdiA9PT0gJ3N0YXJ0JyA/IHN0YXJ0IDogdiA9PT0gJ2VuZCcgPyBlbmQgOiB2O1xufVxuXG5mdW5jdGlvbiBzZXRJbmZsYXRlQW1vdW50KHByb3BlcnRpZXMsIHtpbmZsYXRlQW1vdW50fSwgcmF0aW8pIHtcbiAgcHJvcGVydGllcy5pbmZsYXRlQW1vdW50ID0gaW5mbGF0ZUFtb3VudCA9PT0gJ2F1dG8nXG4gICAgPyByYXRpbyA9PT0gMSA/IDAuMzMgOiAwXG4gICAgOiBpbmZsYXRlQW1vdW50O1xufVxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBCYXJDb250cm9sbGVyIGV4dGVuZHMgRGF0YXNldENvbnRyb2xsZXIge1xuXG4gIHN0YXRpYyBpZCA9ICdiYXInO1xuXG4gIC8qKlxuICAgKiBAdHlwZSB7YW55fVxuICAgKi9cbiAgc3RhdGljIGRlZmF1bHRzID0ge1xuICAgIGRhdGFzZXRFbGVtZW50VHlwZTogZmFsc2UsXG4gICAgZGF0YUVsZW1lbnRUeXBlOiAnYmFyJyxcblxuICAgIGNhdGVnb3J5UGVyY2VudGFnZTogMC44LFxuICAgIGJhclBlcmNlbnRhZ2U6IDAuOSxcbiAgICBncm91cGVkOiB0cnVlLFxuXG4gICAgYW5pbWF0aW9uczoge1xuICAgICAgbnVtYmVyczoge1xuICAgICAgICB0eXBlOiAnbnVtYmVyJyxcbiAgICAgICAgcHJvcGVydGllczogWyd4JywgJ3knLCAnYmFzZScsICd3aWR0aCcsICdoZWlnaHQnXVxuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQHR5cGUge2FueX1cbiAgICovXG4gIHN0YXRpYyBvdmVycmlkZXMgPSB7XG4gICAgc2NhbGVzOiB7XG4gICAgICBfaW5kZXhfOiB7XG4gICAgICAgIHR5cGU6ICdjYXRlZ29yeScsXG4gICAgICAgIG9mZnNldDogdHJ1ZSxcbiAgICAgICAgZ3JpZDoge1xuICAgICAgICAgIG9mZnNldDogdHJ1ZVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgX3ZhbHVlXzoge1xuICAgICAgICB0eXBlOiAnbGluZWFyJyxcbiAgICAgICAgYmVnaW5BdFplcm86IHRydWUsXG4gICAgICB9XG4gICAgfVxuICB9O1xuXG5cbiAgLyoqXG5cdCAqIE92ZXJyaWRpbmcgcHJpbWl0aXZlIGRhdGEgcGFyc2luZyBzaW5jZSB3ZSBzdXBwb3J0IG1peGVkIHByaW1pdGl2ZS9hcnJheVxuXHQgKiBkYXRhIGZvciBmbG9hdCBiYXJzXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG4gIHBhcnNlUHJpbWl0aXZlRGF0YShtZXRhLCBkYXRhLCBzdGFydCwgY291bnQpIHtcbiAgICByZXR1cm4gcGFyc2VBcnJheU9yUHJpbWl0aXZlKG1ldGEsIGRhdGEsIHN0YXJ0LCBjb3VudCk7XG4gIH1cblxuICAvKipcblx0ICogT3ZlcnJpZGluZyBhcnJheSBkYXRhIHBhcnNpbmcgc2luY2Ugd2Ugc3VwcG9ydCBtaXhlZCBwcmltaXRpdmUvYXJyYXlcblx0ICogZGF0YSBmb3IgZmxvYXQgYmFyc1xuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuICBwYXJzZUFycmF5RGF0YShtZXRhLCBkYXRhLCBzdGFydCwgY291bnQpIHtcbiAgICByZXR1cm4gcGFyc2VBcnJheU9yUHJpbWl0aXZlKG1ldGEsIGRhdGEsIHN0YXJ0LCBjb3VudCk7XG4gIH1cblxuICAvKipcblx0ICogT3ZlcnJpZGluZyBvYmplY3QgZGF0YSBwYXJzaW5nIHNpbmNlIHdlIHN1cHBvcnQgbWl4ZWQgcHJpbWl0aXZlL2FycmF5XG5cdCAqIHZhbHVlLXNjYWxlIGRhdGEgZm9yIGZsb2F0IGJhcnNcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cbiAgcGFyc2VPYmplY3REYXRhKG1ldGEsIGRhdGEsIHN0YXJ0LCBjb3VudCkge1xuICAgIGNvbnN0IHtpU2NhbGUsIHZTY2FsZX0gPSBtZXRhO1xuICAgIGNvbnN0IHt4QXhpc0tleSA9ICd4JywgeUF4aXNLZXkgPSAneSd9ID0gdGhpcy5fcGFyc2luZztcbiAgICBjb25zdCBpQXhpc0tleSA9IGlTY2FsZS5heGlzID09PSAneCcgPyB4QXhpc0tleSA6IHlBeGlzS2V5O1xuICAgIGNvbnN0IHZBeGlzS2V5ID0gdlNjYWxlLmF4aXMgPT09ICd4JyA/IHhBeGlzS2V5IDogeUF4aXNLZXk7XG4gICAgY29uc3QgcGFyc2VkID0gW107XG4gICAgbGV0IGksIGlsZW4sIGl0ZW0sIG9iajtcbiAgICBmb3IgKGkgPSBzdGFydCwgaWxlbiA9IHN0YXJ0ICsgY291bnQ7IGkgPCBpbGVuOyArK2kpIHtcbiAgICAgIG9iaiA9IGRhdGFbaV07XG4gICAgICBpdGVtID0ge307XG4gICAgICBpdGVtW2lTY2FsZS5heGlzXSA9IGlTY2FsZS5wYXJzZShyZXNvbHZlT2JqZWN0S2V5KG9iaiwgaUF4aXNLZXkpLCBpKTtcbiAgICAgIHBhcnNlZC5wdXNoKHBhcnNlVmFsdWUocmVzb2x2ZU9iamVjdEtleShvYmosIHZBeGlzS2V5KSwgaXRlbSwgdlNjYWxlLCBpKSk7XG4gICAgfVxuICAgIHJldHVybiBwYXJzZWQ7XG4gIH1cblxuICAvKipcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cbiAgdXBkYXRlUmFuZ2VGcm9tUGFyc2VkKHJhbmdlLCBzY2FsZSwgcGFyc2VkLCBzdGFjaykge1xuICAgIHN1cGVyLnVwZGF0ZVJhbmdlRnJvbVBhcnNlZChyYW5nZSwgc2NhbGUsIHBhcnNlZCwgc3RhY2spO1xuICAgIGNvbnN0IGN1c3RvbSA9IHBhcnNlZC5fY3VzdG9tO1xuICAgIGlmIChjdXN0b20gJiYgc2NhbGUgPT09IHRoaXMuX2NhY2hlZE1ldGEudlNjYWxlKSB7XG4gICAgICAvLyBmbG9hdCBiYXI6IG9ubHkgb25lIGVuZCBvZiB0aGUgYmFyIGlzIGNvbnNpZGVyZWQgYnkgYHN1cGVyYFxuICAgICAgcmFuZ2UubWluID0gTWF0aC5taW4ocmFuZ2UubWluLCBjdXN0b20ubWluKTtcbiAgICAgIHJhbmdlLm1heCA9IE1hdGgubWF4KHJhbmdlLm1heCwgY3VzdG9tLm1heCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG5cdCAqIEByZXR1cm4ge251bWJlcnxib29sZWFufVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuICBnZXRNYXhPdmVyZmxvdygpIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuICBnZXRMYWJlbEFuZFZhbHVlKGluZGV4KSB7XG4gICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgY29uc3Qge2lTY2FsZSwgdlNjYWxlfSA9IG1ldGE7XG4gICAgY29uc3QgcGFyc2VkID0gdGhpcy5nZXRQYXJzZWQoaW5kZXgpO1xuICAgIGNvbnN0IGN1c3RvbSA9IHBhcnNlZC5fY3VzdG9tO1xuICAgIGNvbnN0IHZhbHVlID0gaXNGbG9hdEJhcihjdXN0b20pXG4gICAgICA/ICdbJyArIGN1c3RvbS5zdGFydCArICcsICcgKyBjdXN0b20uZW5kICsgJ10nXG4gICAgICA6ICcnICsgdlNjYWxlLmdldExhYmVsRm9yVmFsdWUocGFyc2VkW3ZTY2FsZS5heGlzXSk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgbGFiZWw6ICcnICsgaVNjYWxlLmdldExhYmVsRm9yVmFsdWUocGFyc2VkW2lTY2FsZS5heGlzXSksXG4gICAgICB2YWx1ZVxuICAgIH07XG4gIH1cblxuICBpbml0aWFsaXplKCkge1xuICAgIHRoaXMuZW5hYmxlT3B0aW9uU2hhcmluZyA9IHRydWU7XG5cbiAgICBzdXBlci5pbml0aWFsaXplKCk7XG5cbiAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICBtZXRhLnN0YWNrID0gdGhpcy5nZXREYXRhc2V0KCkuc3RhY2s7XG4gIH1cblxuICB1cGRhdGUobW9kZSkge1xuICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgIHRoaXMudXBkYXRlRWxlbWVudHMobWV0YS5kYXRhLCAwLCBtZXRhLmRhdGEubGVuZ3RoLCBtb2RlKTtcbiAgfVxuXG4gIHVwZGF0ZUVsZW1lbnRzKGJhcnMsIHN0YXJ0LCBjb3VudCwgbW9kZSkge1xuICAgIGNvbnN0IHJlc2V0ID0gbW9kZSA9PT0gJ3Jlc2V0JztcbiAgICBjb25zdCB7aW5kZXgsIF9jYWNoZWRNZXRhOiB7dlNjYWxlfX0gPSB0aGlzO1xuICAgIGNvbnN0IGJhc2UgPSB2U2NhbGUuZ2V0QmFzZVBpeGVsKCk7XG4gICAgY29uc3QgaG9yaXpvbnRhbCA9IHZTY2FsZS5pc0hvcml6b250YWwoKTtcbiAgICBjb25zdCBydWxlciA9IHRoaXMuX2dldFJ1bGVyKCk7XG4gICAgY29uc3Qge3NoYXJlZE9wdGlvbnMsIGluY2x1ZGVPcHRpb25zfSA9IHRoaXMuX2dldFNoYXJlZE9wdGlvbnMoc3RhcnQsIG1vZGUpO1xuXG4gICAgZm9yIChsZXQgaSA9IHN0YXJ0OyBpIDwgc3RhcnQgKyBjb3VudDsgaSsrKSB7XG4gICAgICBjb25zdCBwYXJzZWQgPSB0aGlzLmdldFBhcnNlZChpKTtcbiAgICAgIGNvbnN0IHZwaXhlbHMgPSByZXNldCB8fCBpc051bGxPclVuZGVmKHBhcnNlZFt2U2NhbGUuYXhpc10pID8ge2Jhc2UsIGhlYWQ6IGJhc2V9IDogdGhpcy5fY2FsY3VsYXRlQmFyVmFsdWVQaXhlbHMoaSk7XG4gICAgICBjb25zdCBpcGl4ZWxzID0gdGhpcy5fY2FsY3VsYXRlQmFySW5kZXhQaXhlbHMoaSwgcnVsZXIpO1xuICAgICAgY29uc3Qgc3RhY2sgPSAocGFyc2VkLl9zdGFja3MgfHwge30pW3ZTY2FsZS5heGlzXTtcblxuICAgICAgY29uc3QgcHJvcGVydGllcyA9IHtcbiAgICAgICAgaG9yaXpvbnRhbCxcbiAgICAgICAgYmFzZTogdnBpeGVscy5iYXNlLFxuICAgICAgICBlbmFibGVCb3JkZXJSYWRpdXM6ICFzdGFjayB8fCBpc0Zsb2F0QmFyKHBhcnNlZC5fY3VzdG9tKSB8fCAoaW5kZXggPT09IHN0YWNrLl90b3AgfHwgaW5kZXggPT09IHN0YWNrLl9ib3R0b20pLFxuICAgICAgICB4OiBob3Jpem9udGFsID8gdnBpeGVscy5oZWFkIDogaXBpeGVscy5jZW50ZXIsXG4gICAgICAgIHk6IGhvcml6b250YWwgPyBpcGl4ZWxzLmNlbnRlciA6IHZwaXhlbHMuaGVhZCxcbiAgICAgICAgaGVpZ2h0OiBob3Jpem9udGFsID8gaXBpeGVscy5zaXplIDogTWF0aC5hYnModnBpeGVscy5zaXplKSxcbiAgICAgICAgd2lkdGg6IGhvcml6b250YWwgPyBNYXRoLmFicyh2cGl4ZWxzLnNpemUpIDogaXBpeGVscy5zaXplXG4gICAgICB9O1xuXG4gICAgICBpZiAoaW5jbHVkZU9wdGlvbnMpIHtcbiAgICAgICAgcHJvcGVydGllcy5vcHRpb25zID0gc2hhcmVkT3B0aW9ucyB8fCB0aGlzLnJlc29sdmVEYXRhRWxlbWVudE9wdGlvbnMoaSwgYmFyc1tpXS5hY3RpdmUgPyAnYWN0aXZlJyA6IG1vZGUpO1xuICAgICAgfVxuICAgICAgY29uc3Qgb3B0aW9ucyA9IHByb3BlcnRpZXMub3B0aW9ucyB8fCBiYXJzW2ldLm9wdGlvbnM7XG4gICAgICBzZXRCb3JkZXJTa2lwcGVkKHByb3BlcnRpZXMsIG9wdGlvbnMsIHN0YWNrLCBpbmRleCk7XG4gICAgICBzZXRJbmZsYXRlQW1vdW50KHByb3BlcnRpZXMsIG9wdGlvbnMsIHJ1bGVyLnJhdGlvKTtcbiAgICAgIHRoaXMudXBkYXRlRWxlbWVudChiYXJzW2ldLCBpLCBwcm9wZXJ0aWVzLCBtb2RlKTtcbiAgICB9XG4gIH1cblxuICAvKipcblx0ICogUmV0dXJucyB0aGUgc3RhY2tzIGJhc2VkIG9uIGdyb3VwcyBhbmQgYmFyIHZpc2liaWxpdHkuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBbbGFzdF0gLSBUaGUgZGF0YXNldCBpbmRleFxuXHQgKiBAcGFyYW0ge251bWJlcn0gW2RhdGFJbmRleF0gLSBUaGUgZGF0YSBpbmRleCBvZiB0aGUgcnVsZXJcblx0ICogQHJldHVybnMge3N0cmluZ1tdfSBUaGUgbGlzdCBvZiBzdGFjayBJRHNcblx0ICogQHByaXZhdGVcblx0ICovXG4gIF9nZXRTdGFja3MobGFzdCwgZGF0YUluZGV4KSB7XG4gICAgY29uc3Qge2lTY2FsZX0gPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgIGNvbnN0IG1ldGFzZXRzID0gaVNjYWxlLmdldE1hdGNoaW5nVmlzaWJsZU1ldGFzKHRoaXMuX3R5cGUpXG4gICAgICAuZmlsdGVyKG1ldGEgPT4gbWV0YS5jb250cm9sbGVyLm9wdGlvbnMuZ3JvdXBlZCk7XG4gICAgY29uc3Qgc3RhY2tlZCA9IGlTY2FsZS5vcHRpb25zLnN0YWNrZWQ7XG4gICAgY29uc3Qgc3RhY2tzID0gW107XG4gICAgY29uc3QgY3VycmVudFBhcnNlZCA9IHRoaXMuX2NhY2hlZE1ldGEuY29udHJvbGxlci5nZXRQYXJzZWQoZGF0YUluZGV4KTtcbiAgICBjb25zdCBpU2NhbGVWYWx1ZSA9IGN1cnJlbnRQYXJzZWQgJiYgY3VycmVudFBhcnNlZFtpU2NhbGUuYXhpc107XG5cbiAgICBjb25zdCBza2lwTnVsbCA9IChtZXRhKSA9PiB7XG4gICAgICBjb25zdCBwYXJzZWQgPSBtZXRhLl9wYXJzZWQuZmluZChpdGVtID0+IGl0ZW1baVNjYWxlLmF4aXNdID09PSBpU2NhbGVWYWx1ZSk7XG4gICAgICBjb25zdCB2YWwgPSBwYXJzZWQgJiYgcGFyc2VkW21ldGEudlNjYWxlLmF4aXNdO1xuXG4gICAgICBpZiAoaXNOdWxsT3JVbmRlZih2YWwpIHx8IGlzTmFOKHZhbCkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGZvciAoY29uc3QgbWV0YSBvZiBtZXRhc2V0cykge1xuICAgICAgaWYgKGRhdGFJbmRleCAhPT0gdW5kZWZpbmVkICYmIHNraXBOdWxsKG1ldGEpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICAvLyBzdGFja2VkICAgfCBtZXRhLnN0YWNrXG4gICAgICAvLyAgICAgICAgICAgfCBmb3VuZCB8IG5vdCBmb3VuZCB8IHVuZGVmaW5lZFxuICAgICAgLy8gZmFsc2UgICAgIHwgICB4ICAgfCAgICAgeCAgICAgfCAgICAgeFxuICAgICAgLy8gdHJ1ZSAgICAgIHwgICAgICAgfCAgICAgeCAgICAgfFxuICAgICAgLy8gdW5kZWZpbmVkIHwgICAgICAgfCAgICAgeCAgICAgfCAgICAgeFxuICAgICAgaWYgKHN0YWNrZWQgPT09IGZhbHNlIHx8IHN0YWNrcy5pbmRleE9mKG1ldGEuc3RhY2spID09PSAtMSB8fFxuXHRcdFx0XHQoc3RhY2tlZCA9PT0gdW5kZWZpbmVkICYmIG1ldGEuc3RhY2sgPT09IHVuZGVmaW5lZCkpIHtcbiAgICAgICAgc3RhY2tzLnB1c2gobWV0YS5zdGFjayk7XG4gICAgICB9XG4gICAgICBpZiAobWV0YS5pbmRleCA9PT0gbGFzdCkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBObyBzdGFja3M/IHRoYXQgbWVhbnMgdGhlcmUgaXMgbm8gdmlzaWJsZSBkYXRhLiBMZXQncyBzdGlsbCBpbml0aWFsaXplIGFuIGB1bmRlZmluZWRgXG4gICAgLy8gc3RhY2sgd2hlcmUgcG9zc2libGUgaW52aXNpYmxlIGJhcnMgd2lsbCBiZSBsb2NhdGVkLlxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9jaGFydGpzL0NoYXJ0LmpzL2lzc3Vlcy82MzY4XG4gICAgaWYgKCFzdGFja3MubGVuZ3RoKSB7XG4gICAgICBzdGFja3MucHVzaCh1bmRlZmluZWQpO1xuICAgIH1cblxuICAgIHJldHVybiBzdGFja3M7XG4gIH1cblxuICAvKipcblx0ICogUmV0dXJucyB0aGUgZWZmZWN0aXZlIG51bWJlciBvZiBzdGFja3MgYmFzZWQgb24gZ3JvdXBzIGFuZCBiYXIgdmlzaWJpbGl0eS5cblx0ICogQHByaXZhdGVcblx0ICovXG4gIF9nZXRTdGFja0NvdW50KGluZGV4KSB7XG4gICAgcmV0dXJuIHRoaXMuX2dldFN0YWNrcyh1bmRlZmluZWQsIGluZGV4KS5sZW5ndGg7XG4gIH1cblxuICAvKipcblx0ICogUmV0dXJucyB0aGUgc3RhY2sgaW5kZXggZm9yIHRoZSBnaXZlbiBkYXRhc2V0IGJhc2VkIG9uIGdyb3VwcyBhbmQgYmFyIHZpc2liaWxpdHkuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBbZGF0YXNldEluZGV4XSAtIFRoZSBkYXRhc2V0IGluZGV4XG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBbbmFtZV0gLSBUaGUgc3RhY2sgbmFtZSB0byBmaW5kXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbZGF0YUluZGV4XVxuXHQgKiBAcmV0dXJucyB7bnVtYmVyfSBUaGUgc3RhY2sgaW5kZXhcblx0ICogQHByaXZhdGVcblx0ICovXG4gIF9nZXRTdGFja0luZGV4KGRhdGFzZXRJbmRleCwgbmFtZSwgZGF0YUluZGV4KSB7XG4gICAgY29uc3Qgc3RhY2tzID0gdGhpcy5fZ2V0U3RhY2tzKGRhdGFzZXRJbmRleCwgZGF0YUluZGV4KTtcbiAgICBjb25zdCBpbmRleCA9IChuYW1lICE9PSB1bmRlZmluZWQpXG4gICAgICA/IHN0YWNrcy5pbmRleE9mKG5hbWUpXG4gICAgICA6IC0xOyAvLyBpbmRleE9mIHJldHVybnMgLTEgaWYgZWxlbWVudCBpcyBub3QgcHJlc2VudFxuXG4gICAgcmV0dXJuIChpbmRleCA9PT0gLTEpXG4gICAgICA/IHN0YWNrcy5sZW5ndGggLSAxXG4gICAgICA6IGluZGV4O1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfZ2V0UnVsZXIoKSB7XG4gICAgY29uc3Qgb3B0cyA9IHRoaXMub3B0aW9ucztcbiAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICBjb25zdCBpU2NhbGUgPSBtZXRhLmlTY2FsZTtcbiAgICBjb25zdCBwaXhlbHMgPSBbXTtcbiAgICBsZXQgaSwgaWxlbjtcblxuICAgIGZvciAoaSA9IDAsIGlsZW4gPSBtZXRhLmRhdGEubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgICBwaXhlbHMucHVzaChpU2NhbGUuZ2V0UGl4ZWxGb3JWYWx1ZSh0aGlzLmdldFBhcnNlZChpKVtpU2NhbGUuYXhpc10sIGkpKTtcbiAgICB9XG5cbiAgICBjb25zdCBiYXJUaGlja25lc3MgPSBvcHRzLmJhclRoaWNrbmVzcztcbiAgICBjb25zdCBtaW4gPSBiYXJUaGlja25lc3MgfHwgY29tcHV0ZU1pblNhbXBsZVNpemUobWV0YSk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgbWluLFxuICAgICAgcGl4ZWxzLFxuICAgICAgc3RhcnQ6IGlTY2FsZS5fc3RhcnRQaXhlbCxcbiAgICAgIGVuZDogaVNjYWxlLl9lbmRQaXhlbCxcbiAgICAgIHN0YWNrQ291bnQ6IHRoaXMuX2dldFN0YWNrQ291bnQoKSxcbiAgICAgIHNjYWxlOiBpU2NhbGUsXG4gICAgICBncm91cGVkOiBvcHRzLmdyb3VwZWQsXG4gICAgICAvLyBiYXIgdGhpY2tuZXNzIHJhdGlvIHVzZWQgZm9yIG5vbi1ncm91cGVkIGJhcnNcbiAgICAgIHJhdGlvOiBiYXJUaGlja25lc3MgPyAxIDogb3B0cy5jYXRlZ29yeVBlcmNlbnRhZ2UgKiBvcHRzLmJhclBlcmNlbnRhZ2VcbiAgICB9O1xuICB9XG5cbiAgLyoqXG5cdCAqIE5vdGU6IHBpeGVsIHZhbHVlcyBhcmUgbm90IGNsYW1wZWQgdG8gdGhlIHNjYWxlIGFyZWEuXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfY2FsY3VsYXRlQmFyVmFsdWVQaXhlbHMoaW5kZXgpIHtcbiAgICBjb25zdCB7X2NhY2hlZE1ldGE6IHt2U2NhbGUsIF9zdGFja2VkLCBpbmRleDogZGF0YXNldEluZGV4fSwgb3B0aW9uczoge2Jhc2U6IGJhc2VWYWx1ZSwgbWluQmFyTGVuZ3RofX0gPSB0aGlzO1xuICAgIGNvbnN0IGFjdHVhbEJhc2UgPSBiYXNlVmFsdWUgfHwgMDtcbiAgICBjb25zdCBwYXJzZWQgPSB0aGlzLmdldFBhcnNlZChpbmRleCk7XG4gICAgY29uc3QgY3VzdG9tID0gcGFyc2VkLl9jdXN0b207XG4gICAgY29uc3QgZmxvYXRpbmcgPSBpc0Zsb2F0QmFyKGN1c3RvbSk7XG4gICAgbGV0IHZhbHVlID0gcGFyc2VkW3ZTY2FsZS5heGlzXTtcbiAgICBsZXQgc3RhcnQgPSAwO1xuICAgIGxldCBsZW5ndGggPSBfc3RhY2tlZCA/IHRoaXMuYXBwbHlTdGFjayh2U2NhbGUsIHBhcnNlZCwgX3N0YWNrZWQpIDogdmFsdWU7XG4gICAgbGV0IGhlYWQsIHNpemU7XG5cbiAgICBpZiAobGVuZ3RoICE9PSB2YWx1ZSkge1xuICAgICAgc3RhcnQgPSBsZW5ndGggLSB2YWx1ZTtcbiAgICAgIGxlbmd0aCA9IHZhbHVlO1xuICAgIH1cblxuICAgIGlmIChmbG9hdGluZykge1xuICAgICAgdmFsdWUgPSBjdXN0b20uYmFyU3RhcnQ7XG4gICAgICBsZW5ndGggPSBjdXN0b20uYmFyRW5kIC0gY3VzdG9tLmJhclN0YXJ0O1xuICAgICAgLy8gYmFycyBjcm9zc2luZyBvcmlnaW4gYXJlIG5vdCBzdGFja2VkXG4gICAgICBpZiAodmFsdWUgIT09IDAgJiYgc2lnbih2YWx1ZSkgIT09IHNpZ24oY3VzdG9tLmJhckVuZCkpIHtcbiAgICAgICAgc3RhcnQgPSAwO1xuICAgICAgfVxuICAgICAgc3RhcnQgKz0gdmFsdWU7XG4gICAgfVxuXG4gICAgY29uc3Qgc3RhcnRWYWx1ZSA9ICFpc051bGxPclVuZGVmKGJhc2VWYWx1ZSkgJiYgIWZsb2F0aW5nID8gYmFzZVZhbHVlIDogc3RhcnQ7XG4gICAgbGV0IGJhc2UgPSB2U2NhbGUuZ2V0UGl4ZWxGb3JWYWx1ZShzdGFydFZhbHVlKTtcblxuICAgIGlmICh0aGlzLmNoYXJ0LmdldERhdGFWaXNpYmlsaXR5KGluZGV4KSkge1xuICAgICAgaGVhZCA9IHZTY2FsZS5nZXRQaXhlbEZvclZhbHVlKHN0YXJ0ICsgbGVuZ3RoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gV2hlbiBub3QgdmlzaWJsZSwgbm8gaGVpZ2h0XG4gICAgICBoZWFkID0gYmFzZTtcbiAgICB9XG5cbiAgICBzaXplID0gaGVhZCAtIGJhc2U7XG5cbiAgICBpZiAoTWF0aC5hYnMoc2l6ZSkgPCBtaW5CYXJMZW5ndGgpIHtcbiAgICAgIHNpemUgPSBiYXJTaWduKHNpemUsIHZTY2FsZSwgYWN0dWFsQmFzZSkgKiBtaW5CYXJMZW5ndGg7XG4gICAgICBpZiAodmFsdWUgPT09IGFjdHVhbEJhc2UpIHtcbiAgICAgICAgYmFzZSAtPSBzaXplIC8gMjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHN0YXJ0UGl4ZWwgPSB2U2NhbGUuZ2V0UGl4ZWxGb3JEZWNpbWFsKDApO1xuICAgICAgY29uc3QgZW5kUGl4ZWwgPSB2U2NhbGUuZ2V0UGl4ZWxGb3JEZWNpbWFsKDEpO1xuICAgICAgY29uc3QgbWluID0gTWF0aC5taW4oc3RhcnRQaXhlbCwgZW5kUGl4ZWwpO1xuICAgICAgY29uc3QgbWF4ID0gTWF0aC5tYXgoc3RhcnRQaXhlbCwgZW5kUGl4ZWwpO1xuICAgICAgYmFzZSA9IE1hdGgubWF4KE1hdGgubWluKGJhc2UsIG1heCksIG1pbik7XG4gICAgICBoZWFkID0gYmFzZSArIHNpemU7XG5cbiAgICAgIGlmIChfc3RhY2tlZCAmJiAhZmxvYXRpbmcpIHtcbiAgICAgICAgLy8gdmlzdWFsIGRhdGEgY29vcmRpbmF0ZXMgYWZ0ZXIgYXBwbHlpbmcgbWluQmFyTGVuZ3RoXG4gICAgICAgIHBhcnNlZC5fc3RhY2tzW3ZTY2FsZS5heGlzXS5fdmlzdWFsVmFsdWVzW2RhdGFzZXRJbmRleF0gPSB2U2NhbGUuZ2V0VmFsdWVGb3JQaXhlbChoZWFkKSAtIHZTY2FsZS5nZXRWYWx1ZUZvclBpeGVsKGJhc2UpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChiYXNlID09PSB2U2NhbGUuZ2V0UGl4ZWxGb3JWYWx1ZShhY3R1YWxCYXNlKSkge1xuICAgICAgY29uc3QgaGFsZkdyaWQgPSBzaWduKHNpemUpICogdlNjYWxlLmdldExpbmVXaWR0aEZvclZhbHVlKGFjdHVhbEJhc2UpIC8gMjtcbiAgICAgIGJhc2UgKz0gaGFsZkdyaWQ7XG4gICAgICBzaXplIC09IGhhbGZHcmlkO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBzaXplLFxuICAgICAgYmFzZSxcbiAgICAgIGhlYWQsXG4gICAgICBjZW50ZXI6IGhlYWQgKyBzaXplIC8gMlxuICAgIH07XG4gIH1cblxuICAvKipcblx0ICogQHByaXZhdGVcblx0ICovXG4gIF9jYWxjdWxhdGVCYXJJbmRleFBpeGVscyhpbmRleCwgcnVsZXIpIHtcbiAgICBjb25zdCBzY2FsZSA9IHJ1bGVyLnNjYWxlO1xuICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgY29uc3Qgc2tpcE51bGwgPSBvcHRpb25zLnNraXBOdWxsO1xuICAgIGNvbnN0IG1heEJhclRoaWNrbmVzcyA9IHZhbHVlT3JEZWZhdWx0KG9wdGlvbnMubWF4QmFyVGhpY2tuZXNzLCBJbmZpbml0eSk7XG4gICAgbGV0IGNlbnRlciwgc2l6ZTtcbiAgICBpZiAocnVsZXIuZ3JvdXBlZCkge1xuICAgICAgY29uc3Qgc3RhY2tDb3VudCA9IHNraXBOdWxsID8gdGhpcy5fZ2V0U3RhY2tDb3VudChpbmRleCkgOiBydWxlci5zdGFja0NvdW50O1xuICAgICAgY29uc3QgcmFuZ2UgPSBvcHRpb25zLmJhclRoaWNrbmVzcyA9PT0gJ2ZsZXgnXG4gICAgICAgID8gY29tcHV0ZUZsZXhDYXRlZ29yeVRyYWl0cyhpbmRleCwgcnVsZXIsIG9wdGlvbnMsIHN0YWNrQ291bnQpXG4gICAgICAgIDogY29tcHV0ZUZpdENhdGVnb3J5VHJhaXRzKGluZGV4LCBydWxlciwgb3B0aW9ucywgc3RhY2tDb3VudCk7XG5cbiAgICAgIGNvbnN0IHN0YWNrSW5kZXggPSB0aGlzLl9nZXRTdGFja0luZGV4KHRoaXMuaW5kZXgsIHRoaXMuX2NhY2hlZE1ldGEuc3RhY2ssIHNraXBOdWxsID8gaW5kZXggOiB1bmRlZmluZWQpO1xuICAgICAgY2VudGVyID0gcmFuZ2Uuc3RhcnQgKyAocmFuZ2UuY2h1bmsgKiBzdGFja0luZGV4KSArIChyYW5nZS5jaHVuayAvIDIpO1xuICAgICAgc2l6ZSA9IE1hdGgubWluKG1heEJhclRoaWNrbmVzcywgcmFuZ2UuY2h1bmsgKiByYW5nZS5yYXRpbyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEZvciBub24tZ3JvdXBlZCBiYXIgY2hhcnRzLCBleGFjdCBwaXhlbCB2YWx1ZXMgYXJlIHVzZWRcbiAgICAgIGNlbnRlciA9IHNjYWxlLmdldFBpeGVsRm9yVmFsdWUodGhpcy5nZXRQYXJzZWQoaW5kZXgpW3NjYWxlLmF4aXNdLCBpbmRleCk7XG4gICAgICBzaXplID0gTWF0aC5taW4obWF4QmFyVGhpY2tuZXNzLCBydWxlci5taW4gKiBydWxlci5yYXRpbyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIGJhc2U6IGNlbnRlciAtIHNpemUgLyAyLFxuICAgICAgaGVhZDogY2VudGVyICsgc2l6ZSAvIDIsXG4gICAgICBjZW50ZXIsXG4gICAgICBzaXplXG4gICAgfTtcbiAgfVxuXG4gIGRyYXcoKSB7XG4gICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgY29uc3QgdlNjYWxlID0gbWV0YS52U2NhbGU7XG4gICAgY29uc3QgcmVjdHMgPSBtZXRhLmRhdGE7XG4gICAgY29uc3QgaWxlbiA9IHJlY3RzLmxlbmd0aDtcbiAgICBsZXQgaSA9IDA7XG5cbiAgICBmb3IgKDsgaSA8IGlsZW47ICsraSkge1xuICAgICAgaWYgKHRoaXMuZ2V0UGFyc2VkKGkpW3ZTY2FsZS5heGlzXSAhPT0gbnVsbCAmJiAhcmVjdHNbaV0uaGlkZGVuKSB7XG4gICAgICAgIHJlY3RzW2ldLmRyYXcodGhpcy5fY3R4KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxufVxuIiwgImltcG9ydCBEYXRhc2V0Q29udHJvbGxlciBmcm9tICcuLi9jb3JlL2NvcmUuZGF0YXNldENvbnRyb2xsZXIuanMnO1xuaW1wb3J0IHt2YWx1ZU9yRGVmYXVsdH0gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLmNvcmUuanMnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBCdWJibGVDb250cm9sbGVyIGV4dGVuZHMgRGF0YXNldENvbnRyb2xsZXIge1xuXG4gIHN0YXRpYyBpZCA9ICdidWJibGUnO1xuXG4gIC8qKlxuICAgKiBAdHlwZSB7YW55fVxuICAgKi9cbiAgc3RhdGljIGRlZmF1bHRzID0ge1xuICAgIGRhdGFzZXRFbGVtZW50VHlwZTogZmFsc2UsXG4gICAgZGF0YUVsZW1lbnRUeXBlOiAncG9pbnQnLFxuXG4gICAgYW5pbWF0aW9uczoge1xuICAgICAgbnVtYmVyczoge1xuICAgICAgICB0eXBlOiAnbnVtYmVyJyxcbiAgICAgICAgcHJvcGVydGllczogWyd4JywgJ3knLCAnYm9yZGVyV2lkdGgnLCAncmFkaXVzJ11cbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEB0eXBlIHthbnl9XG4gICAqL1xuICBzdGF0aWMgb3ZlcnJpZGVzID0ge1xuICAgIHNjYWxlczoge1xuICAgICAgeDoge1xuICAgICAgICB0eXBlOiAnbGluZWFyJ1xuICAgICAgfSxcbiAgICAgIHk6IHtcbiAgICAgICAgdHlwZTogJ2xpbmVhcidcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgaW5pdGlhbGl6ZSgpIHtcbiAgICB0aGlzLmVuYWJsZU9wdGlvblNoYXJpbmcgPSB0cnVlO1xuICAgIHN1cGVyLmluaXRpYWxpemUoKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBQYXJzZSBhcnJheSBvZiBwcmltaXRpdmUgdmFsdWVzXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG4gIHBhcnNlUHJpbWl0aXZlRGF0YShtZXRhLCBkYXRhLCBzdGFydCwgY291bnQpIHtcbiAgICBjb25zdCBwYXJzZWQgPSBzdXBlci5wYXJzZVByaW1pdGl2ZURhdGEobWV0YSwgZGF0YSwgc3RhcnQsIGNvdW50KTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhcnNlZC5sZW5ndGg7IGkrKykge1xuICAgICAgcGFyc2VkW2ldLl9jdXN0b20gPSB0aGlzLnJlc29sdmVEYXRhRWxlbWVudE9wdGlvbnMoaSArIHN0YXJ0KS5yYWRpdXM7XG4gICAgfVxuICAgIHJldHVybiBwYXJzZWQ7XG4gIH1cblxuICAvKipcblx0ICogUGFyc2UgYXJyYXkgb2YgYXJyYXlzXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG4gIHBhcnNlQXJyYXlEYXRhKG1ldGEsIGRhdGEsIHN0YXJ0LCBjb3VudCkge1xuICAgIGNvbnN0IHBhcnNlZCA9IHN1cGVyLnBhcnNlQXJyYXlEYXRhKG1ldGEsIGRhdGEsIHN0YXJ0LCBjb3VudCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXJzZWQubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGl0ZW0gPSBkYXRhW3N0YXJ0ICsgaV07XG4gICAgICBwYXJzZWRbaV0uX2N1c3RvbSA9IHZhbHVlT3JEZWZhdWx0KGl0ZW1bMl0sIHRoaXMucmVzb2x2ZURhdGFFbGVtZW50T3B0aW9ucyhpICsgc3RhcnQpLnJhZGl1cyk7XG4gICAgfVxuICAgIHJldHVybiBwYXJzZWQ7XG4gIH1cblxuICAvKipcblx0ICogUGFyc2UgYXJyYXkgb2Ygb2JqZWN0c1xuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuICBwYXJzZU9iamVjdERhdGEobWV0YSwgZGF0YSwgc3RhcnQsIGNvdW50KSB7XG4gICAgY29uc3QgcGFyc2VkID0gc3VwZXIucGFyc2VPYmplY3REYXRhKG1ldGEsIGRhdGEsIHN0YXJ0LCBjb3VudCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXJzZWQubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGl0ZW0gPSBkYXRhW3N0YXJ0ICsgaV07XG4gICAgICBwYXJzZWRbaV0uX2N1c3RvbSA9IHZhbHVlT3JEZWZhdWx0KGl0ZW0gJiYgaXRlbS5yICYmICtpdGVtLnIsIHRoaXMucmVzb2x2ZURhdGFFbGVtZW50T3B0aW9ucyhpICsgc3RhcnQpLnJhZGl1cyk7XG4gICAgfVxuICAgIHJldHVybiBwYXJzZWQ7XG4gIH1cblxuICAvKipcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cbiAgZ2V0TWF4T3ZlcmZsb3coKSB7XG4gICAgY29uc3QgZGF0YSA9IHRoaXMuX2NhY2hlZE1ldGEuZGF0YTtcblxuICAgIGxldCBtYXggPSAwO1xuICAgIGZvciAobGV0IGkgPSBkYXRhLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICBtYXggPSBNYXRoLm1heChtYXgsIGRhdGFbaV0uc2l6ZSh0aGlzLnJlc29sdmVEYXRhRWxlbWVudE9wdGlvbnMoaSkpIC8gMik7XG4gICAgfVxuICAgIHJldHVybiBtYXggPiAwICYmIG1heDtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuICBnZXRMYWJlbEFuZFZhbHVlKGluZGV4KSB7XG4gICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgY29uc3QgbGFiZWxzID0gdGhpcy5jaGFydC5kYXRhLmxhYmVscyB8fCBbXTtcbiAgICBjb25zdCB7eFNjYWxlLCB5U2NhbGV9ID0gbWV0YTtcbiAgICBjb25zdCBwYXJzZWQgPSB0aGlzLmdldFBhcnNlZChpbmRleCk7XG4gICAgY29uc3QgeCA9IHhTY2FsZS5nZXRMYWJlbEZvclZhbHVlKHBhcnNlZC54KTtcbiAgICBjb25zdCB5ID0geVNjYWxlLmdldExhYmVsRm9yVmFsdWUocGFyc2VkLnkpO1xuICAgIGNvbnN0IHIgPSBwYXJzZWQuX2N1c3RvbTtcblxuICAgIHJldHVybiB7XG4gICAgICBsYWJlbDogbGFiZWxzW2luZGV4XSB8fCAnJyxcbiAgICAgIHZhbHVlOiAnKCcgKyB4ICsgJywgJyArIHkgKyAociA/ICcsICcgKyByIDogJycpICsgJyknXG4gICAgfTtcbiAgfVxuXG4gIHVwZGF0ZShtb2RlKSB7XG4gICAgY29uc3QgcG9pbnRzID0gdGhpcy5fY2FjaGVkTWV0YS5kYXRhO1xuXG4gICAgLy8gVXBkYXRlIFBvaW50c1xuICAgIHRoaXMudXBkYXRlRWxlbWVudHMocG9pbnRzLCAwLCBwb2ludHMubGVuZ3RoLCBtb2RlKTtcbiAgfVxuXG4gIHVwZGF0ZUVsZW1lbnRzKHBvaW50cywgc3RhcnQsIGNvdW50LCBtb2RlKSB7XG4gICAgY29uc3QgcmVzZXQgPSBtb2RlID09PSAncmVzZXQnO1xuICAgIGNvbnN0IHtpU2NhbGUsIHZTY2FsZX0gPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgIGNvbnN0IHtzaGFyZWRPcHRpb25zLCBpbmNsdWRlT3B0aW9uc30gPSB0aGlzLl9nZXRTaGFyZWRPcHRpb25zKHN0YXJ0LCBtb2RlKTtcbiAgICBjb25zdCBpQXhpcyA9IGlTY2FsZS5heGlzO1xuICAgIGNvbnN0IHZBeGlzID0gdlNjYWxlLmF4aXM7XG5cbiAgICBmb3IgKGxldCBpID0gc3RhcnQ7IGkgPCBzdGFydCArIGNvdW50OyBpKyspIHtcbiAgICAgIGNvbnN0IHBvaW50ID0gcG9pbnRzW2ldO1xuICAgICAgY29uc3QgcGFyc2VkID0gIXJlc2V0ICYmIHRoaXMuZ2V0UGFyc2VkKGkpO1xuICAgICAgY29uc3QgcHJvcGVydGllcyA9IHt9O1xuICAgICAgY29uc3QgaVBpeGVsID0gcHJvcGVydGllc1tpQXhpc10gPSByZXNldCA/IGlTY2FsZS5nZXRQaXhlbEZvckRlY2ltYWwoMC41KSA6IGlTY2FsZS5nZXRQaXhlbEZvclZhbHVlKHBhcnNlZFtpQXhpc10pO1xuICAgICAgY29uc3QgdlBpeGVsID0gcHJvcGVydGllc1t2QXhpc10gPSByZXNldCA/IHZTY2FsZS5nZXRCYXNlUGl4ZWwoKSA6IHZTY2FsZS5nZXRQaXhlbEZvclZhbHVlKHBhcnNlZFt2QXhpc10pO1xuXG4gICAgICBwcm9wZXJ0aWVzLnNraXAgPSBpc05hTihpUGl4ZWwpIHx8IGlzTmFOKHZQaXhlbCk7XG5cbiAgICAgIGlmIChpbmNsdWRlT3B0aW9ucykge1xuICAgICAgICBwcm9wZXJ0aWVzLm9wdGlvbnMgPSBzaGFyZWRPcHRpb25zIHx8IHRoaXMucmVzb2x2ZURhdGFFbGVtZW50T3B0aW9ucyhpLCBwb2ludC5hY3RpdmUgPyAnYWN0aXZlJyA6IG1vZGUpO1xuXG4gICAgICAgIGlmIChyZXNldCkge1xuICAgICAgICAgIHByb3BlcnRpZXMub3B0aW9ucy5yYWRpdXMgPSAwO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRoaXMudXBkYXRlRWxlbWVudChwb2ludCwgaSwgcHJvcGVydGllcywgbW9kZSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleFxuXHQgKiBAcGFyYW0ge3N0cmluZ30gW21vZGVdXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG4gIHJlc29sdmVEYXRhRWxlbWVudE9wdGlvbnMoaW5kZXgsIG1vZGUpIHtcbiAgICBjb25zdCBwYXJzZWQgPSB0aGlzLmdldFBhcnNlZChpbmRleCk7XG4gICAgbGV0IHZhbHVlcyA9IHN1cGVyLnJlc29sdmVEYXRhRWxlbWVudE9wdGlvbnMoaW5kZXgsIG1vZGUpO1xuXG4gICAgLy8gSW4gY2FzZSB2YWx1ZXMgd2VyZSBjYWNoZWQgKGFuZCB0aHVzIGZyb3plbiksIHdlIG5lZWQgdG8gY2xvbmUgdGhlIHZhbHVlc1xuICAgIGlmICh2YWx1ZXMuJHNoYXJlZCkge1xuICAgICAgdmFsdWVzID0gT2JqZWN0LmFzc2lnbih7fSwgdmFsdWVzLCB7JHNoYXJlZDogZmFsc2V9KTtcbiAgICB9XG5cbiAgICAvLyBDdXN0b20gcmFkaXVzIHJlc29sdXRpb25cbiAgICBjb25zdCByYWRpdXMgPSB2YWx1ZXMucmFkaXVzO1xuICAgIGlmIChtb2RlICE9PSAnYWN0aXZlJykge1xuICAgICAgdmFsdWVzLnJhZGl1cyA9IDA7XG4gICAgfVxuICAgIHZhbHVlcy5yYWRpdXMgKz0gdmFsdWVPckRlZmF1bHQocGFyc2VkICYmIHBhcnNlZC5fY3VzdG9tLCByYWRpdXMpO1xuXG4gICAgcmV0dXJuIHZhbHVlcztcbiAgfVxufVxuIiwgImltcG9ydCBEYXRhc2V0Q29udHJvbGxlciBmcm9tICcuLi9jb3JlL2NvcmUuZGF0YXNldENvbnRyb2xsZXIuanMnO1xuaW1wb3J0IHtpc09iamVjdCwgcmVzb2x2ZU9iamVjdEtleSwgdG9QZXJjZW50YWdlLCB0b0RpbWVuc2lvbiwgdmFsdWVPckRlZmF1bHR9IGZyb20gJy4uL2hlbHBlcnMvaGVscGVycy5jb3JlLmpzJztcbmltcG9ydCB7Zm9ybWF0TnVtYmVyfSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMuaW50bC5qcyc7XG5pbXBvcnQge3RvUmFkaWFucywgUEksIFRBVSwgSEFMRl9QSSwgX2FuZ2xlQmV0d2Vlbn0gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLm1hdGguanMnO1xuXG4vKipcbiAqIEB0eXBlZGVmIHsgaW1wb3J0KCcuLi9jb3JlL2NvcmUuY29udHJvbGxlci5qcycpLmRlZmF1bHQgfSBDaGFydFxuICovXG5cbmZ1bmN0aW9uIGdldFJhdGlvQW5kT2Zmc2V0KHJvdGF0aW9uLCBjaXJjdW1mZXJlbmNlLCBjdXRvdXQpIHtcbiAgbGV0IHJhdGlvWCA9IDE7XG4gIGxldCByYXRpb1kgPSAxO1xuICBsZXQgb2Zmc2V0WCA9IDA7XG4gIGxldCBvZmZzZXRZID0gMDtcbiAgLy8gSWYgdGhlIGNoYXJ0J3MgY2lyY3VtZmVyZW5jZSBpc24ndCBhIGZ1bGwgY2lyY2xlLCBjYWxjdWxhdGUgc2l6ZSBhcyBhIHJhdGlvIG9mIHRoZSB3aWR0aC9oZWlnaHQgb2YgdGhlIGFyY1xuICBpZiAoY2lyY3VtZmVyZW5jZSA8IFRBVSkge1xuICAgIGNvbnN0IHN0YXJ0QW5nbGUgPSByb3RhdGlvbjtcbiAgICBjb25zdCBlbmRBbmdsZSA9IHN0YXJ0QW5nbGUgKyBjaXJjdW1mZXJlbmNlO1xuICAgIGNvbnN0IHN0YXJ0WCA9IE1hdGguY29zKHN0YXJ0QW5nbGUpO1xuICAgIGNvbnN0IHN0YXJ0WSA9IE1hdGguc2luKHN0YXJ0QW5nbGUpO1xuICAgIGNvbnN0IGVuZFggPSBNYXRoLmNvcyhlbmRBbmdsZSk7XG4gICAgY29uc3QgZW5kWSA9IE1hdGguc2luKGVuZEFuZ2xlKTtcbiAgICBjb25zdCBjYWxjTWF4ID0gKGFuZ2xlLCBhLCBiKSA9PiBfYW5nbGVCZXR3ZWVuKGFuZ2xlLCBzdGFydEFuZ2xlLCBlbmRBbmdsZSwgdHJ1ZSkgPyAxIDogTWF0aC5tYXgoYSwgYSAqIGN1dG91dCwgYiwgYiAqIGN1dG91dCk7XG4gICAgY29uc3QgY2FsY01pbiA9IChhbmdsZSwgYSwgYikgPT4gX2FuZ2xlQmV0d2VlbihhbmdsZSwgc3RhcnRBbmdsZSwgZW5kQW5nbGUsIHRydWUpID8gLTEgOiBNYXRoLm1pbihhLCBhICogY3V0b3V0LCBiLCBiICogY3V0b3V0KTtcbiAgICBjb25zdCBtYXhYID0gY2FsY01heCgwLCBzdGFydFgsIGVuZFgpO1xuICAgIGNvbnN0IG1heFkgPSBjYWxjTWF4KEhBTEZfUEksIHN0YXJ0WSwgZW5kWSk7XG4gICAgY29uc3QgbWluWCA9IGNhbGNNaW4oUEksIHN0YXJ0WCwgZW5kWCk7XG4gICAgY29uc3QgbWluWSA9IGNhbGNNaW4oUEkgKyBIQUxGX1BJLCBzdGFydFksIGVuZFkpO1xuICAgIHJhdGlvWCA9IChtYXhYIC0gbWluWCkgLyAyO1xuICAgIHJhdGlvWSA9IChtYXhZIC0gbWluWSkgLyAyO1xuICAgIG9mZnNldFggPSAtKG1heFggKyBtaW5YKSAvIDI7XG4gICAgb2Zmc2V0WSA9IC0obWF4WSArIG1pblkpIC8gMjtcbiAgfVxuICByZXR1cm4ge3JhdGlvWCwgcmF0aW9ZLCBvZmZzZXRYLCBvZmZzZXRZfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRG91Z2hudXRDb250cm9sbGVyIGV4dGVuZHMgRGF0YXNldENvbnRyb2xsZXIge1xuXG4gIHN0YXRpYyBpZCA9ICdkb3VnaG51dCc7XG5cbiAgLyoqXG4gICAqIEB0eXBlIHthbnl9XG4gICAqL1xuICBzdGF0aWMgZGVmYXVsdHMgPSB7XG4gICAgZGF0YXNldEVsZW1lbnRUeXBlOiBmYWxzZSxcbiAgICBkYXRhRWxlbWVudFR5cGU6ICdhcmMnLFxuICAgIGFuaW1hdGlvbjoge1xuICAgICAgLy8gQm9vbGVhbiAtIFdoZXRoZXIgd2UgYW5pbWF0ZSB0aGUgcm90YXRpb24gb2YgdGhlIERvdWdobnV0XG4gICAgICBhbmltYXRlUm90YXRlOiB0cnVlLFxuICAgICAgLy8gQm9vbGVhbiAtIFdoZXRoZXIgd2UgYW5pbWF0ZSBzY2FsaW5nIHRoZSBEb3VnaG51dCBmcm9tIHRoZSBjZW50cmVcbiAgICAgIGFuaW1hdGVTY2FsZTogZmFsc2VcbiAgICB9LFxuICAgIGFuaW1hdGlvbnM6IHtcbiAgICAgIG51bWJlcnM6IHtcbiAgICAgICAgdHlwZTogJ251bWJlcicsXG4gICAgICAgIHByb3BlcnRpZXM6IFsnY2lyY3VtZmVyZW5jZScsICdlbmRBbmdsZScsICdpbm5lclJhZGl1cycsICdvdXRlclJhZGl1cycsICdzdGFydEFuZ2xlJywgJ3gnLCAneScsICdvZmZzZXQnLCAnYm9yZGVyV2lkdGgnLCAnc3BhY2luZyddXG4gICAgICB9LFxuICAgIH0sXG4gICAgLy8gVGhlIHBlcmNlbnRhZ2Ugb2YgdGhlIGNoYXJ0IHRoYXQgd2UgY3V0IG91dCBvZiB0aGUgbWlkZGxlLlxuICAgIGN1dG91dDogJzUwJScsXG5cbiAgICAvLyBUaGUgcm90YXRpb24gb2YgdGhlIGNoYXJ0LCB3aGVyZSB0aGUgZmlyc3QgZGF0YSBhcmMgYmVnaW5zLlxuICAgIHJvdGF0aW9uOiAwLFxuXG4gICAgLy8gVGhlIHRvdGFsIGNpcmN1bWZlcmVuY2Ugb2YgdGhlIGNoYXJ0LlxuICAgIGNpcmN1bWZlcmVuY2U6IDM2MCxcblxuICAgIC8vIFRoZSBvdXRlciByYWRpdXMgb2YgdGhlIGNoYXJ0XG4gICAgcmFkaXVzOiAnMTAwJScsXG5cbiAgICAvLyBTcGFjaW5nIGJldHdlZW4gYXJjc1xuICAgIHNwYWNpbmc6IDAsXG5cbiAgICBpbmRleEF4aXM6ICdyJyxcbiAgfTtcblxuICBzdGF0aWMgZGVzY3JpcHRvcnMgPSB7XG4gICAgX3NjcmlwdGFibGU6IChuYW1lKSA9PiBuYW1lICE9PSAnc3BhY2luZycsXG4gICAgX2luZGV4YWJsZTogKG5hbWUpID0+IG5hbWUgIT09ICdzcGFjaW5nJyAmJiAhbmFtZS5zdGFydHNXaXRoKCdib3JkZXJEYXNoJykgJiYgIW5hbWUuc3RhcnRzV2l0aCgnaG92ZXJCb3JkZXJEYXNoJyksXG4gIH07XG5cbiAgLyoqXG4gICAqIEB0eXBlIHthbnl9XG4gICAqL1xuICBzdGF0aWMgb3ZlcnJpZGVzID0ge1xuICAgIGFzcGVjdFJhdGlvOiAxLFxuXG4gICAgLy8gTmVlZCB0byBvdmVycmlkZSB0aGVzZSB0byBnaXZlIGEgbmljZSBkZWZhdWx0XG4gICAgcGx1Z2luczoge1xuICAgICAgbGVnZW5kOiB7XG4gICAgICAgIGxhYmVsczoge1xuICAgICAgICAgIGdlbmVyYXRlTGFiZWxzKGNoYXJ0KSB7XG4gICAgICAgICAgICBjb25zdCBkYXRhID0gY2hhcnQuZGF0YTtcbiAgICAgICAgICAgIGlmIChkYXRhLmxhYmVscy5sZW5ndGggJiYgZGF0YS5kYXRhc2V0cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgY29uc3Qge2xhYmVsczoge3BvaW50U3R5bGUsIGNvbG9yfX0gPSBjaGFydC5sZWdlbmQub3B0aW9ucztcblxuICAgICAgICAgICAgICByZXR1cm4gZGF0YS5sYWJlbHMubWFwKChsYWJlbCwgaSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IG1ldGEgPSBjaGFydC5nZXREYXRhc2V0TWV0YSgwKTtcbiAgICAgICAgICAgICAgICBjb25zdCBzdHlsZSA9IG1ldGEuY29udHJvbGxlci5nZXRTdHlsZShpKTtcblxuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICB0ZXh0OiBsYWJlbCxcbiAgICAgICAgICAgICAgICAgIGZpbGxTdHlsZTogc3R5bGUuYmFja2dyb3VuZENvbG9yLFxuICAgICAgICAgICAgICAgICAgc3Ryb2tlU3R5bGU6IHN0eWxlLmJvcmRlckNvbG9yLFxuICAgICAgICAgICAgICAgICAgZm9udENvbG9yOiBjb2xvcixcbiAgICAgICAgICAgICAgICAgIGxpbmVXaWR0aDogc3R5bGUuYm9yZGVyV2lkdGgsXG4gICAgICAgICAgICAgICAgICBwb2ludFN0eWxlOiBwb2ludFN0eWxlLFxuICAgICAgICAgICAgICAgICAgaGlkZGVuOiAhY2hhcnQuZ2V0RGF0YVZpc2liaWxpdHkoaSksXG5cbiAgICAgICAgICAgICAgICAgIC8vIEV4dHJhIGRhdGEgdXNlZCBmb3IgdG9nZ2xpbmcgdGhlIGNvcnJlY3QgaXRlbVxuICAgICAgICAgICAgICAgICAgaW5kZXg6IGlcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgb25DbGljayhlLCBsZWdlbmRJdGVtLCBsZWdlbmQpIHtcbiAgICAgICAgICBsZWdlbmQuY2hhcnQudG9nZ2xlRGF0YVZpc2liaWxpdHkobGVnZW5kSXRlbS5pbmRleCk7XG4gICAgICAgICAgbGVnZW5kLmNoYXJ0LnVwZGF0ZSgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIGNvbnN0cnVjdG9yKGNoYXJ0LCBkYXRhc2V0SW5kZXgpIHtcbiAgICBzdXBlcihjaGFydCwgZGF0YXNldEluZGV4KTtcblxuICAgIHRoaXMuZW5hYmxlT3B0aW9uU2hhcmluZyA9IHRydWU7XG4gICAgdGhpcy5pbm5lclJhZGl1cyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLm91dGVyUmFkaXVzID0gdW5kZWZpbmVkO1xuICAgIHRoaXMub2Zmc2V0WCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLm9mZnNldFkgPSB1bmRlZmluZWQ7XG4gIH1cblxuICBsaW5rU2NhbGVzKCkge31cblxuICAvKipcblx0ICogT3ZlcnJpZGUgZGF0YSBwYXJzaW5nLCBzaW5jZSB3ZSBhcmUgbm90IHVzaW5nIHNjYWxlc1xuXHQgKi9cbiAgcGFyc2Uoc3RhcnQsIGNvdW50KSB7XG4gICAgY29uc3QgZGF0YSA9IHRoaXMuZ2V0RGF0YXNldCgpLmRhdGE7XG4gICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG5cbiAgICBpZiAodGhpcy5fcGFyc2luZyA9PT0gZmFsc2UpIHtcbiAgICAgIG1ldGEuX3BhcnNlZCA9IGRhdGE7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCBnZXR0ZXIgPSAoaSkgPT4gK2RhdGFbaV07XG5cbiAgICAgIGlmIChpc09iamVjdChkYXRhW3N0YXJ0XSkpIHtcbiAgICAgICAgY29uc3Qge2tleSA9ICd2YWx1ZSd9ID0gdGhpcy5fcGFyc2luZztcbiAgICAgICAgZ2V0dGVyID0gKGkpID0+ICtyZXNvbHZlT2JqZWN0S2V5KGRhdGFbaV0sIGtleSk7XG4gICAgICB9XG5cbiAgICAgIGxldCBpLCBpbGVuO1xuICAgICAgZm9yIChpID0gc3RhcnQsIGlsZW4gPSBzdGFydCArIGNvdW50OyBpIDwgaWxlbjsgKytpKSB7XG4gICAgICAgIG1ldGEuX3BhcnNlZFtpXSA9IGdldHRlcihpKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcblx0ICogQHByaXZhdGVcblx0ICovXG4gIF9nZXRSb3RhdGlvbigpIHtcbiAgICByZXR1cm4gdG9SYWRpYW5zKHRoaXMub3B0aW9ucy5yb3RhdGlvbiAtIDkwKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgX2dldENpcmN1bWZlcmVuY2UoKSB7XG4gICAgcmV0dXJuIHRvUmFkaWFucyh0aGlzLm9wdGlvbnMuY2lyY3VtZmVyZW5jZSk7XG4gIH1cblxuICAvKipcblx0ICogR2V0IHRoZSBtYXhpbWFsIHJvdGF0aW9uICYgY2lyY3VtZmVyZW5jZSBleHRlbnRzXG5cdCAqIGFjcm9zcyBhbGwgdmlzaWJsZSBkYXRhc2V0cy5cblx0ICovXG4gIF9nZXRSb3RhdGlvbkV4dGVudHMoKSB7XG4gICAgbGV0IG1pbiA9IFRBVTtcbiAgICBsZXQgbWF4ID0gLVRBVTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5jaGFydC5kYXRhLmRhdGFzZXRzLmxlbmd0aDsgKytpKSB7XG4gICAgICBpZiAodGhpcy5jaGFydC5pc0RhdGFzZXRWaXNpYmxlKGkpICYmIHRoaXMuY2hhcnQuZ2V0RGF0YXNldE1ldGEoaSkudHlwZSA9PT0gdGhpcy5fdHlwZSkge1xuICAgICAgICBjb25zdCBjb250cm9sbGVyID0gdGhpcy5jaGFydC5nZXREYXRhc2V0TWV0YShpKS5jb250cm9sbGVyO1xuICAgICAgICBjb25zdCByb3RhdGlvbiA9IGNvbnRyb2xsZXIuX2dldFJvdGF0aW9uKCk7XG4gICAgICAgIGNvbnN0IGNpcmN1bWZlcmVuY2UgPSBjb250cm9sbGVyLl9nZXRDaXJjdW1mZXJlbmNlKCk7XG5cbiAgICAgICAgbWluID0gTWF0aC5taW4obWluLCByb3RhdGlvbik7XG4gICAgICAgIG1heCA9IE1hdGgubWF4KG1heCwgcm90YXRpb24gKyBjaXJjdW1mZXJlbmNlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgcm90YXRpb246IG1pbixcbiAgICAgIGNpcmN1bWZlcmVuY2U6IG1heCAtIG1pbixcbiAgICB9O1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBtb2RlXG5cdCAqL1xuICB1cGRhdGUobW9kZSkge1xuICAgIGNvbnN0IGNoYXJ0ID0gdGhpcy5jaGFydDtcbiAgICBjb25zdCB7Y2hhcnRBcmVhfSA9IGNoYXJ0O1xuICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgIGNvbnN0IGFyY3MgPSBtZXRhLmRhdGE7XG4gICAgY29uc3Qgc3BhY2luZyA9IHRoaXMuZ2V0TWF4Qm9yZGVyV2lkdGgoKSArIHRoaXMuZ2V0TWF4T2Zmc2V0KGFyY3MpICsgdGhpcy5vcHRpb25zLnNwYWNpbmc7XG4gICAgY29uc3QgbWF4U2l6ZSA9IE1hdGgubWF4KChNYXRoLm1pbihjaGFydEFyZWEud2lkdGgsIGNoYXJ0QXJlYS5oZWlnaHQpIC0gc3BhY2luZykgLyAyLCAwKTtcbiAgICBjb25zdCBjdXRvdXQgPSBNYXRoLm1pbih0b1BlcmNlbnRhZ2UodGhpcy5vcHRpb25zLmN1dG91dCwgbWF4U2l6ZSksIDEpO1xuICAgIGNvbnN0IGNoYXJ0V2VpZ2h0ID0gdGhpcy5fZ2V0UmluZ1dlaWdodCh0aGlzLmluZGV4KTtcblxuICAgIC8vIENvbXB1dGUgdGhlIG1heGltYWwgcm90YXRpb24gJiBjaXJjdW1mZXJlbmNlIGxpbWl0cy5cbiAgICAvLyBJZiB3ZSBvbmx5IGNvbnNpZGVyIG91ciBkYXRhc2V0LCB0aGlzIGNhbiBjYXVzZSBwcm9ibGVtcyB3aGVuIHR3byBkYXRhc2V0c1xuICAgIC8vIGFyZSBib3RoIGxlc3MgdGhhbiBhIGNpcmNsZSB3aXRoIGRpZmZlcmVudCByb3RhdGlvbnMgKHN0YXJ0aW5nIGFuZ2xlcylcbiAgICBjb25zdCB7Y2lyY3VtZmVyZW5jZSwgcm90YXRpb259ID0gdGhpcy5fZ2V0Um90YXRpb25FeHRlbnRzKCk7XG4gICAgY29uc3Qge3JhdGlvWCwgcmF0aW9ZLCBvZmZzZXRYLCBvZmZzZXRZfSA9IGdldFJhdGlvQW5kT2Zmc2V0KHJvdGF0aW9uLCBjaXJjdW1mZXJlbmNlLCBjdXRvdXQpO1xuICAgIGNvbnN0IG1heFdpZHRoID0gKGNoYXJ0QXJlYS53aWR0aCAtIHNwYWNpbmcpIC8gcmF0aW9YO1xuICAgIGNvbnN0IG1heEhlaWdodCA9IChjaGFydEFyZWEuaGVpZ2h0IC0gc3BhY2luZykgLyByYXRpb1k7XG4gICAgY29uc3QgbWF4UmFkaXVzID0gTWF0aC5tYXgoTWF0aC5taW4obWF4V2lkdGgsIG1heEhlaWdodCkgLyAyLCAwKTtcbiAgICBjb25zdCBvdXRlclJhZGl1cyA9IHRvRGltZW5zaW9uKHRoaXMub3B0aW9ucy5yYWRpdXMsIG1heFJhZGl1cyk7XG4gICAgY29uc3QgaW5uZXJSYWRpdXMgPSBNYXRoLm1heChvdXRlclJhZGl1cyAqIGN1dG91dCwgMCk7XG4gICAgY29uc3QgcmFkaXVzTGVuZ3RoID0gKG91dGVyUmFkaXVzIC0gaW5uZXJSYWRpdXMpIC8gdGhpcy5fZ2V0VmlzaWJsZURhdGFzZXRXZWlnaHRUb3RhbCgpO1xuICAgIHRoaXMub2Zmc2V0WCA9IG9mZnNldFggKiBvdXRlclJhZGl1cztcbiAgICB0aGlzLm9mZnNldFkgPSBvZmZzZXRZICogb3V0ZXJSYWRpdXM7XG5cbiAgICBtZXRhLnRvdGFsID0gdGhpcy5jYWxjdWxhdGVUb3RhbCgpO1xuXG4gICAgdGhpcy5vdXRlclJhZGl1cyA9IG91dGVyUmFkaXVzIC0gcmFkaXVzTGVuZ3RoICogdGhpcy5fZ2V0UmluZ1dlaWdodE9mZnNldCh0aGlzLmluZGV4KTtcbiAgICB0aGlzLmlubmVyUmFkaXVzID0gTWF0aC5tYXgodGhpcy5vdXRlclJhZGl1cyAtIHJhZGl1c0xlbmd0aCAqIGNoYXJ0V2VpZ2h0LCAwKTtcblxuICAgIHRoaXMudXBkYXRlRWxlbWVudHMoYXJjcywgMCwgYXJjcy5sZW5ndGgsIG1vZGUpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfY2lyY3VtZmVyZW5jZShpLCByZXNldCkge1xuICAgIGNvbnN0IG9wdHMgPSB0aGlzLm9wdGlvbnM7XG4gICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgY29uc3QgY2lyY3VtZmVyZW5jZSA9IHRoaXMuX2dldENpcmN1bWZlcmVuY2UoKTtcbiAgICBpZiAoKHJlc2V0ICYmIG9wdHMuYW5pbWF0aW9uLmFuaW1hdGVSb3RhdGUpIHx8ICF0aGlzLmNoYXJ0LmdldERhdGFWaXNpYmlsaXR5KGkpIHx8IG1ldGEuX3BhcnNlZFtpXSA9PT0gbnVsbCB8fCBtZXRhLmRhdGFbaV0uaGlkZGVuKSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuY2FsY3VsYXRlQ2lyY3VtZmVyZW5jZShtZXRhLl9wYXJzZWRbaV0gKiBjaXJjdW1mZXJlbmNlIC8gVEFVKTtcbiAgfVxuXG4gIHVwZGF0ZUVsZW1lbnRzKGFyY3MsIHN0YXJ0LCBjb3VudCwgbW9kZSkge1xuICAgIGNvbnN0IHJlc2V0ID0gbW9kZSA9PT0gJ3Jlc2V0JztcbiAgICBjb25zdCBjaGFydCA9IHRoaXMuY2hhcnQ7XG4gICAgY29uc3QgY2hhcnRBcmVhID0gY2hhcnQuY2hhcnRBcmVhO1xuICAgIGNvbnN0IG9wdHMgPSBjaGFydC5vcHRpb25zO1xuICAgIGNvbnN0IGFuaW1hdGlvbk9wdHMgPSBvcHRzLmFuaW1hdGlvbjtcbiAgICBjb25zdCBjZW50ZXJYID0gKGNoYXJ0QXJlYS5sZWZ0ICsgY2hhcnRBcmVhLnJpZ2h0KSAvIDI7XG4gICAgY29uc3QgY2VudGVyWSA9IChjaGFydEFyZWEudG9wICsgY2hhcnRBcmVhLmJvdHRvbSkgLyAyO1xuICAgIGNvbnN0IGFuaW1hdGVTY2FsZSA9IHJlc2V0ICYmIGFuaW1hdGlvbk9wdHMuYW5pbWF0ZVNjYWxlO1xuICAgIGNvbnN0IGlubmVyUmFkaXVzID0gYW5pbWF0ZVNjYWxlID8gMCA6IHRoaXMuaW5uZXJSYWRpdXM7XG4gICAgY29uc3Qgb3V0ZXJSYWRpdXMgPSBhbmltYXRlU2NhbGUgPyAwIDogdGhpcy5vdXRlclJhZGl1cztcbiAgICBjb25zdCB7c2hhcmVkT3B0aW9ucywgaW5jbHVkZU9wdGlvbnN9ID0gdGhpcy5fZ2V0U2hhcmVkT3B0aW9ucyhzdGFydCwgbW9kZSk7XG4gICAgbGV0IHN0YXJ0QW5nbGUgPSB0aGlzLl9nZXRSb3RhdGlvbigpO1xuICAgIGxldCBpO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IHN0YXJ0OyArK2kpIHtcbiAgICAgIHN0YXJ0QW5nbGUgKz0gdGhpcy5fY2lyY3VtZmVyZW5jZShpLCByZXNldCk7XG4gICAgfVxuXG4gICAgZm9yIChpID0gc3RhcnQ7IGkgPCBzdGFydCArIGNvdW50OyArK2kpIHtcbiAgICAgIGNvbnN0IGNpcmN1bWZlcmVuY2UgPSB0aGlzLl9jaXJjdW1mZXJlbmNlKGksIHJlc2V0KTtcbiAgICAgIGNvbnN0IGFyYyA9IGFyY3NbaV07XG4gICAgICBjb25zdCBwcm9wZXJ0aWVzID0ge1xuICAgICAgICB4OiBjZW50ZXJYICsgdGhpcy5vZmZzZXRYLFxuICAgICAgICB5OiBjZW50ZXJZICsgdGhpcy5vZmZzZXRZLFxuICAgICAgICBzdGFydEFuZ2xlLFxuICAgICAgICBlbmRBbmdsZTogc3RhcnRBbmdsZSArIGNpcmN1bWZlcmVuY2UsXG4gICAgICAgIGNpcmN1bWZlcmVuY2UsXG4gICAgICAgIG91dGVyUmFkaXVzLFxuICAgICAgICBpbm5lclJhZGl1c1xuICAgICAgfTtcbiAgICAgIGlmIChpbmNsdWRlT3B0aW9ucykge1xuICAgICAgICBwcm9wZXJ0aWVzLm9wdGlvbnMgPSBzaGFyZWRPcHRpb25zIHx8IHRoaXMucmVzb2x2ZURhdGFFbGVtZW50T3B0aW9ucyhpLCBhcmMuYWN0aXZlID8gJ2FjdGl2ZScgOiBtb2RlKTtcbiAgICAgIH1cbiAgICAgIHN0YXJ0QW5nbGUgKz0gY2lyY3VtZmVyZW5jZTtcblxuICAgICAgdGhpcy51cGRhdGVFbGVtZW50KGFyYywgaSwgcHJvcGVydGllcywgbW9kZSk7XG4gICAgfVxuICB9XG5cbiAgY2FsY3VsYXRlVG90YWwoKSB7XG4gICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgY29uc3QgbWV0YURhdGEgPSBtZXRhLmRhdGE7XG4gICAgbGV0IHRvdGFsID0gMDtcbiAgICBsZXQgaTtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBtZXRhRGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgdmFsdWUgPSBtZXRhLl9wYXJzZWRbaV07XG4gICAgICBpZiAodmFsdWUgIT09IG51bGwgJiYgIWlzTmFOKHZhbHVlKSAmJiB0aGlzLmNoYXJ0LmdldERhdGFWaXNpYmlsaXR5KGkpICYmICFtZXRhRGF0YVtpXS5oaWRkZW4pIHtcbiAgICAgICAgdG90YWwgKz0gTWF0aC5hYnModmFsdWUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0b3RhbDtcbiAgfVxuXG4gIGNhbGN1bGF0ZUNpcmN1bWZlcmVuY2UodmFsdWUpIHtcbiAgICBjb25zdCB0b3RhbCA9IHRoaXMuX2NhY2hlZE1ldGEudG90YWw7XG4gICAgaWYgKHRvdGFsID4gMCAmJiAhaXNOYU4odmFsdWUpKSB7XG4gICAgICByZXR1cm4gVEFVICogKE1hdGguYWJzKHZhbHVlKSAvIHRvdGFsKTtcbiAgICB9XG4gICAgcmV0dXJuIDA7XG4gIH1cblxuICBnZXRMYWJlbEFuZFZhbHVlKGluZGV4KSB7XG4gICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgY29uc3QgY2hhcnQgPSB0aGlzLmNoYXJ0O1xuICAgIGNvbnN0IGxhYmVscyA9IGNoYXJ0LmRhdGEubGFiZWxzIHx8IFtdO1xuICAgIGNvbnN0IHZhbHVlID0gZm9ybWF0TnVtYmVyKG1ldGEuX3BhcnNlZFtpbmRleF0sIGNoYXJ0Lm9wdGlvbnMubG9jYWxlKTtcblxuICAgIHJldHVybiB7XG4gICAgICBsYWJlbDogbGFiZWxzW2luZGV4XSB8fCAnJyxcbiAgICAgIHZhbHVlLFxuICAgIH07XG4gIH1cblxuICBnZXRNYXhCb3JkZXJXaWR0aChhcmNzKSB7XG4gICAgbGV0IG1heCA9IDA7XG4gICAgY29uc3QgY2hhcnQgPSB0aGlzLmNoYXJ0O1xuICAgIGxldCBpLCBpbGVuLCBtZXRhLCBjb250cm9sbGVyLCBvcHRpb25zO1xuXG4gICAgaWYgKCFhcmNzKSB7XG4gICAgICAvLyBGaW5kIHRoZSBvdXRtb3N0IHZpc2libGUgZGF0YXNldFxuICAgICAgZm9yIChpID0gMCwgaWxlbiA9IGNoYXJ0LmRhdGEuZGF0YXNldHMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgICAgIGlmIChjaGFydC5pc0RhdGFzZXRWaXNpYmxlKGkpKSB7XG4gICAgICAgICAgbWV0YSA9IGNoYXJ0LmdldERhdGFzZXRNZXRhKGkpO1xuICAgICAgICAgIGFyY3MgPSBtZXRhLmRhdGE7XG4gICAgICAgICAgY29udHJvbGxlciA9IG1ldGEuY29udHJvbGxlcjtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghYXJjcykge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuXG4gICAgZm9yIChpID0gMCwgaWxlbiA9IGFyY3MubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgICBvcHRpb25zID0gY29udHJvbGxlci5yZXNvbHZlRGF0YUVsZW1lbnRPcHRpb25zKGkpO1xuICAgICAgaWYgKG9wdGlvbnMuYm9yZGVyQWxpZ24gIT09ICdpbm5lcicpIHtcbiAgICAgICAgbWF4ID0gTWF0aC5tYXgobWF4LCBvcHRpb25zLmJvcmRlcldpZHRoIHx8IDAsIG9wdGlvbnMuaG92ZXJCb3JkZXJXaWR0aCB8fCAwKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG1heDtcbiAgfVxuXG4gIGdldE1heE9mZnNldChhcmNzKSB7XG4gICAgbGV0IG1heCA9IDA7XG5cbiAgICBmb3IgKGxldCBpID0gMCwgaWxlbiA9IGFyY3MubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgICBjb25zdCBvcHRpb25zID0gdGhpcy5yZXNvbHZlRGF0YUVsZW1lbnRPcHRpb25zKGkpO1xuICAgICAgbWF4ID0gTWF0aC5tYXgobWF4LCBvcHRpb25zLm9mZnNldCB8fCAwLCBvcHRpb25zLmhvdmVyT2Zmc2V0IHx8IDApO1xuICAgIH1cbiAgICByZXR1cm4gbWF4O1xuICB9XG5cbiAgLyoqXG5cdCAqIEdldCByYWRpdXMgbGVuZ3RoIG9mZnNldCBvZiB0aGUgZGF0YXNldCBpbiByZWxhdGlvbiB0byB0aGUgdmlzaWJsZSBkYXRhc2V0cyB3ZWlnaHRzLiBUaGlzIGFsbG93cyBkZXRlcm1pbmluZyB0aGUgaW5uZXIgYW5kIG91dGVyIHJhZGl1cyBjb3JyZWN0bHlcblx0ICogQHByaXZhdGVcblx0ICovXG4gIF9nZXRSaW5nV2VpZ2h0T2Zmc2V0KGRhdGFzZXRJbmRleCkge1xuICAgIGxldCByaW5nV2VpZ2h0T2Zmc2V0ID0gMDtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGF0YXNldEluZGV4OyArK2kpIHtcbiAgICAgIGlmICh0aGlzLmNoYXJ0LmlzRGF0YXNldFZpc2libGUoaSkpIHtcbiAgICAgICAgcmluZ1dlaWdodE9mZnNldCArPSB0aGlzLl9nZXRSaW5nV2VpZ2h0KGkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByaW5nV2VpZ2h0T2Zmc2V0O1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfZ2V0UmluZ1dlaWdodChkYXRhc2V0SW5kZXgpIHtcbiAgICByZXR1cm4gTWF0aC5tYXgodmFsdWVPckRlZmF1bHQodGhpcy5jaGFydC5kYXRhLmRhdGFzZXRzW2RhdGFzZXRJbmRleF0ud2VpZ2h0LCAxKSwgMCk7XG4gIH1cblxuICAvKipcblx0ICogUmV0dXJucyB0aGUgc3VtIG9mIGFsbCB2aXNpYmxlIGRhdGEgc2V0IHdlaWdodHMuXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfZ2V0VmlzaWJsZURhdGFzZXRXZWlnaHRUb3RhbCgpIHtcbiAgICByZXR1cm4gdGhpcy5fZ2V0UmluZ1dlaWdodE9mZnNldCh0aGlzLmNoYXJ0LmRhdGEuZGF0YXNldHMubGVuZ3RoKSB8fCAxO1xuICB9XG59XG4iLCAiaW1wb3J0IERhdGFzZXRDb250cm9sbGVyIGZyb20gJy4uL2NvcmUvY29yZS5kYXRhc2V0Q29udHJvbGxlci5qcyc7XG5pbXBvcnQge2lzTnVsbE9yVW5kZWZ9IGZyb20gJy4uL2hlbHBlcnMvaW5kZXguanMnO1xuaW1wb3J0IHtpc051bWJlcn0gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLm1hdGguanMnO1xuaW1wb3J0IHtfZ2V0U3RhcnRBbmRDb3VudE9mVmlzaWJsZVBvaW50cywgX3NjYWxlUmFuZ2VzQ2hhbmdlZH0gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLmV4dHJhcy5qcyc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIExpbmVDb250cm9sbGVyIGV4dGVuZHMgRGF0YXNldENvbnRyb2xsZXIge1xuXG4gIHN0YXRpYyBpZCA9ICdsaW5lJztcblxuICAvKipcbiAgICogQHR5cGUge2FueX1cbiAgICovXG4gIHN0YXRpYyBkZWZhdWx0cyA9IHtcbiAgICBkYXRhc2V0RWxlbWVudFR5cGU6ICdsaW5lJyxcbiAgICBkYXRhRWxlbWVudFR5cGU6ICdwb2ludCcsXG5cbiAgICBzaG93TGluZTogdHJ1ZSxcbiAgICBzcGFuR2FwczogZmFsc2UsXG4gIH07XG5cbiAgLyoqXG4gICAqIEB0eXBlIHthbnl9XG4gICAqL1xuICBzdGF0aWMgb3ZlcnJpZGVzID0ge1xuICAgIHNjYWxlczoge1xuICAgICAgX2luZGV4Xzoge1xuICAgICAgICB0eXBlOiAnY2F0ZWdvcnknLFxuICAgICAgfSxcbiAgICAgIF92YWx1ZV86IHtcbiAgICAgICAgdHlwZTogJ2xpbmVhcicsXG4gICAgICB9LFxuICAgIH1cbiAgfTtcblxuICBpbml0aWFsaXplKCkge1xuICAgIHRoaXMuZW5hYmxlT3B0aW9uU2hhcmluZyA9IHRydWU7XG4gICAgdGhpcy5zdXBwb3J0c0RlY2ltYXRpb24gPSB0cnVlO1xuICAgIHN1cGVyLmluaXRpYWxpemUoKTtcbiAgfVxuXG4gIHVwZGF0ZShtb2RlKSB7XG4gICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgY29uc3Qge2RhdGFzZXQ6IGxpbmUsIGRhdGE6IHBvaW50cyA9IFtdLCBfZGF0YXNldH0gPSBtZXRhO1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBjb25zdCBhbmltYXRpb25zRGlzYWJsZWQgPSB0aGlzLmNoYXJ0Ll9hbmltYXRpb25zRGlzYWJsZWQ7XG4gICAgbGV0IHtzdGFydCwgY291bnR9ID0gX2dldFN0YXJ0QW5kQ291bnRPZlZpc2libGVQb2ludHMobWV0YSwgcG9pbnRzLCBhbmltYXRpb25zRGlzYWJsZWQpO1xuXG4gICAgdGhpcy5fZHJhd1N0YXJ0ID0gc3RhcnQ7XG4gICAgdGhpcy5fZHJhd0NvdW50ID0gY291bnQ7XG5cbiAgICBpZiAoX3NjYWxlUmFuZ2VzQ2hhbmdlZChtZXRhKSkge1xuICAgICAgc3RhcnQgPSAwO1xuICAgICAgY291bnQgPSBwb2ludHMubGVuZ3RoO1xuICAgIH1cblxuICAgIC8vIFVwZGF0ZSBMaW5lXG4gICAgbGluZS5fY2hhcnQgPSB0aGlzLmNoYXJ0O1xuICAgIGxpbmUuX2RhdGFzZXRJbmRleCA9IHRoaXMuaW5kZXg7XG4gICAgbGluZS5fZGVjaW1hdGVkID0gISFfZGF0YXNldC5fZGVjaW1hdGVkO1xuICAgIGxpbmUucG9pbnRzID0gcG9pbnRzO1xuXG4gICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMucmVzb2x2ZURhdGFzZXRFbGVtZW50T3B0aW9ucyhtb2RlKTtcbiAgICBpZiAoIXRoaXMub3B0aW9ucy5zaG93TGluZSkge1xuICAgICAgb3B0aW9ucy5ib3JkZXJXaWR0aCA9IDA7XG4gICAgfVxuICAgIG9wdGlvbnMuc2VnbWVudCA9IHRoaXMub3B0aW9ucy5zZWdtZW50O1xuICAgIHRoaXMudXBkYXRlRWxlbWVudChsaW5lLCB1bmRlZmluZWQsIHtcbiAgICAgIGFuaW1hdGVkOiAhYW5pbWF0aW9uc0Rpc2FibGVkLFxuICAgICAgb3B0aW9uc1xuICAgIH0sIG1vZGUpO1xuXG4gICAgLy8gVXBkYXRlIFBvaW50c1xuICAgIHRoaXMudXBkYXRlRWxlbWVudHMocG9pbnRzLCBzdGFydCwgY291bnQsIG1vZGUpO1xuICB9XG5cbiAgdXBkYXRlRWxlbWVudHMocG9pbnRzLCBzdGFydCwgY291bnQsIG1vZGUpIHtcbiAgICBjb25zdCByZXNldCA9IG1vZGUgPT09ICdyZXNldCc7XG4gICAgY29uc3Qge2lTY2FsZSwgdlNjYWxlLCBfc3RhY2tlZCwgX2RhdGFzZXR9ID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICBjb25zdCB7c2hhcmVkT3B0aW9ucywgaW5jbHVkZU9wdGlvbnN9ID0gdGhpcy5fZ2V0U2hhcmVkT3B0aW9ucyhzdGFydCwgbW9kZSk7XG4gICAgY29uc3QgaUF4aXMgPSBpU2NhbGUuYXhpcztcbiAgICBjb25zdCB2QXhpcyA9IHZTY2FsZS5heGlzO1xuICAgIGNvbnN0IHtzcGFuR2Fwcywgc2VnbWVudH0gPSB0aGlzLm9wdGlvbnM7XG4gICAgY29uc3QgbWF4R2FwTGVuZ3RoID0gaXNOdW1iZXIoc3BhbkdhcHMpID8gc3BhbkdhcHMgOiBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7XG4gICAgY29uc3QgZGlyZWN0VXBkYXRlID0gdGhpcy5jaGFydC5fYW5pbWF0aW9uc0Rpc2FibGVkIHx8IHJlc2V0IHx8IG1vZGUgPT09ICdub25lJztcbiAgICBjb25zdCBlbmQgPSBzdGFydCArIGNvdW50O1xuICAgIGNvbnN0IHBvaW50c0NvdW50ID0gcG9pbnRzLmxlbmd0aDtcbiAgICBsZXQgcHJldlBhcnNlZCA9IHN0YXJ0ID4gMCAmJiB0aGlzLmdldFBhcnNlZChzdGFydCAtIDEpO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwb2ludHNDb3VudDsgKytpKSB7XG4gICAgICBjb25zdCBwb2ludCA9IHBvaW50c1tpXTtcbiAgICAgIGNvbnN0IHByb3BlcnRpZXMgPSBkaXJlY3RVcGRhdGUgPyBwb2ludCA6IHt9O1xuXG4gICAgICBpZiAoaSA8IHN0YXJ0IHx8IGkgPj0gZW5kKSB7XG4gICAgICAgIHByb3BlcnRpZXMuc2tpcCA9IHRydWU7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBwYXJzZWQgPSB0aGlzLmdldFBhcnNlZChpKTtcbiAgICAgIGNvbnN0IG51bGxEYXRhID0gaXNOdWxsT3JVbmRlZihwYXJzZWRbdkF4aXNdKTtcbiAgICAgIGNvbnN0IGlQaXhlbCA9IHByb3BlcnRpZXNbaUF4aXNdID0gaVNjYWxlLmdldFBpeGVsRm9yVmFsdWUocGFyc2VkW2lBeGlzXSwgaSk7XG4gICAgICBjb25zdCB2UGl4ZWwgPSBwcm9wZXJ0aWVzW3ZBeGlzXSA9IHJlc2V0IHx8IG51bGxEYXRhID8gdlNjYWxlLmdldEJhc2VQaXhlbCgpIDogdlNjYWxlLmdldFBpeGVsRm9yVmFsdWUoX3N0YWNrZWQgPyB0aGlzLmFwcGx5U3RhY2sodlNjYWxlLCBwYXJzZWQsIF9zdGFja2VkKSA6IHBhcnNlZFt2QXhpc10sIGkpO1xuXG4gICAgICBwcm9wZXJ0aWVzLnNraXAgPSBpc05hTihpUGl4ZWwpIHx8IGlzTmFOKHZQaXhlbCkgfHwgbnVsbERhdGE7XG4gICAgICBwcm9wZXJ0aWVzLnN0b3AgPSBpID4gMCAmJiAoTWF0aC5hYnMocGFyc2VkW2lBeGlzXSAtIHByZXZQYXJzZWRbaUF4aXNdKSkgPiBtYXhHYXBMZW5ndGg7XG4gICAgICBpZiAoc2VnbWVudCkge1xuICAgICAgICBwcm9wZXJ0aWVzLnBhcnNlZCA9IHBhcnNlZDtcbiAgICAgICAgcHJvcGVydGllcy5yYXcgPSBfZGF0YXNldC5kYXRhW2ldO1xuICAgICAgfVxuXG4gICAgICBpZiAoaW5jbHVkZU9wdGlvbnMpIHtcbiAgICAgICAgcHJvcGVydGllcy5vcHRpb25zID0gc2hhcmVkT3B0aW9ucyB8fCB0aGlzLnJlc29sdmVEYXRhRWxlbWVudE9wdGlvbnMoaSwgcG9pbnQuYWN0aXZlID8gJ2FjdGl2ZScgOiBtb2RlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFkaXJlY3RVcGRhdGUpIHtcbiAgICAgICAgdGhpcy51cGRhdGVFbGVtZW50KHBvaW50LCBpLCBwcm9wZXJ0aWVzLCBtb2RlKTtcbiAgICAgIH1cblxuICAgICAgcHJldlBhcnNlZCA9IHBhcnNlZDtcbiAgICB9XG4gIH1cblxuICAvKipcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cbiAgZ2V0TWF4T3ZlcmZsb3coKSB7XG4gICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgY29uc3QgZGF0YXNldCA9IG1ldGEuZGF0YXNldDtcbiAgICBjb25zdCBib3JkZXIgPSBkYXRhc2V0Lm9wdGlvbnMgJiYgZGF0YXNldC5vcHRpb25zLmJvcmRlcldpZHRoIHx8IDA7XG4gICAgY29uc3QgZGF0YSA9IG1ldGEuZGF0YSB8fCBbXTtcbiAgICBpZiAoIWRhdGEubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gYm9yZGVyO1xuICAgIH1cbiAgICBjb25zdCBmaXJzdFBvaW50ID0gZGF0YVswXS5zaXplKHRoaXMucmVzb2x2ZURhdGFFbGVtZW50T3B0aW9ucygwKSk7XG4gICAgY29uc3QgbGFzdFBvaW50ID0gZGF0YVtkYXRhLmxlbmd0aCAtIDFdLnNpemUodGhpcy5yZXNvbHZlRGF0YUVsZW1lbnRPcHRpb25zKGRhdGEubGVuZ3RoIC0gMSkpO1xuICAgIHJldHVybiBNYXRoLm1heChib3JkZXIsIGZpcnN0UG9pbnQsIGxhc3RQb2ludCkgLyAyO1xuICB9XG5cbiAgZHJhdygpIHtcbiAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICBtZXRhLmRhdGFzZXQudXBkYXRlQ29udHJvbFBvaW50cyh0aGlzLmNoYXJ0LmNoYXJ0QXJlYSwgbWV0YS5pU2NhbGUuYXhpcyk7XG4gICAgc3VwZXIuZHJhdygpO1xuICB9XG59XG4iLCAiaW1wb3J0IERhdGFzZXRDb250cm9sbGVyIGZyb20gJy4uL2NvcmUvY29yZS5kYXRhc2V0Q29udHJvbGxlci5qcyc7XG5pbXBvcnQge3RvUmFkaWFucywgUEksIGZvcm1hdE51bWJlciwgX3BhcnNlT2JqZWN0RGF0YVJhZGlhbFNjYWxlfSBmcm9tICcuLi9oZWxwZXJzL2luZGV4LmpzJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUG9sYXJBcmVhQ29udHJvbGxlciBleHRlbmRzIERhdGFzZXRDb250cm9sbGVyIHtcblxuICBzdGF0aWMgaWQgPSAncG9sYXJBcmVhJztcblxuICAvKipcbiAgICogQHR5cGUge2FueX1cbiAgICovXG4gIHN0YXRpYyBkZWZhdWx0cyA9IHtcbiAgICBkYXRhRWxlbWVudFR5cGU6ICdhcmMnLFxuICAgIGFuaW1hdGlvbjoge1xuICAgICAgYW5pbWF0ZVJvdGF0ZTogdHJ1ZSxcbiAgICAgIGFuaW1hdGVTY2FsZTogdHJ1ZVxuICAgIH0sXG4gICAgYW5pbWF0aW9uczoge1xuICAgICAgbnVtYmVyczoge1xuICAgICAgICB0eXBlOiAnbnVtYmVyJyxcbiAgICAgICAgcHJvcGVydGllczogWyd4JywgJ3knLCAnc3RhcnRBbmdsZScsICdlbmRBbmdsZScsICdpbm5lclJhZGl1cycsICdvdXRlclJhZGl1cyddXG4gICAgICB9LFxuICAgIH0sXG4gICAgaW5kZXhBeGlzOiAncicsXG4gICAgc3RhcnRBbmdsZTogMCxcbiAgfTtcblxuICAvKipcbiAgICogQHR5cGUge2FueX1cbiAgICovXG4gIHN0YXRpYyBvdmVycmlkZXMgPSB7XG4gICAgYXNwZWN0UmF0aW86IDEsXG5cbiAgICBwbHVnaW5zOiB7XG4gICAgICBsZWdlbmQ6IHtcbiAgICAgICAgbGFiZWxzOiB7XG4gICAgICAgICAgZ2VuZXJhdGVMYWJlbHMoY2hhcnQpIHtcbiAgICAgICAgICAgIGNvbnN0IGRhdGEgPSBjaGFydC5kYXRhO1xuICAgICAgICAgICAgaWYgKGRhdGEubGFiZWxzLmxlbmd0aCAmJiBkYXRhLmRhdGFzZXRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICBjb25zdCB7bGFiZWxzOiB7cG9pbnRTdHlsZSwgY29sb3J9fSA9IGNoYXJ0LmxlZ2VuZC5vcHRpb25zO1xuXG4gICAgICAgICAgICAgIHJldHVybiBkYXRhLmxhYmVscy5tYXAoKGxhYmVsLCBpKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgbWV0YSA9IGNoYXJ0LmdldERhdGFzZXRNZXRhKDApO1xuICAgICAgICAgICAgICAgIGNvbnN0IHN0eWxlID0gbWV0YS5jb250cm9sbGVyLmdldFN0eWxlKGkpO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgIHRleHQ6IGxhYmVsLFxuICAgICAgICAgICAgICAgICAgZmlsbFN0eWxlOiBzdHlsZS5iYWNrZ3JvdW5kQ29sb3IsXG4gICAgICAgICAgICAgICAgICBzdHJva2VTdHlsZTogc3R5bGUuYm9yZGVyQ29sb3IsXG4gICAgICAgICAgICAgICAgICBmb250Q29sb3I6IGNvbG9yLFxuICAgICAgICAgICAgICAgICAgbGluZVdpZHRoOiBzdHlsZS5ib3JkZXJXaWR0aCxcbiAgICAgICAgICAgICAgICAgIHBvaW50U3R5bGU6IHBvaW50U3R5bGUsXG4gICAgICAgICAgICAgICAgICBoaWRkZW46ICFjaGFydC5nZXREYXRhVmlzaWJpbGl0eShpKSxcblxuICAgICAgICAgICAgICAgICAgLy8gRXh0cmEgZGF0YSB1c2VkIGZvciB0b2dnbGluZyB0aGUgY29ycmVjdCBpdGVtXG4gICAgICAgICAgICAgICAgICBpbmRleDogaVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBvbkNsaWNrKGUsIGxlZ2VuZEl0ZW0sIGxlZ2VuZCkge1xuICAgICAgICAgIGxlZ2VuZC5jaGFydC50b2dnbGVEYXRhVmlzaWJpbGl0eShsZWdlbmRJdGVtLmluZGV4KTtcbiAgICAgICAgICBsZWdlbmQuY2hhcnQudXBkYXRlKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgc2NhbGVzOiB7XG4gICAgICByOiB7XG4gICAgICAgIHR5cGU6ICdyYWRpYWxMaW5lYXInLFxuICAgICAgICBhbmdsZUxpbmVzOiB7XG4gICAgICAgICAgZGlzcGxheTogZmFsc2VcbiAgICAgICAgfSxcbiAgICAgICAgYmVnaW5BdFplcm86IHRydWUsXG4gICAgICAgIGdyaWQ6IHtcbiAgICAgICAgICBjaXJjdWxhcjogdHJ1ZVxuICAgICAgICB9LFxuICAgICAgICBwb2ludExhYmVsczoge1xuICAgICAgICAgIGRpc3BsYXk6IGZhbHNlXG4gICAgICAgIH0sXG4gICAgICAgIHN0YXJ0QW5nbGU6IDBcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgY29uc3RydWN0b3IoY2hhcnQsIGRhdGFzZXRJbmRleCkge1xuICAgIHN1cGVyKGNoYXJ0LCBkYXRhc2V0SW5kZXgpO1xuXG4gICAgdGhpcy5pbm5lclJhZGl1cyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLm91dGVyUmFkaXVzID0gdW5kZWZpbmVkO1xuICB9XG5cbiAgZ2V0TGFiZWxBbmRWYWx1ZShpbmRleCkge1xuICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgIGNvbnN0IGNoYXJ0ID0gdGhpcy5jaGFydDtcbiAgICBjb25zdCBsYWJlbHMgPSBjaGFydC5kYXRhLmxhYmVscyB8fCBbXTtcbiAgICBjb25zdCB2YWx1ZSA9IGZvcm1hdE51bWJlcihtZXRhLl9wYXJzZWRbaW5kZXhdLnIsIGNoYXJ0Lm9wdGlvbnMubG9jYWxlKTtcblxuICAgIHJldHVybiB7XG4gICAgICBsYWJlbDogbGFiZWxzW2luZGV4XSB8fCAnJyxcbiAgICAgIHZhbHVlLFxuICAgIH07XG4gIH1cblxuICBwYXJzZU9iamVjdERhdGEobWV0YSwgZGF0YSwgc3RhcnQsIGNvdW50KSB7XG4gICAgcmV0dXJuIF9wYXJzZU9iamVjdERhdGFSYWRpYWxTY2FsZS5iaW5kKHRoaXMpKG1ldGEsIGRhdGEsIHN0YXJ0LCBjb3VudCk7XG4gIH1cblxuICB1cGRhdGUobW9kZSkge1xuICAgIGNvbnN0IGFyY3MgPSB0aGlzLl9jYWNoZWRNZXRhLmRhdGE7XG5cbiAgICB0aGlzLl91cGRhdGVSYWRpdXMoKTtcbiAgICB0aGlzLnVwZGF0ZUVsZW1lbnRzKGFyY3MsIDAsIGFyY3MubGVuZ3RoLCBtb2RlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuICBnZXRNaW5NYXgoKSB7XG4gICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgY29uc3QgcmFuZ2UgPSB7bWluOiBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFksIG1heDogTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZfTtcblxuICAgIG1ldGEuZGF0YS5mb3JFYWNoKChlbGVtZW50LCBpbmRleCkgPT4ge1xuICAgICAgY29uc3QgcGFyc2VkID0gdGhpcy5nZXRQYXJzZWQoaW5kZXgpLnI7XG5cbiAgICAgIGlmICghaXNOYU4ocGFyc2VkKSAmJiB0aGlzLmNoYXJ0LmdldERhdGFWaXNpYmlsaXR5KGluZGV4KSkge1xuICAgICAgICBpZiAocGFyc2VkIDwgcmFuZ2UubWluKSB7XG4gICAgICAgICAgcmFuZ2UubWluID0gcGFyc2VkO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHBhcnNlZCA+IHJhbmdlLm1heCkge1xuICAgICAgICAgIHJhbmdlLm1heCA9IHBhcnNlZDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIHJhbmdlO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfdXBkYXRlUmFkaXVzKCkge1xuICAgIGNvbnN0IGNoYXJ0ID0gdGhpcy5jaGFydDtcbiAgICBjb25zdCBjaGFydEFyZWEgPSBjaGFydC5jaGFydEFyZWE7XG4gICAgY29uc3Qgb3B0cyA9IGNoYXJ0Lm9wdGlvbnM7XG4gICAgY29uc3QgbWluU2l6ZSA9IE1hdGgubWluKGNoYXJ0QXJlYS5yaWdodCAtIGNoYXJ0QXJlYS5sZWZ0LCBjaGFydEFyZWEuYm90dG9tIC0gY2hhcnRBcmVhLnRvcCk7XG5cbiAgICBjb25zdCBvdXRlclJhZGl1cyA9IE1hdGgubWF4KG1pblNpemUgLyAyLCAwKTtcbiAgICBjb25zdCBpbm5lclJhZGl1cyA9IE1hdGgubWF4KG9wdHMuY3V0b3V0UGVyY2VudGFnZSA/IChvdXRlclJhZGl1cyAvIDEwMCkgKiAob3B0cy5jdXRvdXRQZXJjZW50YWdlKSA6IDEsIDApO1xuICAgIGNvbnN0IHJhZGl1c0xlbmd0aCA9IChvdXRlclJhZGl1cyAtIGlubmVyUmFkaXVzKSAvIGNoYXJ0LmdldFZpc2libGVEYXRhc2V0Q291bnQoKTtcblxuICAgIHRoaXMub3V0ZXJSYWRpdXMgPSBvdXRlclJhZGl1cyAtIChyYWRpdXNMZW5ndGggKiB0aGlzLmluZGV4KTtcbiAgICB0aGlzLmlubmVyUmFkaXVzID0gdGhpcy5vdXRlclJhZGl1cyAtIHJhZGl1c0xlbmd0aDtcbiAgfVxuXG4gIHVwZGF0ZUVsZW1lbnRzKGFyY3MsIHN0YXJ0LCBjb3VudCwgbW9kZSkge1xuICAgIGNvbnN0IHJlc2V0ID0gbW9kZSA9PT0gJ3Jlc2V0JztcbiAgICBjb25zdCBjaGFydCA9IHRoaXMuY2hhcnQ7XG4gICAgY29uc3Qgb3B0cyA9IGNoYXJ0Lm9wdGlvbnM7XG4gICAgY29uc3QgYW5pbWF0aW9uT3B0cyA9IG9wdHMuYW5pbWF0aW9uO1xuICAgIGNvbnN0IHNjYWxlID0gdGhpcy5fY2FjaGVkTWV0YS5yU2NhbGU7XG4gICAgY29uc3QgY2VudGVyWCA9IHNjYWxlLnhDZW50ZXI7XG4gICAgY29uc3QgY2VudGVyWSA9IHNjYWxlLnlDZW50ZXI7XG4gICAgY29uc3QgZGF0YXNldFN0YXJ0QW5nbGUgPSBzY2FsZS5nZXRJbmRleEFuZ2xlKDApIC0gMC41ICogUEk7XG4gICAgbGV0IGFuZ2xlID0gZGF0YXNldFN0YXJ0QW5nbGU7XG4gICAgbGV0IGk7XG5cbiAgICBjb25zdCBkZWZhdWx0QW5nbGUgPSAzNjAgLyB0aGlzLmNvdW50VmlzaWJsZUVsZW1lbnRzKCk7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgc3RhcnQ7ICsraSkge1xuICAgICAgYW5nbGUgKz0gdGhpcy5fY29tcHV0ZUFuZ2xlKGksIG1vZGUsIGRlZmF1bHRBbmdsZSk7XG4gICAgfVxuICAgIGZvciAoaSA9IHN0YXJ0OyBpIDwgc3RhcnQgKyBjb3VudDsgaSsrKSB7XG4gICAgICBjb25zdCBhcmMgPSBhcmNzW2ldO1xuICAgICAgbGV0IHN0YXJ0QW5nbGUgPSBhbmdsZTtcbiAgICAgIGxldCBlbmRBbmdsZSA9IGFuZ2xlICsgdGhpcy5fY29tcHV0ZUFuZ2xlKGksIG1vZGUsIGRlZmF1bHRBbmdsZSk7XG4gICAgICBsZXQgb3V0ZXJSYWRpdXMgPSBjaGFydC5nZXREYXRhVmlzaWJpbGl0eShpKSA/IHNjYWxlLmdldERpc3RhbmNlRnJvbUNlbnRlckZvclZhbHVlKHRoaXMuZ2V0UGFyc2VkKGkpLnIpIDogMDtcbiAgICAgIGFuZ2xlID0gZW5kQW5nbGU7XG5cbiAgICAgIGlmIChyZXNldCkge1xuICAgICAgICBpZiAoYW5pbWF0aW9uT3B0cy5hbmltYXRlU2NhbGUpIHtcbiAgICAgICAgICBvdXRlclJhZGl1cyA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFuaW1hdGlvbk9wdHMuYW5pbWF0ZVJvdGF0ZSkge1xuICAgICAgICAgIHN0YXJ0QW5nbGUgPSBlbmRBbmdsZSA9IGRhdGFzZXRTdGFydEFuZ2xlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHByb3BlcnRpZXMgPSB7XG4gICAgICAgIHg6IGNlbnRlclgsXG4gICAgICAgIHk6IGNlbnRlclksXG4gICAgICAgIGlubmVyUmFkaXVzOiAwLFxuICAgICAgICBvdXRlclJhZGl1cyxcbiAgICAgICAgc3RhcnRBbmdsZSxcbiAgICAgICAgZW5kQW5nbGUsXG4gICAgICAgIG9wdGlvbnM6IHRoaXMucmVzb2x2ZURhdGFFbGVtZW50T3B0aW9ucyhpLCBhcmMuYWN0aXZlID8gJ2FjdGl2ZScgOiBtb2RlKVxuICAgICAgfTtcblxuICAgICAgdGhpcy51cGRhdGVFbGVtZW50KGFyYywgaSwgcHJvcGVydGllcywgbW9kZSk7XG4gICAgfVxuICB9XG5cbiAgY291bnRWaXNpYmxlRWxlbWVudHMoKSB7XG4gICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgbGV0IGNvdW50ID0gMDtcblxuICAgIG1ldGEuZGF0YS5mb3JFYWNoKChlbGVtZW50LCBpbmRleCkgPT4ge1xuICAgICAgaWYgKCFpc05hTih0aGlzLmdldFBhcnNlZChpbmRleCkucikgJiYgdGhpcy5jaGFydC5nZXREYXRhVmlzaWJpbGl0eShpbmRleCkpIHtcbiAgICAgICAgY291bnQrKztcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiBjb3VudDtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgX2NvbXB1dGVBbmdsZShpbmRleCwgbW9kZSwgZGVmYXVsdEFuZ2xlKSB7XG4gICAgcmV0dXJuIHRoaXMuY2hhcnQuZ2V0RGF0YVZpc2liaWxpdHkoaW5kZXgpXG4gICAgICA/IHRvUmFkaWFucyh0aGlzLnJlc29sdmVEYXRhRWxlbWVudE9wdGlvbnMoaW5kZXgsIG1vZGUpLmFuZ2xlIHx8IGRlZmF1bHRBbmdsZSlcbiAgICAgIDogMDtcbiAgfVxufVxuIiwgImltcG9ydCBEb3VnaG51dENvbnRyb2xsZXIgZnJvbSAnLi9jb250cm9sbGVyLmRvdWdobnV0LmpzJztcblxuLy8gUGllIGNoYXJ0cyBhcmUgRG91Z2hudXQgY2hhcnQgd2l0aCBkaWZmZXJlbnQgZGVmYXVsdHNcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFBpZUNvbnRyb2xsZXIgZXh0ZW5kcyBEb3VnaG51dENvbnRyb2xsZXIge1xuXG4gIHN0YXRpYyBpZCA9ICdwaWUnO1xuXG4gIC8qKlxuICAgKiBAdHlwZSB7YW55fVxuICAgKi9cbiAgc3RhdGljIGRlZmF1bHRzID0ge1xuICAgIC8vIFRoZSBwZXJjZW50YWdlIG9mIHRoZSBjaGFydCB0aGF0IHdlIGN1dCBvdXQgb2YgdGhlIG1pZGRsZS5cbiAgICBjdXRvdXQ6IDAsXG5cbiAgICAvLyBUaGUgcm90YXRpb24gb2YgdGhlIGNoYXJ0LCB3aGVyZSB0aGUgZmlyc3QgZGF0YSBhcmMgYmVnaW5zLlxuICAgIHJvdGF0aW9uOiAwLFxuXG4gICAgLy8gVGhlIHRvdGFsIGNpcmN1bWZlcmVuY2Ugb2YgdGhlIGNoYXJ0LlxuICAgIGNpcmN1bWZlcmVuY2U6IDM2MCxcblxuICAgIC8vIFRoZSBvdXRlciByYWRpdXMgb2YgdGhlIGNoYXJ0XG4gICAgcmFkaXVzOiAnMTAwJSdcbiAgfTtcbn1cbiIsICJpbXBvcnQgRGF0YXNldENvbnRyb2xsZXIgZnJvbSAnLi4vY29yZS9jb3JlLmRhdGFzZXRDb250cm9sbGVyLmpzJztcbmltcG9ydCB7X3BhcnNlT2JqZWN0RGF0YVJhZGlhbFNjYWxlfSBmcm9tICcuLi9oZWxwZXJzL2luZGV4LmpzJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUmFkYXJDb250cm9sbGVyIGV4dGVuZHMgRGF0YXNldENvbnRyb2xsZXIge1xuXG4gIHN0YXRpYyBpZCA9ICdyYWRhcic7XG5cbiAgLyoqXG4gICAqIEB0eXBlIHthbnl9XG4gICAqL1xuICBzdGF0aWMgZGVmYXVsdHMgPSB7XG4gICAgZGF0YXNldEVsZW1lbnRUeXBlOiAnbGluZScsXG4gICAgZGF0YUVsZW1lbnRUeXBlOiAncG9pbnQnLFxuICAgIGluZGV4QXhpczogJ3InLFxuICAgIHNob3dMaW5lOiB0cnVlLFxuICAgIGVsZW1lbnRzOiB7XG4gICAgICBsaW5lOiB7XG4gICAgICAgIGZpbGw6ICdzdGFydCdcbiAgICAgIH1cbiAgICB9LFxuICB9O1xuXG4gIC8qKlxuICAgKiBAdHlwZSB7YW55fVxuICAgKi9cbiAgc3RhdGljIG92ZXJyaWRlcyA9IHtcbiAgICBhc3BlY3RSYXRpbzogMSxcblxuICAgIHNjYWxlczoge1xuICAgICAgcjoge1xuICAgICAgICB0eXBlOiAncmFkaWFsTGluZWFyJyxcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLyoqXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG4gIGdldExhYmVsQW5kVmFsdWUoaW5kZXgpIHtcbiAgICBjb25zdCB2U2NhbGUgPSB0aGlzLl9jYWNoZWRNZXRhLnZTY2FsZTtcbiAgICBjb25zdCBwYXJzZWQgPSB0aGlzLmdldFBhcnNlZChpbmRleCk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgbGFiZWw6IHZTY2FsZS5nZXRMYWJlbHMoKVtpbmRleF0sXG4gICAgICB2YWx1ZTogJycgKyB2U2NhbGUuZ2V0TGFiZWxGb3JWYWx1ZShwYXJzZWRbdlNjYWxlLmF4aXNdKVxuICAgIH07XG4gIH1cblxuICBwYXJzZU9iamVjdERhdGEobWV0YSwgZGF0YSwgc3RhcnQsIGNvdW50KSB7XG4gICAgcmV0dXJuIF9wYXJzZU9iamVjdERhdGFSYWRpYWxTY2FsZS5iaW5kKHRoaXMpKG1ldGEsIGRhdGEsIHN0YXJ0LCBjb3VudCk7XG4gIH1cblxuICB1cGRhdGUobW9kZSkge1xuICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgIGNvbnN0IGxpbmUgPSBtZXRhLmRhdGFzZXQ7XG4gICAgY29uc3QgcG9pbnRzID0gbWV0YS5kYXRhIHx8IFtdO1xuICAgIGNvbnN0IGxhYmVscyA9IG1ldGEuaVNjYWxlLmdldExhYmVscygpO1xuXG4gICAgLy8gVXBkYXRlIExpbmVcbiAgICBsaW5lLnBvaW50cyA9IHBvaW50cztcbiAgICAvLyBJbiByZXNpemUgbW9kZSBvbmx5IHBvaW50IGxvY2F0aW9ucyBjaGFuZ2UsIHNvIG5vIG5lZWQgdG8gc2V0IHRoZSBwb2ludHMgb3Igb3B0aW9ucy5cbiAgICBpZiAobW9kZSAhPT0gJ3Jlc2l6ZScpIHtcbiAgICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLnJlc29sdmVEYXRhc2V0RWxlbWVudE9wdGlvbnMobW9kZSk7XG4gICAgICBpZiAoIXRoaXMub3B0aW9ucy5zaG93TGluZSkge1xuICAgICAgICBvcHRpb25zLmJvcmRlcldpZHRoID0gMDtcbiAgICAgIH1cblxuICAgICAgY29uc3QgcHJvcGVydGllcyA9IHtcbiAgICAgICAgX2xvb3A6IHRydWUsXG4gICAgICAgIF9mdWxsTG9vcDogbGFiZWxzLmxlbmd0aCA9PT0gcG9pbnRzLmxlbmd0aCxcbiAgICAgICAgb3B0aW9uc1xuICAgICAgfTtcblxuICAgICAgdGhpcy51cGRhdGVFbGVtZW50KGxpbmUsIHVuZGVmaW5lZCwgcHJvcGVydGllcywgbW9kZSk7XG4gICAgfVxuXG4gICAgLy8gVXBkYXRlIFBvaW50c1xuICAgIHRoaXMudXBkYXRlRWxlbWVudHMocG9pbnRzLCAwLCBwb2ludHMubGVuZ3RoLCBtb2RlKTtcbiAgfVxuXG4gIHVwZGF0ZUVsZW1lbnRzKHBvaW50cywgc3RhcnQsIGNvdW50LCBtb2RlKSB7XG4gICAgY29uc3Qgc2NhbGUgPSB0aGlzLl9jYWNoZWRNZXRhLnJTY2FsZTtcbiAgICBjb25zdCByZXNldCA9IG1vZGUgPT09ICdyZXNldCc7XG5cbiAgICBmb3IgKGxldCBpID0gc3RhcnQ7IGkgPCBzdGFydCArIGNvdW50OyBpKyspIHtcbiAgICAgIGNvbnN0IHBvaW50ID0gcG9pbnRzW2ldO1xuICAgICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMucmVzb2x2ZURhdGFFbGVtZW50T3B0aW9ucyhpLCBwb2ludC5hY3RpdmUgPyAnYWN0aXZlJyA6IG1vZGUpO1xuICAgICAgY29uc3QgcG9pbnRQb3NpdGlvbiA9IHNjYWxlLmdldFBvaW50UG9zaXRpb25Gb3JWYWx1ZShpLCB0aGlzLmdldFBhcnNlZChpKS5yKTtcblxuICAgICAgY29uc3QgeCA9IHJlc2V0ID8gc2NhbGUueENlbnRlciA6IHBvaW50UG9zaXRpb24ueDtcbiAgICAgIGNvbnN0IHkgPSByZXNldCA/IHNjYWxlLnlDZW50ZXIgOiBwb2ludFBvc2l0aW9uLnk7XG5cbiAgICAgIGNvbnN0IHByb3BlcnRpZXMgPSB7XG4gICAgICAgIHgsXG4gICAgICAgIHksXG4gICAgICAgIGFuZ2xlOiBwb2ludFBvc2l0aW9uLmFuZ2xlLFxuICAgICAgICBza2lwOiBpc05hTih4KSB8fCBpc05hTih5KSxcbiAgICAgICAgb3B0aW9uc1xuICAgICAgfTtcblxuICAgICAgdGhpcy51cGRhdGVFbGVtZW50KHBvaW50LCBpLCBwcm9wZXJ0aWVzLCBtb2RlKTtcbiAgICB9XG4gIH1cbn1cbiIsICJpbXBvcnQgRGF0YXNldENvbnRyb2xsZXIgZnJvbSAnLi4vY29yZS9jb3JlLmRhdGFzZXRDb250cm9sbGVyLmpzJztcbmltcG9ydCB7aXNOdWxsT3JVbmRlZn0gZnJvbSAnLi4vaGVscGVycy9pbmRleC5qcyc7XG5pbXBvcnQge2lzTnVtYmVyfSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMubWF0aC5qcyc7XG5pbXBvcnQge19nZXRTdGFydEFuZENvdW50T2ZWaXNpYmxlUG9pbnRzLCBfc2NhbGVSYW5nZXNDaGFuZ2VkfSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMuZXh0cmFzLmpzJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU2NhdHRlckNvbnRyb2xsZXIgZXh0ZW5kcyBEYXRhc2V0Q29udHJvbGxlciB7XG5cbiAgc3RhdGljIGlkID0gJ3NjYXR0ZXInO1xuXG4gIC8qKlxuICAgKiBAdHlwZSB7YW55fVxuICAgKi9cbiAgc3RhdGljIGRlZmF1bHRzID0ge1xuICAgIGRhdGFzZXRFbGVtZW50VHlwZTogZmFsc2UsXG4gICAgZGF0YUVsZW1lbnRUeXBlOiAncG9pbnQnLFxuICAgIHNob3dMaW5lOiBmYWxzZSxcbiAgICBmaWxsOiBmYWxzZVxuICB9O1xuXG4gIC8qKlxuICAgKiBAdHlwZSB7YW55fVxuICAgKi9cbiAgc3RhdGljIG92ZXJyaWRlcyA9IHtcblxuICAgIGludGVyYWN0aW9uOiB7XG4gICAgICBtb2RlOiAncG9pbnQnXG4gICAgfSxcblxuICAgIHNjYWxlczoge1xuICAgICAgeDoge1xuICAgICAgICB0eXBlOiAnbGluZWFyJ1xuICAgICAgfSxcbiAgICAgIHk6IHtcbiAgICAgICAgdHlwZTogJ2xpbmVhcidcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLyoqXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG4gIGdldExhYmVsQW5kVmFsdWUoaW5kZXgpIHtcbiAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICBjb25zdCBsYWJlbHMgPSB0aGlzLmNoYXJ0LmRhdGEubGFiZWxzIHx8IFtdO1xuICAgIGNvbnN0IHt4U2NhbGUsIHlTY2FsZX0gPSBtZXRhO1xuICAgIGNvbnN0IHBhcnNlZCA9IHRoaXMuZ2V0UGFyc2VkKGluZGV4KTtcbiAgICBjb25zdCB4ID0geFNjYWxlLmdldExhYmVsRm9yVmFsdWUocGFyc2VkLngpO1xuICAgIGNvbnN0IHkgPSB5U2NhbGUuZ2V0TGFiZWxGb3JWYWx1ZShwYXJzZWQueSk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgbGFiZWw6IGxhYmVsc1tpbmRleF0gfHwgJycsXG4gICAgICB2YWx1ZTogJygnICsgeCArICcsICcgKyB5ICsgJyknXG4gICAgfTtcbiAgfVxuXG4gIHVwZGF0ZShtb2RlKSB7XG4gICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgY29uc3Qge2RhdGE6IHBvaW50cyA9IFtdfSA9IG1ldGE7XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIGNvbnN0IGFuaW1hdGlvbnNEaXNhYmxlZCA9IHRoaXMuY2hhcnQuX2FuaW1hdGlvbnNEaXNhYmxlZDtcbiAgICBsZXQge3N0YXJ0LCBjb3VudH0gPSBfZ2V0U3RhcnRBbmRDb3VudE9mVmlzaWJsZVBvaW50cyhtZXRhLCBwb2ludHMsIGFuaW1hdGlvbnNEaXNhYmxlZCk7XG5cbiAgICB0aGlzLl9kcmF3U3RhcnQgPSBzdGFydDtcbiAgICB0aGlzLl9kcmF3Q291bnQgPSBjb3VudDtcblxuICAgIGlmIChfc2NhbGVSYW5nZXNDaGFuZ2VkKG1ldGEpKSB7XG4gICAgICBzdGFydCA9IDA7XG4gICAgICBjb3VudCA9IHBvaW50cy5sZW5ndGg7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMub3B0aW9ucy5zaG93TGluZSkge1xuXG4gICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vY2hhcnRqcy9DaGFydC5qcy9pc3N1ZXMvMTEzMzNcbiAgICAgIGlmICghdGhpcy5kYXRhc2V0RWxlbWVudFR5cGUpIHtcbiAgICAgICAgdGhpcy5hZGRFbGVtZW50cygpO1xuICAgICAgfVxuICAgICAgY29uc3Qge2RhdGFzZXQ6IGxpbmUsIF9kYXRhc2V0fSA9IG1ldGE7XG5cbiAgICAgIC8vIFVwZGF0ZSBMaW5lXG4gICAgICBsaW5lLl9jaGFydCA9IHRoaXMuY2hhcnQ7XG4gICAgICBsaW5lLl9kYXRhc2V0SW5kZXggPSB0aGlzLmluZGV4O1xuICAgICAgbGluZS5fZGVjaW1hdGVkID0gISFfZGF0YXNldC5fZGVjaW1hdGVkO1xuICAgICAgbGluZS5wb2ludHMgPSBwb2ludHM7XG5cbiAgICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLnJlc29sdmVEYXRhc2V0RWxlbWVudE9wdGlvbnMobW9kZSk7XG4gICAgICBvcHRpb25zLnNlZ21lbnQgPSB0aGlzLm9wdGlvbnMuc2VnbWVudDtcbiAgICAgIHRoaXMudXBkYXRlRWxlbWVudChsaW5lLCB1bmRlZmluZWQsIHtcbiAgICAgICAgYW5pbWF0ZWQ6ICFhbmltYXRpb25zRGlzYWJsZWQsXG4gICAgICAgIG9wdGlvbnNcbiAgICAgIH0sIG1vZGUpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5kYXRhc2V0RWxlbWVudFR5cGUpIHtcbiAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9jaGFydGpzL0NoYXJ0LmpzL2lzc3Vlcy8xMTMzM1xuICAgICAgZGVsZXRlIG1ldGEuZGF0YXNldDtcbiAgICAgIHRoaXMuZGF0YXNldEVsZW1lbnRUeXBlID0gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gVXBkYXRlIFBvaW50c1xuICAgIHRoaXMudXBkYXRlRWxlbWVudHMocG9pbnRzLCBzdGFydCwgY291bnQsIG1vZGUpO1xuICB9XG5cbiAgYWRkRWxlbWVudHMoKSB7XG4gICAgY29uc3Qge3Nob3dMaW5lfSA9IHRoaXMub3B0aW9ucztcblxuICAgIGlmICghdGhpcy5kYXRhc2V0RWxlbWVudFR5cGUgJiYgc2hvd0xpbmUpIHtcbiAgICAgIHRoaXMuZGF0YXNldEVsZW1lbnRUeXBlID0gdGhpcy5jaGFydC5yZWdpc3RyeS5nZXRFbGVtZW50KCdsaW5lJyk7XG4gICAgfVxuXG4gICAgc3VwZXIuYWRkRWxlbWVudHMoKTtcbiAgfVxuXG4gIHVwZGF0ZUVsZW1lbnRzKHBvaW50cywgc3RhcnQsIGNvdW50LCBtb2RlKSB7XG4gICAgY29uc3QgcmVzZXQgPSBtb2RlID09PSAncmVzZXQnO1xuICAgIGNvbnN0IHtpU2NhbGUsIHZTY2FsZSwgX3N0YWNrZWQsIF9kYXRhc2V0fSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgY29uc3QgZmlyc3RPcHRzID0gdGhpcy5yZXNvbHZlRGF0YUVsZW1lbnRPcHRpb25zKHN0YXJ0LCBtb2RlKTtcbiAgICBjb25zdCBzaGFyZWRPcHRpb25zID0gdGhpcy5nZXRTaGFyZWRPcHRpb25zKGZpcnN0T3B0cyk7XG4gICAgY29uc3QgaW5jbHVkZU9wdGlvbnMgPSB0aGlzLmluY2x1ZGVPcHRpb25zKG1vZGUsIHNoYXJlZE9wdGlvbnMpO1xuICAgIGNvbnN0IGlBeGlzID0gaVNjYWxlLmF4aXM7XG4gICAgY29uc3QgdkF4aXMgPSB2U2NhbGUuYXhpcztcbiAgICBjb25zdCB7c3BhbkdhcHMsIHNlZ21lbnR9ID0gdGhpcy5vcHRpb25zO1xuICAgIGNvbnN0IG1heEdhcExlbmd0aCA9IGlzTnVtYmVyKHNwYW5HYXBzKSA/IHNwYW5HYXBzIDogTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZO1xuICAgIGNvbnN0IGRpcmVjdFVwZGF0ZSA9IHRoaXMuY2hhcnQuX2FuaW1hdGlvbnNEaXNhYmxlZCB8fCByZXNldCB8fCBtb2RlID09PSAnbm9uZSc7XG4gICAgbGV0IHByZXZQYXJzZWQgPSBzdGFydCA+IDAgJiYgdGhpcy5nZXRQYXJzZWQoc3RhcnQgLSAxKTtcblxuICAgIGZvciAobGV0IGkgPSBzdGFydDsgaSA8IHN0YXJ0ICsgY291bnQ7ICsraSkge1xuICAgICAgY29uc3QgcG9pbnQgPSBwb2ludHNbaV07XG4gICAgICBjb25zdCBwYXJzZWQgPSB0aGlzLmdldFBhcnNlZChpKTtcbiAgICAgIGNvbnN0IHByb3BlcnRpZXMgPSBkaXJlY3RVcGRhdGUgPyBwb2ludCA6IHt9O1xuICAgICAgY29uc3QgbnVsbERhdGEgPSBpc051bGxPclVuZGVmKHBhcnNlZFt2QXhpc10pO1xuICAgICAgY29uc3QgaVBpeGVsID0gcHJvcGVydGllc1tpQXhpc10gPSBpU2NhbGUuZ2V0UGl4ZWxGb3JWYWx1ZShwYXJzZWRbaUF4aXNdLCBpKTtcbiAgICAgIGNvbnN0IHZQaXhlbCA9IHByb3BlcnRpZXNbdkF4aXNdID0gcmVzZXQgfHwgbnVsbERhdGEgPyB2U2NhbGUuZ2V0QmFzZVBpeGVsKCkgOiB2U2NhbGUuZ2V0UGl4ZWxGb3JWYWx1ZShfc3RhY2tlZCA/IHRoaXMuYXBwbHlTdGFjayh2U2NhbGUsIHBhcnNlZCwgX3N0YWNrZWQpIDogcGFyc2VkW3ZBeGlzXSwgaSk7XG5cbiAgICAgIHByb3BlcnRpZXMuc2tpcCA9IGlzTmFOKGlQaXhlbCkgfHwgaXNOYU4odlBpeGVsKSB8fCBudWxsRGF0YTtcbiAgICAgIHByb3BlcnRpZXMuc3RvcCA9IGkgPiAwICYmIChNYXRoLmFicyhwYXJzZWRbaUF4aXNdIC0gcHJldlBhcnNlZFtpQXhpc10pKSA+IG1heEdhcExlbmd0aDtcbiAgICAgIGlmIChzZWdtZW50KSB7XG4gICAgICAgIHByb3BlcnRpZXMucGFyc2VkID0gcGFyc2VkO1xuICAgICAgICBwcm9wZXJ0aWVzLnJhdyA9IF9kYXRhc2V0LmRhdGFbaV07XG4gICAgICB9XG5cbiAgICAgIGlmIChpbmNsdWRlT3B0aW9ucykge1xuICAgICAgICBwcm9wZXJ0aWVzLm9wdGlvbnMgPSBzaGFyZWRPcHRpb25zIHx8IHRoaXMucmVzb2x2ZURhdGFFbGVtZW50T3B0aW9ucyhpLCBwb2ludC5hY3RpdmUgPyAnYWN0aXZlJyA6IG1vZGUpO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWRpcmVjdFVwZGF0ZSkge1xuICAgICAgICB0aGlzLnVwZGF0ZUVsZW1lbnQocG9pbnQsIGksIHByb3BlcnRpZXMsIG1vZGUpO1xuICAgICAgfVxuXG4gICAgICBwcmV2UGFyc2VkID0gcGFyc2VkO1xuICAgIH1cblxuICAgIHRoaXMudXBkYXRlU2hhcmVkT3B0aW9ucyhzaGFyZWRPcHRpb25zLCBtb2RlLCBmaXJzdE9wdHMpO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG4gIGdldE1heE92ZXJmbG93KCkge1xuICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgIGNvbnN0IGRhdGEgPSBtZXRhLmRhdGEgfHwgW107XG5cbiAgICBpZiAoIXRoaXMub3B0aW9ucy5zaG93TGluZSkge1xuICAgICAgbGV0IG1heCA9IDA7XG4gICAgICBmb3IgKGxldCBpID0gZGF0YS5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICBtYXggPSBNYXRoLm1heChtYXgsIGRhdGFbaV0uc2l6ZSh0aGlzLnJlc29sdmVEYXRhRWxlbWVudE9wdGlvbnMoaSkpIC8gMik7XG4gICAgICB9XG4gICAgICByZXR1cm4gbWF4ID4gMCAmJiBtYXg7XG4gICAgfVxuXG4gICAgY29uc3QgZGF0YXNldCA9IG1ldGEuZGF0YXNldDtcbiAgICBjb25zdCBib3JkZXIgPSBkYXRhc2V0Lm9wdGlvbnMgJiYgZGF0YXNldC5vcHRpb25zLmJvcmRlcldpZHRoIHx8IDA7XG5cbiAgICBpZiAoIWRhdGEubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gYm9yZGVyO1xuICAgIH1cblxuICAgIGNvbnN0IGZpcnN0UG9pbnQgPSBkYXRhWzBdLnNpemUodGhpcy5yZXNvbHZlRGF0YUVsZW1lbnRPcHRpb25zKDApKTtcbiAgICBjb25zdCBsYXN0UG9pbnQgPSBkYXRhW2RhdGEubGVuZ3RoIC0gMV0uc2l6ZSh0aGlzLnJlc29sdmVEYXRhRWxlbWVudE9wdGlvbnMoZGF0YS5sZW5ndGggLSAxKSk7XG4gICAgcmV0dXJuIE1hdGgubWF4KGJvcmRlciwgZmlyc3RQb2ludCwgbGFzdFBvaW50KSAvIDI7XG4gIH1cbn1cbiIsICIvKipcbiAqIEBuYW1lc3BhY2UgQ2hhcnQuX2FkYXB0ZXJzXG4gKiBAc2luY2UgMi44LjBcbiAqIEBwcml2YXRlXG4gKi9cblxuaW1wb3J0IHR5cGUge0FueU9iamVjdH0gZnJvbSAnLi4vdHlwZXMvYmFzaWMuanMnO1xuaW1wb3J0IHR5cGUge0NoYXJ0T3B0aW9uc30gZnJvbSAnLi4vdHlwZXMvaW5kZXguanMnO1xuXG5leHBvcnQgdHlwZSBUaW1lVW5pdCA9ICdtaWxsaXNlY29uZCcgfCAnc2Vjb25kJyB8ICdtaW51dGUnIHwgJ2hvdXInIHwgJ2RheScgfCAnd2VlaycgfCAnbW9udGgnIHwgJ3F1YXJ0ZXInIHwgJ3llYXInO1xuXG5leHBvcnQgaW50ZXJmYWNlIERhdGVBZGFwdGVyPFQgZXh0ZW5kcyBBbnlPYmplY3QgPSBBbnlPYmplY3Q+IHtcbiAgcmVhZG9ubHkgb3B0aW9uczogVDtcbiAgLyoqXG4gICAqIFdpbGwgY2FsbGVkIHdpdGggY2hhcnQgb3B0aW9ucyBhZnRlciBhZGFwdGVyIGNyZWF0aW9uLlxuICAgKi9cbiAgaW5pdCh0aGlzOiBEYXRlQWRhcHRlcjxUPiwgY2hhcnRPcHRpb25zOiBDaGFydE9wdGlvbnMpOiB2b2lkO1xuICAvKipcbiAgICogUmV0dXJucyBhIG1hcCBvZiB0aW1lIGZvcm1hdHMgZm9yIHRoZSBzdXBwb3J0ZWQgZm9ybWF0dGluZyB1bml0cyBkZWZpbmVkXG4gICAqIGluIFVuaXQgYXMgd2VsbCBhcyAnZGF0ZXRpbWUnIHJlcHJlc2VudGluZyBhIGRldGFpbGVkIGRhdGUvdGltZSBzdHJpbmcuXG4gICAqL1xuICBmb3JtYXRzKHRoaXM6IERhdGVBZGFwdGVyPFQ+KTogUmVjb3JkPHN0cmluZywgc3RyaW5nPjtcbiAgLyoqXG4gICAqIFBhcnNlcyB0aGUgZ2l2ZW4gYHZhbHVlYCBhbmQgcmV0dXJuIHRoZSBhc3NvY2lhdGVkIHRpbWVzdGFtcC5cbiAgICogQHBhcmFtIHZhbHVlIC0gdGhlIHZhbHVlIHRvIHBhcnNlICh1c3VhbGx5IGNvbWVzIGZyb20gdGhlIGRhdGEpXG4gICAqIEBwYXJhbSBbZm9ybWF0XSAtIHRoZSBleHBlY3RlZCBkYXRhIGZvcm1hdFxuICAgKi9cbiAgcGFyc2UodGhpczogRGF0ZUFkYXB0ZXI8VD4sIHZhbHVlOiB1bmtub3duLCBmb3JtYXQ/OiBUaW1lVW5pdCk6IG51bWJlciB8IG51bGw7XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBmb3JtYXR0ZWQgZGF0ZSBpbiB0aGUgc3BlY2lmaWVkIGBmb3JtYXRgIGZvciBhIGdpdmVuIGB0aW1lc3RhbXBgLlxuICAgKiBAcGFyYW0gdGltZXN0YW1wIC0gdGhlIHRpbWVzdGFtcCB0byBmb3JtYXRcbiAgICogQHBhcmFtIGZvcm1hdCAtIHRoZSBkYXRlL3RpbWUgdG9rZW5cbiAgICovXG4gIGZvcm1hdCh0aGlzOiBEYXRlQWRhcHRlcjxUPiwgdGltZXN0YW1wOiBudW1iZXIsIGZvcm1hdDogVGltZVVuaXQpOiBzdHJpbmc7XG4gIC8qKlxuICAgKiBBZGRzIHRoZSBzcGVjaWZpZWQgYGFtb3VudGAgb2YgYHVuaXRgIHRvIHRoZSBnaXZlbiBgdGltZXN0YW1wYC5cbiAgICogQHBhcmFtIHRpbWVzdGFtcCAtIHRoZSBpbnB1dCB0aW1lc3RhbXBcbiAgICogQHBhcmFtIGFtb3VudCAtIHRoZSBhbW91bnQgdG8gYWRkXG4gICAqIEBwYXJhbSB1bml0IC0gdGhlIHVuaXQgYXMgc3RyaW5nXG4gICAqL1xuICBhZGQodGhpczogRGF0ZUFkYXB0ZXI8VD4sIHRpbWVzdGFtcDogbnVtYmVyLCBhbW91bnQ6IG51bWJlciwgdW5pdDogVGltZVVuaXQpOiBudW1iZXI7XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBudW1iZXIgb2YgYHVuaXRgIGJldHdlZW4gdGhlIGdpdmVuIHRpbWVzdGFtcHMuXG4gICAqIEBwYXJhbSBhIC0gdGhlIGlucHV0IHRpbWVzdGFtcCAocmVmZXJlbmNlKVxuICAgKiBAcGFyYW0gYiAtIHRoZSB0aW1lc3RhbXAgdG8gc3VidHJhY3RcbiAgICogQHBhcmFtIHVuaXQgLSB0aGUgdW5pdCBhcyBzdHJpbmdcbiAgICovXG4gIGRpZmYodGhpczogRGF0ZUFkYXB0ZXI8VD4sIGE6IG51bWJlciwgYjogbnVtYmVyLCB1bml0OiBUaW1lVW5pdCk6IG51bWJlcjtcbiAgLyoqXG4gICAqIFJldHVybnMgc3RhcnQgb2YgYHVuaXRgIGZvciB0aGUgZ2l2ZW4gYHRpbWVzdGFtcGAuXG4gICAqIEBwYXJhbSB0aW1lc3RhbXAgLSB0aGUgaW5wdXQgdGltZXN0YW1wXG4gICAqIEBwYXJhbSB1bml0IC0gdGhlIHVuaXQgYXMgc3RyaW5nXG4gICAqIEBwYXJhbSBbd2Vla2RheV0gLSB0aGUgSVNPIGRheSBvZiB0aGUgd2VlayB3aXRoIDEgYmVpbmcgTW9uZGF5XG4gICAqIGFuZCA3IGJlaW5nIFN1bmRheSAob25seSBuZWVkZWQgaWYgcGFyYW0gKnVuaXQqIGlzIGBpc29XZWVrYCkuXG4gICAqL1xuICBzdGFydE9mKHRoaXM6IERhdGVBZGFwdGVyPFQ+LCB0aW1lc3RhbXA6IG51bWJlciwgdW5pdDogVGltZVVuaXQgfCAnaXNvV2VlaycsIHdlZWtkYXk/OiBudW1iZXIpOiBudW1iZXI7XG4gIC8qKlxuICAgKiBSZXR1cm5zIGVuZCBvZiBgdW5pdGAgZm9yIHRoZSBnaXZlbiBgdGltZXN0YW1wYC5cbiAgICogQHBhcmFtIHRpbWVzdGFtcCAtIHRoZSBpbnB1dCB0aW1lc3RhbXBcbiAgICogQHBhcmFtIHVuaXQgLSB0aGUgdW5pdCBhcyBzdHJpbmdcbiAgICovXG4gIGVuZE9mKHRoaXM6IERhdGVBZGFwdGVyPFQ+LCB0aW1lc3RhbXA6IG51bWJlciwgdW5pdDogVGltZVVuaXQgfCAnaXNvV2VlaycpOiBudW1iZXI7XG59XG5cbmZ1bmN0aW9uIGFic3RyYWN0PFQgPSB2b2lkPigpOiBUIHtcbiAgdGhyb3cgbmV3IEVycm9yKCdUaGlzIG1ldGhvZCBpcyBub3QgaW1wbGVtZW50ZWQ6IENoZWNrIHRoYXQgYSBjb21wbGV0ZSBkYXRlIGFkYXB0ZXIgaXMgcHJvdmlkZWQuJyk7XG59XG5cbi8qKlxuICogRGF0ZSBhZGFwdGVyIChjdXJyZW50IHVzZWQgYnkgdGhlIHRpbWUgc2NhbGUpXG4gKiBAbmFtZXNwYWNlIENoYXJ0Ll9hZGFwdGVycy5fZGF0ZVxuICogQG1lbWJlcm9mIENoYXJ0Ll9hZGFwdGVyc1xuICogQHByaXZhdGVcbiAqL1xuY2xhc3MgRGF0ZUFkYXB0ZXJCYXNlIGltcGxlbWVudHMgRGF0ZUFkYXB0ZXIge1xuXG4gIC8qKlxuICAgKiBPdmVycmlkZSBkZWZhdWx0IGRhdGUgYWRhcHRlciBtZXRob2RzLlxuICAgKiBBY2NlcHRzIHR5cGUgcGFyYW1ldGVyIHRvIGRlZmluZSBvcHRpb25zIHR5cGUuXG4gICAqIEBleGFtcGxlXG4gICAqIENoYXJ0Ll9hZGFwdGVycy5fZGF0ZS5vdmVycmlkZTx7bXlBZGFwdGVyT3B0aW9uOiBzdHJpbmd9Pih7XG4gICAqICAgaW5pdCgpIHtcbiAgICogICAgIGNvbnNvbGUubG9nKHRoaXMub3B0aW9ucy5teUFkYXB0ZXJPcHRpb24pO1xuICAgKiAgIH1cbiAgICogfSlcbiAgICovXG4gIHN0YXRpYyBvdmVycmlkZTxUIGV4dGVuZHMgQW55T2JqZWN0ID0gQW55T2JqZWN0PihcbiAgICBtZW1iZXJzOiBQYXJ0aWFsPE9taXQ8RGF0ZUFkYXB0ZXI8VD4sICdvcHRpb25zJz4+XG4gICkge1xuICAgIE9iamVjdC5hc3NpZ24oRGF0ZUFkYXB0ZXJCYXNlLnByb3RvdHlwZSwgbWVtYmVycyk7XG4gIH1cblxuICByZWFkb25seSBvcHRpb25zOiBBbnlPYmplY3Q7XG5cbiAgY29uc3RydWN0b3Iob3B0aW9uczogQW55T2JqZWN0KSB7XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgfVxuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZW1wdHktZnVuY3Rpb25cbiAgaW5pdCgpIHt9XG5cbiAgZm9ybWF0cygpOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+IHtcbiAgICByZXR1cm4gYWJzdHJhY3QoKTtcbiAgfVxuXG4gIHBhcnNlKCk6IG51bWJlciB8IG51bGwge1xuICAgIHJldHVybiBhYnN0cmFjdCgpO1xuICB9XG5cbiAgZm9ybWF0KCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIGFic3RyYWN0KCk7XG4gIH1cblxuICBhZGQoKTogbnVtYmVyIHtcbiAgICByZXR1cm4gYWJzdHJhY3QoKTtcbiAgfVxuXG4gIGRpZmYoKTogbnVtYmVyIHtcbiAgICByZXR1cm4gYWJzdHJhY3QoKTtcbiAgfVxuXG4gIHN0YXJ0T2YoKTogbnVtYmVyIHtcbiAgICByZXR1cm4gYWJzdHJhY3QoKTtcbiAgfVxuXG4gIGVuZE9mKCk6IG51bWJlciB7XG4gICAgcmV0dXJuIGFic3RyYWN0KCk7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQge1xuICBfZGF0ZTogRGF0ZUFkYXB0ZXJCYXNlXG59O1xuIiwgImltcG9ydCB7X2xvb2t1cEJ5S2V5LCBfcmxvb2t1cEJ5S2V5fSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMuY29sbGVjdGlvbi5qcyc7XG5pbXBvcnQge2dldFJlbGF0aXZlUG9zaXRpb259IGZyb20gJy4uL2hlbHBlcnMvaGVscGVycy5kb20uanMnO1xuaW1wb3J0IHtfYW5nbGVCZXR3ZWVuLCBnZXRBbmdsZUZyb21Qb2ludH0gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLm1hdGguanMnO1xuaW1wb3J0IHtfaXNQb2ludEluQXJlYX0gZnJvbSAnLi4vaGVscGVycy9pbmRleC5qcyc7XG5cbi8qKlxuICogQHR5cGVkZWYgeyBpbXBvcnQoJy4vY29yZS5jb250cm9sbGVyLmpzJykuZGVmYXVsdCB9IENoYXJ0XG4gKiBAdHlwZWRlZiB7IGltcG9ydCgnLi4vdHlwZXMvaW5kZXguanMnKS5DaGFydEV2ZW50IH0gQ2hhcnRFdmVudFxuICogQHR5cGVkZWYge3theGlzPzogc3RyaW5nLCBpbnRlcnNlY3Q/OiBib29sZWFuLCBpbmNsdWRlSW52aXNpYmxlPzogYm9vbGVhbn19IEludGVyYWN0aW9uT3B0aW9uc1xuICogQHR5cGVkZWYge3tkYXRhc2V0SW5kZXg6IG51bWJlciwgaW5kZXg6IG51bWJlciwgZWxlbWVudDogaW1wb3J0KCcuL2NvcmUuZWxlbWVudC5qcycpLmRlZmF1bHR9fSBJbnRlcmFjdGlvbkl0ZW1cbiAqIEB0eXBlZGVmIHsgaW1wb3J0KCcuLi90eXBlcy9pbmRleC5qcycpLlBvaW50IH0gUG9pbnRcbiAqL1xuXG4vKipcbiAqIEhlbHBlciBmdW5jdGlvbiB0byBkbyBiaW5hcnkgc2VhcmNoIHdoZW4gcG9zc2libGVcbiAqIEBwYXJhbSB7b2JqZWN0fSBtZXRhc2V0IC0gdGhlIGRhdGFzZXQgbWV0YVxuICogQHBhcmFtIHtzdHJpbmd9IGF4aXMgLSB0aGUgYXhpcyBtb2RlLiB4fHl8eHl8clxuICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIC0gdGhlIHZhbHVlIHRvIGZpbmRcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2ludGVyc2VjdF0gLSBzaG91bGQgdGhlIGVsZW1lbnQgaW50ZXJzZWN0XG4gKiBAcmV0dXJucyB7e2xvOm51bWJlciwgaGk6bnVtYmVyfX0gaW5kaWNlcyB0byBzZWFyY2ggZGF0YSBhcnJheSBiZXR3ZWVuXG4gKi9cbmZ1bmN0aW9uIGJpbmFyeVNlYXJjaChtZXRhc2V0LCBheGlzLCB2YWx1ZSwgaW50ZXJzZWN0KSB7XG4gIGNvbnN0IHtjb250cm9sbGVyLCBkYXRhLCBfc29ydGVkfSA9IG1ldGFzZXQ7XG4gIGNvbnN0IGlTY2FsZSA9IGNvbnRyb2xsZXIuX2NhY2hlZE1ldGEuaVNjYWxlO1xuICBpZiAoaVNjYWxlICYmIGF4aXMgPT09IGlTY2FsZS5heGlzICYmIGF4aXMgIT09ICdyJyAmJiBfc29ydGVkICYmIGRhdGEubGVuZ3RoKSB7XG4gICAgY29uc3QgbG9va3VwTWV0aG9kID0gaVNjYWxlLl9yZXZlcnNlUGl4ZWxzID8gX3Jsb29rdXBCeUtleSA6IF9sb29rdXBCeUtleTtcbiAgICBpZiAoIWludGVyc2VjdCkge1xuICAgICAgcmV0dXJuIGxvb2t1cE1ldGhvZChkYXRhLCBheGlzLCB2YWx1ZSk7XG4gICAgfSBlbHNlIGlmIChjb250cm9sbGVyLl9zaGFyZWRPcHRpb25zKSB7XG4gICAgICAvLyBfc2hhcmVkT3B0aW9ucyBpbmRpY2F0ZXMgdGhhdCBlYWNoIGVsZW1lbnQgaGFzIGVxdWFsIG9wdGlvbnMgLT4gZXF1YWwgcHJvcG9ydGlvbnNcbiAgICAgIC8vIFNvIHdlIGNhbiBkbyBhIHJhbmdlZCBiaW5hcnkgc2VhcmNoIGJhc2VkIG9uIHRoZSByYW5nZSBvZiBmaXJzdCBlbGVtZW50IGFuZFxuICAgICAgLy8gYmUgY29uZmlkZW50IHRvIGdldCB0aGUgZnVsbCByYW5nZSBvZiBpbmRpY2VzIHRoYXQgY2FuIGludGVyc2VjdCB3aXRoIHRoZSB2YWx1ZS5cbiAgICAgIGNvbnN0IGVsID0gZGF0YVswXTtcbiAgICAgIGNvbnN0IHJhbmdlID0gdHlwZW9mIGVsLmdldFJhbmdlID09PSAnZnVuY3Rpb24nICYmIGVsLmdldFJhbmdlKGF4aXMpO1xuICAgICAgaWYgKHJhbmdlKSB7XG4gICAgICAgIGNvbnN0IHN0YXJ0ID0gbG9va3VwTWV0aG9kKGRhdGEsIGF4aXMsIHZhbHVlIC0gcmFuZ2UpO1xuICAgICAgICBjb25zdCBlbmQgPSBsb29rdXBNZXRob2QoZGF0YSwgYXhpcywgdmFsdWUgKyByYW5nZSk7XG4gICAgICAgIHJldHVybiB7bG86IHN0YXJ0LmxvLCBoaTogZW5kLmhpfTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLy8gRGVmYXVsdCB0byBhbGwgZWxlbWVudHMsIHdoZW4gYmluYXJ5IHNlYXJjaCBjYW4gbm90IGJlIHVzZWQuXG4gIHJldHVybiB7bG86IDAsIGhpOiBkYXRhLmxlbmd0aCAtIDF9O1xufVxuXG4vKipcbiAqIEhlbHBlciBmdW5jdGlvbiB0byBzZWxlY3QgY2FuZGlkYXRlIGVsZW1lbnRzIGZvciBpbnRlcmFjdGlvblxuICogQHBhcmFtIHtDaGFydH0gY2hhcnQgLSB0aGUgY2hhcnRcbiAqIEBwYXJhbSB7c3RyaW5nfSBheGlzIC0gdGhlIGF4aXMgbW9kZS4geHx5fHh5fHJcbiAqIEBwYXJhbSB7UG9pbnR9IHBvc2l0aW9uIC0gdGhlIHBvaW50IHRvIGJlIG5lYXJlc3QgdG8sIGluIHJlbGF0aXZlIGNvb3JkaW5hdGVzXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBoYW5kbGVyIC0gdGhlIGNhbGxiYWNrIHRvIGV4ZWN1dGUgZm9yIGVhY2ggdmlzaWJsZSBpdGVtXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtpbnRlcnNlY3RdIC0gY29uc2lkZXIgaW50ZXJzZWN0aW5nIGl0ZW1zXG4gKi9cbmZ1bmN0aW9uIGV2YWx1YXRlSW50ZXJhY3Rpb25JdGVtcyhjaGFydCwgYXhpcywgcG9zaXRpb24sIGhhbmRsZXIsIGludGVyc2VjdCkge1xuICBjb25zdCBtZXRhc2V0cyA9IGNoYXJ0LmdldFNvcnRlZFZpc2libGVEYXRhc2V0TWV0YXMoKTtcbiAgY29uc3QgdmFsdWUgPSBwb3NpdGlvbltheGlzXTtcbiAgZm9yIChsZXQgaSA9IDAsIGlsZW4gPSBtZXRhc2V0cy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICBjb25zdCB7aW5kZXgsIGRhdGF9ID0gbWV0YXNldHNbaV07XG4gICAgY29uc3Qge2xvLCBoaX0gPSBiaW5hcnlTZWFyY2gobWV0YXNldHNbaV0sIGF4aXMsIHZhbHVlLCBpbnRlcnNlY3QpO1xuICAgIGZvciAobGV0IGogPSBsbzsgaiA8PSBoaTsgKytqKSB7XG4gICAgICBjb25zdCBlbGVtZW50ID0gZGF0YVtqXTtcbiAgICAgIGlmICghZWxlbWVudC5za2lwKSB7XG4gICAgICAgIGhhbmRsZXIoZWxlbWVudCwgaW5kZXgsIGopO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEdldCBhIGRpc3RhbmNlIG1ldHJpYyBmdW5jdGlvbiBmb3IgdHdvIHBvaW50cyBiYXNlZCBvbiB0aGVcbiAqIGF4aXMgbW9kZSBzZXR0aW5nXG4gKiBAcGFyYW0ge3N0cmluZ30gYXhpcyAtIHRoZSBheGlzIG1vZGUuIHh8eXx4eXxyXG4gKi9cbmZ1bmN0aW9uIGdldERpc3RhbmNlTWV0cmljRm9yQXhpcyhheGlzKSB7XG4gIGNvbnN0IHVzZVggPSBheGlzLmluZGV4T2YoJ3gnKSAhPT0gLTE7XG4gIGNvbnN0IHVzZVkgPSBheGlzLmluZGV4T2YoJ3knKSAhPT0gLTE7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uKHB0MSwgcHQyKSB7XG4gICAgY29uc3QgZGVsdGFYID0gdXNlWCA/IE1hdGguYWJzKHB0MS54IC0gcHQyLngpIDogMDtcbiAgICBjb25zdCBkZWx0YVkgPSB1c2VZID8gTWF0aC5hYnMocHQxLnkgLSBwdDIueSkgOiAwO1xuICAgIHJldHVybiBNYXRoLnNxcnQoTWF0aC5wb3coZGVsdGFYLCAyKSArIE1hdGgucG93KGRlbHRhWSwgMikpO1xuICB9O1xufVxuXG4vKipcbiAqIEhlbHBlciBmdW5jdGlvbiB0byBnZXQgdGhlIGl0ZW1zIHRoYXQgaW50ZXJzZWN0IHRoZSBldmVudCBwb3NpdGlvblxuICogQHBhcmFtIHtDaGFydH0gY2hhcnQgLSB0aGUgY2hhcnRcbiAqIEBwYXJhbSB7UG9pbnR9IHBvc2l0aW9uIC0gdGhlIHBvaW50IHRvIGJlIG5lYXJlc3QgdG8sIGluIHJlbGF0aXZlIGNvb3JkaW5hdGVzXG4gKiBAcGFyYW0ge3N0cmluZ30gYXhpcyAtIHRoZSBheGlzIG1vZGUuIHh8eXx4eXxyXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFt1c2VGaW5hbFBvc2l0aW9uXSAtIHVzZSB0aGUgZWxlbWVudCdzIGFuaW1hdGlvbiB0YXJnZXQgaW5zdGVhZCBvZiBjdXJyZW50IHBvc2l0aW9uXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtpbmNsdWRlSW52aXNpYmxlXSAtIGluY2x1ZGUgaW52aXNpYmxlIHBvaW50cyB0aGF0IGFyZSBvdXRzaWRlIG9mIHRoZSBjaGFydCBhcmVhXG4gKiBAcmV0dXJuIHtJbnRlcmFjdGlvbkl0ZW1bXX0gdGhlIG5lYXJlc3QgaXRlbXNcbiAqL1xuZnVuY3Rpb24gZ2V0SW50ZXJzZWN0SXRlbXMoY2hhcnQsIHBvc2l0aW9uLCBheGlzLCB1c2VGaW5hbFBvc2l0aW9uLCBpbmNsdWRlSW52aXNpYmxlKSB7XG4gIGNvbnN0IGl0ZW1zID0gW107XG5cbiAgaWYgKCFpbmNsdWRlSW52aXNpYmxlICYmICFjaGFydC5pc1BvaW50SW5BcmVhKHBvc2l0aW9uKSkge1xuICAgIHJldHVybiBpdGVtcztcbiAgfVxuXG4gIGNvbnN0IGV2YWx1YXRpb25GdW5jID0gZnVuY3Rpb24oZWxlbWVudCwgZGF0YXNldEluZGV4LCBpbmRleCkge1xuICAgIGlmICghaW5jbHVkZUludmlzaWJsZSAmJiAhX2lzUG9pbnRJbkFyZWEoZWxlbWVudCwgY2hhcnQuY2hhcnRBcmVhLCAwKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoZWxlbWVudC5pblJhbmdlKHBvc2l0aW9uLngsIHBvc2l0aW9uLnksIHVzZUZpbmFsUG9zaXRpb24pKSB7XG4gICAgICBpdGVtcy5wdXNoKHtlbGVtZW50LCBkYXRhc2V0SW5kZXgsIGluZGV4fSk7XG4gICAgfVxuICB9O1xuXG4gIGV2YWx1YXRlSW50ZXJhY3Rpb25JdGVtcyhjaGFydCwgYXhpcywgcG9zaXRpb24sIGV2YWx1YXRpb25GdW5jLCB0cnVlKTtcbiAgcmV0dXJuIGl0ZW1zO1xufVxuXG4vKipcbiAqIEhlbHBlciBmdW5jdGlvbiB0byBnZXQgdGhlIGl0ZW1zIG5lYXJlc3QgdG8gdGhlIGV2ZW50IHBvc2l0aW9uIGZvciBhIHJhZGlhbCBjaGFydFxuICogQHBhcmFtIHtDaGFydH0gY2hhcnQgLSB0aGUgY2hhcnQgdG8gbG9vayBhdCBlbGVtZW50cyBmcm9tXG4gKiBAcGFyYW0ge1BvaW50fSBwb3NpdGlvbiAtIHRoZSBwb2ludCB0byBiZSBuZWFyZXN0IHRvLCBpbiByZWxhdGl2ZSBjb29yZGluYXRlc1xuICogQHBhcmFtIHtzdHJpbmd9IGF4aXMgLSB0aGUgYXhlcyBhbG9uZyB3aGljaCB0byBtZWFzdXJlIGRpc3RhbmNlXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFt1c2VGaW5hbFBvc2l0aW9uXSAtIHVzZSB0aGUgZWxlbWVudCdzIGFuaW1hdGlvbiB0YXJnZXQgaW5zdGVhZCBvZiBjdXJyZW50IHBvc2l0aW9uXG4gKiBAcmV0dXJuIHtJbnRlcmFjdGlvbkl0ZW1bXX0gdGhlIG5lYXJlc3QgaXRlbXNcbiAqL1xuZnVuY3Rpb24gZ2V0TmVhcmVzdFJhZGlhbEl0ZW1zKGNoYXJ0LCBwb3NpdGlvbiwgYXhpcywgdXNlRmluYWxQb3NpdGlvbikge1xuICBsZXQgaXRlbXMgPSBbXTtcblxuICBmdW5jdGlvbiBldmFsdWF0aW9uRnVuYyhlbGVtZW50LCBkYXRhc2V0SW5kZXgsIGluZGV4KSB7XG4gICAgY29uc3Qge3N0YXJ0QW5nbGUsIGVuZEFuZ2xlfSA9IGVsZW1lbnQuZ2V0UHJvcHMoWydzdGFydEFuZ2xlJywgJ2VuZEFuZ2xlJ10sIHVzZUZpbmFsUG9zaXRpb24pO1xuICAgIGNvbnN0IHthbmdsZX0gPSBnZXRBbmdsZUZyb21Qb2ludChlbGVtZW50LCB7eDogcG9zaXRpb24ueCwgeTogcG9zaXRpb24ueX0pO1xuXG4gICAgaWYgKF9hbmdsZUJldHdlZW4oYW5nbGUsIHN0YXJ0QW5nbGUsIGVuZEFuZ2xlKSkge1xuICAgICAgaXRlbXMucHVzaCh7ZWxlbWVudCwgZGF0YXNldEluZGV4LCBpbmRleH0pO1xuICAgIH1cbiAgfVxuXG4gIGV2YWx1YXRlSW50ZXJhY3Rpb25JdGVtcyhjaGFydCwgYXhpcywgcG9zaXRpb24sIGV2YWx1YXRpb25GdW5jKTtcbiAgcmV0dXJuIGl0ZW1zO1xufVxuXG4vKipcbiAqIEhlbHBlciBmdW5jdGlvbiB0byBnZXQgdGhlIGl0ZW1zIG5lYXJlc3QgdG8gdGhlIGV2ZW50IHBvc2l0aW9uIGZvciBhIGNhcnRlc2lhbiBjaGFydFxuICogQHBhcmFtIHtDaGFydH0gY2hhcnQgLSB0aGUgY2hhcnQgdG8gbG9vayBhdCBlbGVtZW50cyBmcm9tXG4gKiBAcGFyYW0ge1BvaW50fSBwb3NpdGlvbiAtIHRoZSBwb2ludCB0byBiZSBuZWFyZXN0IHRvLCBpbiByZWxhdGl2ZSBjb29yZGluYXRlc1xuICogQHBhcmFtIHtzdHJpbmd9IGF4aXMgLSB0aGUgYXhlcyBhbG9uZyB3aGljaCB0byBtZWFzdXJlIGRpc3RhbmNlXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtpbnRlcnNlY3RdIC0gaWYgdHJ1ZSwgb25seSBjb25zaWRlciBpdGVtcyB0aGF0IGludGVyc2VjdCB0aGUgcG9zaXRpb25cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW3VzZUZpbmFsUG9zaXRpb25dIC0gdXNlIHRoZSBlbGVtZW50J3MgYW5pbWF0aW9uIHRhcmdldCBpbnN0ZWFkIG9mIGN1cnJlbnQgcG9zaXRpb25cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2luY2x1ZGVJbnZpc2libGVdIC0gaW5jbHVkZSBpbnZpc2libGUgcG9pbnRzIHRoYXQgYXJlIG91dHNpZGUgb2YgdGhlIGNoYXJ0IGFyZWFcbiAqIEByZXR1cm4ge0ludGVyYWN0aW9uSXRlbVtdfSB0aGUgbmVhcmVzdCBpdGVtc1xuICovXG5mdW5jdGlvbiBnZXROZWFyZXN0Q2FydGVzaWFuSXRlbXMoY2hhcnQsIHBvc2l0aW9uLCBheGlzLCBpbnRlcnNlY3QsIHVzZUZpbmFsUG9zaXRpb24sIGluY2x1ZGVJbnZpc2libGUpIHtcbiAgbGV0IGl0ZW1zID0gW107XG4gIGNvbnN0IGRpc3RhbmNlTWV0cmljID0gZ2V0RGlzdGFuY2VNZXRyaWNGb3JBeGlzKGF4aXMpO1xuICBsZXQgbWluRGlzdGFuY2UgPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7XG5cbiAgZnVuY3Rpb24gZXZhbHVhdGlvbkZ1bmMoZWxlbWVudCwgZGF0YXNldEluZGV4LCBpbmRleCkge1xuICAgIGNvbnN0IGluUmFuZ2UgPSBlbGVtZW50LmluUmFuZ2UocG9zaXRpb24ueCwgcG9zaXRpb24ueSwgdXNlRmluYWxQb3NpdGlvbik7XG4gICAgaWYgKGludGVyc2VjdCAmJiAhaW5SYW5nZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IGNlbnRlciA9IGVsZW1lbnQuZ2V0Q2VudGVyUG9pbnQodXNlRmluYWxQb3NpdGlvbik7XG4gICAgY29uc3QgcG9pbnRJbkFyZWEgPSAhIWluY2x1ZGVJbnZpc2libGUgfHwgY2hhcnQuaXNQb2ludEluQXJlYShjZW50ZXIpO1xuICAgIGlmICghcG9pbnRJbkFyZWEgJiYgIWluUmFuZ2UpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBkaXN0YW5jZSA9IGRpc3RhbmNlTWV0cmljKHBvc2l0aW9uLCBjZW50ZXIpO1xuICAgIGlmIChkaXN0YW5jZSA8IG1pbkRpc3RhbmNlKSB7XG4gICAgICBpdGVtcyA9IFt7ZWxlbWVudCwgZGF0YXNldEluZGV4LCBpbmRleH1dO1xuICAgICAgbWluRGlzdGFuY2UgPSBkaXN0YW5jZTtcbiAgICB9IGVsc2UgaWYgKGRpc3RhbmNlID09PSBtaW5EaXN0YW5jZSkge1xuICAgICAgLy8gQ2FuIGhhdmUgbXVsdGlwbGUgaXRlbXMgYXQgdGhlIHNhbWUgZGlzdGFuY2UgaW4gd2hpY2ggY2FzZSB3ZSBzb3J0IGJ5IHNpemVcbiAgICAgIGl0ZW1zLnB1c2goe2VsZW1lbnQsIGRhdGFzZXRJbmRleCwgaW5kZXh9KTtcbiAgICB9XG4gIH1cblxuICBldmFsdWF0ZUludGVyYWN0aW9uSXRlbXMoY2hhcnQsIGF4aXMsIHBvc2l0aW9uLCBldmFsdWF0aW9uRnVuYyk7XG4gIHJldHVybiBpdGVtcztcbn1cblxuLyoqXG4gKiBIZWxwZXIgZnVuY3Rpb24gdG8gZ2V0IHRoZSBpdGVtcyBuZWFyZXN0IHRvIHRoZSBldmVudCBwb3NpdGlvbiBjb25zaWRlcmluZyBhbGwgdmlzaWJsZSBpdGVtcyBpbiB0aGUgY2hhcnRcbiAqIEBwYXJhbSB7Q2hhcnR9IGNoYXJ0IC0gdGhlIGNoYXJ0IHRvIGxvb2sgYXQgZWxlbWVudHMgZnJvbVxuICogQHBhcmFtIHtQb2ludH0gcG9zaXRpb24gLSB0aGUgcG9pbnQgdG8gYmUgbmVhcmVzdCB0bywgaW4gcmVsYXRpdmUgY29vcmRpbmF0ZXNcbiAqIEBwYXJhbSB7c3RyaW5nfSBheGlzIC0gdGhlIGF4ZXMgYWxvbmcgd2hpY2ggdG8gbWVhc3VyZSBkaXN0YW5jZVxuICogQHBhcmFtIHtib29sZWFufSBbaW50ZXJzZWN0XSAtIGlmIHRydWUsIG9ubHkgY29uc2lkZXIgaXRlbXMgdGhhdCBpbnRlcnNlY3QgdGhlIHBvc2l0aW9uXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFt1c2VGaW5hbFBvc2l0aW9uXSAtIHVzZSB0aGUgZWxlbWVudCdzIGFuaW1hdGlvbiB0YXJnZXQgaW5zdGVhZCBvZiBjdXJyZW50IHBvc2l0aW9uXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtpbmNsdWRlSW52aXNpYmxlXSAtIGluY2x1ZGUgaW52aXNpYmxlIHBvaW50cyB0aGF0IGFyZSBvdXRzaWRlIG9mIHRoZSBjaGFydCBhcmVhXG4gKiBAcmV0dXJuIHtJbnRlcmFjdGlvbkl0ZW1bXX0gdGhlIG5lYXJlc3QgaXRlbXNcbiAqL1xuZnVuY3Rpb24gZ2V0TmVhcmVzdEl0ZW1zKGNoYXJ0LCBwb3NpdGlvbiwgYXhpcywgaW50ZXJzZWN0LCB1c2VGaW5hbFBvc2l0aW9uLCBpbmNsdWRlSW52aXNpYmxlKSB7XG4gIGlmICghaW5jbHVkZUludmlzaWJsZSAmJiAhY2hhcnQuaXNQb2ludEluQXJlYShwb3NpdGlvbikpIHtcbiAgICByZXR1cm4gW107XG4gIH1cblxuICByZXR1cm4gYXhpcyA9PT0gJ3InICYmICFpbnRlcnNlY3RcbiAgICA/IGdldE5lYXJlc3RSYWRpYWxJdGVtcyhjaGFydCwgcG9zaXRpb24sIGF4aXMsIHVzZUZpbmFsUG9zaXRpb24pXG4gICAgOiBnZXROZWFyZXN0Q2FydGVzaWFuSXRlbXMoY2hhcnQsIHBvc2l0aW9uLCBheGlzLCBpbnRlcnNlY3QsIHVzZUZpbmFsUG9zaXRpb24sIGluY2x1ZGVJbnZpc2libGUpO1xufVxuXG4vKipcbiAqIEhlbHBlciBmdW5jdGlvbiB0byBnZXQgdGhlIGl0ZW1zIG1hdGNoaW5nIGFsb25nIHRoZSBnaXZlbiBYIG9yIFkgYXhpc1xuICogQHBhcmFtIHtDaGFydH0gY2hhcnQgLSB0aGUgY2hhcnQgdG8gbG9vayBhdCBlbGVtZW50cyBmcm9tXG4gKiBAcGFyYW0ge1BvaW50fSBwb3NpdGlvbiAtIHRoZSBwb2ludCB0byBiZSBuZWFyZXN0IHRvLCBpbiByZWxhdGl2ZSBjb29yZGluYXRlc1xuICogQHBhcmFtIHtzdHJpbmd9IGF4aXMgLSB0aGUgYXhpcyB0byBtYXRjaFxuICogQHBhcmFtIHtib29sZWFufSBbaW50ZXJzZWN0XSAtIGlmIHRydWUsIG9ubHkgY29uc2lkZXIgaXRlbXMgdGhhdCBpbnRlcnNlY3QgdGhlIHBvc2l0aW9uXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFt1c2VGaW5hbFBvc2l0aW9uXSAtIHVzZSB0aGUgZWxlbWVudCdzIGFuaW1hdGlvbiB0YXJnZXQgaW5zdGVhZCBvZiBjdXJyZW50IHBvc2l0aW9uXG4gKiBAcmV0dXJuIHtJbnRlcmFjdGlvbkl0ZW1bXX0gdGhlIG5lYXJlc3QgaXRlbXNcbiAqL1xuZnVuY3Rpb24gZ2V0QXhpc0l0ZW1zKGNoYXJ0LCBwb3NpdGlvbiwgYXhpcywgaW50ZXJzZWN0LCB1c2VGaW5hbFBvc2l0aW9uKSB7XG4gIGNvbnN0IGl0ZW1zID0gW107XG4gIGNvbnN0IHJhbmdlTWV0aG9kID0gYXhpcyA9PT0gJ3gnID8gJ2luWFJhbmdlJyA6ICdpbllSYW5nZSc7XG4gIGxldCBpbnRlcnNlY3RzSXRlbSA9IGZhbHNlO1xuXG4gIGV2YWx1YXRlSW50ZXJhY3Rpb25JdGVtcyhjaGFydCwgYXhpcywgcG9zaXRpb24sIChlbGVtZW50LCBkYXRhc2V0SW5kZXgsIGluZGV4KSA9PiB7XG4gICAgaWYgKGVsZW1lbnRbcmFuZ2VNZXRob2RdICYmIGVsZW1lbnRbcmFuZ2VNZXRob2RdKHBvc2l0aW9uW2F4aXNdLCB1c2VGaW5hbFBvc2l0aW9uKSkge1xuICAgICAgaXRlbXMucHVzaCh7ZWxlbWVudCwgZGF0YXNldEluZGV4LCBpbmRleH0pO1xuICAgICAgaW50ZXJzZWN0c0l0ZW0gPSBpbnRlcnNlY3RzSXRlbSB8fCBlbGVtZW50LmluUmFuZ2UocG9zaXRpb24ueCwgcG9zaXRpb24ueSwgdXNlRmluYWxQb3NpdGlvbik7XG4gICAgfVxuICB9KTtcblxuICAvLyBJZiB3ZSB3YW50IHRvIHRyaWdnZXIgb24gYW4gaW50ZXJzZWN0IGFuZCB3ZSBkb24ndCBoYXZlIGFueSBpdGVtc1xuICAvLyB0aGF0IGludGVyc2VjdCB0aGUgcG9zaXRpb24sIHJldHVybiBub3RoaW5nXG4gIGlmIChpbnRlcnNlY3QgJiYgIWludGVyc2VjdHNJdGVtKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG4gIHJldHVybiBpdGVtcztcbn1cblxuLyoqXG4gKiBDb250YWlucyBpbnRlcmFjdGlvbiByZWxhdGVkIGZ1bmN0aW9uc1xuICogQG5hbWVzcGFjZSBDaGFydC5JbnRlcmFjdGlvblxuICovXG5leHBvcnQgZGVmYXVsdCB7XG4gIC8vIFBhcnQgb2YgdGhlIHB1YmxpYyBBUEkgdG8gZmFjaWxpdGF0ZSBkZXZlbG9wZXJzIGNyZWF0aW5nIHRoZWlyIG93biBtb2Rlc1xuICBldmFsdWF0ZUludGVyYWN0aW9uSXRlbXMsXG5cbiAgLy8gSGVscGVyIGZ1bmN0aW9uIGZvciBkaWZmZXJlbnQgbW9kZXNcbiAgbW9kZXM6IHtcbiAgICAvKipcblx0XHQgKiBSZXR1cm5zIGl0ZW1zIGF0IHRoZSBzYW1lIGluZGV4LiBJZiB0aGUgb3B0aW9ucy5pbnRlcnNlY3QgcGFyYW1ldGVyIGlzIHRydWUsIHdlIG9ubHkgcmV0dXJuIGl0ZW1zIGlmIHdlIGludGVyc2VjdCBzb21ldGhpbmdcblx0XHQgKiBJZiB0aGUgb3B0aW9ucy5pbnRlcnNlY3QgbW9kZSBpcyBmYWxzZSwgd2UgZmluZCB0aGUgbmVhcmVzdCBpdGVtIGFuZCByZXR1cm4gdGhlIGl0ZW1zIGF0IHRoZSBzYW1lIGluZGV4IGFzIHRoYXQgaXRlbVxuXHRcdCAqIEBmdW5jdGlvbiBDaGFydC5JbnRlcmFjdGlvbi5tb2Rlcy5pbmRleFxuXHRcdCAqIEBzaW5jZSB2Mi40LjBcblx0XHQgKiBAcGFyYW0ge0NoYXJ0fSBjaGFydCAtIHRoZSBjaGFydCB3ZSBhcmUgcmV0dXJuaW5nIGl0ZW1zIGZyb21cblx0XHQgKiBAcGFyYW0ge0V2ZW50fSBlIC0gdGhlIGV2ZW50IHdlIGFyZSBmaW5kIHRoaW5ncyBhdFxuXHRcdCAqIEBwYXJhbSB7SW50ZXJhY3Rpb25PcHRpb25zfSBvcHRpb25zIC0gb3B0aW9ucyB0byB1c2Vcblx0XHQgKiBAcGFyYW0ge2Jvb2xlYW59IFt1c2VGaW5hbFBvc2l0aW9uXSAtIHVzZSBmaW5hbCBlbGVtZW50IHBvc2l0aW9uIChhbmltYXRpb24gdGFyZ2V0KVxuXHRcdCAqIEByZXR1cm4ge0ludGVyYWN0aW9uSXRlbVtdfSAtIGl0ZW1zIHRoYXQgYXJlIGZvdW5kXG5cdFx0ICovXG4gICAgaW5kZXgoY2hhcnQsIGUsIG9wdGlvbnMsIHVzZUZpbmFsUG9zaXRpb24pIHtcbiAgICAgIGNvbnN0IHBvc2l0aW9uID0gZ2V0UmVsYXRpdmVQb3NpdGlvbihlLCBjaGFydCk7XG4gICAgICAvLyBEZWZhdWx0IGF4aXMgZm9yIGluZGV4IG1vZGUgaXMgJ3gnIHRvIG1hdGNoIG9sZCBiZWhhdmlvdXJcbiAgICAgIGNvbnN0IGF4aXMgPSBvcHRpb25zLmF4aXMgfHwgJ3gnO1xuICAgICAgY29uc3QgaW5jbHVkZUludmlzaWJsZSA9IG9wdGlvbnMuaW5jbHVkZUludmlzaWJsZSB8fCBmYWxzZTtcbiAgICAgIGNvbnN0IGl0ZW1zID0gb3B0aW9ucy5pbnRlcnNlY3RcbiAgICAgICAgPyBnZXRJbnRlcnNlY3RJdGVtcyhjaGFydCwgcG9zaXRpb24sIGF4aXMsIHVzZUZpbmFsUG9zaXRpb24sIGluY2x1ZGVJbnZpc2libGUpXG4gICAgICAgIDogZ2V0TmVhcmVzdEl0ZW1zKGNoYXJ0LCBwb3NpdGlvbiwgYXhpcywgZmFsc2UsIHVzZUZpbmFsUG9zaXRpb24sIGluY2x1ZGVJbnZpc2libGUpO1xuICAgICAgY29uc3QgZWxlbWVudHMgPSBbXTtcblxuICAgICAgaWYgKCFpdGVtcy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuXG4gICAgICBjaGFydC5nZXRTb3J0ZWRWaXNpYmxlRGF0YXNldE1ldGFzKCkuZm9yRWFjaCgobWV0YSkgPT4ge1xuICAgICAgICBjb25zdCBpbmRleCA9IGl0ZW1zWzBdLmluZGV4O1xuICAgICAgICBjb25zdCBlbGVtZW50ID0gbWV0YS5kYXRhW2luZGV4XTtcblxuICAgICAgICAvLyBkb24ndCBjb3VudCBpdGVtcyB0aGF0IGFyZSBza2lwcGVkIChudWxsIGRhdGEpXG4gICAgICAgIGlmIChlbGVtZW50ICYmICFlbGVtZW50LnNraXApIHtcbiAgICAgICAgICBlbGVtZW50cy5wdXNoKHtlbGVtZW50LCBkYXRhc2V0SW5kZXg6IG1ldGEuaW5kZXgsIGluZGV4fSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm4gZWxlbWVudHM7XG4gICAgfSxcblxuICAgIC8qKlxuXHRcdCAqIFJldHVybnMgaXRlbXMgaW4gdGhlIHNhbWUgZGF0YXNldC4gSWYgdGhlIG9wdGlvbnMuaW50ZXJzZWN0IHBhcmFtZXRlciBpcyB0cnVlLCB3ZSBvbmx5IHJldHVybiBpdGVtcyBpZiB3ZSBpbnRlcnNlY3Qgc29tZXRoaW5nXG5cdFx0ICogSWYgdGhlIG9wdGlvbnMuaW50ZXJzZWN0IGlzIGZhbHNlLCB3ZSBmaW5kIHRoZSBuZWFyZXN0IGl0ZW0gYW5kIHJldHVybiB0aGUgaXRlbXMgaW4gdGhhdCBkYXRhc2V0XG5cdFx0ICogQGZ1bmN0aW9uIENoYXJ0LkludGVyYWN0aW9uLm1vZGVzLmRhdGFzZXRcblx0XHQgKiBAcGFyYW0ge0NoYXJ0fSBjaGFydCAtIHRoZSBjaGFydCB3ZSBhcmUgcmV0dXJuaW5nIGl0ZW1zIGZyb21cblx0XHQgKiBAcGFyYW0ge0V2ZW50fSBlIC0gdGhlIGV2ZW50IHdlIGFyZSBmaW5kIHRoaW5ncyBhdFxuXHRcdCAqIEBwYXJhbSB7SW50ZXJhY3Rpb25PcHRpb25zfSBvcHRpb25zIC0gb3B0aW9ucyB0byB1c2Vcblx0XHQgKiBAcGFyYW0ge2Jvb2xlYW59IFt1c2VGaW5hbFBvc2l0aW9uXSAtIHVzZSBmaW5hbCBlbGVtZW50IHBvc2l0aW9uIChhbmltYXRpb24gdGFyZ2V0KVxuXHRcdCAqIEByZXR1cm4ge0ludGVyYWN0aW9uSXRlbVtdfSAtIGl0ZW1zIHRoYXQgYXJlIGZvdW5kXG5cdFx0ICovXG4gICAgZGF0YXNldChjaGFydCwgZSwgb3B0aW9ucywgdXNlRmluYWxQb3NpdGlvbikge1xuICAgICAgY29uc3QgcG9zaXRpb24gPSBnZXRSZWxhdGl2ZVBvc2l0aW9uKGUsIGNoYXJ0KTtcbiAgICAgIGNvbnN0IGF4aXMgPSBvcHRpb25zLmF4aXMgfHwgJ3h5JztcbiAgICAgIGNvbnN0IGluY2x1ZGVJbnZpc2libGUgPSBvcHRpb25zLmluY2x1ZGVJbnZpc2libGUgfHwgZmFsc2U7XG4gICAgICBsZXQgaXRlbXMgPSBvcHRpb25zLmludGVyc2VjdFxuICAgICAgICA/IGdldEludGVyc2VjdEl0ZW1zKGNoYXJ0LCBwb3NpdGlvbiwgYXhpcywgdXNlRmluYWxQb3NpdGlvbiwgaW5jbHVkZUludmlzaWJsZSkgOlxuICAgICAgICBnZXROZWFyZXN0SXRlbXMoY2hhcnQsIHBvc2l0aW9uLCBheGlzLCBmYWxzZSwgdXNlRmluYWxQb3NpdGlvbiwgaW5jbHVkZUludmlzaWJsZSk7XG5cbiAgICAgIGlmIChpdGVtcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGNvbnN0IGRhdGFzZXRJbmRleCA9IGl0ZW1zWzBdLmRhdGFzZXRJbmRleDtcbiAgICAgICAgY29uc3QgZGF0YSA9IGNoYXJ0LmdldERhdGFzZXRNZXRhKGRhdGFzZXRJbmRleCkuZGF0YTtcbiAgICAgICAgaXRlbXMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgaXRlbXMucHVzaCh7ZWxlbWVudDogZGF0YVtpXSwgZGF0YXNldEluZGV4LCBpbmRleDogaX0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBpdGVtcztcbiAgICB9LFxuXG4gICAgLyoqXG5cdFx0ICogUG9pbnQgbW9kZSByZXR1cm5zIGFsbCBlbGVtZW50cyB0aGF0IGhpdCB0ZXN0IGJhc2VkIG9uIHRoZSBldmVudCBwb3NpdGlvblxuXHRcdCAqIG9mIHRoZSBldmVudFxuXHRcdCAqIEBmdW5jdGlvbiBDaGFydC5JbnRlcmFjdGlvbi5tb2Rlcy5pbnRlcnNlY3Rcblx0XHQgKiBAcGFyYW0ge0NoYXJ0fSBjaGFydCAtIHRoZSBjaGFydCB3ZSBhcmUgcmV0dXJuaW5nIGl0ZW1zIGZyb21cblx0XHQgKiBAcGFyYW0ge0V2ZW50fSBlIC0gdGhlIGV2ZW50IHdlIGFyZSBmaW5kIHRoaW5ncyBhdFxuXHRcdCAqIEBwYXJhbSB7SW50ZXJhY3Rpb25PcHRpb25zfSBvcHRpb25zIC0gb3B0aW9ucyB0byB1c2Vcblx0XHQgKiBAcGFyYW0ge2Jvb2xlYW59IFt1c2VGaW5hbFBvc2l0aW9uXSAtIHVzZSBmaW5hbCBlbGVtZW50IHBvc2l0aW9uIChhbmltYXRpb24gdGFyZ2V0KVxuXHRcdCAqIEByZXR1cm4ge0ludGVyYWN0aW9uSXRlbVtdfSAtIGl0ZW1zIHRoYXQgYXJlIGZvdW5kXG5cdFx0ICovXG4gICAgcG9pbnQoY2hhcnQsIGUsIG9wdGlvbnMsIHVzZUZpbmFsUG9zaXRpb24pIHtcbiAgICAgIGNvbnN0IHBvc2l0aW9uID0gZ2V0UmVsYXRpdmVQb3NpdGlvbihlLCBjaGFydCk7XG4gICAgICBjb25zdCBheGlzID0gb3B0aW9ucy5heGlzIHx8ICd4eSc7XG4gICAgICBjb25zdCBpbmNsdWRlSW52aXNpYmxlID0gb3B0aW9ucy5pbmNsdWRlSW52aXNpYmxlIHx8IGZhbHNlO1xuICAgICAgcmV0dXJuIGdldEludGVyc2VjdEl0ZW1zKGNoYXJ0LCBwb3NpdGlvbiwgYXhpcywgdXNlRmluYWxQb3NpdGlvbiwgaW5jbHVkZUludmlzaWJsZSk7XG4gICAgfSxcblxuICAgIC8qKlxuXHRcdCAqIG5lYXJlc3QgbW9kZSByZXR1cm5zIHRoZSBlbGVtZW50IGNsb3Nlc3QgdG8gdGhlIHBvaW50XG5cdFx0ICogQGZ1bmN0aW9uIENoYXJ0LkludGVyYWN0aW9uLm1vZGVzLmludGVyc2VjdFxuXHRcdCAqIEBwYXJhbSB7Q2hhcnR9IGNoYXJ0IC0gdGhlIGNoYXJ0IHdlIGFyZSByZXR1cm5pbmcgaXRlbXMgZnJvbVxuXHRcdCAqIEBwYXJhbSB7RXZlbnR9IGUgLSB0aGUgZXZlbnQgd2UgYXJlIGZpbmQgdGhpbmdzIGF0XG5cdFx0ICogQHBhcmFtIHtJbnRlcmFjdGlvbk9wdGlvbnN9IG9wdGlvbnMgLSBvcHRpb25zIHRvIHVzZVxuXHRcdCAqIEBwYXJhbSB7Ym9vbGVhbn0gW3VzZUZpbmFsUG9zaXRpb25dIC0gdXNlIGZpbmFsIGVsZW1lbnQgcG9zaXRpb24gKGFuaW1hdGlvbiB0YXJnZXQpXG5cdFx0ICogQHJldHVybiB7SW50ZXJhY3Rpb25JdGVtW119IC0gaXRlbXMgdGhhdCBhcmUgZm91bmRcblx0XHQgKi9cbiAgICBuZWFyZXN0KGNoYXJ0LCBlLCBvcHRpb25zLCB1c2VGaW5hbFBvc2l0aW9uKSB7XG4gICAgICBjb25zdCBwb3NpdGlvbiA9IGdldFJlbGF0aXZlUG9zaXRpb24oZSwgY2hhcnQpO1xuICAgICAgY29uc3QgYXhpcyA9IG9wdGlvbnMuYXhpcyB8fCAneHknO1xuICAgICAgY29uc3QgaW5jbHVkZUludmlzaWJsZSA9IG9wdGlvbnMuaW5jbHVkZUludmlzaWJsZSB8fCBmYWxzZTtcbiAgICAgIHJldHVybiBnZXROZWFyZXN0SXRlbXMoY2hhcnQsIHBvc2l0aW9uLCBheGlzLCBvcHRpb25zLmludGVyc2VjdCwgdXNlRmluYWxQb3NpdGlvbiwgaW5jbHVkZUludmlzaWJsZSk7XG4gICAgfSxcblxuICAgIC8qKlxuXHRcdCAqIHggbW9kZSByZXR1cm5zIHRoZSBlbGVtZW50cyB0aGF0IGhpdC10ZXN0IGF0IHRoZSBjdXJyZW50IHggY29vcmRpbmF0ZVxuXHRcdCAqIEBmdW5jdGlvbiBDaGFydC5JbnRlcmFjdGlvbi5tb2Rlcy54XG5cdFx0ICogQHBhcmFtIHtDaGFydH0gY2hhcnQgLSB0aGUgY2hhcnQgd2UgYXJlIHJldHVybmluZyBpdGVtcyBmcm9tXG5cdFx0ICogQHBhcmFtIHtFdmVudH0gZSAtIHRoZSBldmVudCB3ZSBhcmUgZmluZCB0aGluZ3MgYXRcblx0XHQgKiBAcGFyYW0ge0ludGVyYWN0aW9uT3B0aW9uc30gb3B0aW9ucyAtIG9wdGlvbnMgdG8gdXNlXG5cdFx0ICogQHBhcmFtIHtib29sZWFufSBbdXNlRmluYWxQb3NpdGlvbl0gLSB1c2UgZmluYWwgZWxlbWVudCBwb3NpdGlvbiAoYW5pbWF0aW9uIHRhcmdldClcblx0XHQgKiBAcmV0dXJuIHtJbnRlcmFjdGlvbkl0ZW1bXX0gLSBpdGVtcyB0aGF0IGFyZSBmb3VuZFxuXHRcdCAqL1xuICAgIHgoY2hhcnQsIGUsIG9wdGlvbnMsIHVzZUZpbmFsUG9zaXRpb24pIHtcbiAgICAgIGNvbnN0IHBvc2l0aW9uID0gZ2V0UmVsYXRpdmVQb3NpdGlvbihlLCBjaGFydCk7XG4gICAgICByZXR1cm4gZ2V0QXhpc0l0ZW1zKGNoYXJ0LCBwb3NpdGlvbiwgJ3gnLCBvcHRpb25zLmludGVyc2VjdCwgdXNlRmluYWxQb3NpdGlvbik7XG4gICAgfSxcblxuICAgIC8qKlxuXHRcdCAqIHkgbW9kZSByZXR1cm5zIHRoZSBlbGVtZW50cyB0aGF0IGhpdC10ZXN0IGF0IHRoZSBjdXJyZW50IHkgY29vcmRpbmF0ZVxuXHRcdCAqIEBmdW5jdGlvbiBDaGFydC5JbnRlcmFjdGlvbi5tb2Rlcy55XG5cdFx0ICogQHBhcmFtIHtDaGFydH0gY2hhcnQgLSB0aGUgY2hhcnQgd2UgYXJlIHJldHVybmluZyBpdGVtcyBmcm9tXG5cdFx0ICogQHBhcmFtIHtFdmVudH0gZSAtIHRoZSBldmVudCB3ZSBhcmUgZmluZCB0aGluZ3MgYXRcblx0XHQgKiBAcGFyYW0ge0ludGVyYWN0aW9uT3B0aW9uc30gb3B0aW9ucyAtIG9wdGlvbnMgdG8gdXNlXG5cdFx0ICogQHBhcmFtIHtib29sZWFufSBbdXNlRmluYWxQb3NpdGlvbl0gLSB1c2UgZmluYWwgZWxlbWVudCBwb3NpdGlvbiAoYW5pbWF0aW9uIHRhcmdldClcblx0XHQgKiBAcmV0dXJuIHtJbnRlcmFjdGlvbkl0ZW1bXX0gLSBpdGVtcyB0aGF0IGFyZSBmb3VuZFxuXHRcdCAqL1xuICAgIHkoY2hhcnQsIGUsIG9wdGlvbnMsIHVzZUZpbmFsUG9zaXRpb24pIHtcbiAgICAgIGNvbnN0IHBvc2l0aW9uID0gZ2V0UmVsYXRpdmVQb3NpdGlvbihlLCBjaGFydCk7XG4gICAgICByZXR1cm4gZ2V0QXhpc0l0ZW1zKGNoYXJ0LCBwb3NpdGlvbiwgJ3knLCBvcHRpb25zLmludGVyc2VjdCwgdXNlRmluYWxQb3NpdGlvbik7XG4gICAgfVxuICB9XG59O1xuIiwgImltcG9ydCB7ZGVmaW5lZCwgZWFjaCwgaXNPYmplY3R9IGZyb20gJy4uL2hlbHBlcnMvaGVscGVycy5jb3JlLmpzJztcbmltcG9ydCB7dG9QYWRkaW5nfSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMub3B0aW9ucy5qcyc7XG5cbi8qKlxuICogQHR5cGVkZWYgeyBpbXBvcnQoJy4vY29yZS5jb250cm9sbGVyLmpzJykuZGVmYXVsdCB9IENoYXJ0XG4gKi9cblxuY29uc3QgU1RBVElDX1BPU0lUSU9OUyA9IFsnbGVmdCcsICd0b3AnLCAncmlnaHQnLCAnYm90dG9tJ107XG5cbmZ1bmN0aW9uIGZpbHRlckJ5UG9zaXRpb24oYXJyYXksIHBvc2l0aW9uKSB7XG4gIHJldHVybiBhcnJheS5maWx0ZXIodiA9PiB2LnBvcyA9PT0gcG9zaXRpb24pO1xufVxuXG5mdW5jdGlvbiBmaWx0ZXJEeW5hbWljUG9zaXRpb25CeUF4aXMoYXJyYXksIGF4aXMpIHtcbiAgcmV0dXJuIGFycmF5LmZpbHRlcih2ID0+IFNUQVRJQ19QT1NJVElPTlMuaW5kZXhPZih2LnBvcykgPT09IC0xICYmIHYuYm94LmF4aXMgPT09IGF4aXMpO1xufVxuXG5mdW5jdGlvbiBzb3J0QnlXZWlnaHQoYXJyYXksIHJldmVyc2UpIHtcbiAgcmV0dXJuIGFycmF5LnNvcnQoKGEsIGIpID0+IHtcbiAgICBjb25zdCB2MCA9IHJldmVyc2UgPyBiIDogYTtcbiAgICBjb25zdCB2MSA9IHJldmVyc2UgPyBhIDogYjtcbiAgICByZXR1cm4gdjAud2VpZ2h0ID09PSB2MS53ZWlnaHQgP1xuICAgICAgdjAuaW5kZXggLSB2MS5pbmRleCA6XG4gICAgICB2MC53ZWlnaHQgLSB2MS53ZWlnaHQ7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiB3cmFwQm94ZXMoYm94ZXMpIHtcbiAgY29uc3QgbGF5b3V0Qm94ZXMgPSBbXTtcbiAgbGV0IGksIGlsZW4sIGJveCwgcG9zLCBzdGFjaywgc3RhY2tXZWlnaHQ7XG5cbiAgZm9yIChpID0gMCwgaWxlbiA9IChib3hlcyB8fCBbXSkubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgYm94ID0gYm94ZXNbaV07XG4gICAgKHtwb3NpdGlvbjogcG9zLCBvcHRpb25zOiB7c3RhY2ssIHN0YWNrV2VpZ2h0ID0gMX19ID0gYm94KTtcbiAgICBsYXlvdXRCb3hlcy5wdXNoKHtcbiAgICAgIGluZGV4OiBpLFxuICAgICAgYm94LFxuICAgICAgcG9zLFxuICAgICAgaG9yaXpvbnRhbDogYm94LmlzSG9yaXpvbnRhbCgpLFxuICAgICAgd2VpZ2h0OiBib3gud2VpZ2h0LFxuICAgICAgc3RhY2s6IHN0YWNrICYmIChwb3MgKyBzdGFjayksXG4gICAgICBzdGFja1dlaWdodFxuICAgIH0pO1xuICB9XG4gIHJldHVybiBsYXlvdXRCb3hlcztcbn1cblxuZnVuY3Rpb24gYnVpbGRTdGFja3MobGF5b3V0cykge1xuICBjb25zdCBzdGFja3MgPSB7fTtcbiAgZm9yIChjb25zdCB3cmFwIG9mIGxheW91dHMpIHtcbiAgICBjb25zdCB7c3RhY2ssIHBvcywgc3RhY2tXZWlnaHR9ID0gd3JhcDtcbiAgICBpZiAoIXN0YWNrIHx8ICFTVEFUSUNfUE9TSVRJT05TLmluY2x1ZGVzKHBvcykpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBjb25zdCBfc3RhY2sgPSBzdGFja3Nbc3RhY2tdIHx8IChzdGFja3Nbc3RhY2tdID0ge2NvdW50OiAwLCBwbGFjZWQ6IDAsIHdlaWdodDogMCwgc2l6ZTogMH0pO1xuICAgIF9zdGFjay5jb3VudCsrO1xuICAgIF9zdGFjay53ZWlnaHQgKz0gc3RhY2tXZWlnaHQ7XG4gIH1cbiAgcmV0dXJuIHN0YWNrcztcbn1cblxuLyoqXG4gKiBzdG9yZSBkaW1lbnNpb25zIHVzZWQgaW5zdGVhZCBvZiBhdmFpbGFibGUgY2hhcnRBcmVhIGluIGZpdEJveGVzXG4gKiovXG5mdW5jdGlvbiBzZXRMYXlvdXREaW1zKGxheW91dHMsIHBhcmFtcykge1xuICBjb25zdCBzdGFja3MgPSBidWlsZFN0YWNrcyhsYXlvdXRzKTtcbiAgY29uc3Qge3ZCb3hNYXhXaWR0aCwgaEJveE1heEhlaWdodH0gPSBwYXJhbXM7XG4gIGxldCBpLCBpbGVuLCBsYXlvdXQ7XG4gIGZvciAoaSA9IDAsIGlsZW4gPSBsYXlvdXRzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgIGxheW91dCA9IGxheW91dHNbaV07XG4gICAgY29uc3Qge2Z1bGxTaXplfSA9IGxheW91dC5ib3g7XG4gICAgY29uc3Qgc3RhY2sgPSBzdGFja3NbbGF5b3V0LnN0YWNrXTtcbiAgICBjb25zdCBmYWN0b3IgPSBzdGFjayAmJiBsYXlvdXQuc3RhY2tXZWlnaHQgLyBzdGFjay53ZWlnaHQ7XG4gICAgaWYgKGxheW91dC5ob3Jpem9udGFsKSB7XG4gICAgICBsYXlvdXQud2lkdGggPSBmYWN0b3IgPyBmYWN0b3IgKiB2Qm94TWF4V2lkdGggOiBmdWxsU2l6ZSAmJiBwYXJhbXMuYXZhaWxhYmxlV2lkdGg7XG4gICAgICBsYXlvdXQuaGVpZ2h0ID0gaEJveE1heEhlaWdodDtcbiAgICB9IGVsc2Uge1xuICAgICAgbGF5b3V0LndpZHRoID0gdkJveE1heFdpZHRoO1xuICAgICAgbGF5b3V0LmhlaWdodCA9IGZhY3RvciA/IGZhY3RvciAqIGhCb3hNYXhIZWlnaHQgOiBmdWxsU2l6ZSAmJiBwYXJhbXMuYXZhaWxhYmxlSGVpZ2h0O1xuICAgIH1cbiAgfVxuICByZXR1cm4gc3RhY2tzO1xufVxuXG5mdW5jdGlvbiBidWlsZExheW91dEJveGVzKGJveGVzKSB7XG4gIGNvbnN0IGxheW91dEJveGVzID0gd3JhcEJveGVzKGJveGVzKTtcbiAgY29uc3QgZnVsbFNpemUgPSBzb3J0QnlXZWlnaHQobGF5b3V0Qm94ZXMuZmlsdGVyKHdyYXAgPT4gd3JhcC5ib3guZnVsbFNpemUpLCB0cnVlKTtcbiAgY29uc3QgbGVmdCA9IHNvcnRCeVdlaWdodChmaWx0ZXJCeVBvc2l0aW9uKGxheW91dEJveGVzLCAnbGVmdCcpLCB0cnVlKTtcbiAgY29uc3QgcmlnaHQgPSBzb3J0QnlXZWlnaHQoZmlsdGVyQnlQb3NpdGlvbihsYXlvdXRCb3hlcywgJ3JpZ2h0JykpO1xuICBjb25zdCB0b3AgPSBzb3J0QnlXZWlnaHQoZmlsdGVyQnlQb3NpdGlvbihsYXlvdXRCb3hlcywgJ3RvcCcpLCB0cnVlKTtcbiAgY29uc3QgYm90dG9tID0gc29ydEJ5V2VpZ2h0KGZpbHRlckJ5UG9zaXRpb24obGF5b3V0Qm94ZXMsICdib3R0b20nKSk7XG4gIGNvbnN0IGNlbnRlckhvcml6b250YWwgPSBmaWx0ZXJEeW5hbWljUG9zaXRpb25CeUF4aXMobGF5b3V0Qm94ZXMsICd4Jyk7XG4gIGNvbnN0IGNlbnRlclZlcnRpY2FsID0gZmlsdGVyRHluYW1pY1Bvc2l0aW9uQnlBeGlzKGxheW91dEJveGVzLCAneScpO1xuXG4gIHJldHVybiB7XG4gICAgZnVsbFNpemUsXG4gICAgbGVmdEFuZFRvcDogbGVmdC5jb25jYXQodG9wKSxcbiAgICByaWdodEFuZEJvdHRvbTogcmlnaHQuY29uY2F0KGNlbnRlclZlcnRpY2FsKS5jb25jYXQoYm90dG9tKS5jb25jYXQoY2VudGVySG9yaXpvbnRhbCksXG4gICAgY2hhcnRBcmVhOiBmaWx0ZXJCeVBvc2l0aW9uKGxheW91dEJveGVzLCAnY2hhcnRBcmVhJyksXG4gICAgdmVydGljYWw6IGxlZnQuY29uY2F0KHJpZ2h0KS5jb25jYXQoY2VudGVyVmVydGljYWwpLFxuICAgIGhvcml6b250YWw6IHRvcC5jb25jYXQoYm90dG9tKS5jb25jYXQoY2VudGVySG9yaXpvbnRhbClcbiAgfTtcbn1cblxuZnVuY3Rpb24gZ2V0Q29tYmluZWRNYXgobWF4UGFkZGluZywgY2hhcnRBcmVhLCBhLCBiKSB7XG4gIHJldHVybiBNYXRoLm1heChtYXhQYWRkaW5nW2FdLCBjaGFydEFyZWFbYV0pICsgTWF0aC5tYXgobWF4UGFkZGluZ1tiXSwgY2hhcnRBcmVhW2JdKTtcbn1cblxuZnVuY3Rpb24gdXBkYXRlTWF4UGFkZGluZyhtYXhQYWRkaW5nLCBib3hQYWRkaW5nKSB7XG4gIG1heFBhZGRpbmcudG9wID0gTWF0aC5tYXgobWF4UGFkZGluZy50b3AsIGJveFBhZGRpbmcudG9wKTtcbiAgbWF4UGFkZGluZy5sZWZ0ID0gTWF0aC5tYXgobWF4UGFkZGluZy5sZWZ0LCBib3hQYWRkaW5nLmxlZnQpO1xuICBtYXhQYWRkaW5nLmJvdHRvbSA9IE1hdGgubWF4KG1heFBhZGRpbmcuYm90dG9tLCBib3hQYWRkaW5nLmJvdHRvbSk7XG4gIG1heFBhZGRpbmcucmlnaHQgPSBNYXRoLm1heChtYXhQYWRkaW5nLnJpZ2h0LCBib3hQYWRkaW5nLnJpZ2h0KTtcbn1cblxuZnVuY3Rpb24gdXBkYXRlRGltcyhjaGFydEFyZWEsIHBhcmFtcywgbGF5b3V0LCBzdGFja3MpIHtcbiAgY29uc3Qge3BvcywgYm94fSA9IGxheW91dDtcbiAgY29uc3QgbWF4UGFkZGluZyA9IGNoYXJ0QXJlYS5tYXhQYWRkaW5nO1xuXG4gIC8vIGR5bmFtaWNhbGx5IHBsYWNlZCBib3hlcyBzaXplIGlzIG5vdCBjb25zaWRlcmVkXG4gIGlmICghaXNPYmplY3QocG9zKSkge1xuICAgIGlmIChsYXlvdXQuc2l6ZSkge1xuICAgICAgLy8gdGhpcyBsYXlvdXQgd2FzIGFscmVhZHkgY291bnRlZCBmb3IsIGxldHMgZmlyc3QgcmVkdWNlIG9sZCBzaXplXG4gICAgICBjaGFydEFyZWFbcG9zXSAtPSBsYXlvdXQuc2l6ZTtcbiAgICB9XG4gICAgY29uc3Qgc3RhY2sgPSBzdGFja3NbbGF5b3V0LnN0YWNrXSB8fCB7c2l6ZTogMCwgY291bnQ6IDF9O1xuICAgIHN0YWNrLnNpemUgPSBNYXRoLm1heChzdGFjay5zaXplLCBsYXlvdXQuaG9yaXpvbnRhbCA/IGJveC5oZWlnaHQgOiBib3gud2lkdGgpO1xuICAgIGxheW91dC5zaXplID0gc3RhY2suc2l6ZSAvIHN0YWNrLmNvdW50O1xuICAgIGNoYXJ0QXJlYVtwb3NdICs9IGxheW91dC5zaXplO1xuICB9XG5cbiAgaWYgKGJveC5nZXRQYWRkaW5nKSB7XG4gICAgdXBkYXRlTWF4UGFkZGluZyhtYXhQYWRkaW5nLCBib3guZ2V0UGFkZGluZygpKTtcbiAgfVxuXG4gIGNvbnN0IG5ld1dpZHRoID0gTWF0aC5tYXgoMCwgcGFyYW1zLm91dGVyV2lkdGggLSBnZXRDb21iaW5lZE1heChtYXhQYWRkaW5nLCBjaGFydEFyZWEsICdsZWZ0JywgJ3JpZ2h0JykpO1xuICBjb25zdCBuZXdIZWlnaHQgPSBNYXRoLm1heCgwLCBwYXJhbXMub3V0ZXJIZWlnaHQgLSBnZXRDb21iaW5lZE1heChtYXhQYWRkaW5nLCBjaGFydEFyZWEsICd0b3AnLCAnYm90dG9tJykpO1xuICBjb25zdCB3aWR0aENoYW5nZWQgPSBuZXdXaWR0aCAhPT0gY2hhcnRBcmVhLnc7XG4gIGNvbnN0IGhlaWdodENoYW5nZWQgPSBuZXdIZWlnaHQgIT09IGNoYXJ0QXJlYS5oO1xuICBjaGFydEFyZWEudyA9IG5ld1dpZHRoO1xuICBjaGFydEFyZWEuaCA9IG5ld0hlaWdodDtcblxuICAvLyByZXR1cm4gYm9vbGVhbnMgb24gdGhlIGNoYW5nZXMgcGVyIGRpcmVjdGlvblxuICByZXR1cm4gbGF5b3V0Lmhvcml6b250YWxcbiAgICA/IHtzYW1lOiB3aWR0aENoYW5nZWQsIG90aGVyOiBoZWlnaHRDaGFuZ2VkfVxuICAgIDoge3NhbWU6IGhlaWdodENoYW5nZWQsIG90aGVyOiB3aWR0aENoYW5nZWR9O1xufVxuXG5mdW5jdGlvbiBoYW5kbGVNYXhQYWRkaW5nKGNoYXJ0QXJlYSkge1xuICBjb25zdCBtYXhQYWRkaW5nID0gY2hhcnRBcmVhLm1heFBhZGRpbmc7XG5cbiAgZnVuY3Rpb24gdXBkYXRlUG9zKHBvcykge1xuICAgIGNvbnN0IGNoYW5nZSA9IE1hdGgubWF4KG1heFBhZGRpbmdbcG9zXSAtIGNoYXJ0QXJlYVtwb3NdLCAwKTtcbiAgICBjaGFydEFyZWFbcG9zXSArPSBjaGFuZ2U7XG4gICAgcmV0dXJuIGNoYW5nZTtcbiAgfVxuICBjaGFydEFyZWEueSArPSB1cGRhdGVQb3MoJ3RvcCcpO1xuICBjaGFydEFyZWEueCArPSB1cGRhdGVQb3MoJ2xlZnQnKTtcbiAgdXBkYXRlUG9zKCdyaWdodCcpO1xuICB1cGRhdGVQb3MoJ2JvdHRvbScpO1xufVxuXG5mdW5jdGlvbiBnZXRNYXJnaW5zKGhvcml6b250YWwsIGNoYXJ0QXJlYSkge1xuICBjb25zdCBtYXhQYWRkaW5nID0gY2hhcnRBcmVhLm1heFBhZGRpbmc7XG5cbiAgZnVuY3Rpb24gbWFyZ2luRm9yUG9zaXRpb25zKHBvc2l0aW9ucykge1xuICAgIGNvbnN0IG1hcmdpbiA9IHtsZWZ0OiAwLCB0b3A6IDAsIHJpZ2h0OiAwLCBib3R0b206IDB9O1xuICAgIHBvc2l0aW9ucy5mb3JFYWNoKChwb3MpID0+IHtcbiAgICAgIG1hcmdpbltwb3NdID0gTWF0aC5tYXgoY2hhcnRBcmVhW3Bvc10sIG1heFBhZGRpbmdbcG9zXSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIG1hcmdpbjtcbiAgfVxuXG4gIHJldHVybiBob3Jpem9udGFsXG4gICAgPyBtYXJnaW5Gb3JQb3NpdGlvbnMoWydsZWZ0JywgJ3JpZ2h0J10pXG4gICAgOiBtYXJnaW5Gb3JQb3NpdGlvbnMoWyd0b3AnLCAnYm90dG9tJ10pO1xufVxuXG5mdW5jdGlvbiBmaXRCb3hlcyhib3hlcywgY2hhcnRBcmVhLCBwYXJhbXMsIHN0YWNrcykge1xuICBjb25zdCByZWZpdEJveGVzID0gW107XG4gIGxldCBpLCBpbGVuLCBsYXlvdXQsIGJveCwgcmVmaXQsIGNoYW5nZWQ7XG5cbiAgZm9yIChpID0gMCwgaWxlbiA9IGJveGVzLmxlbmd0aCwgcmVmaXQgPSAwOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgbGF5b3V0ID0gYm94ZXNbaV07XG4gICAgYm94ID0gbGF5b3V0LmJveDtcblxuICAgIGJveC51cGRhdGUoXG4gICAgICBsYXlvdXQud2lkdGggfHwgY2hhcnRBcmVhLncsXG4gICAgICBsYXlvdXQuaGVpZ2h0IHx8IGNoYXJ0QXJlYS5oLFxuICAgICAgZ2V0TWFyZ2lucyhsYXlvdXQuaG9yaXpvbnRhbCwgY2hhcnRBcmVhKVxuICAgICk7XG4gICAgY29uc3Qge3NhbWUsIG90aGVyfSA9IHVwZGF0ZURpbXMoY2hhcnRBcmVhLCBwYXJhbXMsIGxheW91dCwgc3RhY2tzKTtcblxuICAgIC8vIERpbWVuc2lvbnMgY2hhbmdlZCBhbmQgdGhlcmUgd2VyZSBub24gZnVsbCB3aWR0aCBib3hlcyBiZWZvcmUgdGhpc1xuICAgIC8vIC0+IHdlIGhhdmUgdG8gcmVmaXQgdGhvc2VcbiAgICByZWZpdCB8PSBzYW1lICYmIHJlZml0Qm94ZXMubGVuZ3RoO1xuXG4gICAgLy8gQ2hhcnQgYXJlYSBjaGFuZ2VkIGluIHRoZSBvcHBvc2l0ZSBkaXJlY3Rpb25cbiAgICBjaGFuZ2VkID0gY2hhbmdlZCB8fCBvdGhlcjtcblxuICAgIGlmICghYm94LmZ1bGxTaXplKSB7IC8vIGZ1bGxTaXplIGJveGVzIGRvbid0IG5lZWQgdG8gYmUgcmUtZml0dGVkIGluIGFueSBjYXNlXG4gICAgICByZWZpdEJveGVzLnB1c2gobGF5b3V0KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVmaXQgJiYgZml0Qm94ZXMocmVmaXRCb3hlcywgY2hhcnRBcmVhLCBwYXJhbXMsIHN0YWNrcykgfHwgY2hhbmdlZDtcbn1cblxuZnVuY3Rpb24gc2V0Qm94RGltcyhib3gsIGxlZnQsIHRvcCwgd2lkdGgsIGhlaWdodCkge1xuICBib3gudG9wID0gdG9wO1xuICBib3gubGVmdCA9IGxlZnQ7XG4gIGJveC5yaWdodCA9IGxlZnQgKyB3aWR0aDtcbiAgYm94LmJvdHRvbSA9IHRvcCArIGhlaWdodDtcbiAgYm94LndpZHRoID0gd2lkdGg7XG4gIGJveC5oZWlnaHQgPSBoZWlnaHQ7XG59XG5cbmZ1bmN0aW9uIHBsYWNlQm94ZXMoYm94ZXMsIGNoYXJ0QXJlYSwgcGFyYW1zLCBzdGFja3MpIHtcbiAgY29uc3QgdXNlclBhZGRpbmcgPSBwYXJhbXMucGFkZGluZztcbiAgbGV0IHt4LCB5fSA9IGNoYXJ0QXJlYTtcblxuICBmb3IgKGNvbnN0IGxheW91dCBvZiBib3hlcykge1xuICAgIGNvbnN0IGJveCA9IGxheW91dC5ib3g7XG4gICAgY29uc3Qgc3RhY2sgPSBzdGFja3NbbGF5b3V0LnN0YWNrXSB8fCB7Y291bnQ6IDEsIHBsYWNlZDogMCwgd2VpZ2h0OiAxfTtcbiAgICBjb25zdCB3ZWlnaHQgPSAobGF5b3V0LnN0YWNrV2VpZ2h0IC8gc3RhY2sud2VpZ2h0KSB8fCAxO1xuICAgIGlmIChsYXlvdXQuaG9yaXpvbnRhbCkge1xuICAgICAgY29uc3Qgd2lkdGggPSBjaGFydEFyZWEudyAqIHdlaWdodDtcbiAgICAgIGNvbnN0IGhlaWdodCA9IHN0YWNrLnNpemUgfHwgYm94LmhlaWdodDtcbiAgICAgIGlmIChkZWZpbmVkKHN0YWNrLnN0YXJ0KSkge1xuICAgICAgICB5ID0gc3RhY2suc3RhcnQ7XG4gICAgICB9XG4gICAgICBpZiAoYm94LmZ1bGxTaXplKSB7XG4gICAgICAgIHNldEJveERpbXMoYm94LCB1c2VyUGFkZGluZy5sZWZ0LCB5LCBwYXJhbXMub3V0ZXJXaWR0aCAtIHVzZXJQYWRkaW5nLnJpZ2h0IC0gdXNlclBhZGRpbmcubGVmdCwgaGVpZ2h0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNldEJveERpbXMoYm94LCBjaGFydEFyZWEubGVmdCArIHN0YWNrLnBsYWNlZCwgeSwgd2lkdGgsIGhlaWdodCk7XG4gICAgICB9XG4gICAgICBzdGFjay5zdGFydCA9IHk7XG4gICAgICBzdGFjay5wbGFjZWQgKz0gd2lkdGg7XG4gICAgICB5ID0gYm94LmJvdHRvbTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgaGVpZ2h0ID0gY2hhcnRBcmVhLmggKiB3ZWlnaHQ7XG4gICAgICBjb25zdCB3aWR0aCA9IHN0YWNrLnNpemUgfHwgYm94LndpZHRoO1xuICAgICAgaWYgKGRlZmluZWQoc3RhY2suc3RhcnQpKSB7XG4gICAgICAgIHggPSBzdGFjay5zdGFydDtcbiAgICAgIH1cbiAgICAgIGlmIChib3guZnVsbFNpemUpIHtcbiAgICAgICAgc2V0Qm94RGltcyhib3gsIHgsIHVzZXJQYWRkaW5nLnRvcCwgd2lkdGgsIHBhcmFtcy5vdXRlckhlaWdodCAtIHVzZXJQYWRkaW5nLmJvdHRvbSAtIHVzZXJQYWRkaW5nLnRvcCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZXRCb3hEaW1zKGJveCwgeCwgY2hhcnRBcmVhLnRvcCArIHN0YWNrLnBsYWNlZCwgd2lkdGgsIGhlaWdodCk7XG4gICAgICB9XG4gICAgICBzdGFjay5zdGFydCA9IHg7XG4gICAgICBzdGFjay5wbGFjZWQgKz0gaGVpZ2h0O1xuICAgICAgeCA9IGJveC5yaWdodDtcbiAgICB9XG4gIH1cblxuICBjaGFydEFyZWEueCA9IHg7XG4gIGNoYXJ0QXJlYS55ID0geTtcbn1cblxuLyoqXG4gKiBAaW50ZXJmYWNlIExheW91dEl0ZW1cbiAqIEB0eXBlZGVmIHtvYmplY3R9IExheW91dEl0ZW1cbiAqIEBwcm9wIHtzdHJpbmd9IHBvc2l0aW9uIC0gVGhlIHBvc2l0aW9uIG9mIHRoZSBpdGVtIGluIHRoZSBjaGFydCBsYXlvdXQuIFBvc3NpYmxlIHZhbHVlcyBhcmVcbiAqICdsZWZ0JywgJ3RvcCcsICdyaWdodCcsICdib3R0b20nLCBhbmQgJ2NoYXJ0QXJlYSdcbiAqIEBwcm9wIHtudW1iZXJ9IHdlaWdodCAtIFRoZSB3ZWlnaHQgdXNlZCB0byBzb3J0IHRoZSBpdGVtLiBIaWdoZXIgd2VpZ2h0cyBhcmUgZnVydGhlciBhd2F5IGZyb20gdGhlIGNoYXJ0IGFyZWFcbiAqIEBwcm9wIHtib29sZWFufSBmdWxsU2l6ZSAtIGlmIHRydWUsIGFuZCB0aGUgaXRlbSBpcyBob3Jpem9udGFsLCB0aGVuIHB1c2ggdmVydGljYWwgYm94ZXMgZG93blxuICogQHByb3Age2Z1bmN0aW9ufSBpc0hvcml6b250YWwgLSByZXR1cm5zIHRydWUgaWYgdGhlIGxheW91dCBpdGVtIGlzIGhvcml6b250YWwgKGllLiB0b3Agb3IgYm90dG9tKVxuICogQHByb3Age2Z1bmN0aW9ufSB1cGRhdGUgLSBUYWtlcyB0d28gcGFyYW1ldGVyczogd2lkdGggYW5kIGhlaWdodC4gUmV0dXJucyBzaXplIG9mIGl0ZW1cbiAqIEBwcm9wIHtmdW5jdGlvbn0gZHJhdyAtIERyYXdzIHRoZSBlbGVtZW50XG4gKiBAcHJvcCB7ZnVuY3Rpb259IFtnZXRQYWRkaW5nXSAtICBSZXR1cm5zIGFuIG9iamVjdCB3aXRoIHBhZGRpbmcgb24gdGhlIGVkZ2VzXG4gKiBAcHJvcCB7bnVtYmVyfSB3aWR0aCAtIFdpZHRoIG9mIGl0ZW0uIE11c3QgYmUgdmFsaWQgYWZ0ZXIgdXBkYXRlKClcbiAqIEBwcm9wIHtudW1iZXJ9IGhlaWdodCAtIEhlaWdodCBvZiBpdGVtLiBNdXN0IGJlIHZhbGlkIGFmdGVyIHVwZGF0ZSgpXG4gKiBAcHJvcCB7bnVtYmVyfSBsZWZ0IC0gTGVmdCBlZGdlIG9mIHRoZSBpdGVtLiBTZXQgYnkgbGF5b3V0IHN5c3RlbSBhbmQgY2Fubm90IGJlIHVzZWQgaW4gdXBkYXRlXG4gKiBAcHJvcCB7bnVtYmVyfSB0b3AgLSBUb3AgZWRnZSBvZiB0aGUgaXRlbS4gU2V0IGJ5IGxheW91dCBzeXN0ZW0gYW5kIGNhbm5vdCBiZSB1c2VkIGluIHVwZGF0ZVxuICogQHByb3Age251bWJlcn0gcmlnaHQgLSBSaWdodCBlZGdlIG9mIHRoZSBpdGVtLiBTZXQgYnkgbGF5b3V0IHN5c3RlbSBhbmQgY2Fubm90IGJlIHVzZWQgaW4gdXBkYXRlXG4gKiBAcHJvcCB7bnVtYmVyfSBib3R0b20gLSBCb3R0b20gZWRnZSBvZiB0aGUgaXRlbS4gU2V0IGJ5IGxheW91dCBzeXN0ZW0gYW5kIGNhbm5vdCBiZSB1c2VkIGluIHVwZGF0ZVxuICovXG5cbi8vIFRoZSBsYXlvdXQgc2VydmljZSBpcyB2ZXJ5IHNlbGYgZXhwbGFuYXRvcnkuICBJdCdzIHJlc3BvbnNpYmxlIGZvciB0aGUgbGF5b3V0IHdpdGhpbiBhIGNoYXJ0LlxuLy8gU2NhbGVzLCBMZWdlbmRzIGFuZCBQbHVnaW5zIGFsbCByZWx5IG9uIHRoZSBsYXlvdXQgc2VydmljZSBhbmQgY2FuIGVhc2lseSByZWdpc3RlciB0byBiZSBwbGFjZWQgYW55d2hlcmUgdGhleSBuZWVkXG4vLyBJdCBpcyB0aGlzIHNlcnZpY2UncyByZXNwb25zaWJpbGl0eSBvZiBjYXJyeWluZyBvdXQgdGhhdCBsYXlvdXQuXG5leHBvcnQgZGVmYXVsdCB7XG5cbiAgLyoqXG5cdCAqIFJlZ2lzdGVyIGEgYm94IHRvIGEgY2hhcnQuXG5cdCAqIEEgYm94IGlzIHNpbXBseSBhIHJlZmVyZW5jZSB0byBhbiBvYmplY3QgdGhhdCByZXF1aXJlcyBsYXlvdXQuIGVnLiBTY2FsZXMsIExlZ2VuZCwgVGl0bGUuXG5cdCAqIEBwYXJhbSB7Q2hhcnR9IGNoYXJ0IC0gdGhlIGNoYXJ0IHRvIHVzZVxuXHQgKiBAcGFyYW0ge0xheW91dEl0ZW19IGl0ZW0gLSB0aGUgaXRlbSB0byBhZGQgdG8gYmUgbGFpZCBvdXRcblx0ICovXG4gIGFkZEJveChjaGFydCwgaXRlbSkge1xuICAgIGlmICghY2hhcnQuYm94ZXMpIHtcbiAgICAgIGNoYXJ0LmJveGVzID0gW107XG4gICAgfVxuXG4gICAgLy8gaW5pdGlhbGl6ZSBpdGVtIHdpdGggZGVmYXVsdCB2YWx1ZXNcbiAgICBpdGVtLmZ1bGxTaXplID0gaXRlbS5mdWxsU2l6ZSB8fCBmYWxzZTtcbiAgICBpdGVtLnBvc2l0aW9uID0gaXRlbS5wb3NpdGlvbiB8fCAndG9wJztcbiAgICBpdGVtLndlaWdodCA9IGl0ZW0ud2VpZ2h0IHx8IDA7XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIGl0ZW0uX2xheWVycyA9IGl0ZW0uX2xheWVycyB8fCBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBbe1xuICAgICAgICB6OiAwLFxuICAgICAgICBkcmF3KGNoYXJ0QXJlYSkge1xuICAgICAgICAgIGl0ZW0uZHJhdyhjaGFydEFyZWEpO1xuICAgICAgICB9XG4gICAgICB9XTtcbiAgICB9O1xuXG4gICAgY2hhcnQuYm94ZXMucHVzaChpdGVtKTtcbiAgfSxcblxuICAvKipcblx0ICogUmVtb3ZlIGEgbGF5b3V0SXRlbSBmcm9tIGEgY2hhcnRcblx0ICogQHBhcmFtIHtDaGFydH0gY2hhcnQgLSB0aGUgY2hhcnQgdG8gcmVtb3ZlIHRoZSBib3ggZnJvbVxuXHQgKiBAcGFyYW0ge0xheW91dEl0ZW19IGxheW91dEl0ZW0gLSB0aGUgaXRlbSB0byByZW1vdmUgZnJvbSB0aGUgbGF5b3V0XG5cdCAqL1xuICByZW1vdmVCb3goY2hhcnQsIGxheW91dEl0ZW0pIHtcbiAgICBjb25zdCBpbmRleCA9IGNoYXJ0LmJveGVzID8gY2hhcnQuYm94ZXMuaW5kZXhPZihsYXlvdXRJdGVtKSA6IC0xO1xuICAgIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICAgIGNoYXJ0LmJveGVzLnNwbGljZShpbmRleCwgMSk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuXHQgKiBTZXRzIChvciB1cGRhdGVzKSBvcHRpb25zIG9uIHRoZSBnaXZlbiBgaXRlbWAuXG5cdCAqIEBwYXJhbSB7Q2hhcnR9IGNoYXJ0IC0gdGhlIGNoYXJ0IGluIHdoaWNoIHRoZSBpdGVtIGxpdmVzIChvciB3aWxsIGJlIGFkZGVkIHRvKVxuXHQgKiBAcGFyYW0ge0xheW91dEl0ZW19IGl0ZW0gLSB0aGUgaXRlbSB0byBjb25maWd1cmUgd2l0aCB0aGUgZ2l2ZW4gb3B0aW9uc1xuXHQgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9ucyAtIHRoZSBuZXcgaXRlbSBvcHRpb25zLlxuXHQgKi9cbiAgY29uZmlndXJlKGNoYXJ0LCBpdGVtLCBvcHRpb25zKSB7XG4gICAgaXRlbS5mdWxsU2l6ZSA9IG9wdGlvbnMuZnVsbFNpemU7XG4gICAgaXRlbS5wb3NpdGlvbiA9IG9wdGlvbnMucG9zaXRpb247XG4gICAgaXRlbS53ZWlnaHQgPSBvcHRpb25zLndlaWdodDtcbiAgfSxcblxuICAvKipcblx0ICogRml0cyBib3hlcyBvZiB0aGUgZ2l2ZW4gY2hhcnQgaW50byB0aGUgZ2l2ZW4gc2l6ZSBieSBoYXZpbmcgZWFjaCBib3ggbWVhc3VyZSBpdHNlbGZcblx0ICogdGhlbiBydW5uaW5nIGEgZml0dGluZyBhbGdvcml0aG1cblx0ICogQHBhcmFtIHtDaGFydH0gY2hhcnQgLSB0aGUgY2hhcnRcblx0ICogQHBhcmFtIHtudW1iZXJ9IHdpZHRoIC0gdGhlIHdpZHRoIHRvIGZpdCBpbnRvXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBoZWlnaHQgLSB0aGUgaGVpZ2h0IHRvIGZpdCBpbnRvXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBtaW5QYWRkaW5nIC0gbWluaW11bSBwYWRkaW5nIHJlcXVpcmVkIGZvciBlYWNoIHNpZGUgb2YgY2hhcnQgYXJlYVxuXHQgKi9cbiAgdXBkYXRlKGNoYXJ0LCB3aWR0aCwgaGVpZ2h0LCBtaW5QYWRkaW5nKSB7XG4gICAgaWYgKCFjaGFydCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IHBhZGRpbmcgPSB0b1BhZGRpbmcoY2hhcnQub3B0aW9ucy5sYXlvdXQucGFkZGluZyk7XG4gICAgY29uc3QgYXZhaWxhYmxlV2lkdGggPSBNYXRoLm1heCh3aWR0aCAtIHBhZGRpbmcud2lkdGgsIDApO1xuICAgIGNvbnN0IGF2YWlsYWJsZUhlaWdodCA9IE1hdGgubWF4KGhlaWdodCAtIHBhZGRpbmcuaGVpZ2h0LCAwKTtcbiAgICBjb25zdCBib3hlcyA9IGJ1aWxkTGF5b3V0Qm94ZXMoY2hhcnQuYm94ZXMpO1xuICAgIGNvbnN0IHZlcnRpY2FsQm94ZXMgPSBib3hlcy52ZXJ0aWNhbDtcbiAgICBjb25zdCBob3Jpem9udGFsQm94ZXMgPSBib3hlcy5ob3Jpem9udGFsO1xuXG4gICAgLy8gQmVmb3JlIGFueSBjaGFuZ2VzIGFyZSBtYWRlLCBub3RpZnkgYm94ZXMgdGhhdCBhbiB1cGRhdGUgaXMgYWJvdXQgdG8gYmVpbmdcbiAgICAvLyBUaGlzIGlzIHVzZWQgdG8gY2xlYXIgYW55IGNhY2hlZCBkYXRhIChlLmcuIHNjYWxlIGxpbWl0cylcbiAgICBlYWNoKGNoYXJ0LmJveGVzLCBib3ggPT4ge1xuICAgICAgaWYgKHR5cGVvZiBib3guYmVmb3JlTGF5b3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGJveC5iZWZvcmVMYXlvdXQoKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIEVzc2VudGlhbGx5IHdlIG5vdyBoYXZlIGFueSBudW1iZXIgb2YgYm94ZXMgb24gZWFjaCBvZiB0aGUgNCBzaWRlcy5cbiAgICAvLyBPdXIgY2FudmFzIGxvb2tzIGxpa2UgdGhlIGZvbGxvd2luZy5cbiAgICAvLyBUaGUgYXJlYXMgTDEgYW5kIEwyIGFyZSB0aGUgbGVmdCBheGVzLiBSMSBpcyB0aGUgcmlnaHQgYXhpcywgVDEgaXMgdGhlIHRvcCBheGlzIGFuZFxuICAgIC8vIEIxIGlzIHRoZSBib3R0b20gYXhpc1xuICAgIC8vIFRoZXJlIGFyZSBhbHNvIDQgcXVhZHJhbnQtbGlrZSBsb2NhdGlvbnMgKGxlZnQgdG8gcmlnaHQgaW5zdGVhZCBvZiBjbG9ja3dpc2UpIHJlc2VydmVkIGZvciBjaGFydCBvdmVybGF5c1xuICAgIC8vIFRoZXNlIGxvY2F0aW9ucyBhcmUgc2luZ2xlLWJveCBsb2NhdGlvbnMgb25seSwgd2hlbiB0cnlpbmcgdG8gcmVnaXN0ZXIgYSBjaGFydEFyZWEgbG9jYXRpb24gdGhhdCBpcyBhbHJlYWR5IHRha2VuLFxuICAgIC8vIGFuIGVycm9yIHdpbGwgYmUgdGhyb3duLlxuICAgIC8vXG4gICAgLy8gfC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS18XG4gICAgLy8gfCAgICAgICAgICAgICAgICAgIFQxIChGdWxsIFdpZHRoKSAgICAgICAgICAgICAgICAgICB8XG4gICAgLy8gfC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS18XG4gICAgLy8gfCAgICB8ICAgIHwgICAgICAgICAgICAgICAgIFQyICAgICAgICAgICAgICAgICAgfCAgICB8XG4gICAgLy8gfCAgICB8LS0tLXwtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tfC0tLS18XG4gICAgLy8gfCAgICB8ICAgIHwgQzEgfCAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgQzIgfCAgICB8XG4gICAgLy8gfCAgICB8ICAgIHwtLS0tfCAgICAgICAgICAgICAgICAgICAgICAgICAgIHwtLS0tfCAgICB8XG4gICAgLy8gfCAgICB8ICAgIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICB8XG4gICAgLy8gfCBMMSB8IEwyIHwgICAgICAgICAgIENoYXJ0QXJlYSAoQzApICAgICAgICAgICAgfCBSMSB8XG4gICAgLy8gfCAgICB8ICAgIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICB8XG4gICAgLy8gfCAgICB8ICAgIHwtLS0tfCAgICAgICAgICAgICAgICAgICAgICAgICAgIHwtLS0tfCAgICB8XG4gICAgLy8gfCAgICB8ICAgIHwgQzMgfCAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgQzQgfCAgICB8XG4gICAgLy8gfCAgICB8LS0tLXwtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tfC0tLS18XG4gICAgLy8gfCAgICB8ICAgIHwgICAgICAgICAgICAgICAgIEIxICAgICAgICAgICAgICAgICAgfCAgICB8XG4gICAgLy8gfC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS18XG4gICAgLy8gfCAgICAgICAgICAgICAgICAgIEIyIChGdWxsIFdpZHRoKSAgICAgICAgICAgICAgICAgICB8XG4gICAgLy8gfC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS18XG4gICAgLy9cblxuICAgIGNvbnN0IHZpc2libGVWZXJ0aWNhbEJveENvdW50ID0gdmVydGljYWxCb3hlcy5yZWR1Y2UoKHRvdGFsLCB3cmFwKSA9PlxuICAgICAgd3JhcC5ib3gub3B0aW9ucyAmJiB3cmFwLmJveC5vcHRpb25zLmRpc3BsYXkgPT09IGZhbHNlID8gdG90YWwgOiB0b3RhbCArIDEsIDApIHx8IDE7XG5cbiAgICBjb25zdCBwYXJhbXMgPSBPYmplY3QuZnJlZXplKHtcbiAgICAgIG91dGVyV2lkdGg6IHdpZHRoLFxuICAgICAgb3V0ZXJIZWlnaHQ6IGhlaWdodCxcbiAgICAgIHBhZGRpbmcsXG4gICAgICBhdmFpbGFibGVXaWR0aCxcbiAgICAgIGF2YWlsYWJsZUhlaWdodCxcbiAgICAgIHZCb3hNYXhXaWR0aDogYXZhaWxhYmxlV2lkdGggLyAyIC8gdmlzaWJsZVZlcnRpY2FsQm94Q291bnQsXG4gICAgICBoQm94TWF4SGVpZ2h0OiBhdmFpbGFibGVIZWlnaHQgLyAyXG4gICAgfSk7XG4gICAgY29uc3QgbWF4UGFkZGluZyA9IE9iamVjdC5hc3NpZ24oe30sIHBhZGRpbmcpO1xuICAgIHVwZGF0ZU1heFBhZGRpbmcobWF4UGFkZGluZywgdG9QYWRkaW5nKG1pblBhZGRpbmcpKTtcbiAgICBjb25zdCBjaGFydEFyZWEgPSBPYmplY3QuYXNzaWduKHtcbiAgICAgIG1heFBhZGRpbmcsXG4gICAgICB3OiBhdmFpbGFibGVXaWR0aCxcbiAgICAgIGg6IGF2YWlsYWJsZUhlaWdodCxcbiAgICAgIHg6IHBhZGRpbmcubGVmdCxcbiAgICAgIHk6IHBhZGRpbmcudG9wXG4gICAgfSwgcGFkZGluZyk7XG5cbiAgICBjb25zdCBzdGFja3MgPSBzZXRMYXlvdXREaW1zKHZlcnRpY2FsQm94ZXMuY29uY2F0KGhvcml6b250YWxCb3hlcyksIHBhcmFtcyk7XG5cbiAgICAvLyBGaXJzdCBmaXQgdGhlIGZ1bGxTaXplIGJveGVzLCB0byByZWR1Y2UgcHJvYmFiaWxpdHkgb2YgcmUtZml0dGluZy5cbiAgICBmaXRCb3hlcyhib3hlcy5mdWxsU2l6ZSwgY2hhcnRBcmVhLCBwYXJhbXMsIHN0YWNrcyk7XG5cbiAgICAvLyBUaGVuIGZpdCB2ZXJ0aWNhbCBib3hlc1xuICAgIGZpdEJveGVzKHZlcnRpY2FsQm94ZXMsIGNoYXJ0QXJlYSwgcGFyYW1zLCBzdGFja3MpO1xuXG4gICAgLy8gVGhlbiBmaXQgaG9yaXpvbnRhbCBib3hlc1xuICAgIGlmIChmaXRCb3hlcyhob3Jpem9udGFsQm94ZXMsIGNoYXJ0QXJlYSwgcGFyYW1zLCBzdGFja3MpKSB7XG4gICAgICAvLyBpZiB0aGUgYXJlYSBjaGFuZ2VkLCByZS1maXQgdmVydGljYWwgYm94ZXNcbiAgICAgIGZpdEJveGVzKHZlcnRpY2FsQm94ZXMsIGNoYXJ0QXJlYSwgcGFyYW1zLCBzdGFja3MpO1xuICAgIH1cblxuICAgIGhhbmRsZU1heFBhZGRpbmcoY2hhcnRBcmVhKTtcblxuICAgIC8vIEZpbmFsbHkgcGxhY2UgdGhlIGJveGVzIHRvIGNvcnJlY3QgY29vcmRpbmF0ZXNcbiAgICBwbGFjZUJveGVzKGJveGVzLmxlZnRBbmRUb3AsIGNoYXJ0QXJlYSwgcGFyYW1zLCBzdGFja3MpO1xuXG4gICAgLy8gTW92ZSB0byBvcHBvc2l0ZSBzaWRlIG9mIGNoYXJ0XG4gICAgY2hhcnRBcmVhLnggKz0gY2hhcnRBcmVhLnc7XG4gICAgY2hhcnRBcmVhLnkgKz0gY2hhcnRBcmVhLmg7XG5cbiAgICBwbGFjZUJveGVzKGJveGVzLnJpZ2h0QW5kQm90dG9tLCBjaGFydEFyZWEsIHBhcmFtcywgc3RhY2tzKTtcblxuICAgIGNoYXJ0LmNoYXJ0QXJlYSA9IHtcbiAgICAgIGxlZnQ6IGNoYXJ0QXJlYS5sZWZ0LFxuICAgICAgdG9wOiBjaGFydEFyZWEudG9wLFxuICAgICAgcmlnaHQ6IGNoYXJ0QXJlYS5sZWZ0ICsgY2hhcnRBcmVhLncsXG4gICAgICBib3R0b206IGNoYXJ0QXJlYS50b3AgKyBjaGFydEFyZWEuaCxcbiAgICAgIGhlaWdodDogY2hhcnRBcmVhLmgsXG4gICAgICB3aWR0aDogY2hhcnRBcmVhLncsXG4gICAgfTtcblxuICAgIC8vIEZpbmFsbHkgdXBkYXRlIGJveGVzIGluIGNoYXJ0QXJlYSAocmFkaWFsIHNjYWxlIGZvciBleGFtcGxlKVxuICAgIGVhY2goYm94ZXMuY2hhcnRBcmVhLCAobGF5b3V0KSA9PiB7XG4gICAgICBjb25zdCBib3ggPSBsYXlvdXQuYm94O1xuICAgICAgT2JqZWN0LmFzc2lnbihib3gsIGNoYXJ0LmNoYXJ0QXJlYSk7XG4gICAgICBib3gudXBkYXRlKGNoYXJ0QXJlYS53LCBjaGFydEFyZWEuaCwge2xlZnQ6IDAsIHRvcDogMCwgcmlnaHQ6IDAsIGJvdHRvbTogMH0pO1xuICAgIH0pO1xuICB9XG59O1xuIiwgIlxuLyoqXG4gKiBAdHlwZWRlZiB7IGltcG9ydCgnLi4vY29yZS9jb3JlLmNvbnRyb2xsZXIuanMnKS5kZWZhdWx0IH0gQ2hhcnRcbiAqL1xuXG4vKipcbiAqIEFic3RyYWN0IGNsYXNzIHRoYXQgYWxsb3dzIGFic3RyYWN0aW5nIHBsYXRmb3JtIGRlcGVuZGVuY2llcyBhd2F5IGZyb20gdGhlIGNoYXJ0LlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBCYXNlUGxhdGZvcm0ge1xuICAvKipcblx0ICogQ2FsbGVkIGF0IGNoYXJ0IGNvbnN0cnVjdGlvbiB0aW1lLCByZXR1cm5zIGEgY29udGV4dDJkIGluc3RhbmNlIGltcGxlbWVudGluZ1xuXHQgKiB0aGUgW1czQyBDYW52YXMgMkQgQ29udGV4dCBBUEkgc3RhbmRhcmRde0BsaW5rIGh0dHBzOi8vd3d3LnczLm9yZy9UUi8yZGNvbnRleHQvfS5cblx0ICogQHBhcmFtIHtIVE1MQ2FudmFzRWxlbWVudH0gY2FudmFzIC0gVGhlIGNhbnZhcyBmcm9tIHdoaWNoIHRvIGFjcXVpcmUgY29udGV4dCAocGxhdGZvcm0gc3BlY2lmaWMpXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBbYXNwZWN0UmF0aW9dIC0gVGhlIGNoYXJ0IG9wdGlvbnNcblx0ICovXG4gIGFjcXVpcmVDb250ZXh0KGNhbnZhcywgYXNwZWN0UmF0aW8pIHt9IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcblxuICAvKipcblx0ICogQ2FsbGVkIGF0IGNoYXJ0IGRlc3RydWN0aW9uIHRpbWUsIHJlbGVhc2VzIGFueSByZXNvdXJjZXMgYXNzb2NpYXRlZCB0byB0aGUgY29udGV4dFxuXHQgKiBwcmV2aW91c2x5IHJldHVybmVkIGJ5IHRoZSBhY3F1aXJlQ29udGV4dCgpIG1ldGhvZC5cblx0ICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGNvbnRleHQgLSBUaGUgY29udGV4dDJkIGluc3RhbmNlXG5cdCAqIEByZXR1cm5zIHtib29sZWFufSB0cnVlIGlmIHRoZSBtZXRob2Qgc3VjY2VlZGVkLCBlbHNlIGZhbHNlXG5cdCAqL1xuICByZWxlYXNlQ29udGV4dChjb250ZXh0KSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvKipcblx0ICogUmVnaXN0ZXJzIHRoZSBzcGVjaWZpZWQgbGlzdGVuZXIgb24gdGhlIGdpdmVuIGNoYXJ0LlxuXHQgKiBAcGFyYW0ge0NoYXJ0fSBjaGFydCAtIENoYXJ0IGZyb20gd2hpY2ggdG8gbGlzdGVuIGZvciBldmVudFxuXHQgKiBAcGFyYW0ge3N0cmluZ30gdHlwZSAtIFRoZSAoe0BsaW5rIENoYXJ0RXZlbnR9KSB0eXBlIHRvIGxpc3RlbiBmb3Jcblx0ICogQHBhcmFtIHtmdW5jdGlvbn0gbGlzdGVuZXIgLSBSZWNlaXZlcyBhIG5vdGlmaWNhdGlvbiAoYW4gb2JqZWN0IHRoYXQgaW1wbGVtZW50c1xuXHQgKiB0aGUge0BsaW5rIENoYXJ0RXZlbnR9IGludGVyZmFjZSkgd2hlbiBhbiBldmVudCBvZiB0aGUgc3BlY2lmaWVkIHR5cGUgb2NjdXJzLlxuXHQgKi9cbiAgYWRkRXZlbnRMaXN0ZW5lcihjaGFydCwgdHlwZSwgbGlzdGVuZXIpIHt9IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcblxuICAvKipcblx0ICogUmVtb3ZlcyB0aGUgc3BlY2lmaWVkIGxpc3RlbmVyIHByZXZpb3VzbHkgcmVnaXN0ZXJlZCB3aXRoIGFkZEV2ZW50TGlzdGVuZXIuXG5cdCAqIEBwYXJhbSB7Q2hhcnR9IGNoYXJ0IC0gQ2hhcnQgZnJvbSB3aGljaCB0byByZW1vdmUgdGhlIGxpc3RlbmVyXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIC0gVGhlICh7QGxpbmsgQ2hhcnRFdmVudH0pIHR5cGUgdG8gcmVtb3ZlXG5cdCAqIEBwYXJhbSB7ZnVuY3Rpb259IGxpc3RlbmVyIC0gVGhlIGxpc3RlbmVyIGZ1bmN0aW9uIHRvIHJlbW92ZSBmcm9tIHRoZSBldmVudCB0YXJnZXQuXG5cdCAqL1xuICByZW1vdmVFdmVudExpc3RlbmVyKGNoYXJ0LCB0eXBlLCBsaXN0ZW5lcikge30gLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuXG4gIC8qKlxuXHQgKiBAcmV0dXJucyB7bnVtYmVyfSB0aGUgY3VycmVudCBkZXZpY2VQaXhlbFJhdGlvIG9mIHRoZSBkZXZpY2UgdGhpcyBwbGF0Zm9ybSBpcyBjb25uZWN0ZWQgdG8uXG5cdCAqL1xuICBnZXREZXZpY2VQaXhlbFJhdGlvKCkge1xuICAgIHJldHVybiAxO1xuICB9XG5cbiAgLyoqXG5cdCAqIFJldHVybnMgdGhlIG1heGltdW0gc2l6ZSBpbiBwaXhlbHMgb2YgZ2l2ZW4gY2FudmFzIGVsZW1lbnQuXG5cdCAqIEBwYXJhbSB7SFRNTENhbnZhc0VsZW1lbnR9IGVsZW1lbnRcblx0ICogQHBhcmFtIHtudW1iZXJ9IFt3aWR0aF0gLSBjb250ZW50IHdpZHRoIG9mIHBhcmVudCBlbGVtZW50XG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBbaGVpZ2h0XSAtIGNvbnRlbnQgaGVpZ2h0IG9mIHBhcmVudCBlbGVtZW50XG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBbYXNwZWN0UmF0aW9dIC0gYXNwZWN0IHJhdGlvIHRvIG1haW50YWluXG5cdCAqL1xuICBnZXRNYXhpbXVtU2l6ZShlbGVtZW50LCB3aWR0aCwgaGVpZ2h0LCBhc3BlY3RSYXRpbykge1xuICAgIHdpZHRoID0gTWF0aC5tYXgoMCwgd2lkdGggfHwgZWxlbWVudC53aWR0aCk7XG4gICAgaGVpZ2h0ID0gaGVpZ2h0IHx8IGVsZW1lbnQuaGVpZ2h0O1xuICAgIHJldHVybiB7XG4gICAgICB3aWR0aCxcbiAgICAgIGhlaWdodDogTWF0aC5tYXgoMCwgYXNwZWN0UmF0aW8gPyBNYXRoLmZsb29yKHdpZHRoIC8gYXNwZWN0UmF0aW8pIDogaGVpZ2h0KVxuICAgIH07XG4gIH1cblxuICAvKipcblx0ICogQHBhcmFtIHtIVE1MQ2FudmFzRWxlbWVudH0gY2FudmFzXG5cdCAqIEByZXR1cm5zIHtib29sZWFufSB0cnVlIGlmIHRoZSBjYW52YXMgaXMgYXR0YWNoZWQgdG8gdGhlIHBsYXRmb3JtLCBmYWxzZSBpZiBub3QuXG5cdCAqL1xuICBpc0F0dGFjaGVkKGNhbnZhcykgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvKipcbiAgICogVXBkYXRlcyBjb25maWcgd2l0aCBwbGF0Zm9ybSBzcGVjaWZpYyByZXF1aXJlbWVudHNcbiAgICogQHBhcmFtIHtpbXBvcnQoJy4uL2NvcmUvY29yZS5jb25maWcuanMnKS5kZWZhdWx0fSBjb25maWdcbiAgICovXG4gIHVwZGF0ZUNvbmZpZyhjb25maWcpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuICAgIC8vIG5vLW9wXG4gIH1cbn1cbiIsICIvKipcbiAqIFBsYXRmb3JtIGZhbGxiYWNrIGltcGxlbWVudGF0aW9uIChtaW5pbWFsKS5cbiAqIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2NoYXJ0anMvQ2hhcnQuanMvcHVsbC80NTkxI2lzc3VlY29tbWVudC0zMTk1NzU5MzlcbiAqL1xuXG5pbXBvcnQgQmFzZVBsYXRmb3JtIGZyb20gJy4vcGxhdGZvcm0uYmFzZS5qcyc7XG5cbi8qKlxuICogUGxhdGZvcm0gY2xhc3MgZm9yIGNoYXJ0cyB3aXRob3V0IGFjY2VzcyB0byB0aGUgRE9NIG9yIHRvIG1hbnkgZWxlbWVudCBwcm9wZXJ0aWVzXG4gKiBUaGlzIHBsYXRmb3JtIGlzIHVzZWQgYnkgZGVmYXVsdCBmb3IgYW55IGNoYXJ0IHBhc3NlZCBhbiBPZmZzY3JlZW5DYW52YXMuXG4gKiBAZXh0ZW5kcyBCYXNlUGxhdGZvcm1cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQmFzaWNQbGF0Zm9ybSBleHRlbmRzIEJhc2VQbGF0Zm9ybSB7XG4gIGFjcXVpcmVDb250ZXh0KGl0ZW0pIHtcbiAgICAvLyBUbyBwcmV2ZW50IGNhbnZhcyBmaW5nZXJwcmludGluZywgc29tZSBhZGQtb25zIHVuZGVmaW5lIHRoZSBnZXRDb250ZXh0XG4gICAgLy8gbWV0aG9kLCBmb3IgZXhhbXBsZTogaHR0cHM6Ly9naXRodWIuY29tL2trYXBzbmVyL0NhbnZhc0Jsb2NrZXJcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vY2hhcnRqcy9DaGFydC5qcy9pc3N1ZXMvMjgwN1xuICAgIHJldHVybiBpdGVtICYmIGl0ZW0uZ2V0Q29udGV4dCAmJiBpdGVtLmdldENvbnRleHQoJzJkJykgfHwgbnVsbDtcbiAgfVxuICB1cGRhdGVDb25maWcoY29uZmlnKSB7XG4gICAgY29uZmlnLm9wdGlvbnMuYW5pbWF0aW9uID0gZmFsc2U7XG4gIH1cbn1cbiIsICIvKipcbiAqIENoYXJ0LlBsYXRmb3JtIGltcGxlbWVudGF0aW9uIGZvciB0YXJnZXRpbmcgYSB3ZWIgYnJvd3NlclxuICovXG5cbmltcG9ydCBCYXNlUGxhdGZvcm0gZnJvbSAnLi9wbGF0Zm9ybS5iYXNlLmpzJztcbmltcG9ydCB7X2dldFBhcmVudE5vZGUsIGdldFJlbGF0aXZlUG9zaXRpb24sIHN1cHBvcnRzRXZlbnRMaXN0ZW5lck9wdGlvbnMsIHJlYWRVc2VkU2l6ZSwgZ2V0TWF4aW11bVNpemV9IGZyb20gJy4uL2hlbHBlcnMvaGVscGVycy5kb20uanMnO1xuaW1wb3J0IHt0aHJvdHRsZWR9IGZyb20gJy4uL2hlbHBlcnMvaGVscGVycy5leHRyYXMuanMnO1xuaW1wb3J0IHtpc051bGxPclVuZGVmfSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMuY29yZS5qcyc7XG5cbi8qKlxuICogQHR5cGVkZWYgeyBpbXBvcnQoJy4uL2NvcmUvY29yZS5jb250cm9sbGVyLmpzJykuZGVmYXVsdCB9IENoYXJ0XG4gKi9cblxuY29uc3QgRVhQQU5ET19LRVkgPSAnJGNoYXJ0anMnO1xuXG4vKipcbiAqIERPTSBldmVudCB0eXBlcyAtPiBDaGFydC5qcyBldmVudCB0eXBlcy5cbiAqIE5vdGU6IG9ubHkgZXZlbnRzIHdpdGggZGlmZmVyZW50IHR5cGVzIGFyZSBtYXBwZWQuXG4gKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0V2ZW50c1xuICovXG5jb25zdCBFVkVOVF9UWVBFUyA9IHtcbiAgdG91Y2hzdGFydDogJ21vdXNlZG93bicsXG4gIHRvdWNobW92ZTogJ21vdXNlbW92ZScsXG4gIHRvdWNoZW5kOiAnbW91c2V1cCcsXG4gIHBvaW50ZXJlbnRlcjogJ21vdXNlZW50ZXInLFxuICBwb2ludGVyZG93bjogJ21vdXNlZG93bicsXG4gIHBvaW50ZXJtb3ZlOiAnbW91c2Vtb3ZlJyxcbiAgcG9pbnRlcnVwOiAnbW91c2V1cCcsXG4gIHBvaW50ZXJsZWF2ZTogJ21vdXNlb3V0JyxcbiAgcG9pbnRlcm91dDogJ21vdXNlb3V0J1xufTtcblxuY29uc3QgaXNOdWxsT3JFbXB0eSA9IHZhbHVlID0+IHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSAnJztcbi8qKlxuICogSW5pdGlhbGl6ZXMgdGhlIGNhbnZhcyBzdHlsZSBhbmQgcmVuZGVyIHNpemUgd2l0aG91dCBtb2RpZnlpbmcgdGhlIGNhbnZhcyBkaXNwbGF5IHNpemUsXG4gKiBzaW5jZSByZXNwb25zaXZlbmVzcyBpcyBoYW5kbGVkIGJ5IHRoZSBjb250cm9sbGVyLnJlc2l6ZSgpIG1ldGhvZC4gVGhlIGNvbmZpZyBpcyB1c2VkXG4gKiB0byBkZXRlcm1pbmUgdGhlIGFzcGVjdCByYXRpbyB0byBhcHBseSBpbiBjYXNlIG5vIGV4cGxpY2l0IGhlaWdodCBoYXMgYmVlbiBzcGVjaWZpZWQuXG4gKiBAcGFyYW0ge0hUTUxDYW52YXNFbGVtZW50fSBjYW52YXNcbiAqIEBwYXJhbSB7bnVtYmVyfSBbYXNwZWN0UmF0aW9dXG4gKi9cbmZ1bmN0aW9uIGluaXRDYW52YXMoY2FudmFzLCBhc3BlY3RSYXRpbykge1xuICBjb25zdCBzdHlsZSA9IGNhbnZhcy5zdHlsZTtcblxuICAvLyBOT1RFKFNCKSBjYW52YXMuZ2V0QXR0cmlidXRlKCd3aWR0aCcpICE9PSBjYW52YXMud2lkdGg6IGluIHRoZSBmaXJzdCBjYXNlIGl0XG4gIC8vIHJldHVybnMgbnVsbCBvciAnJyBpZiBubyBleHBsaWNpdCB2YWx1ZSBoYXMgYmVlbiBzZXQgdG8gdGhlIGNhbnZhcyBhdHRyaWJ1dGUuXG4gIGNvbnN0IHJlbmRlckhlaWdodCA9IGNhbnZhcy5nZXRBdHRyaWJ1dGUoJ2hlaWdodCcpO1xuICBjb25zdCByZW5kZXJXaWR0aCA9IGNhbnZhcy5nZXRBdHRyaWJ1dGUoJ3dpZHRoJyk7XG5cbiAgLy8gQ2hhcnQuanMgbW9kaWZpZXMgc29tZSBjYW52YXMgdmFsdWVzIHRoYXQgd2Ugd2FudCB0byByZXN0b3JlIG9uIGRlc3Ryb3lcbiAgY2FudmFzW0VYUEFORE9fS0VZXSA9IHtcbiAgICBpbml0aWFsOiB7XG4gICAgICBoZWlnaHQ6IHJlbmRlckhlaWdodCxcbiAgICAgIHdpZHRoOiByZW5kZXJXaWR0aCxcbiAgICAgIHN0eWxlOiB7XG4gICAgICAgIGRpc3BsYXk6IHN0eWxlLmRpc3BsYXksXG4gICAgICAgIGhlaWdodDogc3R5bGUuaGVpZ2h0LFxuICAgICAgICB3aWR0aDogc3R5bGUud2lkdGhcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLy8gRm9yY2UgY2FudmFzIHRvIGRpc3BsYXkgYXMgYmxvY2sgdG8gYXZvaWQgZXh0cmEgc3BhY2UgY2F1c2VkIGJ5IGlubGluZVxuICAvLyBlbGVtZW50cywgd2hpY2ggd291bGQgaW50ZXJmZXJlIHdpdGggdGhlIHJlc3BvbnNpdmUgcmVzaXplIHByb2Nlc3MuXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9jaGFydGpzL0NoYXJ0LmpzL2lzc3Vlcy8yNTM4XG4gIHN0eWxlLmRpc3BsYXkgPSBzdHlsZS5kaXNwbGF5IHx8ICdibG9jayc7XG4gIC8vIEluY2x1ZGUgcG9zc2libGUgYm9yZGVycyBpbiB0aGUgc2l6ZVxuICBzdHlsZS5ib3hTaXppbmcgPSBzdHlsZS5ib3hTaXppbmcgfHwgJ2JvcmRlci1ib3gnO1xuXG4gIGlmIChpc051bGxPckVtcHR5KHJlbmRlcldpZHRoKSkge1xuICAgIGNvbnN0IGRpc3BsYXlXaWR0aCA9IHJlYWRVc2VkU2l6ZShjYW52YXMsICd3aWR0aCcpO1xuICAgIGlmIChkaXNwbGF5V2lkdGggIT09IHVuZGVmaW5lZCkge1xuICAgICAgY2FudmFzLndpZHRoID0gZGlzcGxheVdpZHRoO1xuICAgIH1cbiAgfVxuXG4gIGlmIChpc051bGxPckVtcHR5KHJlbmRlckhlaWdodCkpIHtcbiAgICBpZiAoY2FudmFzLnN0eWxlLmhlaWdodCA9PT0gJycpIHtcbiAgICAgIC8vIElmIG5vIGV4cGxpY2l0IHJlbmRlciBoZWlnaHQgYW5kIHN0eWxlIGhlaWdodCwgbGV0J3MgYXBwbHkgdGhlIGFzcGVjdCByYXRpbyxcbiAgICAgIC8vIHdoaWNoIG9uZSBjYW4gYmUgc3BlY2lmaWVkIGJ5IHRoZSB1c2VyIGJ1dCBhbHNvIGJ5IGNoYXJ0cyBhcyBkZWZhdWx0IG9wdGlvblxuICAgICAgLy8gKGkuZS4gb3B0aW9ucy5hc3BlY3RSYXRpbykuIElmIG5vdCBzcGVjaWZpZWQsIHVzZSBjYW52YXMgYXNwZWN0IHJhdGlvIG9mIDIuXG4gICAgICBjYW52YXMuaGVpZ2h0ID0gY2FudmFzLndpZHRoIC8gKGFzcGVjdFJhdGlvIHx8IDIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBkaXNwbGF5SGVpZ2h0ID0gcmVhZFVzZWRTaXplKGNhbnZhcywgJ2hlaWdodCcpO1xuICAgICAgaWYgKGRpc3BsYXlIZWlnaHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjYW52YXMuaGVpZ2h0ID0gZGlzcGxheUhlaWdodDtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gY2FudmFzO1xufVxuXG4vLyBEZWZhdWx0IHBhc3NpdmUgdG8gdHJ1ZSBhcyBleHBlY3RlZCBieSBDaHJvbWUgZm9yICd0b3VjaHN0YXJ0JyBhbmQgJ3RvdWNoZW5kJyBldmVudHMuXG4vLyBodHRwczovL2dpdGh1Yi5jb20vY2hhcnRqcy9DaGFydC5qcy9pc3N1ZXMvNDI4N1xuY29uc3QgZXZlbnRMaXN0ZW5lck9wdGlvbnMgPSBzdXBwb3J0c0V2ZW50TGlzdGVuZXJPcHRpb25zID8ge3Bhc3NpdmU6IHRydWV9IDogZmFsc2U7XG5cbmZ1bmN0aW9uIGFkZExpc3RlbmVyKG5vZGUsIHR5cGUsIGxpc3RlbmVyKSB7XG4gIGlmIChub2RlKSB7XG4gICAgbm9kZS5hZGRFdmVudExpc3RlbmVyKHR5cGUsIGxpc3RlbmVyLCBldmVudExpc3RlbmVyT3B0aW9ucyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVtb3ZlTGlzdGVuZXIoY2hhcnQsIHR5cGUsIGxpc3RlbmVyKSB7XG4gIGlmIChjaGFydCAmJiBjaGFydC5jYW52YXMpIHtcbiAgICBjaGFydC5jYW52YXMucmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lciwgZXZlbnRMaXN0ZW5lck9wdGlvbnMpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGZyb21OYXRpdmVFdmVudChldmVudCwgY2hhcnQpIHtcbiAgY29uc3QgdHlwZSA9IEVWRU5UX1RZUEVTW2V2ZW50LnR5cGVdIHx8IGV2ZW50LnR5cGU7XG4gIGNvbnN0IHt4LCB5fSA9IGdldFJlbGF0aXZlUG9zaXRpb24oZXZlbnQsIGNoYXJ0KTtcbiAgcmV0dXJuIHtcbiAgICB0eXBlLFxuICAgIGNoYXJ0LFxuICAgIG5hdGl2ZTogZXZlbnQsXG4gICAgeDogeCAhPT0gdW5kZWZpbmVkID8geCA6IG51bGwsXG4gICAgeTogeSAhPT0gdW5kZWZpbmVkID8geSA6IG51bGwsXG4gIH07XG59XG5cbmZ1bmN0aW9uIG5vZGVMaXN0Q29udGFpbnMobm9kZUxpc3QsIGNhbnZhcykge1xuICBmb3IgKGNvbnN0IG5vZGUgb2Ygbm9kZUxpc3QpIHtcbiAgICBpZiAobm9kZSA9PT0gY2FudmFzIHx8IG5vZGUuY29udGFpbnMoY2FudmFzKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUF0dGFjaE9ic2VydmVyKGNoYXJ0LCB0eXBlLCBsaXN0ZW5lcikge1xuICBjb25zdCBjYW52YXMgPSBjaGFydC5jYW52YXM7XG4gIGNvbnN0IG9ic2VydmVyID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIoZW50cmllcyA9PiB7XG4gICAgbGV0IHRyaWdnZXIgPSBmYWxzZTtcbiAgICBmb3IgKGNvbnN0IGVudHJ5IG9mIGVudHJpZXMpIHtcbiAgICAgIHRyaWdnZXIgPSB0cmlnZ2VyIHx8IG5vZGVMaXN0Q29udGFpbnMoZW50cnkuYWRkZWROb2RlcywgY2FudmFzKTtcbiAgICAgIHRyaWdnZXIgPSB0cmlnZ2VyICYmICFub2RlTGlzdENvbnRhaW5zKGVudHJ5LnJlbW92ZWROb2RlcywgY2FudmFzKTtcbiAgICB9XG4gICAgaWYgKHRyaWdnZXIpIHtcbiAgICAgIGxpc3RlbmVyKCk7XG4gICAgfVxuICB9KTtcbiAgb2JzZXJ2ZXIub2JzZXJ2ZShkb2N1bWVudCwge2NoaWxkTGlzdDogdHJ1ZSwgc3VidHJlZTogdHJ1ZX0pO1xuICByZXR1cm4gb2JzZXJ2ZXI7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZURldGFjaE9ic2VydmVyKGNoYXJ0LCB0eXBlLCBsaXN0ZW5lcikge1xuICBjb25zdCBjYW52YXMgPSBjaGFydC5jYW52YXM7XG4gIGNvbnN0IG9ic2VydmVyID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIoZW50cmllcyA9PiB7XG4gICAgbGV0IHRyaWdnZXIgPSBmYWxzZTtcbiAgICBmb3IgKGNvbnN0IGVudHJ5IG9mIGVudHJpZXMpIHtcbiAgICAgIHRyaWdnZXIgPSB0cmlnZ2VyIHx8IG5vZGVMaXN0Q29udGFpbnMoZW50cnkucmVtb3ZlZE5vZGVzLCBjYW52YXMpO1xuICAgICAgdHJpZ2dlciA9IHRyaWdnZXIgJiYgIW5vZGVMaXN0Q29udGFpbnMoZW50cnkuYWRkZWROb2RlcywgY2FudmFzKTtcbiAgICB9XG4gICAgaWYgKHRyaWdnZXIpIHtcbiAgICAgIGxpc3RlbmVyKCk7XG4gICAgfVxuICB9KTtcbiAgb2JzZXJ2ZXIub2JzZXJ2ZShkb2N1bWVudCwge2NoaWxkTGlzdDogdHJ1ZSwgc3VidHJlZTogdHJ1ZX0pO1xuICByZXR1cm4gb2JzZXJ2ZXI7XG59XG5cbmNvbnN0IGRycExpc3RlbmluZ0NoYXJ0cyA9IG5ldyBNYXAoKTtcbmxldCBvbGREZXZpY2VQaXhlbFJhdGlvID0gMDtcblxuZnVuY3Rpb24gb25XaW5kb3dSZXNpemUoKSB7XG4gIGNvbnN0IGRwciA9IHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvO1xuICBpZiAoZHByID09PSBvbGREZXZpY2VQaXhlbFJhdGlvKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIG9sZERldmljZVBpeGVsUmF0aW8gPSBkcHI7XG4gIGRycExpc3RlbmluZ0NoYXJ0cy5mb3JFYWNoKChyZXNpemUsIGNoYXJ0KSA9PiB7XG4gICAgaWYgKGNoYXJ0LmN1cnJlbnREZXZpY2VQaXhlbFJhdGlvICE9PSBkcHIpIHtcbiAgICAgIHJlc2l6ZSgpO1xuICAgIH1cbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGxpc3RlbkRldmljZVBpeGVsUmF0aW9DaGFuZ2VzKGNoYXJ0LCByZXNpemUpIHtcbiAgaWYgKCFkcnBMaXN0ZW5pbmdDaGFydHMuc2l6ZSkge1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCBvbldpbmRvd1Jlc2l6ZSk7XG4gIH1cbiAgZHJwTGlzdGVuaW5nQ2hhcnRzLnNldChjaGFydCwgcmVzaXplKTtcbn1cblxuZnVuY3Rpb24gdW5saXN0ZW5EZXZpY2VQaXhlbFJhdGlvQ2hhbmdlcyhjaGFydCkge1xuICBkcnBMaXN0ZW5pbmdDaGFydHMuZGVsZXRlKGNoYXJ0KTtcbiAgaWYgKCFkcnBMaXN0ZW5pbmdDaGFydHMuc2l6ZSkge1xuICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdyZXNpemUnLCBvbldpbmRvd1Jlc2l6ZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlUmVzaXplT2JzZXJ2ZXIoY2hhcnQsIHR5cGUsIGxpc3RlbmVyKSB7XG4gIGNvbnN0IGNhbnZhcyA9IGNoYXJ0LmNhbnZhcztcbiAgY29uc3QgY29udGFpbmVyID0gY2FudmFzICYmIF9nZXRQYXJlbnROb2RlKGNhbnZhcyk7XG4gIGlmICghY29udGFpbmVyKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IHJlc2l6ZSA9IHRocm90dGxlZCgod2lkdGgsIGhlaWdodCkgPT4ge1xuICAgIGNvbnN0IHcgPSBjb250YWluZXIuY2xpZW50V2lkdGg7XG4gICAgbGlzdGVuZXIod2lkdGgsIGhlaWdodCk7XG4gICAgaWYgKHcgPCBjb250YWluZXIuY2xpZW50V2lkdGgpIHtcbiAgICAgIC8vIElmIHRoZSBjb250YWluZXIgc2l6ZSBzaHJhbmsgZHVyaW5nIGNoYXJ0IHJlc2l6ZSwgbGV0J3MgYXNzdW1lXG4gICAgICAvLyBzY3JvbGxiYXIgYXBwZWFyZWQuIFNvIHdlIHJlc2l6ZSBhZ2FpbiB3aXRoIHRoZSBzY3JvbGxiYXIgdmlzaWJsZSAtXG4gICAgICAvLyBlZmZlY3RpdmVseSBtYWtpbmcgY2hhcnQgc21hbGxlciBhbmQgdGhlIHNjcm9sbGJhciBoaWRkZW4gYWdhaW4uXG4gICAgICAvLyBCZWNhdXNlIHdlIGFyZSBpbnNpZGUgYHRocm90dGxlZGAsIGFuZCBjdXJyZW50bHkgYHRpY2tpbmdgLCBzY3JvbGxcbiAgICAgIC8vIGV2ZW50cyBhcmUgaWdub3JlZCBkdXJpbmcgdGhpcyB3aG9sZSAyIHJlc2l6ZSBwcm9jZXNzLlxuICAgICAgLy8gSWYgd2UgYXNzdW1lZCB3cm9uZyBhbmQgc29tZXRoaW5nIGVsc2UgaGFwcGVuZWQsIHdlIGFyZSByZXNpemluZ1xuICAgICAgLy8gdHdpY2UgaW4gYSBmcmFtZSAocG90ZW50aWFsIHBlcmZvcm1hbmNlIGlzc3VlKVxuICAgICAgbGlzdGVuZXIoKTtcbiAgICB9XG4gIH0sIHdpbmRvdyk7XG5cbiAgLy8gQHRzLWlnbm9yZSB1bnRpbCBodHRwczovL2dpdGh1Yi5jb20vbWljcm9zb2Z0L1R5cGVTY3JpcHQvaXNzdWVzLzM3ODYxIGltcGxlbWVudGVkXG4gIGNvbnN0IG9ic2VydmVyID0gbmV3IFJlc2l6ZU9ic2VydmVyKGVudHJpZXMgPT4ge1xuICAgIGNvbnN0IGVudHJ5ID0gZW50cmllc1swXTtcbiAgICBjb25zdCB3aWR0aCA9IGVudHJ5LmNvbnRlbnRSZWN0LndpZHRoO1xuICAgIGNvbnN0IGhlaWdodCA9IGVudHJ5LmNvbnRlbnRSZWN0LmhlaWdodDtcbiAgICAvLyBXaGVuIGl0cyBjb250YWluZXIncyBkaXNwbGF5IGlzIHNldCB0byAnbm9uZScgdGhlIGNhbGxiYWNrIHdpbGwgYmUgY2FsbGVkIHdpdGggYVxuICAgIC8vIHNpemUgb2YgKDAsIDApLCB3aGljaCB3aWxsIGNhdXNlIHRoZSBjaGFydCB0byBsb3NlIGl0cyBvcmlnaW5hbCBoZWlnaHQsIHNvIHNraXBcbiAgICAvLyByZXNpemluZyBpbiBzdWNoIGNhc2UuXG4gICAgaWYgKHdpZHRoID09PSAwICYmIGhlaWdodCA9PT0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICByZXNpemUod2lkdGgsIGhlaWdodCk7XG4gIH0pO1xuICBvYnNlcnZlci5vYnNlcnZlKGNvbnRhaW5lcik7XG4gIGxpc3RlbkRldmljZVBpeGVsUmF0aW9DaGFuZ2VzKGNoYXJ0LCByZXNpemUpO1xuXG4gIHJldHVybiBvYnNlcnZlcjtcbn1cblxuZnVuY3Rpb24gcmVsZWFzZU9ic2VydmVyKGNoYXJ0LCB0eXBlLCBvYnNlcnZlcikge1xuICBpZiAob2JzZXJ2ZXIpIHtcbiAgICBvYnNlcnZlci5kaXNjb25uZWN0KCk7XG4gIH1cbiAgaWYgKHR5cGUgPT09ICdyZXNpemUnKSB7XG4gICAgdW5saXN0ZW5EZXZpY2VQaXhlbFJhdGlvQ2hhbmdlcyhjaGFydCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlUHJveHlBbmRMaXN0ZW4oY2hhcnQsIHR5cGUsIGxpc3RlbmVyKSB7XG4gIGNvbnN0IGNhbnZhcyA9IGNoYXJ0LmNhbnZhcztcbiAgY29uc3QgcHJveHkgPSB0aHJvdHRsZWQoKGV2ZW50KSA9PiB7XG4gICAgLy8gVGhpcyBjYXNlIGNhbiBvY2N1ciBpZiB0aGUgY2hhcnQgaXMgZGVzdHJveWVkIHdoaWxlIHdhaXRpbmdcbiAgICAvLyBmb3IgdGhlIHRocm90dGxlZCBmdW5jdGlvbiB0byBvY2N1ci4gV2UgcHJldmVudCBjcmFzaGVzIGJ5IGNoZWNraW5nXG4gICAgLy8gZm9yIGEgZGVzdHJveWVkIGNoYXJ0XG4gICAgaWYgKGNoYXJ0LmN0eCAhPT0gbnVsbCkge1xuICAgICAgbGlzdGVuZXIoZnJvbU5hdGl2ZUV2ZW50KGV2ZW50LCBjaGFydCkpO1xuICAgIH1cbiAgfSwgY2hhcnQpO1xuXG4gIGFkZExpc3RlbmVyKGNhbnZhcywgdHlwZSwgcHJveHkpO1xuXG4gIHJldHVybiBwcm94eTtcbn1cblxuLyoqXG4gKiBQbGF0Zm9ybSBjbGFzcyBmb3IgY2hhcnRzIHRoYXQgY2FuIGFjY2VzcyB0aGUgRE9NIGFuZCBnbG9iYWwgd2luZG93L2RvY3VtZW50IHByb3BlcnRpZXNcbiAqIEBleHRlbmRzIEJhc2VQbGF0Zm9ybVxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBEb21QbGF0Zm9ybSBleHRlbmRzIEJhc2VQbGF0Zm9ybSB7XG5cbiAgLyoqXG5cdCAqIEBwYXJhbSB7SFRNTENhbnZhc0VsZW1lbnR9IGNhbnZhc1xuXHQgKiBAcGFyYW0ge251bWJlcn0gW2FzcGVjdFJhdGlvXVxuXHQgKiBAcmV0dXJuIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR8bnVsbH1cblx0ICovXG4gIGFjcXVpcmVDb250ZXh0KGNhbnZhcywgYXNwZWN0UmF0aW8pIHtcbiAgICAvLyBUbyBwcmV2ZW50IGNhbnZhcyBmaW5nZXJwcmludGluZywgc29tZSBhZGQtb25zIHVuZGVmaW5lIHRoZSBnZXRDb250ZXh0XG4gICAgLy8gbWV0aG9kLCBmb3IgZXhhbXBsZTogaHR0cHM6Ly9naXRodWIuY29tL2trYXBzbmVyL0NhbnZhc0Jsb2NrZXJcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vY2hhcnRqcy9DaGFydC5qcy9pc3N1ZXMvMjgwN1xuICAgIGNvbnN0IGNvbnRleHQgPSBjYW52YXMgJiYgY2FudmFzLmdldENvbnRleHQgJiYgY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG5cbiAgICAvLyBgaW5zdGFuY2VvZiBIVE1MQ2FudmFzRWxlbWVudC9DYW52YXNSZW5kZXJpbmdDb250ZXh0MkRgIGZhaWxzIHdoZW4gdGhlIGNhbnZhcyBpc1xuICAgIC8vIGluc2lkZSBhbiBpZnJhbWUgb3Igd2hlbiBydW5uaW5nIGluIGEgcHJvdGVjdGVkIGVudmlyb25tZW50LiBXZSBjb3VsZCBndWVzcyB0aGVcbiAgICAvLyB0eXBlcyBmcm9tIHRoZWlyIHRvU3RyaW5nKCkgdmFsdWUgYnV0IGxldCdzIGtlZXAgdGhpbmdzIGZsZXhpYmxlIGFuZCBhc3N1bWUgaXQnc1xuICAgIC8vIGEgc3VmZmljaWVudCBjb25kaXRpb24gaWYgdGhlIGNhbnZhcyBoYXMgYSBjb250ZXh0MkQgd2hpY2ggaGFzIGNhbnZhcyBhcyBgY2FudmFzYC5cbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vY2hhcnRqcy9DaGFydC5qcy9pc3N1ZXMvMzg4N1xuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9jaGFydGpzL0NoYXJ0LmpzL2lzc3Vlcy80MTAyXG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2NoYXJ0anMvQ2hhcnQuanMvaXNzdWVzLzQxNTJcbiAgICBpZiAoY29udGV4dCAmJiBjb250ZXh0LmNhbnZhcyA9PT0gY2FudmFzKSB7XG4gICAgICAvLyBMb2FkIHBsYXRmb3JtIHJlc291cmNlcyBvbiBmaXJzdCBjaGFydCBjcmVhdGlvbiwgdG8gbWFrZSBpdCBwb3NzaWJsZSB0b1xuICAgICAgLy8gaW1wb3J0IHRoZSBsaWJyYXJ5IGJlZm9yZSBzZXR0aW5nIHBsYXRmb3JtIG9wdGlvbnMuXG4gICAgICBpbml0Q2FudmFzKGNhbnZhcywgYXNwZWN0UmF0aW8pO1xuICAgICAgcmV0dXJuIGNvbnRleHQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvKipcblx0ICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGNvbnRleHRcblx0ICovXG4gIHJlbGVhc2VDb250ZXh0KGNvbnRleHQpIHtcbiAgICBjb25zdCBjYW52YXMgPSBjb250ZXh0LmNhbnZhcztcbiAgICBpZiAoIWNhbnZhc1tFWFBBTkRPX0tFWV0pIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBjb25zdCBpbml0aWFsID0gY2FudmFzW0VYUEFORE9fS0VZXS5pbml0aWFsO1xuICAgIFsnaGVpZ2h0JywgJ3dpZHRoJ10uZm9yRWFjaCgocHJvcCkgPT4ge1xuICAgICAgY29uc3QgdmFsdWUgPSBpbml0aWFsW3Byb3BdO1xuICAgICAgaWYgKGlzTnVsbE9yVW5kZWYodmFsdWUpKSB7XG4gICAgICAgIGNhbnZhcy5yZW1vdmVBdHRyaWJ1dGUocHJvcCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjYW52YXMuc2V0QXR0cmlidXRlKHByb3AsIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGNvbnN0IHN0eWxlID0gaW5pdGlhbC5zdHlsZSB8fCB7fTtcbiAgICBPYmplY3Qua2V5cyhzdHlsZSkuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICBjYW52YXMuc3R5bGVba2V5XSA9IHN0eWxlW2tleV07XG4gICAgfSk7XG5cbiAgICAvLyBUaGUgY2FudmFzIHJlbmRlciBzaXplIG1pZ2h0IGhhdmUgYmVlbiBjaGFuZ2VkIChhbmQgdGh1cyB0aGUgc3RhdGUgc3RhY2sgZGlzY2FyZGVkKSxcbiAgICAvLyB3ZSBjYW4ndCB1c2Ugc2F2ZSgpIGFuZCByZXN0b3JlKCkgdG8gcmVzdG9yZSB0aGUgaW5pdGlhbCBzdGF0ZS4gU28gbWFrZSBzdXJlIHRoYXQgYXRcbiAgICAvLyBsZWFzdCB0aGUgY2FudmFzIGNvbnRleHQgaXMgcmVzZXQgdG8gdGhlIGRlZmF1bHQgc3RhdGUgYnkgc2V0dGluZyB0aGUgY2FudmFzIHdpZHRoLlxuICAgIC8vIGh0dHBzOi8vd3d3LnczLm9yZy9UUi8yMDExL1dELWh0bWw1LTIwMTEwNTI1L3RoZS1jYW52YXMtZWxlbWVudC5odG1sXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNlbGYtYXNzaWduXG4gICAgY2FudmFzLndpZHRoID0gY2FudmFzLndpZHRoO1xuXG4gICAgZGVsZXRlIGNhbnZhc1tFWFBBTkRPX0tFWV07XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvKipcblx0ICpcblx0ICogQHBhcmFtIHtDaGFydH0gY2hhcnRcblx0ICogQHBhcmFtIHtzdHJpbmd9IHR5cGVcblx0ICogQHBhcmFtIHtmdW5jdGlvbn0gbGlzdGVuZXJcblx0ICovXG4gIGFkZEV2ZW50TGlzdGVuZXIoY2hhcnQsIHR5cGUsIGxpc3RlbmVyKSB7XG4gICAgLy8gQ2FuIGhhdmUgb25seSBvbmUgbGlzdGVuZXIgcGVyIHR5cGUsIHNvIG1ha2Ugc3VyZSBwcmV2aW91cyBpcyByZW1vdmVkXG4gICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKGNoYXJ0LCB0eXBlKTtcblxuICAgIGNvbnN0IHByb3hpZXMgPSBjaGFydC4kcHJveGllcyB8fCAoY2hhcnQuJHByb3hpZXMgPSB7fSk7XG4gICAgY29uc3QgaGFuZGxlcnMgPSB7XG4gICAgICBhdHRhY2g6IGNyZWF0ZUF0dGFjaE9ic2VydmVyLFxuICAgICAgZGV0YWNoOiBjcmVhdGVEZXRhY2hPYnNlcnZlcixcbiAgICAgIHJlc2l6ZTogY3JlYXRlUmVzaXplT2JzZXJ2ZXJcbiAgICB9O1xuICAgIGNvbnN0IGhhbmRsZXIgPSBoYW5kbGVyc1t0eXBlXSB8fCBjcmVhdGVQcm94eUFuZExpc3RlbjtcbiAgICBwcm94aWVzW3R5cGVdID0gaGFuZGxlcihjaGFydCwgdHlwZSwgbGlzdGVuZXIpO1xuICB9XG5cblxuICAvKipcblx0ICogQHBhcmFtIHtDaGFydH0gY2hhcnRcblx0ICogQHBhcmFtIHtzdHJpbmd9IHR5cGVcblx0ICovXG4gIHJlbW92ZUV2ZW50TGlzdGVuZXIoY2hhcnQsIHR5cGUpIHtcbiAgICBjb25zdCBwcm94aWVzID0gY2hhcnQuJHByb3hpZXMgfHwgKGNoYXJ0LiRwcm94aWVzID0ge30pO1xuICAgIGNvbnN0IHByb3h5ID0gcHJveGllc1t0eXBlXTtcblxuICAgIGlmICghcHJveHkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBoYW5kbGVycyA9IHtcbiAgICAgIGF0dGFjaDogcmVsZWFzZU9ic2VydmVyLFxuICAgICAgZGV0YWNoOiByZWxlYXNlT2JzZXJ2ZXIsXG4gICAgICByZXNpemU6IHJlbGVhc2VPYnNlcnZlclxuICAgIH07XG4gICAgY29uc3QgaGFuZGxlciA9IGhhbmRsZXJzW3R5cGVdIHx8IHJlbW92ZUxpc3RlbmVyO1xuICAgIGhhbmRsZXIoY2hhcnQsIHR5cGUsIHByb3h5KTtcbiAgICBwcm94aWVzW3R5cGVdID0gdW5kZWZpbmVkO1xuICB9XG5cbiAgZ2V0RGV2aWNlUGl4ZWxSYXRpbygpIHtcbiAgICByZXR1cm4gd2luZG93LmRldmljZVBpeGVsUmF0aW87XG4gIH1cblxuICAvKipcblx0ICogQHBhcmFtIHtIVE1MQ2FudmFzRWxlbWVudH0gY2FudmFzXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBbd2lkdGhdIC0gY29udGVudCB3aWR0aCBvZiBwYXJlbnQgZWxlbWVudFxuXHQgKiBAcGFyYW0ge251bWJlcn0gW2hlaWdodF0gLSBjb250ZW50IGhlaWdodCBvZiBwYXJlbnQgZWxlbWVudFxuXHQgKiBAcGFyYW0ge251bWJlcn0gW2FzcGVjdFJhdGlvXSAtIGFzcGVjdCByYXRpbyB0byBtYWludGFpblxuXHQgKi9cbiAgZ2V0TWF4aW11bVNpemUoY2FudmFzLCB3aWR0aCwgaGVpZ2h0LCBhc3BlY3RSYXRpbykge1xuICAgIHJldHVybiBnZXRNYXhpbXVtU2l6ZShjYW52YXMsIHdpZHRoLCBoZWlnaHQsIGFzcGVjdFJhdGlvKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcGFyYW0ge0hUTUxDYW52YXNFbGVtZW50fSBjYW52YXNcblx0ICovXG4gIGlzQXR0YWNoZWQoY2FudmFzKSB7XG4gICAgY29uc3QgY29udGFpbmVyID0gY2FudmFzICYmIF9nZXRQYXJlbnROb2RlKGNhbnZhcyk7XG4gICAgcmV0dXJuICEhKGNvbnRhaW5lciAmJiBjb250YWluZXIuaXNDb25uZWN0ZWQpO1xuICB9XG59XG4iLCAiaW1wb3J0IHtfaXNEb21TdXBwb3J0ZWR9IGZyb20gJy4uL2hlbHBlcnMvaW5kZXguanMnO1xuaW1wb3J0IEJhc2VQbGF0Zm9ybSBmcm9tICcuL3BsYXRmb3JtLmJhc2UuanMnO1xuaW1wb3J0IEJhc2ljUGxhdGZvcm0gZnJvbSAnLi9wbGF0Zm9ybS5iYXNpYy5qcyc7XG5pbXBvcnQgRG9tUGxhdGZvcm0gZnJvbSAnLi9wbGF0Zm9ybS5kb20uanMnO1xuXG5leHBvcnQgZnVuY3Rpb24gX2RldGVjdFBsYXRmb3JtKGNhbnZhcykge1xuICBpZiAoIV9pc0RvbVN1cHBvcnRlZCgpIHx8ICh0eXBlb2YgT2Zmc2NyZWVuQ2FudmFzICE9PSAndW5kZWZpbmVkJyAmJiBjYW52YXMgaW5zdGFuY2VvZiBPZmZzY3JlZW5DYW52YXMpKSB7XG4gICAgcmV0dXJuIEJhc2ljUGxhdGZvcm07XG4gIH1cbiAgcmV0dXJuIERvbVBsYXRmb3JtO1xufVxuXG5leHBvcnQge0Jhc2VQbGF0Zm9ybSwgQmFzaWNQbGF0Zm9ybSwgRG9tUGxhdGZvcm19O1xuIiwgImltcG9ydCB0eXBlIHtBbnlPYmplY3R9IGZyb20gJy4uL3R5cGVzL2Jhc2ljLmpzJztcbmltcG9ydCB0eXBlIHtQb2ludH0gZnJvbSAnLi4vdHlwZXMvZ2VvbWV0cmljLmpzJztcbmltcG9ydCB0eXBlIHtBbmltYXRpb259IGZyb20gJy4uL3R5cGVzL2FuaW1hdGlvbi5qcyc7XG5pbXBvcnQge2lzTnVtYmVyfSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMubWF0aC5qcyc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEVsZW1lbnQ8VCA9IEFueU9iamVjdCwgTyA9IEFueU9iamVjdD4ge1xuXG4gIHN0YXRpYyBkZWZhdWx0cyA9IHt9O1xuICBzdGF0aWMgZGVmYXVsdFJvdXRlcyA9IHVuZGVmaW5lZDtcblxuICB4OiBudW1iZXI7XG4gIHk6IG51bWJlcjtcbiAgYWN0aXZlID0gZmFsc2U7XG4gIG9wdGlvbnM6IE87XG4gICRhbmltYXRpb25zOiBSZWNvcmQ8a2V5b2YgVCwgQW5pbWF0aW9uPjtcblxuICB0b29sdGlwUG9zaXRpb24odXNlRmluYWxQb3NpdGlvbjogYm9vbGVhbik6IFBvaW50IHtcbiAgICBjb25zdCB7eCwgeX0gPSB0aGlzLmdldFByb3BzKFsneCcsICd5J10sIHVzZUZpbmFsUG9zaXRpb24pO1xuICAgIHJldHVybiB7eCwgeX0gYXMgUG9pbnQ7XG4gIH1cblxuICBoYXNWYWx1ZSgpIHtcbiAgICByZXR1cm4gaXNOdW1iZXIodGhpcy54KSAmJiBpc051bWJlcih0aGlzLnkpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIGN1cnJlbnQgb3IgZmluYWwgdmFsdWUgb2YgZWFjaCBwcm9wLiBDYW4gcmV0dXJuIGV4dHJhIHByb3BlcnRpZXMgKHdob2xlIG9iamVjdCkuXG4gICAqIEBwYXJhbSBwcm9wcyAtIHByb3BlcnRpZXMgdG8gZ2V0XG4gICAqIEBwYXJhbSBbZmluYWxdIC0gZ2V0IHRoZSBmaW5hbCB2YWx1ZSAoYW5pbWF0aW9uIHRhcmdldClcbiAgICovXG4gIGdldFByb3BzPFAgZXh0ZW5kcyAoa2V5b2YgVClbXT4ocHJvcHM6IFAsIGZpbmFsPzogYm9vbGVhbik6IFBpY2s8VCwgUFtudW1iZXJdPjtcbiAgZ2V0UHJvcHM8UCBleHRlbmRzIHN0cmluZz4ocHJvcHM6IFBbXSwgZmluYWw/OiBib29sZWFuKTogUGFydGlhbDxSZWNvcmQ8UCwgdW5rbm93bj4+O1xuICBnZXRQcm9wcyhwcm9wczogc3RyaW5nW10sIGZpbmFsPzogYm9vbGVhbik6IFBhcnRpYWw8UmVjb3JkPHN0cmluZywgdW5rbm93bj4+IHtcbiAgICBjb25zdCBhbmltcyA9IHRoaXMuJGFuaW1hdGlvbnM7XG4gICAgaWYgKCFmaW5hbCB8fCAhYW5pbXMpIHtcbiAgICAgIC8vIGxldCdzIG5vdCBjcmVhdGUgYW4gb2JqZWN0LCBpZiBub3QgbmVlZGVkXG4gICAgICByZXR1cm4gdGhpcyBhcyBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPjtcbiAgICB9XG4gICAgY29uc3QgcmV0OiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPiA9IHt9O1xuICAgIHByb3BzLmZvckVhY2goKHByb3ApID0+IHtcbiAgICAgIHJldFtwcm9wXSA9IGFuaW1zW3Byb3BdICYmIGFuaW1zW3Byb3BdLmFjdGl2ZSgpID8gYW5pbXNbcHJvcF0uX3RvIDogdGhpc1twcm9wIGFzIHN0cmluZ107XG4gICAgfSk7XG4gICAgcmV0dXJuIHJldDtcbiAgfVxufVxuIiwgImltcG9ydCB7aXNOdWxsT3JVbmRlZiwgdmFsdWVPckRlZmF1bHR9IGZyb20gJy4uL2hlbHBlcnMvaGVscGVycy5jb3JlLmpzJztcbmltcG9ydCB7X2ZhY3Rvcml6ZX0gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLm1hdGguanMnO1xuXG5cbi8qKlxuICogQHR5cGVkZWYgeyBpbXBvcnQoJy4vY29yZS5jb250cm9sbGVyLmpzJykuZGVmYXVsdCB9IENoYXJ0XG4gKiBAdHlwZWRlZiB7e3ZhbHVlOm51bWJlciB8IHN0cmluZywgbGFiZWw/OnN0cmluZywgbWFqb3I/OmJvb2xlYW4sICRjb250ZXh0Pzphbnl9fSBUaWNrXG4gKi9cblxuLyoqXG4gKiBSZXR1cm5zIGEgc3Vic2V0IG9mIHRpY2tzIHRvIGJlIHBsb3R0ZWQgdG8gYXZvaWQgb3ZlcmxhcHBpbmcgbGFiZWxzLlxuICogQHBhcmFtIHtpbXBvcnQoJy4vY29yZS5zY2FsZS5qcycpLmRlZmF1bHR9IHNjYWxlXG4gKiBAcGFyYW0ge1RpY2tbXX0gdGlja3NcbiAqIEByZXR1cm4ge1RpY2tbXX1cbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhdXRvU2tpcChzY2FsZSwgdGlja3MpIHtcbiAgY29uc3QgdGlja09wdHMgPSBzY2FsZS5vcHRpb25zLnRpY2tzO1xuICBjb25zdCBkZXRlcm1pbmVkTWF4VGlja3MgPSBkZXRlcm1pbmVNYXhUaWNrcyhzY2FsZSk7XG4gIGNvbnN0IHRpY2tzTGltaXQgPSBNYXRoLm1pbih0aWNrT3B0cy5tYXhUaWNrc0xpbWl0IHx8IGRldGVybWluZWRNYXhUaWNrcywgZGV0ZXJtaW5lZE1heFRpY2tzKTtcbiAgY29uc3QgbWFqb3JJbmRpY2VzID0gdGlja09wdHMubWFqb3IuZW5hYmxlZCA/IGdldE1ham9ySW5kaWNlcyh0aWNrcykgOiBbXTtcbiAgY29uc3QgbnVtTWFqb3JJbmRpY2VzID0gbWFqb3JJbmRpY2VzLmxlbmd0aDtcbiAgY29uc3QgZmlyc3QgPSBtYWpvckluZGljZXNbMF07XG4gIGNvbnN0IGxhc3QgPSBtYWpvckluZGljZXNbbnVtTWFqb3JJbmRpY2VzIC0gMV07XG4gIGNvbnN0IG5ld1RpY2tzID0gW107XG5cbiAgLy8gSWYgdGhlcmUgYXJlIHRvbyBtYW55IG1ham9yIHRpY2tzIHRvIGRpc3BsYXkgdGhlbSBhbGxcbiAgaWYgKG51bU1ham9ySW5kaWNlcyA+IHRpY2tzTGltaXQpIHtcbiAgICBza2lwTWFqb3JzKHRpY2tzLCBuZXdUaWNrcywgbWFqb3JJbmRpY2VzLCBudW1NYWpvckluZGljZXMgLyB0aWNrc0xpbWl0KTtcbiAgICByZXR1cm4gbmV3VGlja3M7XG4gIH1cblxuICBjb25zdCBzcGFjaW5nID0gY2FsY3VsYXRlU3BhY2luZyhtYWpvckluZGljZXMsIHRpY2tzLCB0aWNrc0xpbWl0KTtcblxuICBpZiAobnVtTWFqb3JJbmRpY2VzID4gMCkge1xuICAgIGxldCBpLCBpbGVuO1xuICAgIGNvbnN0IGF2Z01ham9yU3BhY2luZyA9IG51bU1ham9ySW5kaWNlcyA+IDEgPyBNYXRoLnJvdW5kKChsYXN0IC0gZmlyc3QpIC8gKG51bU1ham9ySW5kaWNlcyAtIDEpKSA6IG51bGw7XG4gICAgc2tpcCh0aWNrcywgbmV3VGlja3MsIHNwYWNpbmcsIGlzTnVsbE9yVW5kZWYoYXZnTWFqb3JTcGFjaW5nKSA/IDAgOiBmaXJzdCAtIGF2Z01ham9yU3BhY2luZywgZmlyc3QpO1xuICAgIGZvciAoaSA9IDAsIGlsZW4gPSBudW1NYWpvckluZGljZXMgLSAxOyBpIDwgaWxlbjsgaSsrKSB7XG4gICAgICBza2lwKHRpY2tzLCBuZXdUaWNrcywgc3BhY2luZywgbWFqb3JJbmRpY2VzW2ldLCBtYWpvckluZGljZXNbaSArIDFdKTtcbiAgICB9XG4gICAgc2tpcCh0aWNrcywgbmV3VGlja3MsIHNwYWNpbmcsIGxhc3QsIGlzTnVsbE9yVW5kZWYoYXZnTWFqb3JTcGFjaW5nKSA/IHRpY2tzLmxlbmd0aCA6IGxhc3QgKyBhdmdNYWpvclNwYWNpbmcpO1xuICAgIHJldHVybiBuZXdUaWNrcztcbiAgfVxuICBza2lwKHRpY2tzLCBuZXdUaWNrcywgc3BhY2luZyk7XG4gIHJldHVybiBuZXdUaWNrcztcbn1cblxuZnVuY3Rpb24gZGV0ZXJtaW5lTWF4VGlja3Moc2NhbGUpIHtcbiAgY29uc3Qgb2Zmc2V0ID0gc2NhbGUub3B0aW9ucy5vZmZzZXQ7XG4gIGNvbnN0IHRpY2tMZW5ndGggPSBzY2FsZS5fdGlja1NpemUoKTtcbiAgY29uc3QgbWF4U2NhbGUgPSBzY2FsZS5fbGVuZ3RoIC8gdGlja0xlbmd0aCArIChvZmZzZXQgPyAwIDogMSk7XG4gIGNvbnN0IG1heENoYXJ0ID0gc2NhbGUuX21heExlbmd0aCAvIHRpY2tMZW5ndGg7XG4gIHJldHVybiBNYXRoLmZsb29yKE1hdGgubWluKG1heFNjYWxlLCBtYXhDaGFydCkpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyW119IG1ham9ySW5kaWNlc1xuICogQHBhcmFtIHtUaWNrW119IHRpY2tzXG4gKiBAcGFyYW0ge251bWJlcn0gdGlja3NMaW1pdFxuICovXG5mdW5jdGlvbiBjYWxjdWxhdGVTcGFjaW5nKG1ham9ySW5kaWNlcywgdGlja3MsIHRpY2tzTGltaXQpIHtcbiAgY29uc3QgZXZlbk1ham9yU3BhY2luZyA9IGdldEV2ZW5TcGFjaW5nKG1ham9ySW5kaWNlcyk7XG4gIGNvbnN0IHNwYWNpbmcgPSB0aWNrcy5sZW5ndGggLyB0aWNrc0xpbWl0O1xuXG4gIC8vIElmIHRoZSBtYWpvciB0aWNrcyBhcmUgZXZlbmx5IHNwYWNlZCBhcGFydCwgcGxhY2UgdGhlIG1pbm9yIHRpY2tzXG4gIC8vIHNvIHRoYXQgdGhleSBkaXZpZGUgdGhlIG1ham9yIHRpY2tzIGludG8gZXZlbiBjaHVua3NcbiAgaWYgKCFldmVuTWFqb3JTcGFjaW5nKSB7XG4gICAgcmV0dXJuIE1hdGgubWF4KHNwYWNpbmcsIDEpO1xuICB9XG5cbiAgY29uc3QgZmFjdG9ycyA9IF9mYWN0b3JpemUoZXZlbk1ham9yU3BhY2luZyk7XG4gIGZvciAobGV0IGkgPSAwLCBpbGVuID0gZmFjdG9ycy5sZW5ndGggLSAxOyBpIDwgaWxlbjsgaSsrKSB7XG4gICAgY29uc3QgZmFjdG9yID0gZmFjdG9yc1tpXTtcbiAgICBpZiAoZmFjdG9yID4gc3BhY2luZykge1xuICAgICAgcmV0dXJuIGZhY3RvcjtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIE1hdGgubWF4KHNwYWNpbmcsIDEpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7VGlja1tdfSB0aWNrc1xuICovXG5mdW5jdGlvbiBnZXRNYWpvckluZGljZXModGlja3MpIHtcbiAgY29uc3QgcmVzdWx0ID0gW107XG4gIGxldCBpLCBpbGVuO1xuICBmb3IgKGkgPSAwLCBpbGVuID0gdGlja3MubGVuZ3RoOyBpIDwgaWxlbjsgaSsrKSB7XG4gICAgaWYgKHRpY2tzW2ldLm1ham9yKSB7XG4gICAgICByZXN1bHQucHVzaChpKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge1RpY2tbXX0gdGlja3NcbiAqIEBwYXJhbSB7VGlja1tdfSBuZXdUaWNrc1xuICogQHBhcmFtIHtudW1iZXJbXX0gbWFqb3JJbmRpY2VzXG4gKiBAcGFyYW0ge251bWJlcn0gc3BhY2luZ1xuICovXG5mdW5jdGlvbiBza2lwTWFqb3JzKHRpY2tzLCBuZXdUaWNrcywgbWFqb3JJbmRpY2VzLCBzcGFjaW5nKSB7XG4gIGxldCBjb3VudCA9IDA7XG4gIGxldCBuZXh0ID0gbWFqb3JJbmRpY2VzWzBdO1xuICBsZXQgaTtcblxuICBzcGFjaW5nID0gTWF0aC5jZWlsKHNwYWNpbmcpO1xuICBmb3IgKGkgPSAwOyBpIDwgdGlja3MubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoaSA9PT0gbmV4dCkge1xuICAgICAgbmV3VGlja3MucHVzaCh0aWNrc1tpXSk7XG4gICAgICBjb3VudCsrO1xuICAgICAgbmV4dCA9IG1ham9ySW5kaWNlc1tjb3VudCAqIHNwYWNpbmddO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7VGlja1tdfSB0aWNrc1xuICogQHBhcmFtIHtUaWNrW119IG5ld1RpY2tzXG4gKiBAcGFyYW0ge251bWJlcn0gc3BhY2luZ1xuICogQHBhcmFtIHtudW1iZXJ9IFttYWpvclN0YXJ0XVxuICogQHBhcmFtIHtudW1iZXJ9IFttYWpvckVuZF1cbiAqL1xuZnVuY3Rpb24gc2tpcCh0aWNrcywgbmV3VGlja3MsIHNwYWNpbmcsIG1ham9yU3RhcnQsIG1ham9yRW5kKSB7XG4gIGNvbnN0IHN0YXJ0ID0gdmFsdWVPckRlZmF1bHQobWFqb3JTdGFydCwgMCk7XG4gIGNvbnN0IGVuZCA9IE1hdGgubWluKHZhbHVlT3JEZWZhdWx0KG1ham9yRW5kLCB0aWNrcy5sZW5ndGgpLCB0aWNrcy5sZW5ndGgpO1xuICBsZXQgY291bnQgPSAwO1xuICBsZXQgbGVuZ3RoLCBpLCBuZXh0O1xuXG4gIHNwYWNpbmcgPSBNYXRoLmNlaWwoc3BhY2luZyk7XG4gIGlmIChtYWpvckVuZCkge1xuICAgIGxlbmd0aCA9IG1ham9yRW5kIC0gbWFqb3JTdGFydDtcbiAgICBzcGFjaW5nID0gbGVuZ3RoIC8gTWF0aC5mbG9vcihsZW5ndGggLyBzcGFjaW5nKTtcbiAgfVxuXG4gIG5leHQgPSBzdGFydDtcblxuICB3aGlsZSAobmV4dCA8IDApIHtcbiAgICBjb3VudCsrO1xuICAgIG5leHQgPSBNYXRoLnJvdW5kKHN0YXJ0ICsgY291bnQgKiBzcGFjaW5nKTtcbiAgfVxuXG4gIGZvciAoaSA9IE1hdGgubWF4KHN0YXJ0LCAwKTsgaSA8IGVuZDsgaSsrKSB7XG4gICAgaWYgKGkgPT09IG5leHQpIHtcbiAgICAgIG5ld1RpY2tzLnB1c2godGlja3NbaV0pO1xuICAgICAgY291bnQrKztcbiAgICAgIG5leHQgPSBNYXRoLnJvdW5kKHN0YXJ0ICsgY291bnQgKiBzcGFjaW5nKTtcbiAgICB9XG4gIH1cbn1cblxuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyW119IGFyclxuICovXG5mdW5jdGlvbiBnZXRFdmVuU3BhY2luZyhhcnIpIHtcbiAgY29uc3QgbGVuID0gYXJyLmxlbmd0aDtcbiAgbGV0IGksIGRpZmY7XG5cbiAgaWYgKGxlbiA8IDIpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBmb3IgKGRpZmYgPSBhcnJbMF0sIGkgPSAxOyBpIDwgbGVuOyArK2kpIHtcbiAgICBpZiAoYXJyW2ldIC0gYXJyW2kgLSAxXSAhPT0gZGlmZikge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZGlmZjtcbn1cbiIsICJpbXBvcnQgRWxlbWVudCBmcm9tICcuL2NvcmUuZWxlbWVudC5qcyc7XG5pbXBvcnQge19hbGlnblBpeGVsLCBfbWVhc3VyZVRleHQsIHJlbmRlclRleHQsIGNsaXBBcmVhLCB1bmNsaXBBcmVhfSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMuY2FudmFzLmpzJztcbmltcG9ydCB7Y2FsbGJhY2sgYXMgY2FsbCwgZWFjaCwgZmluaXRlT3JEZWZhdWx0LCBpc0FycmF5LCBpc0Zpbml0ZSwgaXNOdWxsT3JVbmRlZiwgaXNPYmplY3QsIHZhbHVlT3JEZWZhdWx0fSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMuY29yZS5qcyc7XG5pbXBvcnQge3RvRGVncmVlcywgdG9SYWRpYW5zLCBfaW50MTZSYW5nZSwgX2xpbWl0VmFsdWUsIEhBTEZfUEl9IGZyb20gJy4uL2hlbHBlcnMvaGVscGVycy5tYXRoLmpzJztcbmltcG9ydCB7X2FsaWduU3RhcnRFbmQsIF90b0xlZnRSaWdodENlbnRlcn0gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLmV4dHJhcy5qcyc7XG5pbXBvcnQge2NyZWF0ZUNvbnRleHQsIHRvRm9udCwgdG9QYWRkaW5nLCBfYWRkR3JhY2V9IGZyb20gJy4uL2hlbHBlcnMvaGVscGVycy5vcHRpb25zLmpzJztcbmltcG9ydCB7YXV0b1NraXB9IGZyb20gJy4vY29yZS5zY2FsZS5hdXRvc2tpcC5qcyc7XG5cbmNvbnN0IHJldmVyc2VBbGlnbiA9IChhbGlnbikgPT4gYWxpZ24gPT09ICdsZWZ0JyA/ICdyaWdodCcgOiBhbGlnbiA9PT0gJ3JpZ2h0JyA/ICdsZWZ0JyA6IGFsaWduO1xuY29uc3Qgb2Zmc2V0RnJvbUVkZ2UgPSAoc2NhbGUsIGVkZ2UsIG9mZnNldCkgPT4gZWRnZSA9PT0gJ3RvcCcgfHwgZWRnZSA9PT0gJ2xlZnQnID8gc2NhbGVbZWRnZV0gKyBvZmZzZXQgOiBzY2FsZVtlZGdlXSAtIG9mZnNldDtcbmNvbnN0IGdldFRpY2tzTGltaXQgPSAodGlja3NMZW5ndGgsIG1heFRpY2tzTGltaXQpID0+IE1hdGgubWluKG1heFRpY2tzTGltaXQgfHwgdGlja3NMZW5ndGgsIHRpY2tzTGVuZ3RoKTtcblxuLyoqXG4gKiBAdHlwZWRlZiB7IGltcG9ydCgnLi4vdHlwZXMvaW5kZXguanMnKS5DaGFydCB9IENoYXJ0XG4gKiBAdHlwZWRlZiB7e3ZhbHVlOm51bWJlciB8IHN0cmluZywgbGFiZWw/OnN0cmluZywgbWFqb3I/OmJvb2xlYW4sICRjb250ZXh0Pzphbnl9fSBUaWNrXG4gKi9cblxuLyoqXG4gKiBSZXR1cm5zIGEgbmV3IGFycmF5IGNvbnRhaW5pbmcgbnVtSXRlbXMgZnJvbSBhcnJcbiAqIEBwYXJhbSB7YW55W119IGFyclxuICogQHBhcmFtIHtudW1iZXJ9IG51bUl0ZW1zXG4gKi9cbmZ1bmN0aW9uIHNhbXBsZShhcnIsIG51bUl0ZW1zKSB7XG4gIGNvbnN0IHJlc3VsdCA9IFtdO1xuICBjb25zdCBpbmNyZW1lbnQgPSBhcnIubGVuZ3RoIC8gbnVtSXRlbXM7XG4gIGNvbnN0IGxlbiA9IGFyci5sZW5ndGg7XG4gIGxldCBpID0gMDtcblxuICBmb3IgKDsgaSA8IGxlbjsgaSArPSBpbmNyZW1lbnQpIHtcbiAgICByZXN1bHQucHVzaChhcnJbTWF0aC5mbG9vcihpKV0pO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogQHBhcmFtIHtTY2FsZX0gc2NhbGVcbiAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleFxuICogQHBhcmFtIHtib29sZWFufSBvZmZzZXRHcmlkTGluZXNcbiAqL1xuZnVuY3Rpb24gZ2V0UGl4ZWxGb3JHcmlkTGluZShzY2FsZSwgaW5kZXgsIG9mZnNldEdyaWRMaW5lcykge1xuICBjb25zdCBsZW5ndGggPSBzY2FsZS50aWNrcy5sZW5ndGg7XG4gIGNvbnN0IHZhbGlkSW5kZXggPSBNYXRoLm1pbihpbmRleCwgbGVuZ3RoIC0gMSk7XG4gIGNvbnN0IHN0YXJ0ID0gc2NhbGUuX3N0YXJ0UGl4ZWw7XG4gIGNvbnN0IGVuZCA9IHNjYWxlLl9lbmRQaXhlbDtcbiAgY29uc3QgZXBzaWxvbiA9IDFlLTY7IC8vIDFlLTYgaXMgbWFyZ2luIGluIHBpeGVscyBmb3IgYWNjdW11bGF0ZWQgZXJyb3IuXG4gIGxldCBsaW5lVmFsdWUgPSBzY2FsZS5nZXRQaXhlbEZvclRpY2sodmFsaWRJbmRleCk7XG4gIGxldCBvZmZzZXQ7XG5cbiAgaWYgKG9mZnNldEdyaWRMaW5lcykge1xuICAgIGlmIChsZW5ndGggPT09IDEpIHtcbiAgICAgIG9mZnNldCA9IE1hdGgubWF4KGxpbmVWYWx1ZSAtIHN0YXJ0LCBlbmQgLSBsaW5lVmFsdWUpO1xuICAgIH0gZWxzZSBpZiAoaW5kZXggPT09IDApIHtcbiAgICAgIG9mZnNldCA9IChzY2FsZS5nZXRQaXhlbEZvclRpY2soMSkgLSBsaW5lVmFsdWUpIC8gMjtcbiAgICB9IGVsc2Uge1xuICAgICAgb2Zmc2V0ID0gKGxpbmVWYWx1ZSAtIHNjYWxlLmdldFBpeGVsRm9yVGljayh2YWxpZEluZGV4IC0gMSkpIC8gMjtcbiAgICB9XG4gICAgbGluZVZhbHVlICs9IHZhbGlkSW5kZXggPCBpbmRleCA/IG9mZnNldCA6IC1vZmZzZXQ7XG5cbiAgICAvLyBSZXR1cm4gdW5kZWZpbmVkIGlmIHRoZSBwaXhlbCBpcyBvdXQgb2YgdGhlIHJhbmdlXG4gICAgaWYgKGxpbmVWYWx1ZSA8IHN0YXJ0IC0gZXBzaWxvbiB8fCBsaW5lVmFsdWUgPiBlbmQgKyBlcHNpbG9uKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9XG4gIHJldHVybiBsaW5lVmFsdWU7XG59XG5cbi8qKlxuICogQHBhcmFtIHtvYmplY3R9IGNhY2hlc1xuICogQHBhcmFtIHtudW1iZXJ9IGxlbmd0aFxuICovXG5mdW5jdGlvbiBnYXJiYWdlQ29sbGVjdChjYWNoZXMsIGxlbmd0aCkge1xuICBlYWNoKGNhY2hlcywgKGNhY2hlKSA9PiB7XG4gICAgY29uc3QgZ2MgPSBjYWNoZS5nYztcbiAgICBjb25zdCBnY0xlbiA9IGdjLmxlbmd0aCAvIDI7XG4gICAgbGV0IGk7XG4gICAgaWYgKGdjTGVuID4gbGVuZ3RoKSB7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgZ2NMZW47ICsraSkge1xuICAgICAgICBkZWxldGUgY2FjaGUuZGF0YVtnY1tpXV07XG4gICAgICB9XG4gICAgICBnYy5zcGxpY2UoMCwgZ2NMZW4pO1xuICAgIH1cbiAgfSk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnNcbiAqL1xuZnVuY3Rpb24gZ2V0VGlja01hcmtMZW5ndGgob3B0aW9ucykge1xuICByZXR1cm4gb3B0aW9ucy5kcmF3VGlja3MgPyBvcHRpb25zLnRpY2tMZW5ndGggOiAwO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zXG4gKi9cbmZ1bmN0aW9uIGdldFRpdGxlSGVpZ2h0KG9wdGlvbnMsIGZhbGxiYWNrKSB7XG4gIGlmICghb3B0aW9ucy5kaXNwbGF5KSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cblxuICBjb25zdCBmb250ID0gdG9Gb250KG9wdGlvbnMuZm9udCwgZmFsbGJhY2spO1xuICBjb25zdCBwYWRkaW5nID0gdG9QYWRkaW5nKG9wdGlvbnMucGFkZGluZyk7XG4gIGNvbnN0IGxpbmVzID0gaXNBcnJheShvcHRpb25zLnRleHQpID8gb3B0aW9ucy50ZXh0Lmxlbmd0aCA6IDE7XG5cbiAgcmV0dXJuIChsaW5lcyAqIGZvbnQubGluZUhlaWdodCkgKyBwYWRkaW5nLmhlaWdodDtcbn1cblxuZnVuY3Rpb24gY3JlYXRlU2NhbGVDb250ZXh0KHBhcmVudCwgc2NhbGUpIHtcbiAgcmV0dXJuIGNyZWF0ZUNvbnRleHQocGFyZW50LCB7XG4gICAgc2NhbGUsXG4gICAgdHlwZTogJ3NjYWxlJ1xuICB9KTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlVGlja0NvbnRleHQocGFyZW50LCBpbmRleCwgdGljaykge1xuICByZXR1cm4gY3JlYXRlQ29udGV4dChwYXJlbnQsIHtcbiAgICB0aWNrLFxuICAgIGluZGV4LFxuICAgIHR5cGU6ICd0aWNrJ1xuICB9KTtcbn1cblxuZnVuY3Rpb24gdGl0bGVBbGlnbihhbGlnbiwgcG9zaXRpb24sIHJldmVyc2UpIHtcbiAgLyoqIEB0eXBlIHtDYW52YXNUZXh0QWxpZ259ICovXG4gIGxldCByZXQgPSBfdG9MZWZ0UmlnaHRDZW50ZXIoYWxpZ24pO1xuICBpZiAoKHJldmVyc2UgJiYgcG9zaXRpb24gIT09ICdyaWdodCcpIHx8ICghcmV2ZXJzZSAmJiBwb3NpdGlvbiA9PT0gJ3JpZ2h0JykpIHtcbiAgICByZXQgPSByZXZlcnNlQWxpZ24ocmV0KTtcbiAgfVxuICByZXR1cm4gcmV0O1xufVxuXG5mdW5jdGlvbiB0aXRsZUFyZ3Moc2NhbGUsIG9mZnNldCwgcG9zaXRpb24sIGFsaWduKSB7XG4gIGNvbnN0IHt0b3AsIGxlZnQsIGJvdHRvbSwgcmlnaHQsIGNoYXJ0fSA9IHNjYWxlO1xuICBjb25zdCB7Y2hhcnRBcmVhLCBzY2FsZXN9ID0gY2hhcnQ7XG4gIGxldCByb3RhdGlvbiA9IDA7XG4gIGxldCBtYXhXaWR0aCwgdGl0bGVYLCB0aXRsZVk7XG4gIGNvbnN0IGhlaWdodCA9IGJvdHRvbSAtIHRvcDtcbiAgY29uc3Qgd2lkdGggPSByaWdodCAtIGxlZnQ7XG5cbiAgaWYgKHNjYWxlLmlzSG9yaXpvbnRhbCgpKSB7XG4gICAgdGl0bGVYID0gX2FsaWduU3RhcnRFbmQoYWxpZ24sIGxlZnQsIHJpZ2h0KTtcblxuICAgIGlmIChpc09iamVjdChwb3NpdGlvbikpIHtcbiAgICAgIGNvbnN0IHBvc2l0aW9uQXhpc0lEID0gT2JqZWN0LmtleXMocG9zaXRpb24pWzBdO1xuICAgICAgY29uc3QgdmFsdWUgPSBwb3NpdGlvbltwb3NpdGlvbkF4aXNJRF07XG4gICAgICB0aXRsZVkgPSBzY2FsZXNbcG9zaXRpb25BeGlzSURdLmdldFBpeGVsRm9yVmFsdWUodmFsdWUpICsgaGVpZ2h0IC0gb2Zmc2V0O1xuICAgIH0gZWxzZSBpZiAocG9zaXRpb24gPT09ICdjZW50ZXInKSB7XG4gICAgICB0aXRsZVkgPSAoY2hhcnRBcmVhLmJvdHRvbSArIGNoYXJ0QXJlYS50b3ApIC8gMiArIGhlaWdodCAtIG9mZnNldDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGl0bGVZID0gb2Zmc2V0RnJvbUVkZ2Uoc2NhbGUsIHBvc2l0aW9uLCBvZmZzZXQpO1xuICAgIH1cbiAgICBtYXhXaWR0aCA9IHJpZ2h0IC0gbGVmdDtcbiAgfSBlbHNlIHtcbiAgICBpZiAoaXNPYmplY3QocG9zaXRpb24pKSB7XG4gICAgICBjb25zdCBwb3NpdGlvbkF4aXNJRCA9IE9iamVjdC5rZXlzKHBvc2l0aW9uKVswXTtcbiAgICAgIGNvbnN0IHZhbHVlID0gcG9zaXRpb25bcG9zaXRpb25BeGlzSURdO1xuICAgICAgdGl0bGVYID0gc2NhbGVzW3Bvc2l0aW9uQXhpc0lEXS5nZXRQaXhlbEZvclZhbHVlKHZhbHVlKSAtIHdpZHRoICsgb2Zmc2V0O1xuICAgIH0gZWxzZSBpZiAocG9zaXRpb24gPT09ICdjZW50ZXInKSB7XG4gICAgICB0aXRsZVggPSAoY2hhcnRBcmVhLmxlZnQgKyBjaGFydEFyZWEucmlnaHQpIC8gMiAtIHdpZHRoICsgb2Zmc2V0O1xuICAgIH0gZWxzZSB7XG4gICAgICB0aXRsZVggPSBvZmZzZXRGcm9tRWRnZShzY2FsZSwgcG9zaXRpb24sIG9mZnNldCk7XG4gICAgfVxuICAgIHRpdGxlWSA9IF9hbGlnblN0YXJ0RW5kKGFsaWduLCBib3R0b20sIHRvcCk7XG4gICAgcm90YXRpb24gPSBwb3NpdGlvbiA9PT0gJ2xlZnQnID8gLUhBTEZfUEkgOiBIQUxGX1BJO1xuICB9XG4gIHJldHVybiB7dGl0bGVYLCB0aXRsZVksIG1heFdpZHRoLCByb3RhdGlvbn07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFNjYWxlIGV4dGVuZHMgRWxlbWVudCB7XG5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG1heC1zdGF0ZW1lbnRzXG4gIGNvbnN0cnVjdG9yKGNmZykge1xuICAgIHN1cGVyKCk7XG5cbiAgICAvKiogQHR5cGUge3N0cmluZ30gKi9cbiAgICB0aGlzLmlkID0gY2ZnLmlkO1xuICAgIC8qKiBAdHlwZSB7c3RyaW5nfSAqL1xuICAgIHRoaXMudHlwZSA9IGNmZy50eXBlO1xuICAgIC8qKiBAdHlwZSB7YW55fSAqL1xuICAgIHRoaXMub3B0aW9ucyA9IHVuZGVmaW5lZDtcbiAgICAvKiogQHR5cGUge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gKi9cbiAgICB0aGlzLmN0eCA9IGNmZy5jdHg7XG4gICAgLyoqIEB0eXBlIHtDaGFydH0gKi9cbiAgICB0aGlzLmNoYXJ0ID0gY2ZnLmNoYXJ0O1xuXG4gICAgLy8gaW1wbGVtZW50cyBib3hcbiAgICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgICB0aGlzLnRvcCA9IHVuZGVmaW5lZDtcbiAgICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgICB0aGlzLmJvdHRvbSA9IHVuZGVmaW5lZDtcbiAgICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgICB0aGlzLmxlZnQgPSB1bmRlZmluZWQ7XG4gICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgdGhpcy5yaWdodCA9IHVuZGVmaW5lZDtcbiAgICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgICB0aGlzLndpZHRoID0gdW5kZWZpbmVkO1xuICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgIHRoaXMuaGVpZ2h0ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX21hcmdpbnMgPSB7XG4gICAgICBsZWZ0OiAwLFxuICAgICAgcmlnaHQ6IDAsXG4gICAgICB0b3A6IDAsXG4gICAgICBib3R0b206IDBcbiAgICB9O1xuICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgIHRoaXMubWF4V2lkdGggPSB1bmRlZmluZWQ7XG4gICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgdGhpcy5tYXhIZWlnaHQgPSB1bmRlZmluZWQ7XG4gICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgdGhpcy5wYWRkaW5nVG9wID0gdW5kZWZpbmVkO1xuICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgIHRoaXMucGFkZGluZ0JvdHRvbSA9IHVuZGVmaW5lZDtcbiAgICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgICB0aGlzLnBhZGRpbmdMZWZ0ID0gdW5kZWZpbmVkO1xuICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgIHRoaXMucGFkZGluZ1JpZ2h0ID0gdW5kZWZpbmVkO1xuXG4gICAgLy8gc2NhbGUtc3BlY2lmaWMgcHJvcGVydGllc1xuICAgIC8qKiBAdHlwZSB7c3RyaW5nPX0gKi9cbiAgICB0aGlzLmF4aXMgPSB1bmRlZmluZWQ7XG4gICAgLyoqIEB0eXBlIHtudW1iZXI9fSAqL1xuICAgIHRoaXMubGFiZWxSb3RhdGlvbiA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLm1pbiA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLm1heCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9yYW5nZSA9IHVuZGVmaW5lZDtcbiAgICAvKiogQHR5cGUge1RpY2tbXX0gKi9cbiAgICB0aGlzLnRpY2tzID0gW107XG4gICAgLyoqIEB0eXBlIHtvYmplY3RbXXxudWxsfSAqL1xuICAgIHRoaXMuX2dyaWRMaW5lSXRlbXMgPSBudWxsO1xuICAgIC8qKiBAdHlwZSB7b2JqZWN0W118bnVsbH0gKi9cbiAgICB0aGlzLl9sYWJlbEl0ZW1zID0gbnVsbDtcbiAgICAvKiogQHR5cGUge29iamVjdHxudWxsfSAqL1xuICAgIHRoaXMuX2xhYmVsU2l6ZXMgPSBudWxsO1xuICAgIHRoaXMuX2xlbmd0aCA9IDA7XG4gICAgdGhpcy5fbWF4TGVuZ3RoID0gMDtcbiAgICB0aGlzLl9sb25nZXN0VGV4dENhY2hlID0ge307XG4gICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgdGhpcy5fc3RhcnRQaXhlbCA9IHVuZGVmaW5lZDtcbiAgICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgICB0aGlzLl9lbmRQaXhlbCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9yZXZlcnNlUGl4ZWxzID0gZmFsc2U7XG4gICAgdGhpcy5fdXNlck1heCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl91c2VyTWluID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX3N1Z2dlc3RlZE1heCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9zdWdnZXN0ZWRNaW4gPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fdGlja3NMZW5ndGggPSAwO1xuICAgIHRoaXMuX2JvcmRlclZhbHVlID0gMDtcbiAgICB0aGlzLl9jYWNoZSA9IHt9O1xuICAgIHRoaXMuX2RhdGFMaW1pdHNDYWNoZWQgPSBmYWxzZTtcbiAgICB0aGlzLiRjb250ZXh0ID0gdW5kZWZpbmVkO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwYXJhbSB7YW55fSBvcHRpb25zXG5cdCAqIEBzaW5jZSAzLjBcblx0ICovXG4gIGluaXQob3B0aW9ucykge1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnMuc2V0Q29udGV4dCh0aGlzLmdldENvbnRleHQoKSk7XG5cbiAgICB0aGlzLmF4aXMgPSBvcHRpb25zLmF4aXM7XG5cbiAgICAvLyBwYXJzZSBtaW4vbWF4IHZhbHVlLCBzbyB3ZSBjYW4gcHJvcGVybHkgZGV0ZXJtaW5lIG1pbi9tYXggZm9yIG90aGVyIHNjYWxlc1xuICAgIHRoaXMuX3VzZXJNaW4gPSB0aGlzLnBhcnNlKG9wdGlvbnMubWluKTtcbiAgICB0aGlzLl91c2VyTWF4ID0gdGhpcy5wYXJzZShvcHRpb25zLm1heCk7XG4gICAgdGhpcy5fc3VnZ2VzdGVkTWluID0gdGhpcy5wYXJzZShvcHRpb25zLnN1Z2dlc3RlZE1pbik7XG4gICAgdGhpcy5fc3VnZ2VzdGVkTWF4ID0gdGhpcy5wYXJzZShvcHRpb25zLnN1Z2dlc3RlZE1heCk7XG4gIH1cblxuICAvKipcblx0ICogUGFyc2UgYSBzdXBwb3J0ZWQgaW5wdXQgdmFsdWUgdG8gaW50ZXJuYWwgcmVwcmVzZW50YXRpb24uXG5cdCAqIEBwYXJhbSB7Kn0gcmF3XG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBbaW5kZXhdXG5cdCAqIEBzaW5jZSAzLjBcblx0ICovXG4gIHBhcnNlKHJhdywgaW5kZXgpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuICAgIHJldHVybiByYXc7XG4gIH1cblxuICAvKipcblx0ICogQHJldHVybiB7e21pbjogbnVtYmVyLCBtYXg6IG51bWJlciwgbWluRGVmaW5lZDogYm9vbGVhbiwgbWF4RGVmaW5lZDogYm9vbGVhbn19XG5cdCAqIEBwcm90ZWN0ZWRcblx0ICogQHNpbmNlIDMuMFxuXHQgKi9cbiAgZ2V0VXNlckJvdW5kcygpIHtcbiAgICBsZXQge191c2VyTWluLCBfdXNlck1heCwgX3N1Z2dlc3RlZE1pbiwgX3N1Z2dlc3RlZE1heH0gPSB0aGlzO1xuICAgIF91c2VyTWluID0gZmluaXRlT3JEZWZhdWx0KF91c2VyTWluLCBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFkpO1xuICAgIF91c2VyTWF4ID0gZmluaXRlT3JEZWZhdWx0KF91c2VyTWF4LCBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFkpO1xuICAgIF9zdWdnZXN0ZWRNaW4gPSBmaW5pdGVPckRlZmF1bHQoX3N1Z2dlc3RlZE1pbiwgTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZKTtcbiAgICBfc3VnZ2VzdGVkTWF4ID0gZmluaXRlT3JEZWZhdWx0KF9zdWdnZXN0ZWRNYXgsIE51bWJlci5ORUdBVElWRV9JTkZJTklUWSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIG1pbjogZmluaXRlT3JEZWZhdWx0KF91c2VyTWluLCBfc3VnZ2VzdGVkTWluKSxcbiAgICAgIG1heDogZmluaXRlT3JEZWZhdWx0KF91c2VyTWF4LCBfc3VnZ2VzdGVkTWF4KSxcbiAgICAgIG1pbkRlZmluZWQ6IGlzRmluaXRlKF91c2VyTWluKSxcbiAgICAgIG1heERlZmluZWQ6IGlzRmluaXRlKF91c2VyTWF4KVxuICAgIH07XG4gIH1cblxuICAvKipcblx0ICogQHBhcmFtIHtib29sZWFufSBjYW5TdGFja1xuXHQgKiBAcmV0dXJuIHt7bWluOiBudW1iZXIsIG1heDogbnVtYmVyfX1cblx0ICogQHByb3RlY3RlZFxuXHQgKiBAc2luY2UgMy4wXG5cdCAqL1xuICBnZXRNaW5NYXgoY2FuU3RhY2spIHtcbiAgICBsZXQge21pbiwgbWF4LCBtaW5EZWZpbmVkLCBtYXhEZWZpbmVkfSA9IHRoaXMuZ2V0VXNlckJvdW5kcygpO1xuICAgIGxldCByYW5nZTtcblxuICAgIGlmIChtaW5EZWZpbmVkICYmIG1heERlZmluZWQpIHtcbiAgICAgIHJldHVybiB7bWluLCBtYXh9O1xuICAgIH1cblxuICAgIGNvbnN0IG1ldGFzID0gdGhpcy5nZXRNYXRjaGluZ1Zpc2libGVNZXRhcygpO1xuICAgIGZvciAobGV0IGkgPSAwLCBpbGVuID0gbWV0YXMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgICByYW5nZSA9IG1ldGFzW2ldLmNvbnRyb2xsZXIuZ2V0TWluTWF4KHRoaXMsIGNhblN0YWNrKTtcbiAgICAgIGlmICghbWluRGVmaW5lZCkge1xuICAgICAgICBtaW4gPSBNYXRoLm1pbihtaW4sIHJhbmdlLm1pbik7XG4gICAgICB9XG4gICAgICBpZiAoIW1heERlZmluZWQpIHtcbiAgICAgICAgbWF4ID0gTWF0aC5tYXgobWF4LCByYW5nZS5tYXgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIE1ha2Ugc3VyZSBtaW4gPD0gbWF4IHdoZW4gb25seSBtaW4gb3IgbWF4IGlzIGRlZmluZWQgYnkgdXNlciBhbmQgdGhlIGRhdGEgaXMgb3V0c2lkZSB0aGF0IHJhbmdlXG4gICAgbWluID0gbWF4RGVmaW5lZCAmJiBtaW4gPiBtYXggPyBtYXggOiBtaW47XG4gICAgbWF4ID0gbWluRGVmaW5lZCAmJiBtaW4gPiBtYXggPyBtaW4gOiBtYXg7XG5cbiAgICByZXR1cm4ge1xuICAgICAgbWluOiBmaW5pdGVPckRlZmF1bHQobWluLCBmaW5pdGVPckRlZmF1bHQobWF4LCBtaW4pKSxcbiAgICAgIG1heDogZmluaXRlT3JEZWZhdWx0KG1heCwgZmluaXRlT3JEZWZhdWx0KG1pbiwgbWF4KSlcbiAgICB9O1xuICB9XG5cbiAgLyoqXG5cdCAqIEdldCB0aGUgcGFkZGluZyBuZWVkZWQgZm9yIHRoZSBzY2FsZVxuXHQgKiBAcmV0dXJuIHt7dG9wOiBudW1iZXIsIGxlZnQ6IG51bWJlciwgYm90dG9tOiBudW1iZXIsIHJpZ2h0OiBudW1iZXJ9fSB0aGUgbmVjZXNzYXJ5IHBhZGRpbmdcblx0ICogQHByaXZhdGVcblx0ICovXG4gIGdldFBhZGRpbmcoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGxlZnQ6IHRoaXMucGFkZGluZ0xlZnQgfHwgMCxcbiAgICAgIHRvcDogdGhpcy5wYWRkaW5nVG9wIHx8IDAsXG4gICAgICByaWdodDogdGhpcy5wYWRkaW5nUmlnaHQgfHwgMCxcbiAgICAgIGJvdHRvbTogdGhpcy5wYWRkaW5nQm90dG9tIHx8IDBcbiAgICB9O1xuICB9XG5cbiAgLyoqXG5cdCAqIFJldHVybnMgdGhlIHNjYWxlIHRpY2sgb2JqZWN0c1xuXHQgKiBAcmV0dXJuIHtUaWNrW119XG5cdCAqIEBzaW5jZSAyLjdcblx0ICovXG4gIGdldFRpY2tzKCkge1xuICAgIHJldHVybiB0aGlzLnRpY2tzO1xuICB9XG5cbiAgLyoqXG5cdCAqIEByZXR1cm4ge3N0cmluZ1tdfVxuXHQgKi9cbiAgZ2V0TGFiZWxzKCkge1xuICAgIGNvbnN0IGRhdGEgPSB0aGlzLmNoYXJ0LmRhdGE7XG4gICAgcmV0dXJuIHRoaXMub3B0aW9ucy5sYWJlbHMgfHwgKHRoaXMuaXNIb3Jpem9udGFsKCkgPyBkYXRhLnhMYWJlbHMgOiBkYXRhLnlMYWJlbHMpIHx8IGRhdGEubGFiZWxzIHx8IFtdO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge2ltcG9ydCgnLi4vdHlwZXMuanMnKS5MYWJlbEl0ZW1bXX1cbiAgICovXG4gIGdldExhYmVsSXRlbXMoY2hhcnRBcmVhID0gdGhpcy5jaGFydC5jaGFydEFyZWEpIHtcbiAgICBjb25zdCBpdGVtcyA9IHRoaXMuX2xhYmVsSXRlbXMgfHwgKHRoaXMuX2xhYmVsSXRlbXMgPSB0aGlzLl9jb21wdXRlTGFiZWxJdGVtcyhjaGFydEFyZWEpKTtcbiAgICByZXR1cm4gaXRlbXM7XG4gIH1cblxuICAvLyBXaGVuIGEgbmV3IGxheW91dCBpcyBjcmVhdGVkLCByZXNldCB0aGUgZGF0YSBsaW1pdHMgY2FjaGVcbiAgYmVmb3JlTGF5b3V0KCkge1xuICAgIHRoaXMuX2NhY2hlID0ge307XG4gICAgdGhpcy5fZGF0YUxpbWl0c0NhY2hlZCA9IGZhbHNlO1xuICB9XG5cbiAgLy8gVGhlc2UgbWV0aG9kcyBhcmUgb3JkZXJlZCBieSBsaWZlY3ljbGUuIFV0aWxpdGllcyB0aGVuIGZvbGxvdy5cbiAgLy8gQW55IGZ1bmN0aW9uIGRlZmluZWQgaGVyZSBpcyBpbmhlcml0ZWQgYnkgYWxsIHNjYWxlIHR5cGVzLlxuICAvLyBBbnkgZnVuY3Rpb24gY2FuIGJlIGV4dGVuZGVkIGJ5IHRoZSBzY2FsZSB0eXBlXG5cbiAgYmVmb3JlVXBkYXRlKCkge1xuICAgIGNhbGwodGhpcy5vcHRpb25zLmJlZm9yZVVwZGF0ZSwgW3RoaXNdKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcGFyYW0ge251bWJlcn0gbWF4V2lkdGggLSB0aGUgbWF4IHdpZHRoIGluIHBpeGVsc1xuXHQgKiBAcGFyYW0ge251bWJlcn0gbWF4SGVpZ2h0IC0gdGhlIG1heCBoZWlnaHQgaW4gcGl4ZWxzXG5cdCAqIEBwYXJhbSB7e3RvcDogbnVtYmVyLCBsZWZ0OiBudW1iZXIsIGJvdHRvbTogbnVtYmVyLCByaWdodDogbnVtYmVyfX0gbWFyZ2lucyAtIHRoZSBzcGFjZSBiZXR3ZWVuIHRoZSBlZGdlIG9mIHRoZSBvdGhlciBzY2FsZXMgYW5kIGVkZ2Ugb2YgdGhlIGNoYXJ0XG5cdCAqICAgVGhpcyBzcGFjZSBjb21lcyBmcm9tIHR3byBzb3VyY2VzOlxuXHQgKiAgICAgLSBwYWRkaW5nIC0gc3BhY2UgdGhhdCdzIHJlcXVpcmVkIHRvIHNob3cgdGhlIGxhYmVscyBhdCB0aGUgZWRnZXMgb2YgdGhlIHNjYWxlXG5cdCAqICAgICAtIHRoaWNrbmVzcyBvZiBzY2FsZXMgb3IgbGVnZW5kcyBpbiBhbm90aGVyIG9yaWVudGF0aW9uXG5cdCAqL1xuICB1cGRhdGUobWF4V2lkdGgsIG1heEhlaWdodCwgbWFyZ2lucykge1xuICAgIGNvbnN0IHtiZWdpbkF0WmVybywgZ3JhY2UsIHRpY2tzOiB0aWNrT3B0c30gPSB0aGlzLm9wdGlvbnM7XG4gICAgY29uc3Qgc2FtcGxlU2l6ZSA9IHRpY2tPcHRzLnNhbXBsZVNpemU7XG5cbiAgICAvLyBVcGRhdGUgTGlmZWN5Y2xlIC0gUHJvYmFibHkgZG9uJ3Qgd2FudCB0byBldmVyIGV4dGVuZCBvciBvdmVyd3JpdGUgdGhpcyBmdW5jdGlvbiA7KVxuICAgIHRoaXMuYmVmb3JlVXBkYXRlKCk7XG5cbiAgICAvLyBBYnNvcmIgdGhlIG1hc3RlciBtZWFzdXJlbWVudHNcbiAgICB0aGlzLm1heFdpZHRoID0gbWF4V2lkdGg7XG4gICAgdGhpcy5tYXhIZWlnaHQgPSBtYXhIZWlnaHQ7XG4gICAgdGhpcy5fbWFyZ2lucyA9IG1hcmdpbnMgPSBPYmplY3QuYXNzaWduKHtcbiAgICAgIGxlZnQ6IDAsXG4gICAgICByaWdodDogMCxcbiAgICAgIHRvcDogMCxcbiAgICAgIGJvdHRvbTogMFxuICAgIH0sIG1hcmdpbnMpO1xuXG4gICAgdGhpcy50aWNrcyA9IG51bGw7XG4gICAgdGhpcy5fbGFiZWxTaXplcyA9IG51bGw7XG4gICAgdGhpcy5fZ3JpZExpbmVJdGVtcyA9IG51bGw7XG4gICAgdGhpcy5fbGFiZWxJdGVtcyA9IG51bGw7XG5cbiAgICAvLyBEaW1lbnNpb25zXG4gICAgdGhpcy5iZWZvcmVTZXREaW1lbnNpb25zKCk7XG4gICAgdGhpcy5zZXREaW1lbnNpb25zKCk7XG4gICAgdGhpcy5hZnRlclNldERpbWVuc2lvbnMoKTtcblxuICAgIHRoaXMuX21heExlbmd0aCA9IHRoaXMuaXNIb3Jpem9udGFsKClcbiAgICAgID8gdGhpcy53aWR0aCArIG1hcmdpbnMubGVmdCArIG1hcmdpbnMucmlnaHRcbiAgICAgIDogdGhpcy5oZWlnaHQgKyBtYXJnaW5zLnRvcCArIG1hcmdpbnMuYm90dG9tO1xuXG4gICAgLy8gRGF0YSBtaW4vbWF4XG4gICAgaWYgKCF0aGlzLl9kYXRhTGltaXRzQ2FjaGVkKSB7XG4gICAgICB0aGlzLmJlZm9yZURhdGFMaW1pdHMoKTtcbiAgICAgIHRoaXMuZGV0ZXJtaW5lRGF0YUxpbWl0cygpO1xuICAgICAgdGhpcy5hZnRlckRhdGFMaW1pdHMoKTtcbiAgICAgIHRoaXMuX3JhbmdlID0gX2FkZEdyYWNlKHRoaXMsIGdyYWNlLCBiZWdpbkF0WmVybyk7XG4gICAgICB0aGlzLl9kYXRhTGltaXRzQ2FjaGVkID0gdHJ1ZTtcbiAgICB9XG5cbiAgICB0aGlzLmJlZm9yZUJ1aWxkVGlja3MoKTtcblxuICAgIHRoaXMudGlja3MgPSB0aGlzLmJ1aWxkVGlja3MoKSB8fCBbXTtcblxuICAgIC8vIEFsbG93IG1vZGlmaWNhdGlvbiBvZiB0aWNrcyBpbiBjYWxsYmFjay5cbiAgICB0aGlzLmFmdGVyQnVpbGRUaWNrcygpO1xuXG4gICAgLy8gQ29tcHV0ZSB0aWNrIHJvdGF0aW9uIGFuZCBmaXQgdXNpbmcgYSBzYW1wbGVkIHN1YnNldCBvZiBsYWJlbHNcbiAgICAvLyBXZSBnZW5lcmFsbHkgZG9uJ3QgbmVlZCB0byBjb21wdXRlIHRoZSBzaXplIG9mIGV2ZXJ5IHNpbmdsZSBsYWJlbCBmb3IgZGV0ZXJtaW5pbmcgc2NhbGUgc2l6ZVxuICAgIGNvbnN0IHNhbXBsaW5nRW5hYmxlZCA9IHNhbXBsZVNpemUgPCB0aGlzLnRpY2tzLmxlbmd0aDtcbiAgICB0aGlzLl9jb252ZXJ0VGlja3NUb0xhYmVscyhzYW1wbGluZ0VuYWJsZWQgPyBzYW1wbGUodGhpcy50aWNrcywgc2FtcGxlU2l6ZSkgOiB0aGlzLnRpY2tzKTtcblxuICAgIC8vIGNvbmZpZ3VyZSBpcyBjYWxsZWQgdHdpY2UsIG9uY2UgaGVyZSwgb25jZSBmcm9tIGNvcmUuY29udHJvbGxlci51cGRhdGVMYXlvdXQuXG4gICAgLy8gSGVyZSB3ZSBoYXZlbid0IGJlZW4gcG9zaXRpb25lZCB5ZXQsIGJ1dCBkaW1lbnNpb25zIGFyZSBjb3JyZWN0LlxuICAgIC8vIFZhcmlhYmxlcyBzZXQgaW4gY29uZmlndXJlIGFyZSBuZWVkZWQgZm9yIGNhbGN1bGF0ZUxhYmVsUm90YXRpb24sIGFuZFxuICAgIC8vIGl0J3Mgb2sgdGhhdCBjb29yZGluYXRlcyBhcmUgbm90IGNvcnJlY3QgdGhlcmUsIG9ubHkgZGltZW5zaW9ucyBtYXR0ZXIuXG4gICAgdGhpcy5jb25maWd1cmUoKTtcblxuICAgIC8vIFRpY2sgUm90YXRpb25cbiAgICB0aGlzLmJlZm9yZUNhbGN1bGF0ZUxhYmVsUm90YXRpb24oKTtcbiAgICB0aGlzLmNhbGN1bGF0ZUxhYmVsUm90YXRpb24oKTsgLy8gUHJlY29uZGl0aW9uczogbnVtYmVyIG9mIHRpY2tzIGFuZCBzaXplcyBvZiBsYXJnZXN0IGxhYmVscyBtdXN0IGJlIGNhbGN1bGF0ZWQgYmVmb3JlaGFuZFxuICAgIHRoaXMuYWZ0ZXJDYWxjdWxhdGVMYWJlbFJvdGF0aW9uKCk7XG5cbiAgICAvLyBBdXRvLXNraXBcbiAgICBpZiAodGlja09wdHMuZGlzcGxheSAmJiAodGlja09wdHMuYXV0b1NraXAgfHwgdGlja09wdHMuc291cmNlID09PSAnYXV0bycpKSB7XG4gICAgICB0aGlzLnRpY2tzID0gYXV0b1NraXAodGhpcywgdGhpcy50aWNrcyk7XG4gICAgICB0aGlzLl9sYWJlbFNpemVzID0gbnVsbDtcbiAgICAgIHRoaXMuYWZ0ZXJBdXRvU2tpcCgpO1xuICAgIH1cblxuICAgIGlmIChzYW1wbGluZ0VuYWJsZWQpIHtcbiAgICAgIC8vIEdlbmVyYXRlIGxhYmVscyB1c2luZyBhbGwgbm9uLXNraXBwZWQgdGlja3NcbiAgICAgIHRoaXMuX2NvbnZlcnRUaWNrc1RvTGFiZWxzKHRoaXMudGlja3MpO1xuICAgIH1cblxuICAgIHRoaXMuYmVmb3JlRml0KCk7XG4gICAgdGhpcy5maXQoKTsgLy8gUHJlY29uZGl0aW9uczogbGFiZWwgcm90YXRpb24gYW5kIGxhYmVsIHNpemVzIG11c3QgYmUgY2FsY3VsYXRlZCBiZWZvcmVoYW5kXG4gICAgdGhpcy5hZnRlckZpdCgpO1xuXG4gICAgLy8gSU1QT1JUQU5UOiBhZnRlciB0aGlzIHBvaW50LCB3ZSBjb25zaWRlciB0aGF0IGB0aGlzLnRpY2tzYCB3aWxsIE5FVkVSIGNoYW5nZSFcblxuICAgIHRoaXMuYWZ0ZXJVcGRhdGUoKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuICBjb25maWd1cmUoKSB7XG4gICAgbGV0IHJldmVyc2VQaXhlbHMgPSB0aGlzLm9wdGlvbnMucmV2ZXJzZTtcbiAgICBsZXQgc3RhcnRQaXhlbCwgZW5kUGl4ZWw7XG5cbiAgICBpZiAodGhpcy5pc0hvcml6b250YWwoKSkge1xuICAgICAgc3RhcnRQaXhlbCA9IHRoaXMubGVmdDtcbiAgICAgIGVuZFBpeGVsID0gdGhpcy5yaWdodDtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RhcnRQaXhlbCA9IHRoaXMudG9wO1xuICAgICAgZW5kUGl4ZWwgPSB0aGlzLmJvdHRvbTtcbiAgICAgIC8vIGJ5IGRlZmF1bHQgdmVydGljYWwgc2NhbGVzIGFyZSBmcm9tIGJvdHRvbSB0byB0b3AsIHNvIHBpeGVscyBhcmUgcmV2ZXJzZWRcbiAgICAgIHJldmVyc2VQaXhlbHMgPSAhcmV2ZXJzZVBpeGVscztcbiAgICB9XG4gICAgdGhpcy5fc3RhcnRQaXhlbCA9IHN0YXJ0UGl4ZWw7XG4gICAgdGhpcy5fZW5kUGl4ZWwgPSBlbmRQaXhlbDtcbiAgICB0aGlzLl9yZXZlcnNlUGl4ZWxzID0gcmV2ZXJzZVBpeGVscztcbiAgICB0aGlzLl9sZW5ndGggPSBlbmRQaXhlbCAtIHN0YXJ0UGl4ZWw7XG4gICAgdGhpcy5fYWxpZ25Ub1BpeGVscyA9IHRoaXMub3B0aW9ucy5hbGlnblRvUGl4ZWxzO1xuICB9XG5cbiAgYWZ0ZXJVcGRhdGUoKSB7XG4gICAgY2FsbCh0aGlzLm9wdGlvbnMuYWZ0ZXJVcGRhdGUsIFt0aGlzXSk7XG4gIH1cblxuICAvL1xuXG4gIGJlZm9yZVNldERpbWVuc2lvbnMoKSB7XG4gICAgY2FsbCh0aGlzLm9wdGlvbnMuYmVmb3JlU2V0RGltZW5zaW9ucywgW3RoaXNdKTtcbiAgfVxuICBzZXREaW1lbnNpb25zKCkge1xuICAgIC8vIFNldCB0aGUgdW5jb25zdHJhaW5lZCBkaW1lbnNpb24gYmVmb3JlIGxhYmVsIHJvdGF0aW9uXG4gICAgaWYgKHRoaXMuaXNIb3Jpem9udGFsKCkpIHtcbiAgICAgIC8vIFJlc2V0IHBvc2l0aW9uIGJlZm9yZSBjYWxjdWxhdGluZyByb3RhdGlvblxuICAgICAgdGhpcy53aWR0aCA9IHRoaXMubWF4V2lkdGg7XG4gICAgICB0aGlzLmxlZnQgPSAwO1xuICAgICAgdGhpcy5yaWdodCA9IHRoaXMud2lkdGg7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuaGVpZ2h0ID0gdGhpcy5tYXhIZWlnaHQ7XG5cbiAgICAgIC8vIFJlc2V0IHBvc2l0aW9uIGJlZm9yZSBjYWxjdWxhdGluZyByb3RhdGlvblxuICAgICAgdGhpcy50b3AgPSAwO1xuICAgICAgdGhpcy5ib3R0b20gPSB0aGlzLmhlaWdodDtcbiAgICB9XG5cbiAgICAvLyBSZXNldCBwYWRkaW5nXG4gICAgdGhpcy5wYWRkaW5nTGVmdCA9IDA7XG4gICAgdGhpcy5wYWRkaW5nVG9wID0gMDtcbiAgICB0aGlzLnBhZGRpbmdSaWdodCA9IDA7XG4gICAgdGhpcy5wYWRkaW5nQm90dG9tID0gMDtcbiAgfVxuICBhZnRlclNldERpbWVuc2lvbnMoKSB7XG4gICAgY2FsbCh0aGlzLm9wdGlvbnMuYWZ0ZXJTZXREaW1lbnNpb25zLCBbdGhpc10pO1xuICB9XG5cbiAgX2NhbGxIb29rcyhuYW1lKSB7XG4gICAgdGhpcy5jaGFydC5ub3RpZnlQbHVnaW5zKG5hbWUsIHRoaXMuZ2V0Q29udGV4dCgpKTtcbiAgICBjYWxsKHRoaXMub3B0aW9uc1tuYW1lXSwgW3RoaXNdKTtcbiAgfVxuXG4gIC8vIERhdGEgbGltaXRzXG4gIGJlZm9yZURhdGFMaW1pdHMoKSB7XG4gICAgdGhpcy5fY2FsbEhvb2tzKCdiZWZvcmVEYXRhTGltaXRzJyk7XG4gIH1cbiAgZGV0ZXJtaW5lRGF0YUxpbWl0cygpIHt9XG4gIGFmdGVyRGF0YUxpbWl0cygpIHtcbiAgICB0aGlzLl9jYWxsSG9va3MoJ2FmdGVyRGF0YUxpbWl0cycpO1xuICB9XG5cbiAgLy9cbiAgYmVmb3JlQnVpbGRUaWNrcygpIHtcbiAgICB0aGlzLl9jYWxsSG9va3MoJ2JlZm9yZUJ1aWxkVGlja3MnKTtcbiAgfVxuICAvKipcblx0ICogQHJldHVybiB7b2JqZWN0W119IHRoZSB0aWNrc1xuXHQgKi9cbiAgYnVpbGRUaWNrcygpIHtcbiAgICByZXR1cm4gW107XG4gIH1cbiAgYWZ0ZXJCdWlsZFRpY2tzKCkge1xuICAgIHRoaXMuX2NhbGxIb29rcygnYWZ0ZXJCdWlsZFRpY2tzJyk7XG4gIH1cblxuICBiZWZvcmVUaWNrVG9MYWJlbENvbnZlcnNpb24oKSB7XG4gICAgY2FsbCh0aGlzLm9wdGlvbnMuYmVmb3JlVGlja1RvTGFiZWxDb252ZXJzaW9uLCBbdGhpc10pO1xuICB9XG4gIC8qKlxuXHQgKiBDb252ZXJ0IHRpY2tzIHRvIGxhYmVsIHN0cmluZ3Ncblx0ICogQHBhcmFtIHtUaWNrW119IHRpY2tzXG5cdCAqL1xuICBnZW5lcmF0ZVRpY2tMYWJlbHModGlja3MpIHtcbiAgICBjb25zdCB0aWNrT3B0cyA9IHRoaXMub3B0aW9ucy50aWNrcztcbiAgICBsZXQgaSwgaWxlbiwgdGljaztcbiAgICBmb3IgKGkgPSAwLCBpbGVuID0gdGlja3MubGVuZ3RoOyBpIDwgaWxlbjsgaSsrKSB7XG4gICAgICB0aWNrID0gdGlja3NbaV07XG4gICAgICB0aWNrLmxhYmVsID0gY2FsbCh0aWNrT3B0cy5jYWxsYmFjaywgW3RpY2sudmFsdWUsIGksIHRpY2tzXSwgdGhpcyk7XG4gICAgfVxuICB9XG4gIGFmdGVyVGlja1RvTGFiZWxDb252ZXJzaW9uKCkge1xuICAgIGNhbGwodGhpcy5vcHRpb25zLmFmdGVyVGlja1RvTGFiZWxDb252ZXJzaW9uLCBbdGhpc10pO1xuICB9XG5cbiAgLy9cblxuICBiZWZvcmVDYWxjdWxhdGVMYWJlbFJvdGF0aW9uKCkge1xuICAgIGNhbGwodGhpcy5vcHRpb25zLmJlZm9yZUNhbGN1bGF0ZUxhYmVsUm90YXRpb24sIFt0aGlzXSk7XG4gIH1cbiAgY2FsY3VsYXRlTGFiZWxSb3RhdGlvbigpIHtcbiAgICBjb25zdCBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgIGNvbnN0IHRpY2tPcHRzID0gb3B0aW9ucy50aWNrcztcbiAgICBjb25zdCBudW1UaWNrcyA9IGdldFRpY2tzTGltaXQodGhpcy50aWNrcy5sZW5ndGgsIG9wdGlvbnMudGlja3MubWF4VGlja3NMaW1pdCk7XG4gICAgY29uc3QgbWluUm90YXRpb24gPSB0aWNrT3B0cy5taW5Sb3RhdGlvbiB8fCAwO1xuICAgIGNvbnN0IG1heFJvdGF0aW9uID0gdGlja09wdHMubWF4Um90YXRpb247XG4gICAgbGV0IGxhYmVsUm90YXRpb24gPSBtaW5Sb3RhdGlvbjtcbiAgICBsZXQgdGlja1dpZHRoLCBtYXhIZWlnaHQsIG1heExhYmVsRGlhZ29uYWw7XG5cbiAgICBpZiAoIXRoaXMuX2lzVmlzaWJsZSgpIHx8ICF0aWNrT3B0cy5kaXNwbGF5IHx8IG1pblJvdGF0aW9uID49IG1heFJvdGF0aW9uIHx8IG51bVRpY2tzIDw9IDEgfHwgIXRoaXMuaXNIb3Jpem9udGFsKCkpIHtcbiAgICAgIHRoaXMubGFiZWxSb3RhdGlvbiA9IG1pblJvdGF0aW9uO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IGxhYmVsU2l6ZXMgPSB0aGlzLl9nZXRMYWJlbFNpemVzKCk7XG4gICAgY29uc3QgbWF4TGFiZWxXaWR0aCA9IGxhYmVsU2l6ZXMud2lkZXN0LndpZHRoO1xuICAgIGNvbnN0IG1heExhYmVsSGVpZ2h0ID0gbGFiZWxTaXplcy5oaWdoZXN0LmhlaWdodDtcblxuICAgIC8vIEVzdGltYXRlIHRoZSB3aWR0aCBvZiBlYWNoIGdyaWQgYmFzZWQgb24gdGhlIGNhbnZhcyB3aWR0aCwgdGhlIG1heGltdW1cbiAgICAvLyBsYWJlbCB3aWR0aCBhbmQgdGhlIG51bWJlciBvZiB0aWNrIGludGVydmFsc1xuICAgIGNvbnN0IG1heFdpZHRoID0gX2xpbWl0VmFsdWUodGhpcy5jaGFydC53aWR0aCAtIG1heExhYmVsV2lkdGgsIDAsIHRoaXMubWF4V2lkdGgpO1xuICAgIHRpY2tXaWR0aCA9IG9wdGlvbnMub2Zmc2V0ID8gdGhpcy5tYXhXaWR0aCAvIG51bVRpY2tzIDogbWF4V2lkdGggLyAobnVtVGlja3MgLSAxKTtcblxuICAgIC8vIEFsbG93IDMgcGl4ZWxzIHgyIHBhZGRpbmcgZWl0aGVyIHNpZGUgZm9yIGxhYmVsIHJlYWRhYmlsaXR5XG4gICAgaWYgKG1heExhYmVsV2lkdGggKyA2ID4gdGlja1dpZHRoKSB7XG4gICAgICB0aWNrV2lkdGggPSBtYXhXaWR0aCAvIChudW1UaWNrcyAtIChvcHRpb25zLm9mZnNldCA/IDAuNSA6IDEpKTtcbiAgICAgIG1heEhlaWdodCA9IHRoaXMubWF4SGVpZ2h0IC0gZ2V0VGlja01hcmtMZW5ndGgob3B0aW9ucy5ncmlkKVxuXHRcdFx0XHQtIHRpY2tPcHRzLnBhZGRpbmcgLSBnZXRUaXRsZUhlaWdodChvcHRpb25zLnRpdGxlLCB0aGlzLmNoYXJ0Lm9wdGlvbnMuZm9udCk7XG4gICAgICBtYXhMYWJlbERpYWdvbmFsID0gTWF0aC5zcXJ0KG1heExhYmVsV2lkdGggKiBtYXhMYWJlbFdpZHRoICsgbWF4TGFiZWxIZWlnaHQgKiBtYXhMYWJlbEhlaWdodCk7XG4gICAgICBsYWJlbFJvdGF0aW9uID0gdG9EZWdyZWVzKE1hdGgubWluKFxuICAgICAgICBNYXRoLmFzaW4oX2xpbWl0VmFsdWUoKGxhYmVsU2l6ZXMuaGlnaGVzdC5oZWlnaHQgKyA2KSAvIHRpY2tXaWR0aCwgLTEsIDEpKSxcbiAgICAgICAgTWF0aC5hc2luKF9saW1pdFZhbHVlKG1heEhlaWdodCAvIG1heExhYmVsRGlhZ29uYWwsIC0xLCAxKSkgLSBNYXRoLmFzaW4oX2xpbWl0VmFsdWUobWF4TGFiZWxIZWlnaHQgLyBtYXhMYWJlbERpYWdvbmFsLCAtMSwgMSkpXG4gICAgICApKTtcbiAgICAgIGxhYmVsUm90YXRpb24gPSBNYXRoLm1heChtaW5Sb3RhdGlvbiwgTWF0aC5taW4obWF4Um90YXRpb24sIGxhYmVsUm90YXRpb24pKTtcbiAgICB9XG5cbiAgICB0aGlzLmxhYmVsUm90YXRpb24gPSBsYWJlbFJvdGF0aW9uO1xuICB9XG4gIGFmdGVyQ2FsY3VsYXRlTGFiZWxSb3RhdGlvbigpIHtcbiAgICBjYWxsKHRoaXMub3B0aW9ucy5hZnRlckNhbGN1bGF0ZUxhYmVsUm90YXRpb24sIFt0aGlzXSk7XG4gIH1cbiAgYWZ0ZXJBdXRvU2tpcCgpIHt9XG5cbiAgLy9cblxuICBiZWZvcmVGaXQoKSB7XG4gICAgY2FsbCh0aGlzLm9wdGlvbnMuYmVmb3JlRml0LCBbdGhpc10pO1xuICB9XG4gIGZpdCgpIHtcbiAgICAvLyBSZXNldFxuICAgIGNvbnN0IG1pblNpemUgPSB7XG4gICAgICB3aWR0aDogMCxcbiAgICAgIGhlaWdodDogMFxuICAgIH07XG5cbiAgICBjb25zdCB7Y2hhcnQsIG9wdGlvbnM6IHt0aWNrczogdGlja09wdHMsIHRpdGxlOiB0aXRsZU9wdHMsIGdyaWQ6IGdyaWRPcHRzfX0gPSB0aGlzO1xuICAgIGNvbnN0IGRpc3BsYXkgPSB0aGlzLl9pc1Zpc2libGUoKTtcbiAgICBjb25zdCBpc0hvcml6b250YWwgPSB0aGlzLmlzSG9yaXpvbnRhbCgpO1xuXG4gICAgaWYgKGRpc3BsYXkpIHtcbiAgICAgIGNvbnN0IHRpdGxlSGVpZ2h0ID0gZ2V0VGl0bGVIZWlnaHQodGl0bGVPcHRzLCBjaGFydC5vcHRpb25zLmZvbnQpO1xuICAgICAgaWYgKGlzSG9yaXpvbnRhbCkge1xuICAgICAgICBtaW5TaXplLndpZHRoID0gdGhpcy5tYXhXaWR0aDtcbiAgICAgICAgbWluU2l6ZS5oZWlnaHQgPSBnZXRUaWNrTWFya0xlbmd0aChncmlkT3B0cykgKyB0aXRsZUhlaWdodDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG1pblNpemUuaGVpZ2h0ID0gdGhpcy5tYXhIZWlnaHQ7IC8vIGZpbGwgYWxsIHRoZSBoZWlnaHRcbiAgICAgICAgbWluU2l6ZS53aWR0aCA9IGdldFRpY2tNYXJrTGVuZ3RoKGdyaWRPcHRzKSArIHRpdGxlSGVpZ2h0O1xuICAgICAgfVxuXG4gICAgICAvLyBEb24ndCBib3RoZXIgZml0dGluZyB0aGUgdGlja3MgaWYgd2UgYXJlIG5vdCBzaG93aW5nIHRoZSBsYWJlbHNcbiAgICAgIGlmICh0aWNrT3B0cy5kaXNwbGF5ICYmIHRoaXMudGlja3MubGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IHtmaXJzdCwgbGFzdCwgd2lkZXN0LCBoaWdoZXN0fSA9IHRoaXMuX2dldExhYmVsU2l6ZXMoKTtcbiAgICAgICAgY29uc3QgdGlja1BhZGRpbmcgPSB0aWNrT3B0cy5wYWRkaW5nICogMjtcbiAgICAgICAgY29uc3QgYW5nbGVSYWRpYW5zID0gdG9SYWRpYW5zKHRoaXMubGFiZWxSb3RhdGlvbik7XG4gICAgICAgIGNvbnN0IGNvcyA9IE1hdGguY29zKGFuZ2xlUmFkaWFucyk7XG4gICAgICAgIGNvbnN0IHNpbiA9IE1hdGguc2luKGFuZ2xlUmFkaWFucyk7XG5cbiAgICAgICAgaWYgKGlzSG9yaXpvbnRhbCkge1xuICAgICAgICAvLyBBIGhvcml6b250YWwgYXhpcyBpcyBtb3JlIGNvbnN0cmFpbmVkIGJ5IHRoZSBoZWlnaHQuXG4gICAgICAgICAgY29uc3QgbGFiZWxIZWlnaHQgPSB0aWNrT3B0cy5taXJyb3IgPyAwIDogc2luICogd2lkZXN0LndpZHRoICsgY29zICogaGlnaGVzdC5oZWlnaHQ7XG4gICAgICAgICAgbWluU2l6ZS5oZWlnaHQgPSBNYXRoLm1pbih0aGlzLm1heEhlaWdodCwgbWluU2l6ZS5oZWlnaHQgKyBsYWJlbEhlaWdodCArIHRpY2tQYWRkaW5nKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gQSB2ZXJ0aWNhbCBheGlzIGlzIG1vcmUgY29uc3RyYWluZWQgYnkgdGhlIHdpZHRoLiBMYWJlbHMgYXJlIHRoZVxuICAgICAgICAvLyBkb21pbmFudCBmYWN0b3IgaGVyZSwgc28gZ2V0IHRoYXQgbGVuZ3RoIGZpcnN0IGFuZCBhY2NvdW50IGZvciBwYWRkaW5nXG4gICAgICAgICAgY29uc3QgbGFiZWxXaWR0aCA9IHRpY2tPcHRzLm1pcnJvciA/IDAgOiBjb3MgKiB3aWRlc3Qud2lkdGggKyBzaW4gKiBoaWdoZXN0LmhlaWdodDtcblxuICAgICAgICAgIG1pblNpemUud2lkdGggPSBNYXRoLm1pbih0aGlzLm1heFdpZHRoLCBtaW5TaXplLndpZHRoICsgbGFiZWxXaWR0aCArIHRpY2tQYWRkaW5nKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9jYWxjdWxhdGVQYWRkaW5nKGZpcnN0LCBsYXN0LCBzaW4sIGNvcyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5faGFuZGxlTWFyZ2lucygpO1xuXG4gICAgaWYgKGlzSG9yaXpvbnRhbCkge1xuICAgICAgdGhpcy53aWR0aCA9IHRoaXMuX2xlbmd0aCA9IGNoYXJ0LndpZHRoIC0gdGhpcy5fbWFyZ2lucy5sZWZ0IC0gdGhpcy5fbWFyZ2lucy5yaWdodDtcbiAgICAgIHRoaXMuaGVpZ2h0ID0gbWluU2l6ZS5oZWlnaHQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMud2lkdGggPSBtaW5TaXplLndpZHRoO1xuICAgICAgdGhpcy5oZWlnaHQgPSB0aGlzLl9sZW5ndGggPSBjaGFydC5oZWlnaHQgLSB0aGlzLl9tYXJnaW5zLnRvcCAtIHRoaXMuX21hcmdpbnMuYm90dG9tO1xuICAgIH1cbiAgfVxuXG4gIF9jYWxjdWxhdGVQYWRkaW5nKGZpcnN0LCBsYXN0LCBzaW4sIGNvcykge1xuICAgIGNvbnN0IHt0aWNrczoge2FsaWduLCBwYWRkaW5nfSwgcG9zaXRpb259ID0gdGhpcy5vcHRpb25zO1xuICAgIGNvbnN0IGlzUm90YXRlZCA9IHRoaXMubGFiZWxSb3RhdGlvbiAhPT0gMDtcbiAgICBjb25zdCBsYWJlbHNCZWxvd1RpY2tzID0gcG9zaXRpb24gIT09ICd0b3AnICYmIHRoaXMuYXhpcyA9PT0gJ3gnO1xuXG4gICAgaWYgKHRoaXMuaXNIb3Jpem9udGFsKCkpIHtcbiAgICAgIGNvbnN0IG9mZnNldExlZnQgPSB0aGlzLmdldFBpeGVsRm9yVGljaygwKSAtIHRoaXMubGVmdDtcbiAgICAgIGNvbnN0IG9mZnNldFJpZ2h0ID0gdGhpcy5yaWdodCAtIHRoaXMuZ2V0UGl4ZWxGb3JUaWNrKHRoaXMudGlja3MubGVuZ3RoIC0gMSk7XG4gICAgICBsZXQgcGFkZGluZ0xlZnQgPSAwO1xuICAgICAgbGV0IHBhZGRpbmdSaWdodCA9IDA7XG5cbiAgICAgIC8vIEVuc3VyZSB0aGF0IG91ciB0aWNrcyBhcmUgYWx3YXlzIGluc2lkZSB0aGUgY2FudmFzLiBXaGVuIHJvdGF0ZWQsIHRpY2tzIGFyZSByaWdodCBhbGlnbmVkXG4gICAgICAvLyB3aGljaCBtZWFucyB0aGF0IHRoZSByaWdodCBwYWRkaW5nIGlzIGRvbWluYXRlZCBieSB0aGUgZm9udCBoZWlnaHRcbiAgICAgIGlmIChpc1JvdGF0ZWQpIHtcbiAgICAgICAgaWYgKGxhYmVsc0JlbG93VGlja3MpIHtcbiAgICAgICAgICBwYWRkaW5nTGVmdCA9IGNvcyAqIGZpcnN0LndpZHRoO1xuICAgICAgICAgIHBhZGRpbmdSaWdodCA9IHNpbiAqIGxhc3QuaGVpZ2h0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBhZGRpbmdMZWZ0ID0gc2luICogZmlyc3QuaGVpZ2h0O1xuICAgICAgICAgIHBhZGRpbmdSaWdodCA9IGNvcyAqIGxhc3Qud2lkdGg7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoYWxpZ24gPT09ICdzdGFydCcpIHtcbiAgICAgICAgcGFkZGluZ1JpZ2h0ID0gbGFzdC53aWR0aDtcbiAgICAgIH0gZWxzZSBpZiAoYWxpZ24gPT09ICdlbmQnKSB7XG4gICAgICAgIHBhZGRpbmdMZWZ0ID0gZmlyc3Qud2lkdGg7XG4gICAgICB9IGVsc2UgaWYgKGFsaWduICE9PSAnaW5uZXInKSB7XG4gICAgICAgIHBhZGRpbmdMZWZ0ID0gZmlyc3Qud2lkdGggLyAyO1xuICAgICAgICBwYWRkaW5nUmlnaHQgPSBsYXN0LndpZHRoIC8gMjtcbiAgICAgIH1cblxuICAgICAgLy8gQWRqdXN0IHBhZGRpbmcgdGFraW5nIGludG8gYWNjb3VudCBjaGFuZ2VzIGluIG9mZnNldHNcbiAgICAgIHRoaXMucGFkZGluZ0xlZnQgPSBNYXRoLm1heCgocGFkZGluZ0xlZnQgLSBvZmZzZXRMZWZ0ICsgcGFkZGluZykgKiB0aGlzLndpZHRoIC8gKHRoaXMud2lkdGggLSBvZmZzZXRMZWZ0KSwgMCk7XG4gICAgICB0aGlzLnBhZGRpbmdSaWdodCA9IE1hdGgubWF4KChwYWRkaW5nUmlnaHQgLSBvZmZzZXRSaWdodCArIHBhZGRpbmcpICogdGhpcy53aWR0aCAvICh0aGlzLndpZHRoIC0gb2Zmc2V0UmlnaHQpLCAwKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGV0IHBhZGRpbmdUb3AgPSBsYXN0LmhlaWdodCAvIDI7XG4gICAgICBsZXQgcGFkZGluZ0JvdHRvbSA9IGZpcnN0LmhlaWdodCAvIDI7XG5cbiAgICAgIGlmIChhbGlnbiA9PT0gJ3N0YXJ0Jykge1xuICAgICAgICBwYWRkaW5nVG9wID0gMDtcbiAgICAgICAgcGFkZGluZ0JvdHRvbSA9IGZpcnN0LmhlaWdodDtcbiAgICAgIH0gZWxzZSBpZiAoYWxpZ24gPT09ICdlbmQnKSB7XG4gICAgICAgIHBhZGRpbmdUb3AgPSBsYXN0LmhlaWdodDtcbiAgICAgICAgcGFkZGluZ0JvdHRvbSA9IDA7XG4gICAgICB9XG5cbiAgICAgIHRoaXMucGFkZGluZ1RvcCA9IHBhZGRpbmdUb3AgKyBwYWRkaW5nO1xuICAgICAgdGhpcy5wYWRkaW5nQm90dG9tID0gcGFkZGluZ0JvdHRvbSArIHBhZGRpbmc7XG4gICAgfVxuICB9XG5cbiAgLyoqXG5cdCAqIEhhbmRsZSBtYXJnaW5zIGFuZCBwYWRkaW5nIGludGVyYWN0aW9uc1xuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgX2hhbmRsZU1hcmdpbnMoKSB7XG4gICAgaWYgKHRoaXMuX21hcmdpbnMpIHtcbiAgICAgIHRoaXMuX21hcmdpbnMubGVmdCA9IE1hdGgubWF4KHRoaXMucGFkZGluZ0xlZnQsIHRoaXMuX21hcmdpbnMubGVmdCk7XG4gICAgICB0aGlzLl9tYXJnaW5zLnRvcCA9IE1hdGgubWF4KHRoaXMucGFkZGluZ1RvcCwgdGhpcy5fbWFyZ2lucy50b3ApO1xuICAgICAgdGhpcy5fbWFyZ2lucy5yaWdodCA9IE1hdGgubWF4KHRoaXMucGFkZGluZ1JpZ2h0LCB0aGlzLl9tYXJnaW5zLnJpZ2h0KTtcbiAgICAgIHRoaXMuX21hcmdpbnMuYm90dG9tID0gTWF0aC5tYXgodGhpcy5wYWRkaW5nQm90dG9tLCB0aGlzLl9tYXJnaW5zLmJvdHRvbSk7XG4gICAgfVxuICB9XG5cbiAgYWZ0ZXJGaXQoKSB7XG4gICAgY2FsbCh0aGlzLm9wdGlvbnMuYWZ0ZXJGaXQsIFt0aGlzXSk7XG4gIH1cblxuICAvLyBTaGFyZWQgTWV0aG9kc1xuICAvKipcblx0ICogQHJldHVybiB7Ym9vbGVhbn1cblx0ICovXG4gIGlzSG9yaXpvbnRhbCgpIHtcbiAgICBjb25zdCB7YXhpcywgcG9zaXRpb259ID0gdGhpcy5vcHRpb25zO1xuICAgIHJldHVybiBwb3NpdGlvbiA9PT0gJ3RvcCcgfHwgcG9zaXRpb24gPT09ICdib3R0b20nIHx8IGF4aXMgPT09ICd4JztcbiAgfVxuICAvKipcblx0ICogQHJldHVybiB7Ym9vbGVhbn1cblx0ICovXG4gIGlzRnVsbFNpemUoKSB7XG4gICAgcmV0dXJuIHRoaXMub3B0aW9ucy5mdWxsU2l6ZTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcGFyYW0ge1RpY2tbXX0gdGlja3Ncblx0ICogQHByaXZhdGVcblx0ICovXG4gIF9jb252ZXJ0VGlja3NUb0xhYmVscyh0aWNrcykge1xuICAgIHRoaXMuYmVmb3JlVGlja1RvTGFiZWxDb252ZXJzaW9uKCk7XG5cbiAgICB0aGlzLmdlbmVyYXRlVGlja0xhYmVscyh0aWNrcyk7XG5cbiAgICAvLyBUaWNrcyBzaG91bGQgYmUgc2tpcHBlZCB3aGVuIGNhbGxiYWNrIHJldHVybnMgbnVsbCBvciB1bmRlZiwgc28gbGV0cyByZW1vdmUgdGhvc2UuXG4gICAgbGV0IGksIGlsZW47XG4gICAgZm9yIChpID0gMCwgaWxlbiA9IHRpY2tzLmxlbmd0aDsgaSA8IGlsZW47IGkrKykge1xuICAgICAgaWYgKGlzTnVsbE9yVW5kZWYodGlja3NbaV0ubGFiZWwpKSB7XG4gICAgICAgIHRpY2tzLnNwbGljZShpLCAxKTtcbiAgICAgICAgaWxlbi0tO1xuICAgICAgICBpLS07XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5hZnRlclRpY2tUb0xhYmVsQ29udmVyc2lvbigpO1xuICB9XG5cbiAgLyoqXG5cdCAqIEByZXR1cm4ge3sgZmlyc3Q6IG9iamVjdCwgbGFzdDogb2JqZWN0LCB3aWRlc3Q6IG9iamVjdCwgaGlnaGVzdDogb2JqZWN0LCB3aWR0aHM6IEFycmF5LCBoZWlnaHRzOiBhcnJheSB9fVxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgX2dldExhYmVsU2l6ZXMoKSB7XG4gICAgbGV0IGxhYmVsU2l6ZXMgPSB0aGlzLl9sYWJlbFNpemVzO1xuXG4gICAgaWYgKCFsYWJlbFNpemVzKSB7XG4gICAgICBjb25zdCBzYW1wbGVTaXplID0gdGhpcy5vcHRpb25zLnRpY2tzLnNhbXBsZVNpemU7XG4gICAgICBsZXQgdGlja3MgPSB0aGlzLnRpY2tzO1xuICAgICAgaWYgKHNhbXBsZVNpemUgPCB0aWNrcy5sZW5ndGgpIHtcbiAgICAgICAgdGlja3MgPSBzYW1wbGUodGlja3MsIHNhbXBsZVNpemUpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9sYWJlbFNpemVzID0gbGFiZWxTaXplcyA9IHRoaXMuX2NvbXB1dGVMYWJlbFNpemVzKHRpY2tzLCB0aWNrcy5sZW5ndGgsIHRoaXMub3B0aW9ucy50aWNrcy5tYXhUaWNrc0xpbWl0KTtcbiAgICB9XG5cbiAgICByZXR1cm4gbGFiZWxTaXplcztcbiAgfVxuXG4gIC8qKlxuXHQgKiBSZXR1cm5zIHt3aWR0aCwgaGVpZ2h0LCBvZmZzZXR9IG9iamVjdHMgZm9yIHRoZSBmaXJzdCwgbGFzdCwgd2lkZXN0LCBoaWdoZXN0IHRpY2tcblx0ICogbGFiZWxzIHdoZXJlIG9mZnNldCBpbmRpY2F0ZXMgdGhlIGFuY2hvciBwb2ludCBvZmZzZXQgZnJvbSB0aGUgdG9wIGluIHBpeGVscy5cblx0ICogQHJldHVybiB7eyBmaXJzdDogb2JqZWN0LCBsYXN0OiBvYmplY3QsIHdpZGVzdDogb2JqZWN0LCBoaWdoZXN0OiBvYmplY3QsIHdpZHRoczogQXJyYXksIGhlaWdodHM6IGFycmF5IH19XG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfY29tcHV0ZUxhYmVsU2l6ZXModGlja3MsIGxlbmd0aCwgbWF4VGlja3NMaW1pdCkge1xuICAgIGNvbnN0IHtjdHgsIF9sb25nZXN0VGV4dENhY2hlOiBjYWNoZXN9ID0gdGhpcztcbiAgICBjb25zdCB3aWR0aHMgPSBbXTtcbiAgICBjb25zdCBoZWlnaHRzID0gW107XG4gICAgY29uc3QgaW5jcmVtZW50ID0gTWF0aC5mbG9vcihsZW5ndGggLyBnZXRUaWNrc0xpbWl0KGxlbmd0aCwgbWF4VGlja3NMaW1pdCkpO1xuICAgIGxldCB3aWRlc3RMYWJlbFNpemUgPSAwO1xuICAgIGxldCBoaWdoZXN0TGFiZWxTaXplID0gMDtcbiAgICBsZXQgaSwgaiwgamxlbiwgbGFiZWwsIHRpY2tGb250LCBmb250U3RyaW5nLCBjYWNoZSwgbGluZUhlaWdodCwgd2lkdGgsIGhlaWdodCwgbmVzdGVkTGFiZWw7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyBpICs9IGluY3JlbWVudCkge1xuICAgICAgbGFiZWwgPSB0aWNrc1tpXS5sYWJlbDtcbiAgICAgIHRpY2tGb250ID0gdGhpcy5fcmVzb2x2ZVRpY2tGb250T3B0aW9ucyhpKTtcbiAgICAgIGN0eC5mb250ID0gZm9udFN0cmluZyA9IHRpY2tGb250LnN0cmluZztcbiAgICAgIGNhY2hlID0gY2FjaGVzW2ZvbnRTdHJpbmddID0gY2FjaGVzW2ZvbnRTdHJpbmddIHx8IHtkYXRhOiB7fSwgZ2M6IFtdfTtcbiAgICAgIGxpbmVIZWlnaHQgPSB0aWNrRm9udC5saW5lSGVpZ2h0O1xuICAgICAgd2lkdGggPSBoZWlnaHQgPSAwO1xuICAgICAgLy8gVW5kZWZpbmVkIGxhYmVscyBhbmQgYXJyYXlzIHNob3VsZCBub3QgYmUgbWVhc3VyZWRcbiAgICAgIGlmICghaXNOdWxsT3JVbmRlZihsYWJlbCkgJiYgIWlzQXJyYXkobGFiZWwpKSB7XG4gICAgICAgIHdpZHRoID0gX21lYXN1cmVUZXh0KGN0eCwgY2FjaGUuZGF0YSwgY2FjaGUuZ2MsIHdpZHRoLCBsYWJlbCk7XG4gICAgICAgIGhlaWdodCA9IGxpbmVIZWlnaHQ7XG4gICAgICB9IGVsc2UgaWYgKGlzQXJyYXkobGFiZWwpKSB7XG4gICAgICAgIC8vIGlmIGl0IGlzIGFuIGFycmF5IGxldCdzIG1lYXN1cmUgZWFjaCBlbGVtZW50XG4gICAgICAgIGZvciAoaiA9IDAsIGpsZW4gPSBsYWJlbC5sZW5ndGg7IGogPCBqbGVuOyArK2opIHtcbiAgICAgICAgICBuZXN0ZWRMYWJlbCA9IC8qKiBAdHlwZSB7c3RyaW5nfSAqLyAobGFiZWxbal0pO1xuICAgICAgICAgIC8vIFVuZGVmaW5lZCBsYWJlbHMgYW5kIGFycmF5cyBzaG91bGQgbm90IGJlIG1lYXN1cmVkXG4gICAgICAgICAgaWYgKCFpc051bGxPclVuZGVmKG5lc3RlZExhYmVsKSAmJiAhaXNBcnJheShuZXN0ZWRMYWJlbCkpIHtcbiAgICAgICAgICAgIHdpZHRoID0gX21lYXN1cmVUZXh0KGN0eCwgY2FjaGUuZGF0YSwgY2FjaGUuZ2MsIHdpZHRoLCBuZXN0ZWRMYWJlbCk7XG4gICAgICAgICAgICBoZWlnaHQgKz0gbGluZUhlaWdodDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHdpZHRocy5wdXNoKHdpZHRoKTtcbiAgICAgIGhlaWdodHMucHVzaChoZWlnaHQpO1xuICAgICAgd2lkZXN0TGFiZWxTaXplID0gTWF0aC5tYXgod2lkdGgsIHdpZGVzdExhYmVsU2l6ZSk7XG4gICAgICBoaWdoZXN0TGFiZWxTaXplID0gTWF0aC5tYXgoaGVpZ2h0LCBoaWdoZXN0TGFiZWxTaXplKTtcbiAgICB9XG4gICAgZ2FyYmFnZUNvbGxlY3QoY2FjaGVzLCBsZW5ndGgpO1xuXG4gICAgY29uc3Qgd2lkZXN0ID0gd2lkdGhzLmluZGV4T2Yod2lkZXN0TGFiZWxTaXplKTtcbiAgICBjb25zdCBoaWdoZXN0ID0gaGVpZ2h0cy5pbmRleE9mKGhpZ2hlc3RMYWJlbFNpemUpO1xuXG4gICAgY29uc3QgdmFsdWVBdCA9IChpZHgpID0+ICh7d2lkdGg6IHdpZHRoc1tpZHhdIHx8IDAsIGhlaWdodDogaGVpZ2h0c1tpZHhdIHx8IDB9KTtcblxuICAgIHJldHVybiB7XG4gICAgICBmaXJzdDogdmFsdWVBdCgwKSxcbiAgICAgIGxhc3Q6IHZhbHVlQXQobGVuZ3RoIC0gMSksXG4gICAgICB3aWRlc3Q6IHZhbHVlQXQod2lkZXN0KSxcbiAgICAgIGhpZ2hlc3Q6IHZhbHVlQXQoaGlnaGVzdCksXG4gICAgICB3aWR0aHMsXG4gICAgICBoZWlnaHRzLFxuICAgIH07XG4gIH1cblxuICAvKipcblx0ICogVXNlZCB0byBnZXQgdGhlIGxhYmVsIHRvIGRpc3BsYXkgaW4gdGhlIHRvb2x0aXAgZm9yIHRoZSBnaXZlbiB2YWx1ZVxuXHQgKiBAcGFyYW0geyp9IHZhbHVlXG5cdCAqIEByZXR1cm4ge3N0cmluZ31cblx0ICovXG4gIGdldExhYmVsRm9yVmFsdWUodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cblxuICAvKipcblx0ICogUmV0dXJucyB0aGUgbG9jYXRpb24gb2YgdGhlIGdpdmVuIGRhdGEgcG9pbnQuIFZhbHVlIGNhbiBlaXRoZXIgYmUgYW4gaW5kZXggb3IgYSBudW1lcmljYWwgdmFsdWVcblx0ICogVGhlIGNvb3JkaW5hdGUgKDAsIDApIGlzIGF0IHRoZSB1cHBlci1sZWZ0IGNvcm5lciBvZiB0aGUgY2FudmFzXG5cdCAqIEBwYXJhbSB7Kn0gdmFsdWVcblx0ICogQHBhcmFtIHtudW1iZXJ9IFtpbmRleF1cblx0ICogQHJldHVybiB7bnVtYmVyfVxuXHQgKi9cbiAgZ2V0UGl4ZWxGb3JWYWx1ZSh2YWx1ZSwgaW5kZXgpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuICAgIHJldHVybiBOYU47XG4gIH1cblxuICAvKipcblx0ICogVXNlZCB0byBnZXQgdGhlIGRhdGEgdmFsdWUgZnJvbSBhIGdpdmVuIHBpeGVsLiBUaGlzIGlzIHRoZSBpbnZlcnNlIG9mIGdldFBpeGVsRm9yVmFsdWVcblx0ICogVGhlIGNvb3JkaW5hdGUgKDAsIDApIGlzIGF0IHRoZSB1cHBlci1sZWZ0IGNvcm5lciBvZiB0aGUgY2FudmFzXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBwaXhlbFxuXHQgKiBAcmV0dXJuIHsqfVxuXHQgKi9cbiAgZ2V0VmFsdWVGb3JQaXhlbChwaXhlbCkge30gLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuXG4gIC8qKlxuXHQgKiBSZXR1cm5zIHRoZSBsb2NhdGlvbiBvZiB0aGUgdGljayBhdCB0aGUgZ2l2ZW4gaW5kZXhcblx0ICogVGhlIGNvb3JkaW5hdGUgKDAsIDApIGlzIGF0IHRoZSB1cHBlci1sZWZ0IGNvcm5lciBvZiB0aGUgY2FudmFzXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleFxuXHQgKiBAcmV0dXJuIHtudW1iZXJ9XG5cdCAqL1xuICBnZXRQaXhlbEZvclRpY2soaW5kZXgpIHtcbiAgICBjb25zdCB0aWNrcyA9IHRoaXMudGlja3M7XG4gICAgaWYgKGluZGV4IDwgMCB8fCBpbmRleCA+IHRpY2tzLmxlbmd0aCAtIDEpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5nZXRQaXhlbEZvclZhbHVlKHRpY2tzW2luZGV4XS52YWx1ZSk7XG4gIH1cblxuICAvKipcblx0ICogVXRpbGl0eSBmb3IgZ2V0dGluZyB0aGUgcGl4ZWwgbG9jYXRpb24gb2YgYSBwZXJjZW50YWdlIG9mIHNjYWxlXG5cdCAqIFRoZSBjb29yZGluYXRlICgwLCAwKSBpcyBhdCB0aGUgdXBwZXItbGVmdCBjb3JuZXIgb2YgdGhlIGNhbnZhc1xuXHQgKiBAcGFyYW0ge251bWJlcn0gZGVjaW1hbFxuXHQgKiBAcmV0dXJuIHtudW1iZXJ9XG5cdCAqL1xuICBnZXRQaXhlbEZvckRlY2ltYWwoZGVjaW1hbCkge1xuICAgIGlmICh0aGlzLl9yZXZlcnNlUGl4ZWxzKSB7XG4gICAgICBkZWNpbWFsID0gMSAtIGRlY2ltYWw7XG4gICAgfVxuXG4gICAgY29uc3QgcGl4ZWwgPSB0aGlzLl9zdGFydFBpeGVsICsgZGVjaW1hbCAqIHRoaXMuX2xlbmd0aDtcbiAgICByZXR1cm4gX2ludDE2UmFuZ2UodGhpcy5fYWxpZ25Ub1BpeGVscyA/IF9hbGlnblBpeGVsKHRoaXMuY2hhcnQsIHBpeGVsLCAwKSA6IHBpeGVsKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcGFyYW0ge251bWJlcn0gcGl4ZWxcblx0ICogQHJldHVybiB7bnVtYmVyfVxuXHQgKi9cbiAgZ2V0RGVjaW1hbEZvclBpeGVsKHBpeGVsKSB7XG4gICAgY29uc3QgZGVjaW1hbCA9IChwaXhlbCAtIHRoaXMuX3N0YXJ0UGl4ZWwpIC8gdGhpcy5fbGVuZ3RoO1xuICAgIHJldHVybiB0aGlzLl9yZXZlcnNlUGl4ZWxzID8gMSAtIGRlY2ltYWwgOiBkZWNpbWFsO1xuICB9XG5cbiAgLyoqXG5cdCAqIFJldHVybnMgdGhlIHBpeGVsIGZvciB0aGUgbWluaW11bSBjaGFydCB2YWx1ZVxuXHQgKiBUaGUgY29vcmRpbmF0ZSAoMCwgMCkgaXMgYXQgdGhlIHVwcGVyLWxlZnQgY29ybmVyIG9mIHRoZSBjYW52YXNcblx0ICogQHJldHVybiB7bnVtYmVyfVxuXHQgKi9cbiAgZ2V0QmFzZVBpeGVsKCkge1xuICAgIHJldHVybiB0aGlzLmdldFBpeGVsRm9yVmFsdWUodGhpcy5nZXRCYXNlVmFsdWUoKSk7XG4gIH1cblxuICAvKipcblx0ICogQHJldHVybiB7bnVtYmVyfVxuXHQgKi9cbiAgZ2V0QmFzZVZhbHVlKCkge1xuICAgIGNvbnN0IHttaW4sIG1heH0gPSB0aGlzO1xuXG4gICAgcmV0dXJuIG1pbiA8IDAgJiYgbWF4IDwgMCA/IG1heCA6XG4gICAgICBtaW4gPiAwICYmIG1heCA+IDAgPyBtaW4gOlxuICAgICAgMDtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuICBnZXRDb250ZXh0KGluZGV4KSB7XG4gICAgY29uc3QgdGlja3MgPSB0aGlzLnRpY2tzIHx8IFtdO1xuXG4gICAgaWYgKGluZGV4ID49IDAgJiYgaW5kZXggPCB0aWNrcy5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IHRpY2sgPSB0aWNrc1tpbmRleF07XG4gICAgICByZXR1cm4gdGljay4kY29udGV4dCB8fFxuXHRcdFx0XHQodGljay4kY29udGV4dCA9IGNyZWF0ZVRpY2tDb250ZXh0KHRoaXMuZ2V0Q29udGV4dCgpLCBpbmRleCwgdGljaykpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy4kY29udGV4dCB8fFxuXHRcdFx0KHRoaXMuJGNvbnRleHQgPSBjcmVhdGVTY2FsZUNvbnRleHQodGhpcy5jaGFydC5nZXRDb250ZXh0KCksIHRoaXMpKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcmV0dXJuIHtudW1iZXJ9XG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfdGlja1NpemUoKSB7XG4gICAgY29uc3Qgb3B0aW9uVGlja3MgPSB0aGlzLm9wdGlvbnMudGlja3M7XG5cbiAgICAvLyBDYWxjdWxhdGUgc3BhY2UgbmVlZGVkIGJ5IGxhYmVsIGluIGF4aXMgZGlyZWN0aW9uLlxuICAgIGNvbnN0IHJvdCA9IHRvUmFkaWFucyh0aGlzLmxhYmVsUm90YXRpb24pO1xuICAgIGNvbnN0IGNvcyA9IE1hdGguYWJzKE1hdGguY29zKHJvdCkpO1xuICAgIGNvbnN0IHNpbiA9IE1hdGguYWJzKE1hdGguc2luKHJvdCkpO1xuXG4gICAgY29uc3QgbGFiZWxTaXplcyA9IHRoaXMuX2dldExhYmVsU2l6ZXMoKTtcbiAgICBjb25zdCBwYWRkaW5nID0gb3B0aW9uVGlja3MuYXV0b1NraXBQYWRkaW5nIHx8IDA7XG4gICAgY29uc3QgdyA9IGxhYmVsU2l6ZXMgPyBsYWJlbFNpemVzLndpZGVzdC53aWR0aCArIHBhZGRpbmcgOiAwO1xuICAgIGNvbnN0IGggPSBsYWJlbFNpemVzID8gbGFiZWxTaXplcy5oaWdoZXN0LmhlaWdodCArIHBhZGRpbmcgOiAwO1xuXG4gICAgLy8gQ2FsY3VsYXRlIHNwYWNlIG5lZWRlZCBmb3IgMSB0aWNrIGluIGF4aXMgZGlyZWN0aW9uLlxuICAgIHJldHVybiB0aGlzLmlzSG9yaXpvbnRhbCgpXG4gICAgICA/IGggKiBjb3MgPiB3ICogc2luID8gdyAvIGNvcyA6IGggLyBzaW5cbiAgICAgIDogaCAqIHNpbiA8IHcgKiBjb3MgPyBoIC8gY29zIDogdyAvIHNpbjtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcmV0dXJuIHtib29sZWFufVxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgX2lzVmlzaWJsZSgpIHtcbiAgICBjb25zdCBkaXNwbGF5ID0gdGhpcy5vcHRpb25zLmRpc3BsYXk7XG5cbiAgICBpZiAoZGlzcGxheSAhPT0gJ2F1dG8nKSB7XG4gICAgICByZXR1cm4gISFkaXNwbGF5O1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmdldE1hdGNoaW5nVmlzaWJsZU1ldGFzKCkubGVuZ3RoID4gMDtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgX2NvbXB1dGVHcmlkTGluZUl0ZW1zKGNoYXJ0QXJlYSkge1xuICAgIGNvbnN0IGF4aXMgPSB0aGlzLmF4aXM7XG4gICAgY29uc3QgY2hhcnQgPSB0aGlzLmNoYXJ0O1xuICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgY29uc3Qge2dyaWQsIHBvc2l0aW9uLCBib3JkZXJ9ID0gb3B0aW9ucztcbiAgICBjb25zdCBvZmZzZXQgPSBncmlkLm9mZnNldDtcbiAgICBjb25zdCBpc0hvcml6b250YWwgPSB0aGlzLmlzSG9yaXpvbnRhbCgpO1xuICAgIGNvbnN0IHRpY2tzID0gdGhpcy50aWNrcztcbiAgICBjb25zdCB0aWNrc0xlbmd0aCA9IHRpY2tzLmxlbmd0aCArIChvZmZzZXQgPyAxIDogMCk7XG4gICAgY29uc3QgdGwgPSBnZXRUaWNrTWFya0xlbmd0aChncmlkKTtcbiAgICBjb25zdCBpdGVtcyA9IFtdO1xuXG4gICAgY29uc3QgYm9yZGVyT3B0cyA9IGJvcmRlci5zZXRDb250ZXh0KHRoaXMuZ2V0Q29udGV4dCgpKTtcbiAgICBjb25zdCBheGlzV2lkdGggPSBib3JkZXJPcHRzLmRpc3BsYXkgPyBib3JkZXJPcHRzLndpZHRoIDogMDtcbiAgICBjb25zdCBheGlzSGFsZldpZHRoID0gYXhpc1dpZHRoIC8gMjtcbiAgICBjb25zdCBhbGlnbkJvcmRlclZhbHVlID0gZnVuY3Rpb24ocGl4ZWwpIHtcbiAgICAgIHJldHVybiBfYWxpZ25QaXhlbChjaGFydCwgcGl4ZWwsIGF4aXNXaWR0aCk7XG4gICAgfTtcbiAgICBsZXQgYm9yZGVyVmFsdWUsIGksIGxpbmVWYWx1ZSwgYWxpZ25lZExpbmVWYWx1ZTtcbiAgICBsZXQgdHgxLCB0eTEsIHR4MiwgdHkyLCB4MSwgeTEsIHgyLCB5MjtcblxuICAgIGlmIChwb3NpdGlvbiA9PT0gJ3RvcCcpIHtcbiAgICAgIGJvcmRlclZhbHVlID0gYWxpZ25Cb3JkZXJWYWx1ZSh0aGlzLmJvdHRvbSk7XG4gICAgICB0eTEgPSB0aGlzLmJvdHRvbSAtIHRsO1xuICAgICAgdHkyID0gYm9yZGVyVmFsdWUgLSBheGlzSGFsZldpZHRoO1xuICAgICAgeTEgPSBhbGlnbkJvcmRlclZhbHVlKGNoYXJ0QXJlYS50b3ApICsgYXhpc0hhbGZXaWR0aDtcbiAgICAgIHkyID0gY2hhcnRBcmVhLmJvdHRvbTtcbiAgICB9IGVsc2UgaWYgKHBvc2l0aW9uID09PSAnYm90dG9tJykge1xuICAgICAgYm9yZGVyVmFsdWUgPSBhbGlnbkJvcmRlclZhbHVlKHRoaXMudG9wKTtcbiAgICAgIHkxID0gY2hhcnRBcmVhLnRvcDtcbiAgICAgIHkyID0gYWxpZ25Cb3JkZXJWYWx1ZShjaGFydEFyZWEuYm90dG9tKSAtIGF4aXNIYWxmV2lkdGg7XG4gICAgICB0eTEgPSBib3JkZXJWYWx1ZSArIGF4aXNIYWxmV2lkdGg7XG4gICAgICB0eTIgPSB0aGlzLnRvcCArIHRsO1xuICAgIH0gZWxzZSBpZiAocG9zaXRpb24gPT09ICdsZWZ0Jykge1xuICAgICAgYm9yZGVyVmFsdWUgPSBhbGlnbkJvcmRlclZhbHVlKHRoaXMucmlnaHQpO1xuICAgICAgdHgxID0gdGhpcy5yaWdodCAtIHRsO1xuICAgICAgdHgyID0gYm9yZGVyVmFsdWUgLSBheGlzSGFsZldpZHRoO1xuICAgICAgeDEgPSBhbGlnbkJvcmRlclZhbHVlKGNoYXJ0QXJlYS5sZWZ0KSArIGF4aXNIYWxmV2lkdGg7XG4gICAgICB4MiA9IGNoYXJ0QXJlYS5yaWdodDtcbiAgICB9IGVsc2UgaWYgKHBvc2l0aW9uID09PSAncmlnaHQnKSB7XG4gICAgICBib3JkZXJWYWx1ZSA9IGFsaWduQm9yZGVyVmFsdWUodGhpcy5sZWZ0KTtcbiAgICAgIHgxID0gY2hhcnRBcmVhLmxlZnQ7XG4gICAgICB4MiA9IGFsaWduQm9yZGVyVmFsdWUoY2hhcnRBcmVhLnJpZ2h0KSAtIGF4aXNIYWxmV2lkdGg7XG4gICAgICB0eDEgPSBib3JkZXJWYWx1ZSArIGF4aXNIYWxmV2lkdGg7XG4gICAgICB0eDIgPSB0aGlzLmxlZnQgKyB0bDtcbiAgICB9IGVsc2UgaWYgKGF4aXMgPT09ICd4Jykge1xuICAgICAgaWYgKHBvc2l0aW9uID09PSAnY2VudGVyJykge1xuICAgICAgICBib3JkZXJWYWx1ZSA9IGFsaWduQm9yZGVyVmFsdWUoKGNoYXJ0QXJlYS50b3AgKyBjaGFydEFyZWEuYm90dG9tKSAvIDIgKyAwLjUpO1xuICAgICAgfSBlbHNlIGlmIChpc09iamVjdChwb3NpdGlvbikpIHtcbiAgICAgICAgY29uc3QgcG9zaXRpb25BeGlzSUQgPSBPYmplY3Qua2V5cyhwb3NpdGlvbilbMF07XG4gICAgICAgIGNvbnN0IHZhbHVlID0gcG9zaXRpb25bcG9zaXRpb25BeGlzSURdO1xuICAgICAgICBib3JkZXJWYWx1ZSA9IGFsaWduQm9yZGVyVmFsdWUodGhpcy5jaGFydC5zY2FsZXNbcG9zaXRpb25BeGlzSURdLmdldFBpeGVsRm9yVmFsdWUodmFsdWUpKTtcbiAgICAgIH1cblxuICAgICAgeTEgPSBjaGFydEFyZWEudG9wO1xuICAgICAgeTIgPSBjaGFydEFyZWEuYm90dG9tO1xuICAgICAgdHkxID0gYm9yZGVyVmFsdWUgKyBheGlzSGFsZldpZHRoO1xuICAgICAgdHkyID0gdHkxICsgdGw7XG4gICAgfSBlbHNlIGlmIChheGlzID09PSAneScpIHtcbiAgICAgIGlmIChwb3NpdGlvbiA9PT0gJ2NlbnRlcicpIHtcbiAgICAgICAgYm9yZGVyVmFsdWUgPSBhbGlnbkJvcmRlclZhbHVlKChjaGFydEFyZWEubGVmdCArIGNoYXJ0QXJlYS5yaWdodCkgLyAyKTtcbiAgICAgIH0gZWxzZSBpZiAoaXNPYmplY3QocG9zaXRpb24pKSB7XG4gICAgICAgIGNvbnN0IHBvc2l0aW9uQXhpc0lEID0gT2JqZWN0LmtleXMocG9zaXRpb24pWzBdO1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHBvc2l0aW9uW3Bvc2l0aW9uQXhpc0lEXTtcbiAgICAgICAgYm9yZGVyVmFsdWUgPSBhbGlnbkJvcmRlclZhbHVlKHRoaXMuY2hhcnQuc2NhbGVzW3Bvc2l0aW9uQXhpc0lEXS5nZXRQaXhlbEZvclZhbHVlKHZhbHVlKSk7XG4gICAgICB9XG5cbiAgICAgIHR4MSA9IGJvcmRlclZhbHVlIC0gYXhpc0hhbGZXaWR0aDtcbiAgICAgIHR4MiA9IHR4MSAtIHRsO1xuICAgICAgeDEgPSBjaGFydEFyZWEubGVmdDtcbiAgICAgIHgyID0gY2hhcnRBcmVhLnJpZ2h0O1xuICAgIH1cblxuICAgIGNvbnN0IGxpbWl0ID0gdmFsdWVPckRlZmF1bHQob3B0aW9ucy50aWNrcy5tYXhUaWNrc0xpbWl0LCB0aWNrc0xlbmd0aCk7XG4gICAgY29uc3Qgc3RlcCA9IE1hdGgubWF4KDEsIE1hdGguY2VpbCh0aWNrc0xlbmd0aCAvIGxpbWl0KSk7XG4gICAgZm9yIChpID0gMDsgaSA8IHRpY2tzTGVuZ3RoOyBpICs9IHN0ZXApIHtcbiAgICAgIGNvbnN0IGNvbnRleHQgPSB0aGlzLmdldENvbnRleHQoaSk7XG4gICAgICBjb25zdCBvcHRzQXRJbmRleCA9IGdyaWQuc2V0Q29udGV4dChjb250ZXh0KTtcbiAgICAgIGNvbnN0IG9wdHNBdEluZGV4Qm9yZGVyID0gYm9yZGVyLnNldENvbnRleHQoY29udGV4dCk7XG5cbiAgICAgIGNvbnN0IGxpbmVXaWR0aCA9IG9wdHNBdEluZGV4LmxpbmVXaWR0aDtcbiAgICAgIGNvbnN0IGxpbmVDb2xvciA9IG9wdHNBdEluZGV4LmNvbG9yO1xuICAgICAgY29uc3QgYm9yZGVyRGFzaCA9IG9wdHNBdEluZGV4Qm9yZGVyLmRhc2ggfHwgW107XG4gICAgICBjb25zdCBib3JkZXJEYXNoT2Zmc2V0ID0gb3B0c0F0SW5kZXhCb3JkZXIuZGFzaE9mZnNldDtcblxuICAgICAgY29uc3QgdGlja1dpZHRoID0gb3B0c0F0SW5kZXgudGlja1dpZHRoO1xuICAgICAgY29uc3QgdGlja0NvbG9yID0gb3B0c0F0SW5kZXgudGlja0NvbG9yO1xuICAgICAgY29uc3QgdGlja0JvcmRlckRhc2ggPSBvcHRzQXRJbmRleC50aWNrQm9yZGVyRGFzaCB8fCBbXTtcbiAgICAgIGNvbnN0IHRpY2tCb3JkZXJEYXNoT2Zmc2V0ID0gb3B0c0F0SW5kZXgudGlja0JvcmRlckRhc2hPZmZzZXQ7XG5cbiAgICAgIGxpbmVWYWx1ZSA9IGdldFBpeGVsRm9yR3JpZExpbmUodGhpcywgaSwgb2Zmc2V0KTtcblxuICAgICAgLy8gU2tpcCBpZiB0aGUgcGl4ZWwgaXMgb3V0IG9mIHRoZSByYW5nZVxuICAgICAgaWYgKGxpbmVWYWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBhbGlnbmVkTGluZVZhbHVlID0gX2FsaWduUGl4ZWwoY2hhcnQsIGxpbmVWYWx1ZSwgbGluZVdpZHRoKTtcblxuICAgICAgaWYgKGlzSG9yaXpvbnRhbCkge1xuICAgICAgICB0eDEgPSB0eDIgPSB4MSA9IHgyID0gYWxpZ25lZExpbmVWYWx1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHR5MSA9IHR5MiA9IHkxID0geTIgPSBhbGlnbmVkTGluZVZhbHVlO1xuICAgICAgfVxuXG4gICAgICBpdGVtcy5wdXNoKHtcbiAgICAgICAgdHgxLFxuICAgICAgICB0eTEsXG4gICAgICAgIHR4MixcbiAgICAgICAgdHkyLFxuICAgICAgICB4MSxcbiAgICAgICAgeTEsXG4gICAgICAgIHgyLFxuICAgICAgICB5MixcbiAgICAgICAgd2lkdGg6IGxpbmVXaWR0aCxcbiAgICAgICAgY29sb3I6IGxpbmVDb2xvcixcbiAgICAgICAgYm9yZGVyRGFzaCxcbiAgICAgICAgYm9yZGVyRGFzaE9mZnNldCxcbiAgICAgICAgdGlja1dpZHRoLFxuICAgICAgICB0aWNrQ29sb3IsXG4gICAgICAgIHRpY2tCb3JkZXJEYXNoLFxuICAgICAgICB0aWNrQm9yZGVyRGFzaE9mZnNldCxcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHRoaXMuX3RpY2tzTGVuZ3RoID0gdGlja3NMZW5ndGg7XG4gICAgdGhpcy5fYm9yZGVyVmFsdWUgPSBib3JkZXJWYWx1ZTtcblxuICAgIHJldHVybiBpdGVtcztcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgX2NvbXB1dGVMYWJlbEl0ZW1zKGNoYXJ0QXJlYSkge1xuICAgIGNvbnN0IGF4aXMgPSB0aGlzLmF4aXM7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICBjb25zdCB7cG9zaXRpb24sIHRpY2tzOiBvcHRpb25UaWNrc30gPSBvcHRpb25zO1xuICAgIGNvbnN0IGlzSG9yaXpvbnRhbCA9IHRoaXMuaXNIb3Jpem9udGFsKCk7XG4gICAgY29uc3QgdGlja3MgPSB0aGlzLnRpY2tzO1xuICAgIGNvbnN0IHthbGlnbiwgY3Jvc3NBbGlnbiwgcGFkZGluZywgbWlycm9yfSA9IG9wdGlvblRpY2tzO1xuICAgIGNvbnN0IHRsID0gZ2V0VGlja01hcmtMZW5ndGgob3B0aW9ucy5ncmlkKTtcbiAgICBjb25zdCB0aWNrQW5kUGFkZGluZyA9IHRsICsgcGFkZGluZztcbiAgICBjb25zdCBoVGlja0FuZFBhZGRpbmcgPSBtaXJyb3IgPyAtcGFkZGluZyA6IHRpY2tBbmRQYWRkaW5nO1xuICAgIGNvbnN0IHJvdGF0aW9uID0gLXRvUmFkaWFucyh0aGlzLmxhYmVsUm90YXRpb24pO1xuICAgIGNvbnN0IGl0ZW1zID0gW107XG4gICAgbGV0IGksIGlsZW4sIHRpY2ssIGxhYmVsLCB4LCB5LCB0ZXh0QWxpZ24sIHBpeGVsLCBmb250LCBsaW5lSGVpZ2h0LCBsaW5lQ291bnQsIHRleHRPZmZzZXQ7XG4gICAgbGV0IHRleHRCYXNlbGluZSA9ICdtaWRkbGUnO1xuXG4gICAgaWYgKHBvc2l0aW9uID09PSAndG9wJykge1xuICAgICAgeSA9IHRoaXMuYm90dG9tIC0gaFRpY2tBbmRQYWRkaW5nO1xuICAgICAgdGV4dEFsaWduID0gdGhpcy5fZ2V0WEF4aXNMYWJlbEFsaWdubWVudCgpO1xuICAgIH0gZWxzZSBpZiAocG9zaXRpb24gPT09ICdib3R0b20nKSB7XG4gICAgICB5ID0gdGhpcy50b3AgKyBoVGlja0FuZFBhZGRpbmc7XG4gICAgICB0ZXh0QWxpZ24gPSB0aGlzLl9nZXRYQXhpc0xhYmVsQWxpZ25tZW50KCk7XG4gICAgfSBlbHNlIGlmIChwb3NpdGlvbiA9PT0gJ2xlZnQnKSB7XG4gICAgICBjb25zdCByZXQgPSB0aGlzLl9nZXRZQXhpc0xhYmVsQWxpZ25tZW50KHRsKTtcbiAgICAgIHRleHRBbGlnbiA9IHJldC50ZXh0QWxpZ247XG4gICAgICB4ID0gcmV0Lng7XG4gICAgfSBlbHNlIGlmIChwb3NpdGlvbiA9PT0gJ3JpZ2h0Jykge1xuICAgICAgY29uc3QgcmV0ID0gdGhpcy5fZ2V0WUF4aXNMYWJlbEFsaWdubWVudCh0bCk7XG4gICAgICB0ZXh0QWxpZ24gPSByZXQudGV4dEFsaWduO1xuICAgICAgeCA9IHJldC54O1xuICAgIH0gZWxzZSBpZiAoYXhpcyA9PT0gJ3gnKSB7XG4gICAgICBpZiAocG9zaXRpb24gPT09ICdjZW50ZXInKSB7XG4gICAgICAgIHkgPSAoKGNoYXJ0QXJlYS50b3AgKyBjaGFydEFyZWEuYm90dG9tKSAvIDIpICsgdGlja0FuZFBhZGRpbmc7XG4gICAgICB9IGVsc2UgaWYgKGlzT2JqZWN0KHBvc2l0aW9uKSkge1xuICAgICAgICBjb25zdCBwb3NpdGlvbkF4aXNJRCA9IE9iamVjdC5rZXlzKHBvc2l0aW9uKVswXTtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBwb3NpdGlvbltwb3NpdGlvbkF4aXNJRF07XG4gICAgICAgIHkgPSB0aGlzLmNoYXJ0LnNjYWxlc1twb3NpdGlvbkF4aXNJRF0uZ2V0UGl4ZWxGb3JWYWx1ZSh2YWx1ZSkgKyB0aWNrQW5kUGFkZGluZztcbiAgICAgIH1cbiAgICAgIHRleHRBbGlnbiA9IHRoaXMuX2dldFhBeGlzTGFiZWxBbGlnbm1lbnQoKTtcbiAgICB9IGVsc2UgaWYgKGF4aXMgPT09ICd5Jykge1xuICAgICAgaWYgKHBvc2l0aW9uID09PSAnY2VudGVyJykge1xuICAgICAgICB4ID0gKChjaGFydEFyZWEubGVmdCArIGNoYXJ0QXJlYS5yaWdodCkgLyAyKSAtIHRpY2tBbmRQYWRkaW5nO1xuICAgICAgfSBlbHNlIGlmIChpc09iamVjdChwb3NpdGlvbikpIHtcbiAgICAgICAgY29uc3QgcG9zaXRpb25BeGlzSUQgPSBPYmplY3Qua2V5cyhwb3NpdGlvbilbMF07XG4gICAgICAgIGNvbnN0IHZhbHVlID0gcG9zaXRpb25bcG9zaXRpb25BeGlzSURdO1xuICAgICAgICB4ID0gdGhpcy5jaGFydC5zY2FsZXNbcG9zaXRpb25BeGlzSURdLmdldFBpeGVsRm9yVmFsdWUodmFsdWUpO1xuICAgICAgfVxuICAgICAgdGV4dEFsaWduID0gdGhpcy5fZ2V0WUF4aXNMYWJlbEFsaWdubWVudCh0bCkudGV4dEFsaWduO1xuICAgIH1cblxuICAgIGlmIChheGlzID09PSAneScpIHtcbiAgICAgIGlmIChhbGlnbiA9PT0gJ3N0YXJ0Jykge1xuICAgICAgICB0ZXh0QmFzZWxpbmUgPSAndG9wJztcbiAgICAgIH0gZWxzZSBpZiAoYWxpZ24gPT09ICdlbmQnKSB7XG4gICAgICAgIHRleHRCYXNlbGluZSA9ICdib3R0b20nO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IGxhYmVsU2l6ZXMgPSB0aGlzLl9nZXRMYWJlbFNpemVzKCk7XG4gICAgZm9yIChpID0gMCwgaWxlbiA9IHRpY2tzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgICAgdGljayA9IHRpY2tzW2ldO1xuICAgICAgbGFiZWwgPSB0aWNrLmxhYmVsO1xuXG4gICAgICBjb25zdCBvcHRzQXRJbmRleCA9IG9wdGlvblRpY2tzLnNldENvbnRleHQodGhpcy5nZXRDb250ZXh0KGkpKTtcbiAgICAgIHBpeGVsID0gdGhpcy5nZXRQaXhlbEZvclRpY2soaSkgKyBvcHRpb25UaWNrcy5sYWJlbE9mZnNldDtcbiAgICAgIGZvbnQgPSB0aGlzLl9yZXNvbHZlVGlja0ZvbnRPcHRpb25zKGkpO1xuICAgICAgbGluZUhlaWdodCA9IGZvbnQubGluZUhlaWdodDtcbiAgICAgIGxpbmVDb3VudCA9IGlzQXJyYXkobGFiZWwpID8gbGFiZWwubGVuZ3RoIDogMTtcbiAgICAgIGNvbnN0IGhhbGZDb3VudCA9IGxpbmVDb3VudCAvIDI7XG4gICAgICBjb25zdCBjb2xvciA9IG9wdHNBdEluZGV4LmNvbG9yO1xuICAgICAgY29uc3Qgc3Ryb2tlQ29sb3IgPSBvcHRzQXRJbmRleC50ZXh0U3Ryb2tlQ29sb3I7XG4gICAgICBjb25zdCBzdHJva2VXaWR0aCA9IG9wdHNBdEluZGV4LnRleHRTdHJva2VXaWR0aDtcbiAgICAgIGxldCB0aWNrVGV4dEFsaWduID0gdGV4dEFsaWduO1xuXG4gICAgICBpZiAoaXNIb3Jpem9udGFsKSB7XG4gICAgICAgIHggPSBwaXhlbDtcblxuICAgICAgICBpZiAodGV4dEFsaWduID09PSAnaW5uZXInKSB7XG4gICAgICAgICAgaWYgKGkgPT09IGlsZW4gLSAxKSB7XG4gICAgICAgICAgICB0aWNrVGV4dEFsaWduID0gIXRoaXMub3B0aW9ucy5yZXZlcnNlID8gJ3JpZ2h0JyA6ICdsZWZ0JztcbiAgICAgICAgICB9IGVsc2UgaWYgKGkgPT09IDApIHtcbiAgICAgICAgICAgIHRpY2tUZXh0QWxpZ24gPSAhdGhpcy5vcHRpb25zLnJldmVyc2UgPyAnbGVmdCcgOiAncmlnaHQnO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aWNrVGV4dEFsaWduID0gJ2NlbnRlcic7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHBvc2l0aW9uID09PSAndG9wJykge1xuICAgICAgICAgIGlmIChjcm9zc0FsaWduID09PSAnbmVhcicgfHwgcm90YXRpb24gIT09IDApIHtcbiAgICAgICAgICAgIHRleHRPZmZzZXQgPSAtbGluZUNvdW50ICogbGluZUhlaWdodCArIGxpbmVIZWlnaHQgLyAyO1xuICAgICAgICAgIH0gZWxzZSBpZiAoY3Jvc3NBbGlnbiA9PT0gJ2NlbnRlcicpIHtcbiAgICAgICAgICAgIHRleHRPZmZzZXQgPSAtbGFiZWxTaXplcy5oaWdoZXN0LmhlaWdodCAvIDIgLSBoYWxmQ291bnQgKiBsaW5lSGVpZ2h0ICsgbGluZUhlaWdodDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGV4dE9mZnNldCA9IC1sYWJlbFNpemVzLmhpZ2hlc3QuaGVpZ2h0ICsgbGluZUhlaWdodCAvIDI7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1sb25lbHktaWZcbiAgICAgICAgICBpZiAoY3Jvc3NBbGlnbiA9PT0gJ25lYXInIHx8IHJvdGF0aW9uICE9PSAwKSB7XG4gICAgICAgICAgICB0ZXh0T2Zmc2V0ID0gbGluZUhlaWdodCAvIDI7XG4gICAgICAgICAgfSBlbHNlIGlmIChjcm9zc0FsaWduID09PSAnY2VudGVyJykge1xuICAgICAgICAgICAgdGV4dE9mZnNldCA9IGxhYmVsU2l6ZXMuaGlnaGVzdC5oZWlnaHQgLyAyIC0gaGFsZkNvdW50ICogbGluZUhlaWdodDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGV4dE9mZnNldCA9IGxhYmVsU2l6ZXMuaGlnaGVzdC5oZWlnaHQgLSBsaW5lQ291bnQgKiBsaW5lSGVpZ2h0O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAobWlycm9yKSB7XG4gICAgICAgICAgdGV4dE9mZnNldCAqPSAtMTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocm90YXRpb24gIT09IDAgJiYgIW9wdHNBdEluZGV4LnNob3dMYWJlbEJhY2tkcm9wKSB7XG4gICAgICAgICAgeCArPSAobGluZUhlaWdodCAvIDIpICogTWF0aC5zaW4ocm90YXRpb24pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB5ID0gcGl4ZWw7XG4gICAgICAgIHRleHRPZmZzZXQgPSAoMSAtIGxpbmVDb3VudCkgKiBsaW5lSGVpZ2h0IC8gMjtcbiAgICAgIH1cblxuICAgICAgbGV0IGJhY2tkcm9wO1xuXG4gICAgICBpZiAob3B0c0F0SW5kZXguc2hvd0xhYmVsQmFja2Ryb3ApIHtcbiAgICAgICAgY29uc3QgbGFiZWxQYWRkaW5nID0gdG9QYWRkaW5nKG9wdHNBdEluZGV4LmJhY2tkcm9wUGFkZGluZyk7XG4gICAgICAgIGNvbnN0IGhlaWdodCA9IGxhYmVsU2l6ZXMuaGVpZ2h0c1tpXTtcbiAgICAgICAgY29uc3Qgd2lkdGggPSBsYWJlbFNpemVzLndpZHRoc1tpXTtcblxuICAgICAgICBsZXQgdG9wID0gdGV4dE9mZnNldCAtIGxhYmVsUGFkZGluZy50b3A7XG4gICAgICAgIGxldCBsZWZ0ID0gMCAtIGxhYmVsUGFkZGluZy5sZWZ0O1xuXG4gICAgICAgIHN3aXRjaCAodGV4dEJhc2VsaW5lKSB7XG4gICAgICAgIGNhc2UgJ21pZGRsZSc6XG4gICAgICAgICAgdG9wIC09IGhlaWdodCAvIDI7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2JvdHRvbSc6XG4gICAgICAgICAgdG9wIC09IGhlaWdodDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIHN3aXRjaCAodGV4dEFsaWduKSB7XG4gICAgICAgIGNhc2UgJ2NlbnRlcic6XG4gICAgICAgICAgbGVmdCAtPSB3aWR0aCAvIDI7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3JpZ2h0JzpcbiAgICAgICAgICBsZWZ0IC09IHdpZHRoO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdpbm5lcic6XG4gICAgICAgICAgaWYgKGkgPT09IGlsZW4gLSAxKSB7XG4gICAgICAgICAgICBsZWZ0IC09IHdpZHRoO1xuICAgICAgICAgIH0gZWxzZSBpZiAoaSA+IDApIHtcbiAgICAgICAgICAgIGxlZnQgLT0gd2lkdGggLyAyO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIGJhY2tkcm9wID0ge1xuICAgICAgICAgIGxlZnQsXG4gICAgICAgICAgdG9wLFxuICAgICAgICAgIHdpZHRoOiB3aWR0aCArIGxhYmVsUGFkZGluZy53aWR0aCxcbiAgICAgICAgICBoZWlnaHQ6IGhlaWdodCArIGxhYmVsUGFkZGluZy5oZWlnaHQsXG5cbiAgICAgICAgICBjb2xvcjogb3B0c0F0SW5kZXguYmFja2Ryb3BDb2xvcixcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgaXRlbXMucHVzaCh7XG4gICAgICAgIGxhYmVsLFxuICAgICAgICBmb250LFxuICAgICAgICB0ZXh0T2Zmc2V0LFxuICAgICAgICBvcHRpb25zOiB7XG4gICAgICAgICAgcm90YXRpb24sXG4gICAgICAgICAgY29sb3IsXG4gICAgICAgICAgc3Ryb2tlQ29sb3IsXG4gICAgICAgICAgc3Ryb2tlV2lkdGgsXG4gICAgICAgICAgdGV4dEFsaWduOiB0aWNrVGV4dEFsaWduLFxuICAgICAgICAgIHRleHRCYXNlbGluZSxcbiAgICAgICAgICB0cmFuc2xhdGlvbjogW3gsIHldLFxuICAgICAgICAgIGJhY2tkcm9wLFxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gaXRlbXM7XG4gIH1cblxuICBfZ2V0WEF4aXNMYWJlbEFsaWdubWVudCgpIHtcbiAgICBjb25zdCB7cG9zaXRpb24sIHRpY2tzfSA9IHRoaXMub3B0aW9ucztcbiAgICBjb25zdCByb3RhdGlvbiA9IC10b1JhZGlhbnModGhpcy5sYWJlbFJvdGF0aW9uKTtcblxuICAgIGlmIChyb3RhdGlvbikge1xuICAgICAgcmV0dXJuIHBvc2l0aW9uID09PSAndG9wJyA/ICdsZWZ0JyA6ICdyaWdodCc7XG4gICAgfVxuXG4gICAgbGV0IGFsaWduID0gJ2NlbnRlcic7XG5cbiAgICBpZiAodGlja3MuYWxpZ24gPT09ICdzdGFydCcpIHtcbiAgICAgIGFsaWduID0gJ2xlZnQnO1xuICAgIH0gZWxzZSBpZiAodGlja3MuYWxpZ24gPT09ICdlbmQnKSB7XG4gICAgICBhbGlnbiA9ICdyaWdodCc7XG4gICAgfSBlbHNlIGlmICh0aWNrcy5hbGlnbiA9PT0gJ2lubmVyJykge1xuICAgICAgYWxpZ24gPSAnaW5uZXInO1xuICAgIH1cblxuICAgIHJldHVybiBhbGlnbjtcbiAgfVxuXG4gIF9nZXRZQXhpc0xhYmVsQWxpZ25tZW50KHRsKSB7XG4gICAgY29uc3Qge3Bvc2l0aW9uLCB0aWNrczoge2Nyb3NzQWxpZ24sIG1pcnJvciwgcGFkZGluZ319ID0gdGhpcy5vcHRpb25zO1xuICAgIGNvbnN0IGxhYmVsU2l6ZXMgPSB0aGlzLl9nZXRMYWJlbFNpemVzKCk7XG4gICAgY29uc3QgdGlja0FuZFBhZGRpbmcgPSB0bCArIHBhZGRpbmc7XG4gICAgY29uc3Qgd2lkZXN0ID0gbGFiZWxTaXplcy53aWRlc3Qud2lkdGg7XG5cbiAgICBsZXQgdGV4dEFsaWduO1xuICAgIGxldCB4O1xuXG4gICAgaWYgKHBvc2l0aW9uID09PSAnbGVmdCcpIHtcbiAgICAgIGlmIChtaXJyb3IpIHtcbiAgICAgICAgeCA9IHRoaXMucmlnaHQgKyBwYWRkaW5nO1xuXG4gICAgICAgIGlmIChjcm9zc0FsaWduID09PSAnbmVhcicpIHtcbiAgICAgICAgICB0ZXh0QWxpZ24gPSAnbGVmdCc7XG4gICAgICAgIH0gZWxzZSBpZiAoY3Jvc3NBbGlnbiA9PT0gJ2NlbnRlcicpIHtcbiAgICAgICAgICB0ZXh0QWxpZ24gPSAnY2VudGVyJztcbiAgICAgICAgICB4ICs9ICh3aWRlc3QgLyAyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0ZXh0QWxpZ24gPSAncmlnaHQnO1xuICAgICAgICAgIHggKz0gd2lkZXN0O1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB4ID0gdGhpcy5yaWdodCAtIHRpY2tBbmRQYWRkaW5nO1xuXG4gICAgICAgIGlmIChjcm9zc0FsaWduID09PSAnbmVhcicpIHtcbiAgICAgICAgICB0ZXh0QWxpZ24gPSAncmlnaHQnO1xuICAgICAgICB9IGVsc2UgaWYgKGNyb3NzQWxpZ24gPT09ICdjZW50ZXInKSB7XG4gICAgICAgICAgdGV4dEFsaWduID0gJ2NlbnRlcic7XG4gICAgICAgICAgeCAtPSAod2lkZXN0IC8gMik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGV4dEFsaWduID0gJ2xlZnQnO1xuICAgICAgICAgIHggPSB0aGlzLmxlZnQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHBvc2l0aW9uID09PSAncmlnaHQnKSB7XG4gICAgICBpZiAobWlycm9yKSB7XG4gICAgICAgIHggPSB0aGlzLmxlZnQgKyBwYWRkaW5nO1xuXG4gICAgICAgIGlmIChjcm9zc0FsaWduID09PSAnbmVhcicpIHtcbiAgICAgICAgICB0ZXh0QWxpZ24gPSAncmlnaHQnO1xuICAgICAgICB9IGVsc2UgaWYgKGNyb3NzQWxpZ24gPT09ICdjZW50ZXInKSB7XG4gICAgICAgICAgdGV4dEFsaWduID0gJ2NlbnRlcic7XG4gICAgICAgICAgeCAtPSAod2lkZXN0IC8gMik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGV4dEFsaWduID0gJ2xlZnQnO1xuICAgICAgICAgIHggLT0gd2lkZXN0O1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB4ID0gdGhpcy5sZWZ0ICsgdGlja0FuZFBhZGRpbmc7XG5cbiAgICAgICAgaWYgKGNyb3NzQWxpZ24gPT09ICduZWFyJykge1xuICAgICAgICAgIHRleHRBbGlnbiA9ICdsZWZ0JztcbiAgICAgICAgfSBlbHNlIGlmIChjcm9zc0FsaWduID09PSAnY2VudGVyJykge1xuICAgICAgICAgIHRleHRBbGlnbiA9ICdjZW50ZXInO1xuICAgICAgICAgIHggKz0gd2lkZXN0IC8gMjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0ZXh0QWxpZ24gPSAncmlnaHQnO1xuICAgICAgICAgIHggPSB0aGlzLnJpZ2h0O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRleHRBbGlnbiA9ICdyaWdodCc7XG4gICAgfVxuXG4gICAgcmV0dXJuIHt0ZXh0QWxpZ24sIHh9O1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfY29tcHV0ZUxhYmVsQXJlYSgpIHtcbiAgICBpZiAodGhpcy5vcHRpb25zLnRpY2tzLm1pcnJvcikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IGNoYXJ0ID0gdGhpcy5jaGFydDtcbiAgICBjb25zdCBwb3NpdGlvbiA9IHRoaXMub3B0aW9ucy5wb3NpdGlvbjtcblxuICAgIGlmIChwb3NpdGlvbiA9PT0gJ2xlZnQnIHx8IHBvc2l0aW9uID09PSAncmlnaHQnKSB7XG4gICAgICByZXR1cm4ge3RvcDogMCwgbGVmdDogdGhpcy5sZWZ0LCBib3R0b206IGNoYXJ0LmhlaWdodCwgcmlnaHQ6IHRoaXMucmlnaHR9O1xuICAgIH0gaWYgKHBvc2l0aW9uID09PSAndG9wJyB8fCBwb3NpdGlvbiA9PT0gJ2JvdHRvbScpIHtcbiAgICAgIHJldHVybiB7dG9wOiB0aGlzLnRvcCwgbGVmdDogMCwgYm90dG9tOiB0aGlzLmJvdHRvbSwgcmlnaHQ6IGNoYXJ0LndpZHRofTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHByb3RlY3RlZFxuICAgKi9cbiAgZHJhd0JhY2tncm91bmQoKSB7XG4gICAgY29uc3Qge2N0eCwgb3B0aW9uczoge2JhY2tncm91bmRDb2xvcn0sIGxlZnQsIHRvcCwgd2lkdGgsIGhlaWdodH0gPSB0aGlzO1xuICAgIGlmIChiYWNrZ3JvdW5kQ29sb3IpIHtcbiAgICAgIGN0eC5zYXZlKCk7XG4gICAgICBjdHguZmlsbFN0eWxlID0gYmFja2dyb3VuZENvbG9yO1xuICAgICAgY3R4LmZpbGxSZWN0KGxlZnQsIHRvcCwgd2lkdGgsIGhlaWdodCk7XG4gICAgICBjdHgucmVzdG9yZSgpO1xuICAgIH1cbiAgfVxuXG4gIGdldExpbmVXaWR0aEZvclZhbHVlKHZhbHVlKSB7XG4gICAgY29uc3QgZ3JpZCA9IHRoaXMub3B0aW9ucy5ncmlkO1xuICAgIGlmICghdGhpcy5faXNWaXNpYmxlKCkgfHwgIWdyaWQuZGlzcGxheSkge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIGNvbnN0IHRpY2tzID0gdGhpcy50aWNrcztcbiAgICBjb25zdCBpbmRleCA9IHRpY2tzLmZpbmRJbmRleCh0ID0+IHQudmFsdWUgPT09IHZhbHVlKTtcbiAgICBpZiAoaW5kZXggPj0gMCkge1xuICAgICAgY29uc3Qgb3B0cyA9IGdyaWQuc2V0Q29udGV4dCh0aGlzLmdldENvbnRleHQoaW5kZXgpKTtcbiAgICAgIHJldHVybiBvcHRzLmxpbmVXaWR0aDtcbiAgICB9XG4gICAgcmV0dXJuIDA7XG4gIH1cblxuICAvKipcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cbiAgZHJhd0dyaWQoY2hhcnRBcmVhKSB7XG4gICAgY29uc3QgZ3JpZCA9IHRoaXMub3B0aW9ucy5ncmlkO1xuICAgIGNvbnN0IGN0eCA9IHRoaXMuY3R4O1xuICAgIGNvbnN0IGl0ZW1zID0gdGhpcy5fZ3JpZExpbmVJdGVtcyB8fCAodGhpcy5fZ3JpZExpbmVJdGVtcyA9IHRoaXMuX2NvbXB1dGVHcmlkTGluZUl0ZW1zKGNoYXJ0QXJlYSkpO1xuICAgIGxldCBpLCBpbGVuO1xuXG4gICAgY29uc3QgZHJhd0xpbmUgPSAocDEsIHAyLCBzdHlsZSkgPT4ge1xuICAgICAgaWYgKCFzdHlsZS53aWR0aCB8fCAhc3R5bGUuY29sb3IpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY3R4LnNhdmUoKTtcbiAgICAgIGN0eC5saW5lV2lkdGggPSBzdHlsZS53aWR0aDtcbiAgICAgIGN0eC5zdHJva2VTdHlsZSA9IHN0eWxlLmNvbG9yO1xuICAgICAgY3R4LnNldExpbmVEYXNoKHN0eWxlLmJvcmRlckRhc2ggfHwgW10pO1xuICAgICAgY3R4LmxpbmVEYXNoT2Zmc2V0ID0gc3R5bGUuYm9yZGVyRGFzaE9mZnNldDtcblxuICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgY3R4Lm1vdmVUbyhwMS54LCBwMS55KTtcbiAgICAgIGN0eC5saW5lVG8ocDIueCwgcDIueSk7XG4gICAgICBjdHguc3Ryb2tlKCk7XG4gICAgICBjdHgucmVzdG9yZSgpO1xuICAgIH07XG5cbiAgICBpZiAoZ3JpZC5kaXNwbGF5KSB7XG4gICAgICBmb3IgKGkgPSAwLCBpbGVuID0gaXRlbXMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgICAgIGNvbnN0IGl0ZW0gPSBpdGVtc1tpXTtcblxuICAgICAgICBpZiAoZ3JpZC5kcmF3T25DaGFydEFyZWEpIHtcbiAgICAgICAgICBkcmF3TGluZShcbiAgICAgICAgICAgIHt4OiBpdGVtLngxLCB5OiBpdGVtLnkxfSxcbiAgICAgICAgICAgIHt4OiBpdGVtLngyLCB5OiBpdGVtLnkyfSxcbiAgICAgICAgICAgIGl0ZW1cbiAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGdyaWQuZHJhd1RpY2tzKSB7XG4gICAgICAgICAgZHJhd0xpbmUoXG4gICAgICAgICAgICB7eDogaXRlbS50eDEsIHk6IGl0ZW0udHkxfSxcbiAgICAgICAgICAgIHt4OiBpdGVtLnR4MiwgeTogaXRlbS50eTJ9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBjb2xvcjogaXRlbS50aWNrQ29sb3IsXG4gICAgICAgICAgICAgIHdpZHRoOiBpdGVtLnRpY2tXaWR0aCxcbiAgICAgICAgICAgICAgYm9yZGVyRGFzaDogaXRlbS50aWNrQm9yZGVyRGFzaCxcbiAgICAgICAgICAgICAgYm9yZGVyRGFzaE9mZnNldDogaXRlbS50aWNrQm9yZGVyRGFzaE9mZnNldFxuICAgICAgICAgICAgfVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cbiAgZHJhd0JvcmRlcigpIHtcbiAgICBjb25zdCB7Y2hhcnQsIGN0eCwgb3B0aW9uczoge2JvcmRlciwgZ3JpZH19ID0gdGhpcztcbiAgICBjb25zdCBib3JkZXJPcHRzID0gYm9yZGVyLnNldENvbnRleHQodGhpcy5nZXRDb250ZXh0KCkpO1xuICAgIGNvbnN0IGF4aXNXaWR0aCA9IGJvcmRlci5kaXNwbGF5ID8gYm9yZGVyT3B0cy53aWR0aCA6IDA7XG4gICAgaWYgKCFheGlzV2lkdGgpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgbGFzdExpbmVXaWR0aCA9IGdyaWQuc2V0Q29udGV4dCh0aGlzLmdldENvbnRleHQoMCkpLmxpbmVXaWR0aDtcbiAgICBjb25zdCBib3JkZXJWYWx1ZSA9IHRoaXMuX2JvcmRlclZhbHVlO1xuICAgIGxldCB4MSwgeDIsIHkxLCB5MjtcblxuICAgIGlmICh0aGlzLmlzSG9yaXpvbnRhbCgpKSB7XG4gICAgICB4MSA9IF9hbGlnblBpeGVsKGNoYXJ0LCB0aGlzLmxlZnQsIGF4aXNXaWR0aCkgLSBheGlzV2lkdGggLyAyO1xuICAgICAgeDIgPSBfYWxpZ25QaXhlbChjaGFydCwgdGhpcy5yaWdodCwgbGFzdExpbmVXaWR0aCkgKyBsYXN0TGluZVdpZHRoIC8gMjtcbiAgICAgIHkxID0geTIgPSBib3JkZXJWYWx1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgeTEgPSBfYWxpZ25QaXhlbChjaGFydCwgdGhpcy50b3AsIGF4aXNXaWR0aCkgLSBheGlzV2lkdGggLyAyO1xuICAgICAgeTIgPSBfYWxpZ25QaXhlbChjaGFydCwgdGhpcy5ib3R0b20sIGxhc3RMaW5lV2lkdGgpICsgbGFzdExpbmVXaWR0aCAvIDI7XG4gICAgICB4MSA9IHgyID0gYm9yZGVyVmFsdWU7XG4gICAgfVxuICAgIGN0eC5zYXZlKCk7XG4gICAgY3R4LmxpbmVXaWR0aCA9IGJvcmRlck9wdHMud2lkdGg7XG4gICAgY3R4LnN0cm9rZVN0eWxlID0gYm9yZGVyT3B0cy5jb2xvcjtcblxuICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICBjdHgubW92ZVRvKHgxLCB5MSk7XG4gICAgY3R4LmxpbmVUbyh4MiwgeTIpO1xuICAgIGN0eC5zdHJva2UoKTtcblxuICAgIGN0eC5yZXN0b3JlKCk7XG4gIH1cblxuICAvKipcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cbiAgZHJhd0xhYmVscyhjaGFydEFyZWEpIHtcbiAgICBjb25zdCBvcHRpb25UaWNrcyA9IHRoaXMub3B0aW9ucy50aWNrcztcblxuICAgIGlmICghb3B0aW9uVGlja3MuZGlzcGxheSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IGN0eCA9IHRoaXMuY3R4O1xuXG4gICAgY29uc3QgYXJlYSA9IHRoaXMuX2NvbXB1dGVMYWJlbEFyZWEoKTtcbiAgICBpZiAoYXJlYSkge1xuICAgICAgY2xpcEFyZWEoY3R4LCBhcmVhKTtcbiAgICB9XG5cbiAgICBjb25zdCBpdGVtcyA9IHRoaXMuZ2V0TGFiZWxJdGVtcyhjaGFydEFyZWEpO1xuICAgIGZvciAoY29uc3QgaXRlbSBvZiBpdGVtcykge1xuICAgICAgY29uc3QgcmVuZGVyVGV4dE9wdGlvbnMgPSBpdGVtLm9wdGlvbnM7XG4gICAgICBjb25zdCB0aWNrRm9udCA9IGl0ZW0uZm9udDtcbiAgICAgIGNvbnN0IGxhYmVsID0gaXRlbS5sYWJlbDtcbiAgICAgIGNvbnN0IHkgPSBpdGVtLnRleHRPZmZzZXQ7XG4gICAgICByZW5kZXJUZXh0KGN0eCwgbGFiZWwsIDAsIHksIHRpY2tGb250LCByZW5kZXJUZXh0T3B0aW9ucyk7XG4gICAgfVxuXG4gICAgaWYgKGFyZWEpIHtcbiAgICAgIHVuY2xpcEFyZWEoY3R4KTtcbiAgICB9XG4gIH1cblxuICAvKipcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cbiAgZHJhd1RpdGxlKCkge1xuICAgIGNvbnN0IHtjdHgsIG9wdGlvbnM6IHtwb3NpdGlvbiwgdGl0bGUsIHJldmVyc2V9fSA9IHRoaXM7XG5cbiAgICBpZiAoIXRpdGxlLmRpc3BsYXkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBmb250ID0gdG9Gb250KHRpdGxlLmZvbnQpO1xuICAgIGNvbnN0IHBhZGRpbmcgPSB0b1BhZGRpbmcodGl0bGUucGFkZGluZyk7XG4gICAgY29uc3QgYWxpZ24gPSB0aXRsZS5hbGlnbjtcbiAgICBsZXQgb2Zmc2V0ID0gZm9udC5saW5lSGVpZ2h0IC8gMjtcblxuICAgIGlmIChwb3NpdGlvbiA9PT0gJ2JvdHRvbScgfHwgcG9zaXRpb24gPT09ICdjZW50ZXInIHx8IGlzT2JqZWN0KHBvc2l0aW9uKSkge1xuICAgICAgb2Zmc2V0ICs9IHBhZGRpbmcuYm90dG9tO1xuICAgICAgaWYgKGlzQXJyYXkodGl0bGUudGV4dCkpIHtcbiAgICAgICAgb2Zmc2V0ICs9IGZvbnQubGluZUhlaWdodCAqICh0aXRsZS50ZXh0Lmxlbmd0aCAtIDEpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBvZmZzZXQgKz0gcGFkZGluZy50b3A7XG4gICAgfVxuXG4gICAgY29uc3Qge3RpdGxlWCwgdGl0bGVZLCBtYXhXaWR0aCwgcm90YXRpb259ID0gdGl0bGVBcmdzKHRoaXMsIG9mZnNldCwgcG9zaXRpb24sIGFsaWduKTtcblxuICAgIHJlbmRlclRleHQoY3R4LCB0aXRsZS50ZXh0LCAwLCAwLCBmb250LCB7XG4gICAgICBjb2xvcjogdGl0bGUuY29sb3IsXG4gICAgICBtYXhXaWR0aCxcbiAgICAgIHJvdGF0aW9uLFxuICAgICAgdGV4dEFsaWduOiB0aXRsZUFsaWduKGFsaWduLCBwb3NpdGlvbiwgcmV2ZXJzZSksXG4gICAgICB0ZXh0QmFzZWxpbmU6ICdtaWRkbGUnLFxuICAgICAgdHJhbnNsYXRpb246IFt0aXRsZVgsIHRpdGxlWV0sXG4gICAgfSk7XG4gIH1cblxuICBkcmF3KGNoYXJ0QXJlYSkge1xuICAgIGlmICghdGhpcy5faXNWaXNpYmxlKCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLmRyYXdCYWNrZ3JvdW5kKCk7XG4gICAgdGhpcy5kcmF3R3JpZChjaGFydEFyZWEpO1xuICAgIHRoaXMuZHJhd0JvcmRlcigpO1xuICAgIHRoaXMuZHJhd1RpdGxlKCk7XG4gICAgdGhpcy5kcmF3TGFiZWxzKGNoYXJ0QXJlYSk7XG4gIH1cblxuICAvKipcblx0ICogQHJldHVybiB7b2JqZWN0W119XG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfbGF5ZXJzKCkge1xuICAgIGNvbnN0IG9wdHMgPSB0aGlzLm9wdGlvbnM7XG4gICAgY29uc3QgdHogPSBvcHRzLnRpY2tzICYmIG9wdHMudGlja3MueiB8fCAwO1xuICAgIGNvbnN0IGd6ID0gdmFsdWVPckRlZmF1bHQob3B0cy5ncmlkICYmIG9wdHMuZ3JpZC56LCAtMSk7XG4gICAgY29uc3QgYnogPSB2YWx1ZU9yRGVmYXVsdChvcHRzLmJvcmRlciAmJiBvcHRzLmJvcmRlci56LCAwKTtcblxuICAgIGlmICghdGhpcy5faXNWaXNpYmxlKCkgfHwgdGhpcy5kcmF3ICE9PSBTY2FsZS5wcm90b3R5cGUuZHJhdykge1xuICAgICAgLy8gYmFja3dhcmQgY29tcGF0aWJpbGl0eTogZHJhdyBoYXMgYmVlbiBvdmVycmlkZGVuIGJ5IGN1c3RvbSBzY2FsZVxuICAgICAgcmV0dXJuIFt7XG4gICAgICAgIHo6IHR6LFxuICAgICAgICBkcmF3OiAoY2hhcnRBcmVhKSA9PiB7XG4gICAgICAgICAgdGhpcy5kcmF3KGNoYXJ0QXJlYSk7XG4gICAgICAgIH1cbiAgICAgIH1dO1xuICAgIH1cblxuICAgIHJldHVybiBbe1xuICAgICAgejogZ3osXG4gICAgICBkcmF3OiAoY2hhcnRBcmVhKSA9PiB7XG4gICAgICAgIHRoaXMuZHJhd0JhY2tncm91bmQoKTtcbiAgICAgICAgdGhpcy5kcmF3R3JpZChjaGFydEFyZWEpO1xuICAgICAgICB0aGlzLmRyYXdUaXRsZSgpO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIHo6IGJ6LFxuICAgICAgZHJhdzogKCkgPT4ge1xuICAgICAgICB0aGlzLmRyYXdCb3JkZXIoKTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICB6OiB0eixcbiAgICAgIGRyYXc6IChjaGFydEFyZWEpID0+IHtcbiAgICAgICAgdGhpcy5kcmF3TGFiZWxzKGNoYXJ0QXJlYSk7XG4gICAgICB9XG4gICAgfV07XG4gIH1cblxuICAvKipcblx0ICogUmV0dXJucyB2aXNpYmxlIGRhdGFzZXQgbWV0YXMgdGhhdCBhcmUgYXR0YWNoZWQgdG8gdGhpcyBzY2FsZVxuXHQgKiBAcGFyYW0ge3N0cmluZ30gW3R5cGVdIC0gaWYgc3BlY2lmaWVkLCBhbHNvIGZpbHRlciBieSBkYXRhc2V0IHR5cGVcblx0ICogQHJldHVybiB7b2JqZWN0W119XG5cdCAqL1xuICBnZXRNYXRjaGluZ1Zpc2libGVNZXRhcyh0eXBlKSB7XG4gICAgY29uc3QgbWV0YXMgPSB0aGlzLmNoYXJ0LmdldFNvcnRlZFZpc2libGVEYXRhc2V0TWV0YXMoKTtcbiAgICBjb25zdCBheGlzSUQgPSB0aGlzLmF4aXMgKyAnQXhpc0lEJztcbiAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICBsZXQgaSwgaWxlbjtcblxuICAgIGZvciAoaSA9IDAsIGlsZW4gPSBtZXRhcy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICAgIGNvbnN0IG1ldGEgPSBtZXRhc1tpXTtcbiAgICAgIGlmIChtZXRhW2F4aXNJRF0gPT09IHRoaXMuaWQgJiYgKCF0eXBlIHx8IG1ldGEudHlwZSA9PT0gdHlwZSkpIHtcbiAgICAgICAgcmVzdWx0LnB1c2gobWV0YSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKipcblx0ICogQHBhcmFtIHtudW1iZXJ9IGluZGV4XG5cdCAqIEByZXR1cm4ge29iamVjdH1cblx0ICogQHByb3RlY3RlZFxuIFx0ICovXG4gIF9yZXNvbHZlVGlja0ZvbnRPcHRpb25zKGluZGV4KSB7XG4gICAgY29uc3Qgb3B0cyA9IHRoaXMub3B0aW9ucy50aWNrcy5zZXRDb250ZXh0KHRoaXMuZ2V0Q29udGV4dChpbmRleCkpO1xuICAgIHJldHVybiB0b0ZvbnQob3B0cy5mb250KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuICBfbWF4RGlnaXRzKCkge1xuICAgIGNvbnN0IGZvbnRTaXplID0gdGhpcy5fcmVzb2x2ZVRpY2tGb250T3B0aW9ucygwKS5saW5lSGVpZ2h0O1xuICAgIHJldHVybiAodGhpcy5pc0hvcml6b250YWwoKSA/IHRoaXMud2lkdGggOiB0aGlzLmhlaWdodCkgLyBmb250U2l6ZTtcbiAgfVxufVxuIiwgImltcG9ydCB7bWVyZ2V9IGZyb20gJy4uL2hlbHBlcnMvaW5kZXguanMnO1xuaW1wb3J0IGRlZmF1bHRzLCB7b3ZlcnJpZGVzfSBmcm9tICcuL2NvcmUuZGVmYXVsdHMuanMnO1xuXG4vKipcbiAqIEB0eXBlZGVmIHt7aWQ6IHN0cmluZywgZGVmYXVsdHM6IGFueSwgb3ZlcnJpZGVzPzogYW55LCBkZWZhdWx0Um91dGVzOiBhbnl9fSBJQ2hhcnRDb21wb25lbnRcbiAqL1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBUeXBlZFJlZ2lzdHJ5IHtcbiAgY29uc3RydWN0b3IodHlwZSwgc2NvcGUsIG92ZXJyaWRlKSB7XG4gICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICB0aGlzLnNjb3BlID0gc2NvcGU7XG4gICAgdGhpcy5vdmVycmlkZSA9IG92ZXJyaWRlO1xuICAgIHRoaXMuaXRlbXMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICB9XG5cbiAgaXNGb3JUeXBlKHR5cGUpIHtcbiAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5pc1Byb3RvdHlwZU9mLmNhbGwodGhpcy50eXBlLnByb3RvdHlwZSwgdHlwZS5wcm90b3R5cGUpO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwYXJhbSB7SUNoYXJ0Q29tcG9uZW50fSBpdGVtXG5cdCAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSBzY29wZSB3aGVyZSBpdGVtcyBkZWZhdWx0cyB3ZXJlIHJlZ2lzdGVyZWQgdG8uXG5cdCAqL1xuICByZWdpc3RlcihpdGVtKSB7XG4gICAgY29uc3QgcHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YoaXRlbSk7XG4gICAgbGV0IHBhcmVudFNjb3BlO1xuXG4gICAgaWYgKGlzSUNoYXJ0Q29tcG9uZW50KHByb3RvKSkge1xuICAgICAgLy8gTWFrZSBzdXJlIHRoZSBwYXJlbnQgaXMgcmVnaXN0ZXJlZCBhbmQgbm90ZSB0aGUgc2NvcGUgd2hlcmUgaXRzIGRlZmF1bHRzIGFyZS5cbiAgICAgIHBhcmVudFNjb3BlID0gdGhpcy5yZWdpc3Rlcihwcm90byk7XG4gICAgfVxuXG4gICAgY29uc3QgaXRlbXMgPSB0aGlzLml0ZW1zO1xuICAgIGNvbnN0IGlkID0gaXRlbS5pZDtcbiAgICBjb25zdCBzY29wZSA9IHRoaXMuc2NvcGUgKyAnLicgKyBpZDtcblxuICAgIGlmICghaWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignY2xhc3MgZG9lcyBub3QgaGF2ZSBpZDogJyArIGl0ZW0pO1xuICAgIH1cblxuICAgIGlmIChpZCBpbiBpdGVtcykge1xuICAgICAgLy8gYWxyZWFkeSByZWdpc3RlcmVkXG4gICAgICByZXR1cm4gc2NvcGU7XG4gICAgfVxuXG4gICAgaXRlbXNbaWRdID0gaXRlbTtcbiAgICByZWdpc3RlckRlZmF1bHRzKGl0ZW0sIHNjb3BlLCBwYXJlbnRTY29wZSk7XG4gICAgaWYgKHRoaXMub3ZlcnJpZGUpIHtcbiAgICAgIGRlZmF1bHRzLm92ZXJyaWRlKGl0ZW0uaWQsIGl0ZW0ub3ZlcnJpZGVzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gc2NvcGU7XG4gIH1cblxuICAvKipcblx0ICogQHBhcmFtIHtzdHJpbmd9IGlkXG5cdCAqIEByZXR1cm5zIHtvYmplY3Q/fVxuXHQgKi9cbiAgZ2V0KGlkKSB7XG4gICAgcmV0dXJuIHRoaXMuaXRlbXNbaWRdO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwYXJhbSB7SUNoYXJ0Q29tcG9uZW50fSBpdGVtXG5cdCAqL1xuICB1bnJlZ2lzdGVyKGl0ZW0pIHtcbiAgICBjb25zdCBpdGVtcyA9IHRoaXMuaXRlbXM7XG4gICAgY29uc3QgaWQgPSBpdGVtLmlkO1xuICAgIGNvbnN0IHNjb3BlID0gdGhpcy5zY29wZTtcblxuICAgIGlmIChpZCBpbiBpdGVtcykge1xuICAgICAgZGVsZXRlIGl0ZW1zW2lkXTtcbiAgICB9XG5cbiAgICBpZiAoc2NvcGUgJiYgaWQgaW4gZGVmYXVsdHNbc2NvcGVdKSB7XG4gICAgICBkZWxldGUgZGVmYXVsdHNbc2NvcGVdW2lkXTtcbiAgICAgIGlmICh0aGlzLm92ZXJyaWRlKSB7XG4gICAgICAgIGRlbGV0ZSBvdmVycmlkZXNbaWRdO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiByZWdpc3RlckRlZmF1bHRzKGl0ZW0sIHNjb3BlLCBwYXJlbnRTY29wZSkge1xuICAvLyBJbmhlcml0IHRoZSBwYXJlbnQncyBkZWZhdWx0cyBhbmQga2VlcCBleGlzdGluZyBkZWZhdWx0c1xuICBjb25zdCBpdGVtRGVmYXVsdHMgPSBtZXJnZShPYmplY3QuY3JlYXRlKG51bGwpLCBbXG4gICAgcGFyZW50U2NvcGUgPyBkZWZhdWx0cy5nZXQocGFyZW50U2NvcGUpIDoge30sXG4gICAgZGVmYXVsdHMuZ2V0KHNjb3BlKSxcbiAgICBpdGVtLmRlZmF1bHRzXG4gIF0pO1xuXG4gIGRlZmF1bHRzLnNldChzY29wZSwgaXRlbURlZmF1bHRzKTtcblxuICBpZiAoaXRlbS5kZWZhdWx0Um91dGVzKSB7XG4gICAgcm91dGVEZWZhdWx0cyhzY29wZSwgaXRlbS5kZWZhdWx0Um91dGVzKTtcbiAgfVxuXG4gIGlmIChpdGVtLmRlc2NyaXB0b3JzKSB7XG4gICAgZGVmYXVsdHMuZGVzY3JpYmUoc2NvcGUsIGl0ZW0uZGVzY3JpcHRvcnMpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJvdXRlRGVmYXVsdHMoc2NvcGUsIHJvdXRlcykge1xuICBPYmplY3Qua2V5cyhyb3V0ZXMpLmZvckVhY2gocHJvcGVydHkgPT4ge1xuICAgIGNvbnN0IHByb3BlcnR5UGFydHMgPSBwcm9wZXJ0eS5zcGxpdCgnLicpO1xuICAgIGNvbnN0IHNvdXJjZU5hbWUgPSBwcm9wZXJ0eVBhcnRzLnBvcCgpO1xuICAgIGNvbnN0IHNvdXJjZVNjb3BlID0gW3Njb3BlXS5jb25jYXQocHJvcGVydHlQYXJ0cykuam9pbignLicpO1xuICAgIGNvbnN0IHBhcnRzID0gcm91dGVzW3Byb3BlcnR5XS5zcGxpdCgnLicpO1xuICAgIGNvbnN0IHRhcmdldE5hbWUgPSBwYXJ0cy5wb3AoKTtcbiAgICBjb25zdCB0YXJnZXRTY29wZSA9IHBhcnRzLmpvaW4oJy4nKTtcbiAgICBkZWZhdWx0cy5yb3V0ZShzb3VyY2VTY29wZSwgc291cmNlTmFtZSwgdGFyZ2V0U2NvcGUsIHRhcmdldE5hbWUpO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gaXNJQ2hhcnRDb21wb25lbnQocHJvdG8pIHtcbiAgcmV0dXJuICdpZCcgaW4gcHJvdG8gJiYgJ2RlZmF1bHRzJyBpbiBwcm90bztcbn1cbiIsICJpbXBvcnQgRGF0YXNldENvbnRyb2xsZXIgZnJvbSAnLi9jb3JlLmRhdGFzZXRDb250cm9sbGVyLmpzJztcbmltcG9ydCBFbGVtZW50IGZyb20gJy4vY29yZS5lbGVtZW50LmpzJztcbmltcG9ydCBTY2FsZSBmcm9tICcuL2NvcmUuc2NhbGUuanMnO1xuaW1wb3J0IFR5cGVkUmVnaXN0cnkgZnJvbSAnLi9jb3JlLnR5cGVkUmVnaXN0cnkuanMnO1xuaW1wb3J0IHtlYWNoLCBjYWxsYmFjayBhcyBjYWxsLCBfY2FwaXRhbGl6ZX0gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLmNvcmUuanMnO1xuXG4vKipcbiAqIFBsZWFzZSB1c2UgdGhlIG1vZHVsZSdzIGRlZmF1bHQgZXhwb3J0IHdoaWNoIHByb3ZpZGVzIGEgc2luZ2xldG9uIGluc3RhbmNlXG4gKiBOb3RlOiBjbGFzcyBpcyBleHBvcnRlZCBmb3IgdHlwZWRvY1xuICovXG5leHBvcnQgY2xhc3MgUmVnaXN0cnkge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLmNvbnRyb2xsZXJzID0gbmV3IFR5cGVkUmVnaXN0cnkoRGF0YXNldENvbnRyb2xsZXIsICdkYXRhc2V0cycsIHRydWUpO1xuICAgIHRoaXMuZWxlbWVudHMgPSBuZXcgVHlwZWRSZWdpc3RyeShFbGVtZW50LCAnZWxlbWVudHMnKTtcbiAgICB0aGlzLnBsdWdpbnMgPSBuZXcgVHlwZWRSZWdpc3RyeShPYmplY3QsICdwbHVnaW5zJyk7XG4gICAgdGhpcy5zY2FsZXMgPSBuZXcgVHlwZWRSZWdpc3RyeShTY2FsZSwgJ3NjYWxlcycpO1xuICAgIC8vIE9yZGVyIGlzIGltcG9ydGFudCwgU2NhbGUgaGFzIEVsZW1lbnQgaW4gcHJvdG90eXBlIGNoYWluLFxuICAgIC8vIHNvIFNjYWxlcyBtdXN0IGJlIGJlZm9yZSBFbGVtZW50cy4gUGx1Z2lucyBhcmUgYSBmYWxsYmFjaywgc28gbm90IGxpc3RlZCBoZXJlLlxuICAgIHRoaXMuX3R5cGVkUmVnaXN0cmllcyA9IFt0aGlzLmNvbnRyb2xsZXJzLCB0aGlzLnNjYWxlcywgdGhpcy5lbGVtZW50c107XG4gIH1cblxuICAvKipcblx0ICogQHBhcmFtICB7Li4uYW55fSBhcmdzXG5cdCAqL1xuICBhZGQoLi4uYXJncykge1xuICAgIHRoaXMuX2VhY2goJ3JlZ2lzdGVyJywgYXJncyk7XG4gIH1cblxuICByZW1vdmUoLi4uYXJncykge1xuICAgIHRoaXMuX2VhY2goJ3VucmVnaXN0ZXInLCBhcmdzKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcGFyYW0gIHsuLi50eXBlb2YgRGF0YXNldENvbnRyb2xsZXJ9IGFyZ3Ncblx0ICovXG4gIGFkZENvbnRyb2xsZXJzKC4uLmFyZ3MpIHtcbiAgICB0aGlzLl9lYWNoKCdyZWdpc3RlcicsIGFyZ3MsIHRoaXMuY29udHJvbGxlcnMpO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwYXJhbSAgey4uLnR5cGVvZiBFbGVtZW50fSBhcmdzXG5cdCAqL1xuICBhZGRFbGVtZW50cyguLi5hcmdzKSB7XG4gICAgdGhpcy5fZWFjaCgncmVnaXN0ZXInLCBhcmdzLCB0aGlzLmVsZW1lbnRzKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcGFyYW0gIHsuLi5hbnl9IGFyZ3Ncblx0ICovXG4gIGFkZFBsdWdpbnMoLi4uYXJncykge1xuICAgIHRoaXMuX2VhY2goJ3JlZ2lzdGVyJywgYXJncywgdGhpcy5wbHVnaW5zKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcGFyYW0gIHsuLi50eXBlb2YgU2NhbGV9IGFyZ3Ncblx0ICovXG4gIGFkZFNjYWxlcyguLi5hcmdzKSB7XG4gICAgdGhpcy5fZWFjaCgncmVnaXN0ZXInLCBhcmdzLCB0aGlzLnNjYWxlcyk7XG4gIH1cblxuICAvKipcblx0ICogQHBhcmFtIHtzdHJpbmd9IGlkXG5cdCAqIEByZXR1cm5zIHt0eXBlb2YgRGF0YXNldENvbnRyb2xsZXJ9XG5cdCAqL1xuICBnZXRDb250cm9sbGVyKGlkKSB7XG4gICAgcmV0dXJuIHRoaXMuX2dldChpZCwgdGhpcy5jb250cm9sbGVycywgJ2NvbnRyb2xsZXInKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gaWRcblx0ICogQHJldHVybnMge3R5cGVvZiBFbGVtZW50fVxuXHQgKi9cbiAgZ2V0RWxlbWVudChpZCkge1xuICAgIHJldHVybiB0aGlzLl9nZXQoaWQsIHRoaXMuZWxlbWVudHMsICdlbGVtZW50Jyk7XG4gIH1cblxuICAvKipcblx0ICogQHBhcmFtIHtzdHJpbmd9IGlkXG5cdCAqIEByZXR1cm5zIHtvYmplY3R9XG5cdCAqL1xuICBnZXRQbHVnaW4oaWQpIHtcbiAgICByZXR1cm4gdGhpcy5fZ2V0KGlkLCB0aGlzLnBsdWdpbnMsICdwbHVnaW4nKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gaWRcblx0ICogQHJldHVybnMge3R5cGVvZiBTY2FsZX1cblx0ICovXG4gIGdldFNjYWxlKGlkKSB7XG4gICAgcmV0dXJuIHRoaXMuX2dldChpZCwgdGhpcy5zY2FsZXMsICdzY2FsZScpO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwYXJhbSAgey4uLnR5cGVvZiBEYXRhc2V0Q29udHJvbGxlcn0gYXJnc1xuXHQgKi9cbiAgcmVtb3ZlQ29udHJvbGxlcnMoLi4uYXJncykge1xuICAgIHRoaXMuX2VhY2goJ3VucmVnaXN0ZXInLCBhcmdzLCB0aGlzLmNvbnRyb2xsZXJzKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcGFyYW0gIHsuLi50eXBlb2YgRWxlbWVudH0gYXJnc1xuXHQgKi9cbiAgcmVtb3ZlRWxlbWVudHMoLi4uYXJncykge1xuICAgIHRoaXMuX2VhY2goJ3VucmVnaXN0ZXInLCBhcmdzLCB0aGlzLmVsZW1lbnRzKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcGFyYW0gIHsuLi5hbnl9IGFyZ3Ncblx0ICovXG4gIHJlbW92ZVBsdWdpbnMoLi4uYXJncykge1xuICAgIHRoaXMuX2VhY2goJ3VucmVnaXN0ZXInLCBhcmdzLCB0aGlzLnBsdWdpbnMpO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwYXJhbSAgey4uLnR5cGVvZiBTY2FsZX0gYXJnc1xuXHQgKi9cbiAgcmVtb3ZlU2NhbGVzKC4uLmFyZ3MpIHtcbiAgICB0aGlzLl9lYWNoKCd1bnJlZ2lzdGVyJywgYXJncywgdGhpcy5zY2FsZXMpO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfZWFjaChtZXRob2QsIGFyZ3MsIHR5cGVkUmVnaXN0cnkpIHtcbiAgICBbLi4uYXJnc10uZm9yRWFjaChhcmcgPT4ge1xuICAgICAgY29uc3QgcmVnID0gdHlwZWRSZWdpc3RyeSB8fCB0aGlzLl9nZXRSZWdpc3RyeUZvclR5cGUoYXJnKTtcbiAgICAgIGlmICh0eXBlZFJlZ2lzdHJ5IHx8IHJlZy5pc0ZvclR5cGUoYXJnKSB8fCAocmVnID09PSB0aGlzLnBsdWdpbnMgJiYgYXJnLmlkKSkge1xuICAgICAgICB0aGlzLl9leGVjKG1ldGhvZCwgcmVnLCBhcmcpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gSGFuZGxlIGxvb3BhYmxlIGFyZ3NcbiAgICAgICAgLy8gVXNlIGNhc2U6XG4gICAgICAgIC8vICBpbXBvcnQgKiBhcyBwbHVnaW5zIGZyb20gJy4vcGx1Z2lucy5qcyc7XG4gICAgICAgIC8vICBDaGFydC5yZWdpc3RlcihwbHVnaW5zKTtcbiAgICAgICAgZWFjaChhcmcsIGl0ZW0gPT4ge1xuICAgICAgICAgIC8vIElmIHRoZXJlIGFyZSBtaXhlZCB0eXBlcyBpbiB0aGUgbG9vcGFibGUsIG1ha2Ugc3VyZSB0aG9zZSBhcmVcbiAgICAgICAgICAvLyByZWdpc3RlcmVkIGluIGNvcnJlY3QgcmVnaXN0cnlcbiAgICAgICAgICAvLyBVc2UgY2FzZTogKHRyZWVtYXAgZXhwb3J0aW5nIGNvbnRyb2xsZXIsIGVsZW1lbnRzIGV0YylcbiAgICAgICAgICAvLyAgaW1wb3J0ICogYXMgdHJlZW1hcCBmcm9tICdjaGFydGpzLWNoYXJ0LXRyZWVtYXAuanMnO1xuICAgICAgICAgIC8vICBDaGFydC5yZWdpc3Rlcih0cmVlbWFwKTtcblxuICAgICAgICAgIGNvbnN0IGl0ZW1SZWcgPSB0eXBlZFJlZ2lzdHJ5IHx8IHRoaXMuX2dldFJlZ2lzdHJ5Rm9yVHlwZShpdGVtKTtcbiAgICAgICAgICB0aGlzLl9leGVjKG1ldGhvZCwgaXRlbVJlZywgaXRlbSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfZXhlYyhtZXRob2QsIHJlZ2lzdHJ5LCBjb21wb25lbnQpIHtcbiAgICBjb25zdCBjYW1lbE1ldGhvZCA9IF9jYXBpdGFsaXplKG1ldGhvZCk7XG4gICAgY2FsbChjb21wb25lbnRbJ2JlZm9yZScgKyBjYW1lbE1ldGhvZF0sIFtdLCBjb21wb25lbnQpOyAvLyBiZWZvcmVSZWdpc3RlciAvIGJlZm9yZVVucmVnaXN0ZXJcbiAgICByZWdpc3RyeVttZXRob2RdKGNvbXBvbmVudCk7XG4gICAgY2FsbChjb21wb25lbnRbJ2FmdGVyJyArIGNhbWVsTWV0aG9kXSwgW10sIGNvbXBvbmVudCk7IC8vIGFmdGVyUmVnaXN0ZXIgLyBhZnRlclVucmVnaXN0ZXJcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgX2dldFJlZ2lzdHJ5Rm9yVHlwZSh0eXBlKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLl90eXBlZFJlZ2lzdHJpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IHJlZyA9IHRoaXMuX3R5cGVkUmVnaXN0cmllc1tpXTtcbiAgICAgIGlmIChyZWcuaXNGb3JUeXBlKHR5cGUpKSB7XG4gICAgICAgIHJldHVybiByZWc7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIHBsdWdpbnMgaXMgdGhlIGZhbGxiYWNrIHJlZ2lzdHJ5XG4gICAgcmV0dXJuIHRoaXMucGx1Z2lucztcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgX2dldChpZCwgdHlwZWRSZWdpc3RyeSwgdHlwZSkge1xuICAgIGNvbnN0IGl0ZW0gPSB0eXBlZFJlZ2lzdHJ5LmdldChpZCk7XG4gICAgaWYgKGl0ZW0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdcIicgKyBpZCArICdcIiBpcyBub3QgYSByZWdpc3RlcmVkICcgKyB0eXBlICsgJy4nKTtcbiAgICB9XG4gICAgcmV0dXJuIGl0ZW07XG4gIH1cblxufVxuXG4vLyBzaW5nbGV0b24gaW5zdGFuY2VcbmV4cG9ydCBkZWZhdWx0IC8qICNfX1BVUkVfXyAqLyBuZXcgUmVnaXN0cnkoKTtcbiIsICJpbXBvcnQgcmVnaXN0cnkgZnJvbSAnLi9jb3JlLnJlZ2lzdHJ5LmpzJztcbmltcG9ydCB7Y2FsbGJhY2sgYXMgY2FsbENhbGxiYWNrLCBpc051bGxPclVuZGVmLCB2YWx1ZU9yRGVmYXVsdH0gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLmNvcmUuanMnO1xuXG4vKipcbiAqIEB0eXBlZGVmIHsgaW1wb3J0KCcuL2NvcmUuY29udHJvbGxlci5qcycpLmRlZmF1bHQgfSBDaGFydFxuICogQHR5cGVkZWYgeyBpbXBvcnQoJy4uL3R5cGVzL2luZGV4LmpzJykuQ2hhcnRFdmVudCB9IENoYXJ0RXZlbnRcbiAqIEB0eXBlZGVmIHsgaW1wb3J0KCcuLi9wbHVnaW5zL3BsdWdpbi50b29sdGlwLmpzJykuZGVmYXVsdCB9IFRvb2x0aXBcbiAqL1xuXG4vKipcbiAqIEBjYWxsYmFjayBmaWx0ZXJDYWxsYmFja1xuICogQHBhcmFtIHt7cGx1Z2luOiBvYmplY3QsIG9wdGlvbnM6IG9iamVjdH19IHZhbHVlXG4gKiBAcGFyYW0ge251bWJlcn0gW2luZGV4XVxuICogQHBhcmFtIHthcnJheX0gW2FycmF5XVxuICogQHBhcmFtIHtvYmplY3R9IFt0aGlzQXJnXVxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFBsdWdpblNlcnZpY2Uge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLl9pbml0ID0gW107XG4gIH1cblxuICAvKipcblx0ICogQ2FsbHMgZW5hYmxlZCBwbHVnaW5zIGZvciBgY2hhcnRgIG9uIHRoZSBzcGVjaWZpZWQgaG9vayBhbmQgd2l0aCB0aGUgZ2l2ZW4gYXJncy5cblx0ICogVGhpcyBtZXRob2QgaW1tZWRpYXRlbHkgcmV0dXJucyBhcyBzb29uIGFzIGEgcGx1Z2luIGV4cGxpY2l0bHkgcmV0dXJucyBmYWxzZS4gVGhlXG5cdCAqIHJldHVybmVkIHZhbHVlIGNhbiBiZSB1c2VkLCBmb3IgaW5zdGFuY2UsIHRvIGludGVycnVwdCB0aGUgY3VycmVudCBhY3Rpb24uXG5cdCAqIEBwYXJhbSB7Q2hhcnR9IGNoYXJ0IC0gVGhlIGNoYXJ0IGluc3RhbmNlIGZvciB3aGljaCBwbHVnaW5zIHNob3VsZCBiZSBjYWxsZWQuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBob29rIC0gVGhlIG5hbWUgb2YgdGhlIHBsdWdpbiBtZXRob2QgdG8gY2FsbCAoZS5nLiAnYmVmb3JlVXBkYXRlJykuXG5cdCAqIEBwYXJhbSB7b2JqZWN0fSBbYXJnc10gLSBFeHRyYSBhcmd1bWVudHMgdG8gYXBwbHkgdG8gdGhlIGhvb2sgY2FsbC5cbiAgICogQHBhcmFtIHtmaWx0ZXJDYWxsYmFja30gW2ZpbHRlcl0gLSBGaWx0ZXJpbmcgZnVuY3Rpb24gZm9yIGxpbWl0aW5nIHdoaWNoIHBsdWdpbnMgYXJlIG5vdGlmaWVkXG5cdCAqIEByZXR1cm5zIHtib29sZWFufSBmYWxzZSBpZiBhbnkgb2YgdGhlIHBsdWdpbnMgcmV0dXJuIGZhbHNlLCBlbHNlIHJldHVybnMgdHJ1ZS5cblx0ICovXG4gIG5vdGlmeShjaGFydCwgaG9vaywgYXJncywgZmlsdGVyKSB7XG4gICAgaWYgKGhvb2sgPT09ICdiZWZvcmVJbml0Jykge1xuICAgICAgdGhpcy5faW5pdCA9IHRoaXMuX2NyZWF0ZURlc2NyaXB0b3JzKGNoYXJ0LCB0cnVlKTtcbiAgICAgIHRoaXMuX25vdGlmeSh0aGlzLl9pbml0LCBjaGFydCwgJ2luc3RhbGwnKTtcbiAgICB9XG5cbiAgICBjb25zdCBkZXNjcmlwdG9ycyA9IGZpbHRlciA/IHRoaXMuX2Rlc2NyaXB0b3JzKGNoYXJ0KS5maWx0ZXIoZmlsdGVyKSA6IHRoaXMuX2Rlc2NyaXB0b3JzKGNoYXJ0KTtcbiAgICBjb25zdCByZXN1bHQgPSB0aGlzLl9ub3RpZnkoZGVzY3JpcHRvcnMsIGNoYXJ0LCBob29rLCBhcmdzKTtcblxuICAgIGlmIChob29rID09PSAnYWZ0ZXJEZXN0cm95Jykge1xuICAgICAgdGhpcy5fbm90aWZ5KGRlc2NyaXB0b3JzLCBjaGFydCwgJ3N0b3AnKTtcbiAgICAgIHRoaXMuX25vdGlmeSh0aGlzLl9pbml0LCBjaGFydCwgJ3VuaW5zdGFsbCcpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfbm90aWZ5KGRlc2NyaXB0b3JzLCBjaGFydCwgaG9vaywgYXJncykge1xuICAgIGFyZ3MgPSBhcmdzIHx8IHt9O1xuICAgIGZvciAoY29uc3QgZGVzY3JpcHRvciBvZiBkZXNjcmlwdG9ycykge1xuICAgICAgY29uc3QgcGx1Z2luID0gZGVzY3JpcHRvci5wbHVnaW47XG4gICAgICBjb25zdCBtZXRob2QgPSBwbHVnaW5baG9va107XG4gICAgICBjb25zdCBwYXJhbXMgPSBbY2hhcnQsIGFyZ3MsIGRlc2NyaXB0b3Iub3B0aW9uc107XG4gICAgICBpZiAoY2FsbENhbGxiYWNrKG1ldGhvZCwgcGFyYW1zLCBwbHVnaW4pID09PSBmYWxzZSAmJiBhcmdzLmNhbmNlbGFibGUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgaW52YWxpZGF0ZSgpIHtcbiAgICAvLyBXaGVuIHBsdWdpbnMgYXJlIHJlZ2lzdGVyZWQsIHRoZXJlIGlzIHRoZSBwb3NzaWJpbGl0eSBvZiBhIGRvdWJsZVxuICAgIC8vIGludmFsaWRhdGUgc2l0dWF0aW9uLiBJbiB0aGlzIGNhc2UsIHdlIG9ubHkgd2FudCB0byBpbnZhbGlkYXRlIG9uY2UuXG4gICAgLy8gSWYgd2UgaW52YWxpZGF0ZSBtdWx0aXBsZSB0aW1lcywgdGhlIGBfb2xkQ2FjaGVgIGlzIGxvc3QgYW5kIGFsbCBvZiB0aGVcbiAgICAvLyBwbHVnaW5zIGFyZSByZXN0YXJ0ZWQgd2l0aG91dCBiZWluZyBjb3JyZWN0bHkgc3RvcHBlZC5cbiAgICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2NoYXJ0anMvQ2hhcnQuanMvaXNzdWVzLzgxNDdcbiAgICBpZiAoIWlzTnVsbE9yVW5kZWYodGhpcy5fY2FjaGUpKSB7XG4gICAgICB0aGlzLl9vbGRDYWNoZSA9IHRoaXMuX2NhY2hlO1xuICAgICAgdGhpcy5fY2FjaGUgPSB1bmRlZmluZWQ7XG4gICAgfVxuICB9XG5cbiAgLyoqXG5cdCAqIEBwYXJhbSB7Q2hhcnR9IGNoYXJ0XG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfZGVzY3JpcHRvcnMoY2hhcnQpIHtcbiAgICBpZiAodGhpcy5fY2FjaGUpIHtcbiAgICAgIHJldHVybiB0aGlzLl9jYWNoZTtcbiAgICB9XG5cbiAgICBjb25zdCBkZXNjcmlwdG9ycyA9IHRoaXMuX2NhY2hlID0gdGhpcy5fY3JlYXRlRGVzY3JpcHRvcnMoY2hhcnQpO1xuXG4gICAgdGhpcy5fbm90aWZ5U3RhdGVDaGFuZ2VzKGNoYXJ0KTtcblxuICAgIHJldHVybiBkZXNjcmlwdG9ycztcbiAgfVxuXG4gIF9jcmVhdGVEZXNjcmlwdG9ycyhjaGFydCwgYWxsKSB7XG4gICAgY29uc3QgY29uZmlnID0gY2hhcnQgJiYgY2hhcnQuY29uZmlnO1xuICAgIGNvbnN0IG9wdGlvbnMgPSB2YWx1ZU9yRGVmYXVsdChjb25maWcub3B0aW9ucyAmJiBjb25maWcub3B0aW9ucy5wbHVnaW5zLCB7fSk7XG4gICAgY29uc3QgcGx1Z2lucyA9IGFsbFBsdWdpbnMoY29uZmlnKTtcbiAgICAvLyBvcHRpb25zID09PSBmYWxzZSA9PiBhbGwgcGx1Z2lucyBhcmUgZGlzYWJsZWRcbiAgICByZXR1cm4gb3B0aW9ucyA9PT0gZmFsc2UgJiYgIWFsbCA/IFtdIDogY3JlYXRlRGVzY3JpcHRvcnMoY2hhcnQsIHBsdWdpbnMsIG9wdGlvbnMsIGFsbCk7XG4gIH1cblxuICAvKipcblx0ICogQHBhcmFtIHtDaGFydH0gY2hhcnRcblx0ICogQHByaXZhdGVcblx0ICovXG4gIF9ub3RpZnlTdGF0ZUNoYW5nZXMoY2hhcnQpIHtcbiAgICBjb25zdCBwcmV2aW91c0Rlc2NyaXB0b3JzID0gdGhpcy5fb2xkQ2FjaGUgfHwgW107XG4gICAgY29uc3QgZGVzY3JpcHRvcnMgPSB0aGlzLl9jYWNoZTtcbiAgICBjb25zdCBkaWZmID0gKGEsIGIpID0+IGEuZmlsdGVyKHggPT4gIWIuc29tZSh5ID0+IHgucGx1Z2luLmlkID09PSB5LnBsdWdpbi5pZCkpO1xuICAgIHRoaXMuX25vdGlmeShkaWZmKHByZXZpb3VzRGVzY3JpcHRvcnMsIGRlc2NyaXB0b3JzKSwgY2hhcnQsICdzdG9wJyk7XG4gICAgdGhpcy5fbm90aWZ5KGRpZmYoZGVzY3JpcHRvcnMsIHByZXZpb3VzRGVzY3JpcHRvcnMpLCBjaGFydCwgJ3N0YXJ0Jyk7XG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9jb3JlLmNvbmZpZy5qcycpLmRlZmF1bHR9IGNvbmZpZ1xuICovXG5mdW5jdGlvbiBhbGxQbHVnaW5zKGNvbmZpZykge1xuICBjb25zdCBsb2NhbElkcyA9IHt9O1xuICBjb25zdCBwbHVnaW5zID0gW107XG4gIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhyZWdpc3RyeS5wbHVnaW5zLml0ZW1zKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgcGx1Z2lucy5wdXNoKHJlZ2lzdHJ5LmdldFBsdWdpbihrZXlzW2ldKSk7XG4gIH1cblxuICBjb25zdCBsb2NhbCA9IGNvbmZpZy5wbHVnaW5zIHx8IFtdO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGxvY2FsLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgcGx1Z2luID0gbG9jYWxbaV07XG5cbiAgICBpZiAocGx1Z2lucy5pbmRleE9mKHBsdWdpbikgPT09IC0xKSB7XG4gICAgICBwbHVnaW5zLnB1c2gocGx1Z2luKTtcbiAgICAgIGxvY2FsSWRzW3BsdWdpbi5pZF0gPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7cGx1Z2lucywgbG9jYWxJZHN9O1xufVxuXG5mdW5jdGlvbiBnZXRPcHRzKG9wdGlvbnMsIGFsbCkge1xuICBpZiAoIWFsbCAmJiBvcHRpb25zID09PSBmYWxzZSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGlmIChvcHRpb25zID09PSB0cnVlKSB7XG4gICAgcmV0dXJuIHt9O1xuICB9XG4gIHJldHVybiBvcHRpb25zO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVEZXNjcmlwdG9ycyhjaGFydCwge3BsdWdpbnMsIGxvY2FsSWRzfSwgb3B0aW9ucywgYWxsKSB7XG4gIGNvbnN0IHJlc3VsdCA9IFtdO1xuICBjb25zdCBjb250ZXh0ID0gY2hhcnQuZ2V0Q29udGV4dCgpO1xuXG4gIGZvciAoY29uc3QgcGx1Z2luIG9mIHBsdWdpbnMpIHtcbiAgICBjb25zdCBpZCA9IHBsdWdpbi5pZDtcbiAgICBjb25zdCBvcHRzID0gZ2V0T3B0cyhvcHRpb25zW2lkXSwgYWxsKTtcbiAgICBpZiAob3B0cyA9PT0gbnVsbCkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIHJlc3VsdC5wdXNoKHtcbiAgICAgIHBsdWdpbixcbiAgICAgIG9wdGlvbnM6IHBsdWdpbk9wdHMoY2hhcnQuY29uZmlnLCB7cGx1Z2luLCBsb2NhbDogbG9jYWxJZHNbaWRdfSwgb3B0cywgY29udGV4dClcbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIHBsdWdpbk9wdHMoY29uZmlnLCB7cGx1Z2luLCBsb2NhbH0sIG9wdHMsIGNvbnRleHQpIHtcbiAgY29uc3Qga2V5cyA9IGNvbmZpZy5wbHVnaW5TY29wZUtleXMocGx1Z2luKTtcbiAgY29uc3Qgc2NvcGVzID0gY29uZmlnLmdldE9wdGlvblNjb3BlcyhvcHRzLCBrZXlzKTtcbiAgaWYgKGxvY2FsICYmIHBsdWdpbi5kZWZhdWx0cykge1xuICAgIC8vIG1ha2Ugc3VyZSBwbHVnaW4gZGVmYXVsdHMgYXJlIGluIHNjb3BlcyBmb3IgbG9jYWwgKG5vdCByZWdpc3RlcmVkKSBwbHVnaW5zXG4gICAgc2NvcGVzLnB1c2gocGx1Z2luLmRlZmF1bHRzKTtcbiAgfVxuICByZXR1cm4gY29uZmlnLmNyZWF0ZVJlc29sdmVyKHNjb3BlcywgY29udGV4dCwgWycnXSwge1xuICAgIC8vIFRoZXNlIGFyZSBqdXN0IGRlZmF1bHRzIHRoYXQgcGx1Z2lucyBjYW4gb3ZlcnJpZGVcbiAgICBzY3JpcHRhYmxlOiBmYWxzZSxcbiAgICBpbmRleGFibGU6IGZhbHNlLFxuICAgIGFsbEtleXM6IHRydWVcbiAgfSk7XG59XG4iLCAiaW1wb3J0IGRlZmF1bHRzLCB7b3ZlcnJpZGVzLCBkZXNjcmlwdG9yc30gZnJvbSAnLi9jb3JlLmRlZmF1bHRzLmpzJztcbmltcG9ydCB7bWVyZ2VJZiwgcmVzb2x2ZU9iamVjdEtleSwgaXNBcnJheSwgaXNGdW5jdGlvbiwgdmFsdWVPckRlZmF1bHQsIGlzT2JqZWN0fSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMuY29yZS5qcyc7XG5pbXBvcnQge19hdHRhY2hDb250ZXh0LCBfY3JlYXRlUmVzb2x2ZXIsIF9kZXNjcmlwdG9yc30gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLmNvbmZpZy5qcyc7XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRJbmRleEF4aXModHlwZSwgb3B0aW9ucykge1xuICBjb25zdCBkYXRhc2V0RGVmYXVsdHMgPSBkZWZhdWx0cy5kYXRhc2V0c1t0eXBlXSB8fCB7fTtcbiAgY29uc3QgZGF0YXNldE9wdGlvbnMgPSAob3B0aW9ucy5kYXRhc2V0cyB8fCB7fSlbdHlwZV0gfHwge307XG4gIHJldHVybiBkYXRhc2V0T3B0aW9ucy5pbmRleEF4aXMgfHwgb3B0aW9ucy5pbmRleEF4aXMgfHwgZGF0YXNldERlZmF1bHRzLmluZGV4QXhpcyB8fCAneCc7XG59XG5cbmZ1bmN0aW9uIGdldEF4aXNGcm9tRGVmYXVsdFNjYWxlSUQoaWQsIGluZGV4QXhpcykge1xuICBsZXQgYXhpcyA9IGlkO1xuICBpZiAoaWQgPT09ICdfaW5kZXhfJykge1xuICAgIGF4aXMgPSBpbmRleEF4aXM7XG4gIH0gZWxzZSBpZiAoaWQgPT09ICdfdmFsdWVfJykge1xuICAgIGF4aXMgPSBpbmRleEF4aXMgPT09ICd4JyA/ICd5JyA6ICd4JztcbiAgfVxuICByZXR1cm4gYXhpcztcbn1cblxuZnVuY3Rpb24gZ2V0RGVmYXVsdFNjYWxlSURGcm9tQXhpcyhheGlzLCBpbmRleEF4aXMpIHtcbiAgcmV0dXJuIGF4aXMgPT09IGluZGV4QXhpcyA/ICdfaW5kZXhfJyA6ICdfdmFsdWVfJztcbn1cblxuZnVuY3Rpb24gaWRNYXRjaGVzQXhpcyhpZCkge1xuICBpZiAoaWQgPT09ICd4JyB8fCBpZCA9PT0gJ3knIHx8IGlkID09PSAncicpIHtcbiAgICByZXR1cm4gaWQ7XG4gIH1cbn1cblxuZnVuY3Rpb24gYXhpc0Zyb21Qb3NpdGlvbihwb3NpdGlvbikge1xuICBpZiAocG9zaXRpb24gPT09ICd0b3AnIHx8IHBvc2l0aW9uID09PSAnYm90dG9tJykge1xuICAgIHJldHVybiAneCc7XG4gIH1cbiAgaWYgKHBvc2l0aW9uID09PSAnbGVmdCcgfHwgcG9zaXRpb24gPT09ICdyaWdodCcpIHtcbiAgICByZXR1cm4gJ3knO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBkZXRlcm1pbmVBeGlzKGlkLCAuLi5zY2FsZU9wdGlvbnMpIHtcbiAgaWYgKGlkTWF0Y2hlc0F4aXMoaWQpKSB7XG4gICAgcmV0dXJuIGlkO1xuICB9XG4gIGZvciAoY29uc3Qgb3B0cyBvZiBzY2FsZU9wdGlvbnMpIHtcbiAgICBjb25zdCBheGlzID0gb3B0cy5heGlzXG4gICAgICB8fCBheGlzRnJvbVBvc2l0aW9uKG9wdHMucG9zaXRpb24pXG4gICAgICB8fCBpZC5sZW5ndGggPiAxICYmIGlkTWF0Y2hlc0F4aXMoaWRbMF0udG9Mb3dlckNhc2UoKSk7XG4gICAgaWYgKGF4aXMpIHtcbiAgICAgIHJldHVybiBheGlzO1xuICAgIH1cbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoYENhbm5vdCBkZXRlcm1pbmUgdHlwZSBvZiAnJHtpZH0nIGF4aXMuIFBsZWFzZSBwcm92aWRlICdheGlzJyBvciAncG9zaXRpb24nIG9wdGlvbi5gKTtcbn1cblxuZnVuY3Rpb24gZ2V0QXhpc0Zyb21EYXRhc2V0KGlkLCBheGlzLCBkYXRhc2V0KSB7XG4gIGlmIChkYXRhc2V0W2F4aXMgKyAnQXhpc0lEJ10gPT09IGlkKSB7XG4gICAgcmV0dXJuIHtheGlzfTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZXRyaWV2ZUF4aXNGcm9tRGF0YXNldHMoaWQsIGNvbmZpZykge1xuICBpZiAoY29uZmlnLmRhdGEgJiYgY29uZmlnLmRhdGEuZGF0YXNldHMpIHtcbiAgICBjb25zdCBib3VuZERzID0gY29uZmlnLmRhdGEuZGF0YXNldHMuZmlsdGVyKChkKSA9PiBkLnhBeGlzSUQgPT09IGlkIHx8IGQueUF4aXNJRCA9PT0gaWQpO1xuICAgIGlmIChib3VuZERzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIGdldEF4aXNGcm9tRGF0YXNldChpZCwgJ3gnLCBib3VuZERzWzBdKSB8fCBnZXRBeGlzRnJvbURhdGFzZXQoaWQsICd5JywgYm91bmREc1swXSk7XG4gICAgfVxuICB9XG4gIHJldHVybiB7fTtcbn1cblxuZnVuY3Rpb24gbWVyZ2VTY2FsZUNvbmZpZyhjb25maWcsIG9wdGlvbnMpIHtcbiAgY29uc3QgY2hhcnREZWZhdWx0cyA9IG92ZXJyaWRlc1tjb25maWcudHlwZV0gfHwge3NjYWxlczoge319O1xuICBjb25zdCBjb25maWdTY2FsZXMgPSBvcHRpb25zLnNjYWxlcyB8fCB7fTtcbiAgY29uc3QgY2hhcnRJbmRleEF4aXMgPSBnZXRJbmRleEF4aXMoY29uZmlnLnR5cGUsIG9wdGlvbnMpO1xuICBjb25zdCBzY2FsZXMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG4gIC8vIEZpcnN0IGZpZ3VyZSBvdXQgZmlyc3Qgc2NhbGUgaWQncyBwZXIgYXhpcy5cbiAgT2JqZWN0LmtleXMoY29uZmlnU2NhbGVzKS5mb3JFYWNoKGlkID0+IHtcbiAgICBjb25zdCBzY2FsZUNvbmYgPSBjb25maWdTY2FsZXNbaWRdO1xuICAgIGlmICghaXNPYmplY3Qoc2NhbGVDb25mKSkge1xuICAgICAgcmV0dXJuIGNvbnNvbGUuZXJyb3IoYEludmFsaWQgc2NhbGUgY29uZmlndXJhdGlvbiBmb3Igc2NhbGU6ICR7aWR9YCk7XG4gICAgfVxuICAgIGlmIChzY2FsZUNvbmYuX3Byb3h5KSB7XG4gICAgICByZXR1cm4gY29uc29sZS53YXJuKGBJZ25vcmluZyByZXNvbHZlciBwYXNzZWQgYXMgb3B0aW9ucyBmb3Igc2NhbGU6ICR7aWR9YCk7XG4gICAgfVxuICAgIGNvbnN0IGF4aXMgPSBkZXRlcm1pbmVBeGlzKGlkLCBzY2FsZUNvbmYsIHJldHJpZXZlQXhpc0Zyb21EYXRhc2V0cyhpZCwgY29uZmlnKSwgZGVmYXVsdHMuc2NhbGVzW3NjYWxlQ29uZi50eXBlXSk7XG4gICAgY29uc3QgZGVmYXVsdElkID0gZ2V0RGVmYXVsdFNjYWxlSURGcm9tQXhpcyhheGlzLCBjaGFydEluZGV4QXhpcyk7XG4gICAgY29uc3QgZGVmYXVsdFNjYWxlT3B0aW9ucyA9IGNoYXJ0RGVmYXVsdHMuc2NhbGVzIHx8IHt9O1xuICAgIHNjYWxlc1tpZF0gPSBtZXJnZUlmKE9iamVjdC5jcmVhdGUobnVsbCksIFt7YXhpc30sIHNjYWxlQ29uZiwgZGVmYXVsdFNjYWxlT3B0aW9uc1theGlzXSwgZGVmYXVsdFNjYWxlT3B0aW9uc1tkZWZhdWx0SWRdXSk7XG4gIH0pO1xuXG4gIC8vIFRoZW4gbWVyZ2UgZGF0YXNldCBkZWZhdWx0cyB0byBzY2FsZSBjb25maWdzXG4gIGNvbmZpZy5kYXRhLmRhdGFzZXRzLmZvckVhY2goZGF0YXNldCA9PiB7XG4gICAgY29uc3QgdHlwZSA9IGRhdGFzZXQudHlwZSB8fCBjb25maWcudHlwZTtcbiAgICBjb25zdCBpbmRleEF4aXMgPSBkYXRhc2V0LmluZGV4QXhpcyB8fCBnZXRJbmRleEF4aXModHlwZSwgb3B0aW9ucyk7XG4gICAgY29uc3QgZGF0YXNldERlZmF1bHRzID0gb3ZlcnJpZGVzW3R5cGVdIHx8IHt9O1xuICAgIGNvbnN0IGRlZmF1bHRTY2FsZU9wdGlvbnMgPSBkYXRhc2V0RGVmYXVsdHMuc2NhbGVzIHx8IHt9O1xuICAgIE9iamVjdC5rZXlzKGRlZmF1bHRTY2FsZU9wdGlvbnMpLmZvckVhY2goZGVmYXVsdElEID0+IHtcbiAgICAgIGNvbnN0IGF4aXMgPSBnZXRBeGlzRnJvbURlZmF1bHRTY2FsZUlEKGRlZmF1bHRJRCwgaW5kZXhBeGlzKTtcbiAgICAgIGNvbnN0IGlkID0gZGF0YXNldFtheGlzICsgJ0F4aXNJRCddIHx8IGF4aXM7XG4gICAgICBzY2FsZXNbaWRdID0gc2NhbGVzW2lkXSB8fCBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgbWVyZ2VJZihzY2FsZXNbaWRdLCBbe2F4aXN9LCBjb25maWdTY2FsZXNbaWRdLCBkZWZhdWx0U2NhbGVPcHRpb25zW2RlZmF1bHRJRF1dKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgLy8gYXBwbHkgc2NhbGUgZGVmYXVsdHMsIGlmIG5vdCBvdmVycmlkZGVuIGJ5IGRhdGFzZXQgZGVmYXVsdHNcbiAgT2JqZWN0LmtleXMoc2NhbGVzKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgY29uc3Qgc2NhbGUgPSBzY2FsZXNba2V5XTtcbiAgICBtZXJnZUlmKHNjYWxlLCBbZGVmYXVsdHMuc2NhbGVzW3NjYWxlLnR5cGVdLCBkZWZhdWx0cy5zY2FsZV0pO1xuICB9KTtcblxuICByZXR1cm4gc2NhbGVzO1xufVxuXG5mdW5jdGlvbiBpbml0T3B0aW9ucyhjb25maWcpIHtcbiAgY29uc3Qgb3B0aW9ucyA9IGNvbmZpZy5vcHRpb25zIHx8IChjb25maWcub3B0aW9ucyA9IHt9KTtcblxuICBvcHRpb25zLnBsdWdpbnMgPSB2YWx1ZU9yRGVmYXVsdChvcHRpb25zLnBsdWdpbnMsIHt9KTtcbiAgb3B0aW9ucy5zY2FsZXMgPSBtZXJnZVNjYWxlQ29uZmlnKGNvbmZpZywgb3B0aW9ucyk7XG59XG5cbmZ1bmN0aW9uIGluaXREYXRhKGRhdGEpIHtcbiAgZGF0YSA9IGRhdGEgfHwge307XG4gIGRhdGEuZGF0YXNldHMgPSBkYXRhLmRhdGFzZXRzIHx8IFtdO1xuICBkYXRhLmxhYmVscyA9IGRhdGEubGFiZWxzIHx8IFtdO1xuICByZXR1cm4gZGF0YTtcbn1cblxuZnVuY3Rpb24gaW5pdENvbmZpZyhjb25maWcpIHtcbiAgY29uZmlnID0gY29uZmlnIHx8IHt9O1xuICBjb25maWcuZGF0YSA9IGluaXREYXRhKGNvbmZpZy5kYXRhKTtcblxuICBpbml0T3B0aW9ucyhjb25maWcpO1xuXG4gIHJldHVybiBjb25maWc7XG59XG5cbmNvbnN0IGtleUNhY2hlID0gbmV3IE1hcCgpO1xuY29uc3Qga2V5c0NhY2hlZCA9IG5ldyBTZXQoKTtcblxuZnVuY3Rpb24gY2FjaGVkS2V5cyhjYWNoZUtleSwgZ2VuZXJhdGUpIHtcbiAgbGV0IGtleXMgPSBrZXlDYWNoZS5nZXQoY2FjaGVLZXkpO1xuICBpZiAoIWtleXMpIHtcbiAgICBrZXlzID0gZ2VuZXJhdGUoKTtcbiAgICBrZXlDYWNoZS5zZXQoY2FjaGVLZXksIGtleXMpO1xuICAgIGtleXNDYWNoZWQuYWRkKGtleXMpO1xuICB9XG4gIHJldHVybiBrZXlzO1xufVxuXG5jb25zdCBhZGRJZkZvdW5kID0gKHNldCwgb2JqLCBrZXkpID0+IHtcbiAgY29uc3Qgb3B0cyA9IHJlc29sdmVPYmplY3RLZXkob2JqLCBrZXkpO1xuICBpZiAob3B0cyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgc2V0LmFkZChvcHRzKTtcbiAgfVxufTtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQ29uZmlnIHtcbiAgY29uc3RydWN0b3IoY29uZmlnKSB7XG4gICAgdGhpcy5fY29uZmlnID0gaW5pdENvbmZpZyhjb25maWcpO1xuICAgIHRoaXMuX3Njb3BlQ2FjaGUgPSBuZXcgTWFwKCk7XG4gICAgdGhpcy5fcmVzb2x2ZXJDYWNoZSA9IG5ldyBNYXAoKTtcbiAgfVxuXG4gIGdldCBwbGF0Zm9ybSgpIHtcbiAgICByZXR1cm4gdGhpcy5fY29uZmlnLnBsYXRmb3JtO1xuICB9XG5cbiAgZ2V0IHR5cGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NvbmZpZy50eXBlO1xuICB9XG5cbiAgc2V0IHR5cGUodHlwZSkge1xuICAgIHRoaXMuX2NvbmZpZy50eXBlID0gdHlwZTtcbiAgfVxuXG4gIGdldCBkYXRhKCkge1xuICAgIHJldHVybiB0aGlzLl9jb25maWcuZGF0YTtcbiAgfVxuXG4gIHNldCBkYXRhKGRhdGEpIHtcbiAgICB0aGlzLl9jb25maWcuZGF0YSA9IGluaXREYXRhKGRhdGEpO1xuICB9XG5cbiAgZ2V0IG9wdGlvbnMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NvbmZpZy5vcHRpb25zO1xuICB9XG5cbiAgc2V0IG9wdGlvbnMob3B0aW9ucykge1xuICAgIHRoaXMuX2NvbmZpZy5vcHRpb25zID0gb3B0aW9ucztcbiAgfVxuXG4gIGdldCBwbHVnaW5zKCkge1xuICAgIHJldHVybiB0aGlzLl9jb25maWcucGx1Z2lucztcbiAgfVxuXG4gIHVwZGF0ZSgpIHtcbiAgICBjb25zdCBjb25maWcgPSB0aGlzLl9jb25maWc7XG4gICAgdGhpcy5jbGVhckNhY2hlKCk7XG4gICAgaW5pdE9wdGlvbnMoY29uZmlnKTtcbiAgfVxuXG4gIGNsZWFyQ2FjaGUoKSB7XG4gICAgdGhpcy5fc2NvcGVDYWNoZS5jbGVhcigpO1xuICAgIHRoaXMuX3Jlc29sdmVyQ2FjaGUuY2xlYXIoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBvcHRpb24gc2NvcGUga2V5cyBmb3IgcmVzb2x2aW5nIGRhdGFzZXQgb3B0aW9ucy5cbiAgICogVGhlc2Uga2V5cyBkbyBub3QgaW5jbHVkZSB0aGUgZGF0YXNldCBpdHNlbGYsIGJlY2F1c2UgaXQgaXMgbm90IHVuZGVyIG9wdGlvbnMuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBkYXRhc2V0VHlwZVxuICAgKiBAcmV0dXJuIHtzdHJpbmdbXVtdfVxuICAgKi9cbiAgZGF0YXNldFNjb3BlS2V5cyhkYXRhc2V0VHlwZSkge1xuICAgIHJldHVybiBjYWNoZWRLZXlzKGRhdGFzZXRUeXBlLFxuICAgICAgKCkgPT4gW1tcbiAgICAgICAgYGRhdGFzZXRzLiR7ZGF0YXNldFR5cGV9YCxcbiAgICAgICAgJydcbiAgICAgIF1dKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBvcHRpb24gc2NvcGUga2V5cyBmb3IgcmVzb2x2aW5nIGRhdGFzZXQgYW5pbWF0aW9uIG9wdGlvbnMuXG4gICAqIFRoZXNlIGtleXMgZG8gbm90IGluY2x1ZGUgdGhlIGRhdGFzZXQgaXRzZWxmLCBiZWNhdXNlIGl0IGlzIG5vdCB1bmRlciBvcHRpb25zLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZGF0YXNldFR5cGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IHRyYW5zaXRpb25cbiAgICogQHJldHVybiB7c3RyaW5nW11bXX1cbiAgICovXG4gIGRhdGFzZXRBbmltYXRpb25TY29wZUtleXMoZGF0YXNldFR5cGUsIHRyYW5zaXRpb24pIHtcbiAgICByZXR1cm4gY2FjaGVkS2V5cyhgJHtkYXRhc2V0VHlwZX0udHJhbnNpdGlvbi4ke3RyYW5zaXRpb259YCxcbiAgICAgICgpID0+IFtcbiAgICAgICAgW1xuICAgICAgICAgIGBkYXRhc2V0cy4ke2RhdGFzZXRUeXBlfS50cmFuc2l0aW9ucy4ke3RyYW5zaXRpb259YCxcbiAgICAgICAgICBgdHJhbnNpdGlvbnMuJHt0cmFuc2l0aW9ufWAsXG4gICAgICAgIF0sXG4gICAgICAgIC8vIFRoZSBmb2xsb3dpbmcgYXJlIHVzZWQgZm9yIGxvb2tpbmcgdXAgdGhlIGBhbmltYXRpb25zYCBhbmQgYGFuaW1hdGlvbmAga2V5c1xuICAgICAgICBbXG4gICAgICAgICAgYGRhdGFzZXRzLiR7ZGF0YXNldFR5cGV9YCxcbiAgICAgICAgICAnJ1xuICAgICAgICBdXG4gICAgICBdKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBvcHRpb25zIHNjb3BlIGtleXMgZm9yIHJlc29sdmluZyBlbGVtZW50IG9wdGlvbnMgdGhhdCBiZWxvbmdcbiAgICogdG8gYW4gZGF0YXNldC4gVGhlc2Uga2V5cyBkbyBub3QgaW5jbHVkZSB0aGUgZGF0YXNldCBpdHNlbGYsIGJlY2F1c2UgaXRcbiAgICogaXMgbm90IHVuZGVyIG9wdGlvbnMuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBkYXRhc2V0VHlwZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gZWxlbWVudFR5cGVcbiAgICogQHJldHVybiB7c3RyaW5nW11bXX1cbiAgICovXG4gIGRhdGFzZXRFbGVtZW50U2NvcGVLZXlzKGRhdGFzZXRUeXBlLCBlbGVtZW50VHlwZSkge1xuICAgIHJldHVybiBjYWNoZWRLZXlzKGAke2RhdGFzZXRUeXBlfS0ke2VsZW1lbnRUeXBlfWAsXG4gICAgICAoKSA9PiBbW1xuICAgICAgICBgZGF0YXNldHMuJHtkYXRhc2V0VHlwZX0uZWxlbWVudHMuJHtlbGVtZW50VHlwZX1gLFxuICAgICAgICBgZGF0YXNldHMuJHtkYXRhc2V0VHlwZX1gLFxuICAgICAgICBgZWxlbWVudHMuJHtlbGVtZW50VHlwZX1gLFxuICAgICAgICAnJ1xuICAgICAgXV0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIG9wdGlvbnMgc2NvcGUga2V5cyBmb3IgcmVzb2x2aW5nIHBsdWdpbiBvcHRpb25zLlxuICAgKiBAcGFyYW0ge3tpZDogc3RyaW5nLCBhZGRpdGlvbmFsT3B0aW9uU2NvcGVzPzogc3RyaW5nW119fSBwbHVnaW5cbiAgICogQHJldHVybiB7c3RyaW5nW11bXX1cbiAgICovXG4gIHBsdWdpblNjb3BlS2V5cyhwbHVnaW4pIHtcbiAgICBjb25zdCBpZCA9IHBsdWdpbi5pZDtcbiAgICBjb25zdCB0eXBlID0gdGhpcy50eXBlO1xuICAgIHJldHVybiBjYWNoZWRLZXlzKGAke3R5cGV9LXBsdWdpbi0ke2lkfWAsXG4gICAgICAoKSA9PiBbW1xuICAgICAgICBgcGx1Z2lucy4ke2lkfWAsXG4gICAgICAgIC4uLnBsdWdpbi5hZGRpdGlvbmFsT3B0aW9uU2NvcGVzIHx8IFtdLFxuICAgICAgXV0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfY2FjaGVkU2NvcGVzKG1haW5TY29wZSwgcmVzZXRDYWNoZSkge1xuICAgIGNvbnN0IF9zY29wZUNhY2hlID0gdGhpcy5fc2NvcGVDYWNoZTtcbiAgICBsZXQgY2FjaGUgPSBfc2NvcGVDYWNoZS5nZXQobWFpblNjb3BlKTtcbiAgICBpZiAoIWNhY2hlIHx8IHJlc2V0Q2FjaGUpIHtcbiAgICAgIGNhY2hlID0gbmV3IE1hcCgpO1xuICAgICAgX3Njb3BlQ2FjaGUuc2V0KG1haW5TY29wZSwgY2FjaGUpO1xuICAgIH1cbiAgICByZXR1cm4gY2FjaGU7XG4gIH1cblxuICAvKipcbiAgICogUmVzb2x2ZXMgdGhlIG9iamVjdHMgZnJvbSBvcHRpb25zIGFuZCBkZWZhdWx0cyBmb3Igb3B0aW9uIHZhbHVlIHJlc29sdXRpb24uXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBtYWluU2NvcGUgLSBUaGUgbWFpbiBzY29wZSBvYmplY3QgZm9yIG9wdGlvbnNcbiAgICogQHBhcmFtIHtzdHJpbmdbXVtdfSBrZXlMaXN0cyAtIFRoZSBhcnJheXMgb2Yga2V5cyBpbiByZXNvbHV0aW9uIG9yZGVyXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3Jlc2V0Q2FjaGVdIC0gcmVzZXQgdGhlIGNhY2hlIGZvciB0aGlzIG1haW5TY29wZVxuICAgKi9cbiAgZ2V0T3B0aW9uU2NvcGVzKG1haW5TY29wZSwga2V5TGlzdHMsIHJlc2V0Q2FjaGUpIHtcbiAgICBjb25zdCB7b3B0aW9ucywgdHlwZX0gPSB0aGlzO1xuICAgIGNvbnN0IGNhY2hlID0gdGhpcy5fY2FjaGVkU2NvcGVzKG1haW5TY29wZSwgcmVzZXRDYWNoZSk7XG4gICAgY29uc3QgY2FjaGVkID0gY2FjaGUuZ2V0KGtleUxpc3RzKTtcbiAgICBpZiAoY2FjaGVkKSB7XG4gICAgICByZXR1cm4gY2FjaGVkO1xuICAgIH1cblxuICAgIGNvbnN0IHNjb3BlcyA9IG5ldyBTZXQoKTtcblxuICAgIGtleUxpc3RzLmZvckVhY2goa2V5cyA9PiB7XG4gICAgICBpZiAobWFpblNjb3BlKSB7XG4gICAgICAgIHNjb3Blcy5hZGQobWFpblNjb3BlKTtcbiAgICAgICAga2V5cy5mb3JFYWNoKGtleSA9PiBhZGRJZkZvdW5kKHNjb3BlcywgbWFpblNjb3BlLCBrZXkpKTtcbiAgICAgIH1cbiAgICAgIGtleXMuZm9yRWFjaChrZXkgPT4gYWRkSWZGb3VuZChzY29wZXMsIG9wdGlvbnMsIGtleSkpO1xuICAgICAga2V5cy5mb3JFYWNoKGtleSA9PiBhZGRJZkZvdW5kKHNjb3Blcywgb3ZlcnJpZGVzW3R5cGVdIHx8IHt9LCBrZXkpKTtcbiAgICAgIGtleXMuZm9yRWFjaChrZXkgPT4gYWRkSWZGb3VuZChzY29wZXMsIGRlZmF1bHRzLCBrZXkpKTtcbiAgICAgIGtleXMuZm9yRWFjaChrZXkgPT4gYWRkSWZGb3VuZChzY29wZXMsIGRlc2NyaXB0b3JzLCBrZXkpKTtcbiAgICB9KTtcblxuICAgIGNvbnN0IGFycmF5ID0gQXJyYXkuZnJvbShzY29wZXMpO1xuICAgIGlmIChhcnJheS5sZW5ndGggPT09IDApIHtcbiAgICAgIGFycmF5LnB1c2goT2JqZWN0LmNyZWF0ZShudWxsKSk7XG4gICAgfVxuICAgIGlmIChrZXlzQ2FjaGVkLmhhcyhrZXlMaXN0cykpIHtcbiAgICAgIGNhY2hlLnNldChrZXlMaXN0cywgYXJyYXkpO1xuICAgIH1cbiAgICByZXR1cm4gYXJyYXk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgb3B0aW9uIHNjb3BlcyBmb3IgcmVzb2x2aW5nIGNoYXJ0IG9wdGlvbnNcbiAgICogQHJldHVybiB7b2JqZWN0W119XG4gICAqL1xuICBjaGFydE9wdGlvblNjb3BlcygpIHtcbiAgICBjb25zdCB7b3B0aW9ucywgdHlwZX0gPSB0aGlzO1xuXG4gICAgcmV0dXJuIFtcbiAgICAgIG9wdGlvbnMsXG4gICAgICBvdmVycmlkZXNbdHlwZV0gfHwge30sXG4gICAgICBkZWZhdWx0cy5kYXRhc2V0c1t0eXBlXSB8fCB7fSwgLy8gaHR0cHM6Ly9naXRodWIuY29tL2NoYXJ0anMvQ2hhcnQuanMvaXNzdWVzLzg1MzFcbiAgICAgIHt0eXBlfSxcbiAgICAgIGRlZmF1bHRzLFxuICAgICAgZGVzY3JpcHRvcnNcbiAgICBdO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7b2JqZWN0W119IHNjb3Blc1xuICAgKiBAcGFyYW0ge3N0cmluZ1tdfSBuYW1lc1xuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufG9iamVjdH0gY29udGV4dFxuICAgKiBAcGFyYW0ge3N0cmluZ1tdfSBbcHJlZml4ZXNdXG4gICAqIEByZXR1cm4ge29iamVjdH1cbiAgICovXG4gIHJlc29sdmVOYW1lZE9wdGlvbnMoc2NvcGVzLCBuYW1lcywgY29udGV4dCwgcHJlZml4ZXMgPSBbJyddKSB7XG4gICAgY29uc3QgcmVzdWx0ID0geyRzaGFyZWQ6IHRydWV9O1xuICAgIGNvbnN0IHtyZXNvbHZlciwgc3ViUHJlZml4ZXN9ID0gZ2V0UmVzb2x2ZXIodGhpcy5fcmVzb2x2ZXJDYWNoZSwgc2NvcGVzLCBwcmVmaXhlcyk7XG4gICAgbGV0IG9wdGlvbnMgPSByZXNvbHZlcjtcbiAgICBpZiAobmVlZENvbnRleHQocmVzb2x2ZXIsIG5hbWVzKSkge1xuICAgICAgcmVzdWx0LiRzaGFyZWQgPSBmYWxzZTtcbiAgICAgIGNvbnRleHQgPSBpc0Z1bmN0aW9uKGNvbnRleHQpID8gY29udGV4dCgpIDogY29udGV4dDtcbiAgICAgIC8vIHN1YlJlc29sdmVyIGlzIHBhc3NlZCB0byBzY3JpcHRhYmxlIG9wdGlvbnMuIEl0IHNob3VsZCBub3QgcmVzb2x2ZSB0byBob3ZlciBvcHRpb25zLlxuICAgICAgY29uc3Qgc3ViUmVzb2x2ZXIgPSB0aGlzLmNyZWF0ZVJlc29sdmVyKHNjb3BlcywgY29udGV4dCwgc3ViUHJlZml4ZXMpO1xuICAgICAgb3B0aW9ucyA9IF9hdHRhY2hDb250ZXh0KHJlc29sdmVyLCBjb250ZXh0LCBzdWJSZXNvbHZlcik7XG4gICAgfVxuXG4gICAgZm9yIChjb25zdCBwcm9wIG9mIG5hbWVzKSB7XG4gICAgICByZXN1bHRbcHJvcF0gPSBvcHRpb25zW3Byb3BdO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7b2JqZWN0W119IHNjb3Blc1xuICAgKiBAcGFyYW0ge29iamVjdH0gW2NvbnRleHRdXG4gICAqIEBwYXJhbSB7c3RyaW5nW119IFtwcmVmaXhlc11cbiAgICogQHBhcmFtIHt7c2NyaXB0YWJsZTogYm9vbGVhbiwgaW5kZXhhYmxlOiBib29sZWFuLCBhbGxLZXlzPzogYm9vbGVhbn19IFtkZXNjcmlwdG9yRGVmYXVsdHNdXG4gICAqL1xuICBjcmVhdGVSZXNvbHZlcihzY29wZXMsIGNvbnRleHQsIHByZWZpeGVzID0gWycnXSwgZGVzY3JpcHRvckRlZmF1bHRzKSB7XG4gICAgY29uc3Qge3Jlc29sdmVyfSA9IGdldFJlc29sdmVyKHRoaXMuX3Jlc29sdmVyQ2FjaGUsIHNjb3BlcywgcHJlZml4ZXMpO1xuICAgIHJldHVybiBpc09iamVjdChjb250ZXh0KVxuICAgICAgPyBfYXR0YWNoQ29udGV4dChyZXNvbHZlciwgY29udGV4dCwgdW5kZWZpbmVkLCBkZXNjcmlwdG9yRGVmYXVsdHMpXG4gICAgICA6IHJlc29sdmVyO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldFJlc29sdmVyKHJlc29sdmVyQ2FjaGUsIHNjb3BlcywgcHJlZml4ZXMpIHtcbiAgbGV0IGNhY2hlID0gcmVzb2x2ZXJDYWNoZS5nZXQoc2NvcGVzKTtcbiAgaWYgKCFjYWNoZSkge1xuICAgIGNhY2hlID0gbmV3IE1hcCgpO1xuICAgIHJlc29sdmVyQ2FjaGUuc2V0KHNjb3BlcywgY2FjaGUpO1xuICB9XG4gIGNvbnN0IGNhY2hlS2V5ID0gcHJlZml4ZXMuam9pbigpO1xuICBsZXQgY2FjaGVkID0gY2FjaGUuZ2V0KGNhY2hlS2V5KTtcbiAgaWYgKCFjYWNoZWQpIHtcbiAgICBjb25zdCByZXNvbHZlciA9IF9jcmVhdGVSZXNvbHZlcihzY29wZXMsIHByZWZpeGVzKTtcbiAgICBjYWNoZWQgPSB7XG4gICAgICByZXNvbHZlcixcbiAgICAgIHN1YlByZWZpeGVzOiBwcmVmaXhlcy5maWx0ZXIocCA9PiAhcC50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKCdob3ZlcicpKVxuICAgIH07XG4gICAgY2FjaGUuc2V0KGNhY2hlS2V5LCBjYWNoZWQpO1xuICB9XG4gIHJldHVybiBjYWNoZWQ7XG59XG5cbmNvbnN0IGhhc0Z1bmN0aW9uID0gdmFsdWUgPT4gaXNPYmplY3QodmFsdWUpXG4gICYmIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHZhbHVlKS5zb21lKChrZXkpID0+IGlzRnVuY3Rpb24odmFsdWVba2V5XSkpO1xuXG5mdW5jdGlvbiBuZWVkQ29udGV4dChwcm94eSwgbmFtZXMpIHtcbiAgY29uc3Qge2lzU2NyaXB0YWJsZSwgaXNJbmRleGFibGV9ID0gX2Rlc2NyaXB0b3JzKHByb3h5KTtcblxuICBmb3IgKGNvbnN0IHByb3Agb2YgbmFtZXMpIHtcbiAgICBjb25zdCBzY3JpcHRhYmxlID0gaXNTY3JpcHRhYmxlKHByb3ApO1xuICAgIGNvbnN0IGluZGV4YWJsZSA9IGlzSW5kZXhhYmxlKHByb3ApO1xuICAgIGNvbnN0IHZhbHVlID0gKGluZGV4YWJsZSB8fCBzY3JpcHRhYmxlKSAmJiBwcm94eVtwcm9wXTtcbiAgICBpZiAoKHNjcmlwdGFibGUgJiYgKGlzRnVuY3Rpb24odmFsdWUpIHx8IGhhc0Z1bmN0aW9uKHZhbHVlKSkpXG4gICAgICB8fCAoaW5kZXhhYmxlICYmIGlzQXJyYXkodmFsdWUpKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbiIsICJpbXBvcnQgYW5pbWF0b3IgZnJvbSAnLi9jb3JlLmFuaW1hdG9yLmpzJztcbmltcG9ydCBkZWZhdWx0cywge292ZXJyaWRlc30gZnJvbSAnLi9jb3JlLmRlZmF1bHRzLmpzJztcbmltcG9ydCBJbnRlcmFjdGlvbiBmcm9tICcuL2NvcmUuaW50ZXJhY3Rpb24uanMnO1xuaW1wb3J0IGxheW91dHMgZnJvbSAnLi9jb3JlLmxheW91dHMuanMnO1xuaW1wb3J0IHtfZGV0ZWN0UGxhdGZvcm19IGZyb20gJy4uL3BsYXRmb3JtL2luZGV4LmpzJztcbmltcG9ydCBQbHVnaW5TZXJ2aWNlIGZyb20gJy4vY29yZS5wbHVnaW5zLmpzJztcbmltcG9ydCByZWdpc3RyeSBmcm9tICcuL2NvcmUucmVnaXN0cnkuanMnO1xuaW1wb3J0IENvbmZpZywge2RldGVybWluZUF4aXMsIGdldEluZGV4QXhpc30gZnJvbSAnLi9jb3JlLmNvbmZpZy5qcyc7XG5pbXBvcnQge3JldGluYVNjYWxlLCBfaXNEb21TdXBwb3J0ZWR9IGZyb20gJy4uL2hlbHBlcnMvaGVscGVycy5kb20uanMnO1xuaW1wb3J0IHtlYWNoLCBjYWxsYmFjayBhcyBjYWxsQ2FsbGJhY2ssIHVpZCwgdmFsdWVPckRlZmF1bHQsIF9lbGVtZW50c0VxdWFsLCBpc051bGxPclVuZGVmLCBzZXRzRXF1YWwsIGRlZmluZWQsIGlzRnVuY3Rpb24sIF9pc0NsaWNrRXZlbnR9IGZyb20gJy4uL2hlbHBlcnMvaGVscGVycy5jb3JlLmpzJztcbmltcG9ydCB7Y2xlYXJDYW52YXMsIGNsaXBBcmVhLCBjcmVhdGVDb250ZXh0LCB1bmNsaXBBcmVhLCBfaXNQb2ludEluQXJlYX0gZnJvbSAnLi4vaGVscGVycy9pbmRleC5qcyc7XG4vLyBAdHMtaWdub3JlXG5pbXBvcnQge3ZlcnNpb259IGZyb20gJy4uLy4uL3BhY2thZ2UuanNvbic7XG5pbXBvcnQge2RlYm91bmNlfSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMuZXh0cmFzLmpzJztcblxuLyoqXG4gKiBAdHlwZWRlZiB7IGltcG9ydCgnLi4vdHlwZXMvaW5kZXguanMnKS5DaGFydEV2ZW50IH0gQ2hhcnRFdmVudFxuICogQHR5cGVkZWYgeyBpbXBvcnQoJy4uL3R5cGVzL2luZGV4LmpzJykuUG9pbnQgfSBQb2ludFxuICovXG5cbmNvbnN0IEtOT1dOX1BPU0lUSU9OUyA9IFsndG9wJywgJ2JvdHRvbScsICdsZWZ0JywgJ3JpZ2h0JywgJ2NoYXJ0QXJlYSddO1xuZnVuY3Rpb24gcG9zaXRpb25Jc0hvcml6b250YWwocG9zaXRpb24sIGF4aXMpIHtcbiAgcmV0dXJuIHBvc2l0aW9uID09PSAndG9wJyB8fCBwb3NpdGlvbiA9PT0gJ2JvdHRvbScgfHwgKEtOT1dOX1BPU0lUSU9OUy5pbmRleE9mKHBvc2l0aW9uKSA9PT0gLTEgJiYgYXhpcyA9PT0gJ3gnKTtcbn1cblxuZnVuY3Rpb24gY29tcGFyZTJMZXZlbChsMSwgbDIpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKGEsIGIpIHtcbiAgICByZXR1cm4gYVtsMV0gPT09IGJbbDFdXG4gICAgICA/IGFbbDJdIC0gYltsMl1cbiAgICAgIDogYVtsMV0gLSBiW2wxXTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gb25BbmltYXRpb25zQ29tcGxldGUoY29udGV4dCkge1xuICBjb25zdCBjaGFydCA9IGNvbnRleHQuY2hhcnQ7XG4gIGNvbnN0IGFuaW1hdGlvbk9wdGlvbnMgPSBjaGFydC5vcHRpb25zLmFuaW1hdGlvbjtcblxuICBjaGFydC5ub3RpZnlQbHVnaW5zKCdhZnRlclJlbmRlcicpO1xuICBjYWxsQ2FsbGJhY2soYW5pbWF0aW9uT3B0aW9ucyAmJiBhbmltYXRpb25PcHRpb25zLm9uQ29tcGxldGUsIFtjb250ZXh0XSwgY2hhcnQpO1xufVxuXG5mdW5jdGlvbiBvbkFuaW1hdGlvblByb2dyZXNzKGNvbnRleHQpIHtcbiAgY29uc3QgY2hhcnQgPSBjb250ZXh0LmNoYXJ0O1xuICBjb25zdCBhbmltYXRpb25PcHRpb25zID0gY2hhcnQub3B0aW9ucy5hbmltYXRpb247XG4gIGNhbGxDYWxsYmFjayhhbmltYXRpb25PcHRpb25zICYmIGFuaW1hdGlvbk9wdGlvbnMub25Qcm9ncmVzcywgW2NvbnRleHRdLCBjaGFydCk7XG59XG5cbi8qKlxuICogQ2hhcnQuanMgY2FuIHRha2UgYSBzdHJpbmcgaWQgb2YgYSBjYW52YXMgZWxlbWVudCwgYSAyZCBjb250ZXh0LCBvciBhIGNhbnZhcyBlbGVtZW50IGl0c2VsZi5cbiAqIEF0dGVtcHQgdG8gdW53cmFwIHRoZSBpdGVtIHBhc3NlZCBpbnRvIHRoZSBjaGFydCBjb25zdHJ1Y3RvciBzbyB0aGF0IGl0IGlzIGEgY2FudmFzIGVsZW1lbnQgKGlmIHBvc3NpYmxlKS5cbiAqL1xuZnVuY3Rpb24gZ2V0Q2FudmFzKGl0ZW0pIHtcbiAgaWYgKF9pc0RvbVN1cHBvcnRlZCgpICYmIHR5cGVvZiBpdGVtID09PSAnc3RyaW5nJykge1xuICAgIGl0ZW0gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChpdGVtKTtcbiAgfSBlbHNlIGlmIChpdGVtICYmIGl0ZW0ubGVuZ3RoKSB7XG4gICAgLy8gU3VwcG9ydCBmb3IgYXJyYXkgYmFzZWQgcXVlcmllcyAoc3VjaCBhcyBqUXVlcnkpXG4gICAgaXRlbSA9IGl0ZW1bMF07XG4gIH1cblxuICBpZiAoaXRlbSAmJiBpdGVtLmNhbnZhcykge1xuICAgIC8vIFN1cHBvcnQgZm9yIGFueSBvYmplY3QgYXNzb2NpYXRlZCB0byBhIGNhbnZhcyAoaW5jbHVkaW5nIGEgY29udGV4dDJkKVxuICAgIGl0ZW0gPSBpdGVtLmNhbnZhcztcbiAgfVxuICByZXR1cm4gaXRlbTtcbn1cblxuY29uc3QgaW5zdGFuY2VzID0ge307XG5jb25zdCBnZXRDaGFydCA9IChrZXkpID0+IHtcbiAgY29uc3QgY2FudmFzID0gZ2V0Q2FudmFzKGtleSk7XG4gIHJldHVybiBPYmplY3QudmFsdWVzKGluc3RhbmNlcykuZmlsdGVyKChjKSA9PiBjLmNhbnZhcyA9PT0gY2FudmFzKS5wb3AoKTtcbn07XG5cbmZ1bmN0aW9uIG1vdmVOdW1lcmljS2V5cyhvYmosIHN0YXJ0LCBtb3ZlKSB7XG4gIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhvYmopO1xuICBmb3IgKGNvbnN0IGtleSBvZiBrZXlzKSB7XG4gICAgY29uc3QgaW50S2V5ID0gK2tleTtcbiAgICBpZiAoaW50S2V5ID49IHN0YXJ0KSB7XG4gICAgICBjb25zdCB2YWx1ZSA9IG9ialtrZXldO1xuICAgICAgZGVsZXRlIG9ialtrZXldO1xuICAgICAgaWYgKG1vdmUgPiAwIHx8IGludEtleSA+IHN0YXJ0KSB7XG4gICAgICAgIG9ialtpbnRLZXkgKyBtb3ZlXSA9IHZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7Q2hhcnRFdmVudH0gZVxuICogQHBhcmFtIHtDaGFydEV2ZW50fG51bGx9IGxhc3RFdmVudFxuICogQHBhcmFtIHtib29sZWFufSBpbkNoYXJ0QXJlYVxuICogQHBhcmFtIHtib29sZWFufSBpc0NsaWNrXG4gKiBAcmV0dXJucyB7Q2hhcnRFdmVudHxudWxsfVxuICovXG5mdW5jdGlvbiBkZXRlcm1pbmVMYXN0RXZlbnQoZSwgbGFzdEV2ZW50LCBpbkNoYXJ0QXJlYSwgaXNDbGljaykge1xuICBpZiAoIWluQ2hhcnRBcmVhIHx8IGUudHlwZSA9PT0gJ21vdXNlb3V0Jykge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGlmIChpc0NsaWNrKSB7XG4gICAgcmV0dXJuIGxhc3RFdmVudDtcbiAgfVxuICByZXR1cm4gZTtcbn1cblxuZnVuY3Rpb24gZ2V0U2l6ZUZvckFyZWEoc2NhbGUsIGNoYXJ0QXJlYSwgZmllbGQpIHtcbiAgcmV0dXJuIHNjYWxlLm9wdGlvbnMuY2xpcCA/IHNjYWxlW2ZpZWxkXSA6IGNoYXJ0QXJlYVtmaWVsZF07XG59XG5cbmZ1bmN0aW9uIGdldERhdGFzZXRBcmVhKG1ldGEsIGNoYXJ0QXJlYSkge1xuICBjb25zdCB7eFNjYWxlLCB5U2NhbGV9ID0gbWV0YTtcbiAgaWYgKHhTY2FsZSAmJiB5U2NhbGUpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbGVmdDogZ2V0U2l6ZUZvckFyZWEoeFNjYWxlLCBjaGFydEFyZWEsICdsZWZ0JyksXG4gICAgICByaWdodDogZ2V0U2l6ZUZvckFyZWEoeFNjYWxlLCBjaGFydEFyZWEsICdyaWdodCcpLFxuICAgICAgdG9wOiBnZXRTaXplRm9yQXJlYSh5U2NhbGUsIGNoYXJ0QXJlYSwgJ3RvcCcpLFxuICAgICAgYm90dG9tOiBnZXRTaXplRm9yQXJlYSh5U2NhbGUsIGNoYXJ0QXJlYSwgJ2JvdHRvbScpXG4gICAgfTtcbiAgfVxuICByZXR1cm4gY2hhcnRBcmVhO1xufVxuXG5jbGFzcyBDaGFydCB7XG5cbiAgc3RhdGljIGRlZmF1bHRzID0gZGVmYXVsdHM7XG4gIHN0YXRpYyBpbnN0YW5jZXMgPSBpbnN0YW5jZXM7XG4gIHN0YXRpYyBvdmVycmlkZXMgPSBvdmVycmlkZXM7XG4gIHN0YXRpYyByZWdpc3RyeSA9IHJlZ2lzdHJ5O1xuICBzdGF0aWMgdmVyc2lvbiA9IHZlcnNpb247XG4gIHN0YXRpYyBnZXRDaGFydCA9IGdldENoYXJ0O1xuXG4gIHN0YXRpYyByZWdpc3RlciguLi5pdGVtcykge1xuICAgIHJlZ2lzdHJ5LmFkZCguLi5pdGVtcyk7XG4gICAgaW52YWxpZGF0ZVBsdWdpbnMoKTtcbiAgfVxuXG4gIHN0YXRpYyB1bnJlZ2lzdGVyKC4uLml0ZW1zKSB7XG4gICAgcmVnaXN0cnkucmVtb3ZlKC4uLml0ZW1zKTtcbiAgICBpbnZhbGlkYXRlUGx1Z2lucygpO1xuICB9XG5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG1heC1zdGF0ZW1lbnRzXG4gIGNvbnN0cnVjdG9yKGl0ZW0sIHVzZXJDb25maWcpIHtcbiAgICBjb25zdCBjb25maWcgPSB0aGlzLmNvbmZpZyA9IG5ldyBDb25maWcodXNlckNvbmZpZyk7XG4gICAgY29uc3QgaW5pdGlhbENhbnZhcyA9IGdldENhbnZhcyhpdGVtKTtcbiAgICBjb25zdCBleGlzdGluZ0NoYXJ0ID0gZ2V0Q2hhcnQoaW5pdGlhbENhbnZhcyk7XG4gICAgaWYgKGV4aXN0aW5nQ2hhcnQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ0NhbnZhcyBpcyBhbHJlYWR5IGluIHVzZS4gQ2hhcnQgd2l0aCBJRCBcXCcnICsgZXhpc3RpbmdDaGFydC5pZCArICdcXCcnICtcblx0XHRcdFx0JyBtdXN0IGJlIGRlc3Ryb3llZCBiZWZvcmUgdGhlIGNhbnZhcyB3aXRoIElEIFxcJycgKyBleGlzdGluZ0NoYXJ0LmNhbnZhcy5pZCArICdcXCcgY2FuIGJlIHJldXNlZC4nXG4gICAgICApO1xuICAgIH1cblxuICAgIGNvbnN0IG9wdGlvbnMgPSBjb25maWcuY3JlYXRlUmVzb2x2ZXIoY29uZmlnLmNoYXJ0T3B0aW9uU2NvcGVzKCksIHRoaXMuZ2V0Q29udGV4dCgpKTtcblxuICAgIHRoaXMucGxhdGZvcm0gPSBuZXcgKGNvbmZpZy5wbGF0Zm9ybSB8fCBfZGV0ZWN0UGxhdGZvcm0oaW5pdGlhbENhbnZhcykpKCk7XG4gICAgdGhpcy5wbGF0Zm9ybS51cGRhdGVDb25maWcoY29uZmlnKTtcblxuICAgIGNvbnN0IGNvbnRleHQgPSB0aGlzLnBsYXRmb3JtLmFjcXVpcmVDb250ZXh0KGluaXRpYWxDYW52YXMsIG9wdGlvbnMuYXNwZWN0UmF0aW8pO1xuICAgIGNvbnN0IGNhbnZhcyA9IGNvbnRleHQgJiYgY29udGV4dC5jYW52YXM7XG4gICAgY29uc3QgaGVpZ2h0ID0gY2FudmFzICYmIGNhbnZhcy5oZWlnaHQ7XG4gICAgY29uc3Qgd2lkdGggPSBjYW52YXMgJiYgY2FudmFzLndpZHRoO1xuXG4gICAgdGhpcy5pZCA9IHVpZCgpO1xuICAgIHRoaXMuY3R4ID0gY29udGV4dDtcbiAgICB0aGlzLmNhbnZhcyA9IGNhbnZhcztcbiAgICB0aGlzLndpZHRoID0gd2lkdGg7XG4gICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgdGhpcy5fb3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgLy8gU3RvcmUgdGhlIHByZXZpb3VzbHkgdXNlZCBhc3BlY3QgcmF0aW8gdG8gZGV0ZXJtaW5lIGlmIGEgcmVzaXplXG4gICAgLy8gaXMgbmVlZGVkIGR1cmluZyB1cGRhdGVzLiBEbyB0aGlzIGFmdGVyIF9vcHRpb25zIGlzIHNldCBzaW5jZVxuICAgIC8vIGFzcGVjdFJhdGlvIHVzZXMgYSBnZXR0ZXJcbiAgICB0aGlzLl9hc3BlY3RSYXRpbyA9IHRoaXMuYXNwZWN0UmF0aW87XG4gICAgdGhpcy5fbGF5ZXJzID0gW107XG4gICAgdGhpcy5fbWV0YXNldHMgPSBbXTtcbiAgICB0aGlzLl9zdGFja3MgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5ib3hlcyA9IFtdO1xuICAgIHRoaXMuY3VycmVudERldmljZVBpeGVsUmF0aW8gPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5jaGFydEFyZWEgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fYWN0aXZlID0gW107XG4gICAgdGhpcy5fbGFzdEV2ZW50ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX2xpc3RlbmVycyA9IHt9O1xuICAgIC8qKiBAdHlwZSB7P3thdHRhY2g/OiBmdW5jdGlvbiwgZGV0YWNoPzogZnVuY3Rpb24sIHJlc2l6ZT86IGZ1bmN0aW9ufX0gKi9cbiAgICB0aGlzLl9yZXNwb25zaXZlTGlzdGVuZXJzID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX3NvcnRlZE1ldGFzZXRzID0gW107XG4gICAgdGhpcy5zY2FsZXMgPSB7fTtcbiAgICB0aGlzLl9wbHVnaW5zID0gbmV3IFBsdWdpblNlcnZpY2UoKTtcbiAgICB0aGlzLiRwcm94aWVzID0ge307XG4gICAgdGhpcy5faGlkZGVuSW5kaWNlcyA9IHt9O1xuICAgIHRoaXMuYXR0YWNoZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9hbmltYXRpb25zRGlzYWJsZWQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy4kY29udGV4dCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9kb1Jlc2l6ZSA9IGRlYm91bmNlKG1vZGUgPT4gdGhpcy51cGRhdGUobW9kZSksIG9wdGlvbnMucmVzaXplRGVsYXkgfHwgMCk7XG4gICAgdGhpcy5fZGF0YUNoYW5nZXMgPSBbXTtcblxuICAgIC8vIEFkZCB0aGUgY2hhcnQgaW5zdGFuY2UgdG8gdGhlIGdsb2JhbCBuYW1lc3BhY2VcbiAgICBpbnN0YW5jZXNbdGhpcy5pZF0gPSB0aGlzO1xuXG4gICAgaWYgKCFjb250ZXh0IHx8ICFjYW52YXMpIHtcbiAgICAgIC8vIFRoZSBnaXZlbiBpdGVtIGlzIG5vdCBhIGNvbXBhdGlibGUgY29udGV4dDJkIGVsZW1lbnQsIGxldCdzIHJldHVybiBiZWZvcmUgZmluYWxpemluZ1xuICAgICAgLy8gdGhlIGNoYXJ0IGluaXRpYWxpemF0aW9uIGJ1dCBhZnRlciBzZXR0aW5nIGJhc2ljIGNoYXJ0IC8gY29udHJvbGxlciBwcm9wZXJ0aWVzIHRoYXRcbiAgICAgIC8vIGNhbiBoZWxwIHRvIGZpZ3VyZSBvdXQgdGhhdCB0aGUgY2hhcnQgaXMgbm90IHZhbGlkIChlLmcgY2hhcnQuY2FudmFzICE9PSBudWxsKTtcbiAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9jaGFydGpzL0NoYXJ0LmpzL2lzc3Vlcy8yODA3XG4gICAgICBjb25zb2xlLmVycm9yKFwiRmFpbGVkIHRvIGNyZWF0ZSBjaGFydDogY2FuJ3QgYWNxdWlyZSBjb250ZXh0IGZyb20gdGhlIGdpdmVuIGl0ZW1cIik7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgYW5pbWF0b3IubGlzdGVuKHRoaXMsICdjb21wbGV0ZScsIG9uQW5pbWF0aW9uc0NvbXBsZXRlKTtcbiAgICBhbmltYXRvci5saXN0ZW4odGhpcywgJ3Byb2dyZXNzJywgb25BbmltYXRpb25Qcm9ncmVzcyk7XG5cbiAgICB0aGlzLl9pbml0aWFsaXplKCk7XG4gICAgaWYgKHRoaXMuYXR0YWNoZWQpIHtcbiAgICAgIHRoaXMudXBkYXRlKCk7XG4gICAgfVxuICB9XG5cbiAgZ2V0IGFzcGVjdFJhdGlvKCkge1xuICAgIGNvbnN0IHtvcHRpb25zOiB7YXNwZWN0UmF0aW8sIG1haW50YWluQXNwZWN0UmF0aW99LCB3aWR0aCwgaGVpZ2h0LCBfYXNwZWN0UmF0aW99ID0gdGhpcztcbiAgICBpZiAoIWlzTnVsbE9yVW5kZWYoYXNwZWN0UmF0aW8pKSB7XG4gICAgICAvLyBJZiBhc3BlY3RSYXRpbyBpcyBkZWZpbmVkIGluIG9wdGlvbnMsIHVzZSB0aGF0LlxuICAgICAgcmV0dXJuIGFzcGVjdFJhdGlvO1xuICAgIH1cblxuICAgIGlmIChtYWludGFpbkFzcGVjdFJhdGlvICYmIF9hc3BlY3RSYXRpbykge1xuICAgICAgLy8gSWYgbWFpbnRhaW5Bc3BlY3RSYXRpbyBpcyB0cnV0aGx5IGFuZCB3ZSBoYWQgcHJldmlvdXNseSBkZXRlcm1pbmVkIF9hc3BlY3RSYXRpbywgdXNlIHRoYXRcbiAgICAgIHJldHVybiBfYXNwZWN0UmF0aW87XG4gICAgfVxuXG4gICAgLy8gQ2FsY3VsYXRlXG4gICAgcmV0dXJuIGhlaWdodCA/IHdpZHRoIC8gaGVpZ2h0IDogbnVsbDtcbiAgfVxuXG4gIGdldCBkYXRhKCkge1xuICAgIHJldHVybiB0aGlzLmNvbmZpZy5kYXRhO1xuICB9XG5cbiAgc2V0IGRhdGEoZGF0YSkge1xuICAgIHRoaXMuY29uZmlnLmRhdGEgPSBkYXRhO1xuICB9XG5cbiAgZ2V0IG9wdGlvbnMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX29wdGlvbnM7XG4gIH1cblxuICBzZXQgb3B0aW9ucyhvcHRpb25zKSB7XG4gICAgdGhpcy5jb25maWcub3B0aW9ucyA9IG9wdGlvbnM7XG4gIH1cblxuICBnZXQgcmVnaXN0cnkoKSB7XG4gICAgcmV0dXJuIHJlZ2lzdHJ5O1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfaW5pdGlhbGl6ZSgpIHtcbiAgICAvLyBCZWZvcmUgaW5pdCBwbHVnaW4gbm90aWZpY2F0aW9uXG4gICAgdGhpcy5ub3RpZnlQbHVnaW5zKCdiZWZvcmVJbml0Jyk7XG5cbiAgICBpZiAodGhpcy5vcHRpb25zLnJlc3BvbnNpdmUpIHtcbiAgICAgIHRoaXMucmVzaXplKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldGluYVNjYWxlKHRoaXMsIHRoaXMub3B0aW9ucy5kZXZpY2VQaXhlbFJhdGlvKTtcbiAgICB9XG5cbiAgICB0aGlzLmJpbmRFdmVudHMoKTtcblxuICAgIC8vIEFmdGVyIGluaXQgcGx1Z2luIG5vdGlmaWNhdGlvblxuICAgIHRoaXMubm90aWZ5UGx1Z2lucygnYWZ0ZXJJbml0Jyk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIGNsZWFyKCkge1xuICAgIGNsZWFyQ2FudmFzKHRoaXMuY2FudmFzLCB0aGlzLmN0eCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBzdG9wKCkge1xuICAgIGFuaW1hdG9yLnN0b3AodGhpcyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcblx0ICogUmVzaXplIHRoZSBjaGFydCB0byBpdHMgY29udGFpbmVyIG9yIHRvIGV4cGxpY2l0IGRpbWVuc2lvbnMuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBbd2lkdGhdXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBbaGVpZ2h0XVxuXHQgKi9cbiAgcmVzaXplKHdpZHRoLCBoZWlnaHQpIHtcbiAgICBpZiAoIWFuaW1hdG9yLnJ1bm5pbmcodGhpcykpIHtcbiAgICAgIHRoaXMuX3Jlc2l6ZSh3aWR0aCwgaGVpZ2h0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fcmVzaXplQmVmb3JlRHJhdyA9IHt3aWR0aCwgaGVpZ2h0fTtcbiAgICB9XG4gIH1cblxuICBfcmVzaXplKHdpZHRoLCBoZWlnaHQpIHtcbiAgICBjb25zdCBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgIGNvbnN0IGNhbnZhcyA9IHRoaXMuY2FudmFzO1xuICAgIGNvbnN0IGFzcGVjdFJhdGlvID0gb3B0aW9ucy5tYWludGFpbkFzcGVjdFJhdGlvICYmIHRoaXMuYXNwZWN0UmF0aW87XG4gICAgY29uc3QgbmV3U2l6ZSA9IHRoaXMucGxhdGZvcm0uZ2V0TWF4aW11bVNpemUoY2FudmFzLCB3aWR0aCwgaGVpZ2h0LCBhc3BlY3RSYXRpbyk7XG4gICAgY29uc3QgbmV3UmF0aW8gPSBvcHRpb25zLmRldmljZVBpeGVsUmF0aW8gfHwgdGhpcy5wbGF0Zm9ybS5nZXREZXZpY2VQaXhlbFJhdGlvKCk7XG4gICAgY29uc3QgbW9kZSA9IHRoaXMud2lkdGggPyAncmVzaXplJyA6ICdhdHRhY2gnO1xuXG4gICAgdGhpcy53aWR0aCA9IG5ld1NpemUud2lkdGg7XG4gICAgdGhpcy5oZWlnaHQgPSBuZXdTaXplLmhlaWdodDtcbiAgICB0aGlzLl9hc3BlY3RSYXRpbyA9IHRoaXMuYXNwZWN0UmF0aW87XG4gICAgaWYgKCFyZXRpbmFTY2FsZSh0aGlzLCBuZXdSYXRpbywgdHJ1ZSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLm5vdGlmeVBsdWdpbnMoJ3Jlc2l6ZScsIHtzaXplOiBuZXdTaXplfSk7XG5cbiAgICBjYWxsQ2FsbGJhY2sob3B0aW9ucy5vblJlc2l6ZSwgW3RoaXMsIG5ld1NpemVdLCB0aGlzKTtcblxuICAgIGlmICh0aGlzLmF0dGFjaGVkKSB7XG4gICAgICBpZiAodGhpcy5fZG9SZXNpemUobW9kZSkpIHtcbiAgICAgICAgLy8gVGhlIHJlc2l6ZSB1cGRhdGUgaXMgZGVsYXllZCwgb25seSBkcmF3IHdpdGhvdXQgdXBkYXRpbmcuXG4gICAgICAgIHRoaXMucmVuZGVyKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZW5zdXJlU2NhbGVzSGF2ZUlEcygpIHtcbiAgICBjb25zdCBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgIGNvbnN0IHNjYWxlc09wdGlvbnMgPSBvcHRpb25zLnNjYWxlcyB8fCB7fTtcblxuICAgIGVhY2goc2NhbGVzT3B0aW9ucywgKGF4aXNPcHRpb25zLCBheGlzSUQpID0+IHtcbiAgICAgIGF4aXNPcHRpb25zLmlkID0gYXhpc0lEO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG5cdCAqIEJ1aWxkcyBhIG1hcCBvZiBzY2FsZSBJRCB0byBzY2FsZSBvYmplY3QgZm9yIGZ1dHVyZSBsb29rdXAuXG5cdCAqL1xuICBidWlsZE9yVXBkYXRlU2NhbGVzKCkge1xuICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgY29uc3Qgc2NhbGVPcHRzID0gb3B0aW9ucy5zY2FsZXM7XG4gICAgY29uc3Qgc2NhbGVzID0gdGhpcy5zY2FsZXM7XG4gICAgY29uc3QgdXBkYXRlZCA9IE9iamVjdC5rZXlzKHNjYWxlcykucmVkdWNlKChvYmosIGlkKSA9PiB7XG4gICAgICBvYmpbaWRdID0gZmFsc2U7XG4gICAgICByZXR1cm4gb2JqO1xuICAgIH0sIHt9KTtcbiAgICBsZXQgaXRlbXMgPSBbXTtcblxuICAgIGlmIChzY2FsZU9wdHMpIHtcbiAgICAgIGl0ZW1zID0gaXRlbXMuY29uY2F0KFxuICAgICAgICBPYmplY3Qua2V5cyhzY2FsZU9wdHMpLm1hcCgoaWQpID0+IHtcbiAgICAgICAgICBjb25zdCBzY2FsZU9wdGlvbnMgPSBzY2FsZU9wdHNbaWRdO1xuICAgICAgICAgIGNvbnN0IGF4aXMgPSBkZXRlcm1pbmVBeGlzKGlkLCBzY2FsZU9wdGlvbnMpO1xuICAgICAgICAgIGNvbnN0IGlzUmFkaWFsID0gYXhpcyA9PT0gJ3InO1xuICAgICAgICAgIGNvbnN0IGlzSG9yaXpvbnRhbCA9IGF4aXMgPT09ICd4JztcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgb3B0aW9uczogc2NhbGVPcHRpb25zLFxuICAgICAgICAgICAgZHBvc2l0aW9uOiBpc1JhZGlhbCA/ICdjaGFydEFyZWEnIDogaXNIb3Jpem9udGFsID8gJ2JvdHRvbScgOiAnbGVmdCcsXG4gICAgICAgICAgICBkdHlwZTogaXNSYWRpYWwgPyAncmFkaWFsTGluZWFyJyA6IGlzSG9yaXpvbnRhbCA/ICdjYXRlZ29yeScgOiAnbGluZWFyJ1xuICAgICAgICAgIH07XG4gICAgICAgIH0pXG4gICAgICApO1xuICAgIH1cblxuICAgIGVhY2goaXRlbXMsIChpdGVtKSA9PiB7XG4gICAgICBjb25zdCBzY2FsZU9wdGlvbnMgPSBpdGVtLm9wdGlvbnM7XG4gICAgICBjb25zdCBpZCA9IHNjYWxlT3B0aW9ucy5pZDtcbiAgICAgIGNvbnN0IGF4aXMgPSBkZXRlcm1pbmVBeGlzKGlkLCBzY2FsZU9wdGlvbnMpO1xuICAgICAgY29uc3Qgc2NhbGVUeXBlID0gdmFsdWVPckRlZmF1bHQoc2NhbGVPcHRpb25zLnR5cGUsIGl0ZW0uZHR5cGUpO1xuXG4gICAgICBpZiAoc2NhbGVPcHRpb25zLnBvc2l0aW9uID09PSB1bmRlZmluZWQgfHwgcG9zaXRpb25Jc0hvcml6b250YWwoc2NhbGVPcHRpb25zLnBvc2l0aW9uLCBheGlzKSAhPT0gcG9zaXRpb25Jc0hvcml6b250YWwoaXRlbS5kcG9zaXRpb24pKSB7XG4gICAgICAgIHNjYWxlT3B0aW9ucy5wb3NpdGlvbiA9IGl0ZW0uZHBvc2l0aW9uO1xuICAgICAgfVxuXG4gICAgICB1cGRhdGVkW2lkXSA9IHRydWU7XG4gICAgICBsZXQgc2NhbGUgPSBudWxsO1xuICAgICAgaWYgKGlkIGluIHNjYWxlcyAmJiBzY2FsZXNbaWRdLnR5cGUgPT09IHNjYWxlVHlwZSkge1xuICAgICAgICBzY2FsZSA9IHNjYWxlc1tpZF07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBzY2FsZUNsYXNzID0gcmVnaXN0cnkuZ2V0U2NhbGUoc2NhbGVUeXBlKTtcbiAgICAgICAgc2NhbGUgPSBuZXcgc2NhbGVDbGFzcyh7XG4gICAgICAgICAgaWQsXG4gICAgICAgICAgdHlwZTogc2NhbGVUeXBlLFxuICAgICAgICAgIGN0eDogdGhpcy5jdHgsXG4gICAgICAgICAgY2hhcnQ6IHRoaXNcbiAgICAgICAgfSk7XG4gICAgICAgIHNjYWxlc1tzY2FsZS5pZF0gPSBzY2FsZTtcbiAgICAgIH1cblxuICAgICAgc2NhbGUuaW5pdChzY2FsZU9wdGlvbnMsIG9wdGlvbnMpO1xuICAgIH0pO1xuICAgIC8vIGNsZWFyIHVwIGRpc2NhcmRlZCBzY2FsZXNcbiAgICBlYWNoKHVwZGF0ZWQsIChoYXNVcGRhdGVkLCBpZCkgPT4ge1xuICAgICAgaWYgKCFoYXNVcGRhdGVkKSB7XG4gICAgICAgIGRlbGV0ZSBzY2FsZXNbaWRdO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgZWFjaChzY2FsZXMsIChzY2FsZSkgPT4ge1xuICAgICAgbGF5b3V0cy5jb25maWd1cmUodGhpcywgc2NhbGUsIHNjYWxlLm9wdGlvbnMpO1xuICAgICAgbGF5b3V0cy5hZGRCb3godGhpcywgc2NhbGUpO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfdXBkYXRlTWV0YXNldHMoKSB7XG4gICAgY29uc3QgbWV0YXNldHMgPSB0aGlzLl9tZXRhc2V0cztcbiAgICBjb25zdCBudW1EYXRhID0gdGhpcy5kYXRhLmRhdGFzZXRzLmxlbmd0aDtcbiAgICBjb25zdCBudW1NZXRhID0gbWV0YXNldHMubGVuZ3RoO1xuXG4gICAgbWV0YXNldHMuc29ydCgoYSwgYikgPT4gYS5pbmRleCAtIGIuaW5kZXgpO1xuICAgIGlmIChudW1NZXRhID4gbnVtRGF0YSkge1xuICAgICAgZm9yIChsZXQgaSA9IG51bURhdGE7IGkgPCBudW1NZXRhOyArK2kpIHtcbiAgICAgICAgdGhpcy5fZGVzdHJveURhdGFzZXRNZXRhKGkpO1xuICAgICAgfVxuICAgICAgbWV0YXNldHMuc3BsaWNlKG51bURhdGEsIG51bU1ldGEgLSBudW1EYXRhKTtcbiAgICB9XG4gICAgdGhpcy5fc29ydGVkTWV0YXNldHMgPSBtZXRhc2V0cy5zbGljZSgwKS5zb3J0KGNvbXBhcmUyTGV2ZWwoJ29yZGVyJywgJ2luZGV4JykpO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfcmVtb3ZlVW5yZWZlcmVuY2VkTWV0YXNldHMoKSB7XG4gICAgY29uc3Qge19tZXRhc2V0czogbWV0YXNldHMsIGRhdGE6IHtkYXRhc2V0c319ID0gdGhpcztcbiAgICBpZiAobWV0YXNldHMubGVuZ3RoID4gZGF0YXNldHMubGVuZ3RoKSB7XG4gICAgICBkZWxldGUgdGhpcy5fc3RhY2tzO1xuICAgIH1cbiAgICBtZXRhc2V0cy5mb3JFYWNoKChtZXRhLCBpbmRleCkgPT4ge1xuICAgICAgaWYgKGRhdGFzZXRzLmZpbHRlcih4ID0+IHggPT09IG1ldGEuX2RhdGFzZXQpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0aGlzLl9kZXN0cm95RGF0YXNldE1ldGEoaW5kZXgpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgYnVpbGRPclVwZGF0ZUNvbnRyb2xsZXJzKCkge1xuICAgIGNvbnN0IG5ld0NvbnRyb2xsZXJzID0gW107XG4gICAgY29uc3QgZGF0YXNldHMgPSB0aGlzLmRhdGEuZGF0YXNldHM7XG4gICAgbGV0IGksIGlsZW47XG5cbiAgICB0aGlzLl9yZW1vdmVVbnJlZmVyZW5jZWRNZXRhc2V0cygpO1xuXG4gICAgZm9yIChpID0gMCwgaWxlbiA9IGRhdGFzZXRzLmxlbmd0aDsgaSA8IGlsZW47IGkrKykge1xuICAgICAgY29uc3QgZGF0YXNldCA9IGRhdGFzZXRzW2ldO1xuICAgICAgbGV0IG1ldGEgPSB0aGlzLmdldERhdGFzZXRNZXRhKGkpO1xuICAgICAgY29uc3QgdHlwZSA9IGRhdGFzZXQudHlwZSB8fCB0aGlzLmNvbmZpZy50eXBlO1xuXG4gICAgICBpZiAobWV0YS50eXBlICYmIG1ldGEudHlwZSAhPT0gdHlwZSkge1xuICAgICAgICB0aGlzLl9kZXN0cm95RGF0YXNldE1ldGEoaSk7XG4gICAgICAgIG1ldGEgPSB0aGlzLmdldERhdGFzZXRNZXRhKGkpO1xuICAgICAgfVxuICAgICAgbWV0YS50eXBlID0gdHlwZTtcbiAgICAgIG1ldGEuaW5kZXhBeGlzID0gZGF0YXNldC5pbmRleEF4aXMgfHwgZ2V0SW5kZXhBeGlzKHR5cGUsIHRoaXMub3B0aW9ucyk7XG4gICAgICBtZXRhLm9yZGVyID0gZGF0YXNldC5vcmRlciB8fCAwO1xuICAgICAgbWV0YS5pbmRleCA9IGk7XG4gICAgICBtZXRhLmxhYmVsID0gJycgKyBkYXRhc2V0LmxhYmVsO1xuICAgICAgbWV0YS52aXNpYmxlID0gdGhpcy5pc0RhdGFzZXRWaXNpYmxlKGkpO1xuXG4gICAgICBpZiAobWV0YS5jb250cm9sbGVyKSB7XG4gICAgICAgIG1ldGEuY29udHJvbGxlci51cGRhdGVJbmRleChpKTtcbiAgICAgICAgbWV0YS5jb250cm9sbGVyLmxpbmtTY2FsZXMoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IENvbnRyb2xsZXJDbGFzcyA9IHJlZ2lzdHJ5LmdldENvbnRyb2xsZXIodHlwZSk7XG4gICAgICAgIGNvbnN0IHtkYXRhc2V0RWxlbWVudFR5cGUsIGRhdGFFbGVtZW50VHlwZX0gPSBkZWZhdWx0cy5kYXRhc2V0c1t0eXBlXTtcbiAgICAgICAgT2JqZWN0LmFzc2lnbihDb250cm9sbGVyQ2xhc3MsIHtcbiAgICAgICAgICBkYXRhRWxlbWVudFR5cGU6IHJlZ2lzdHJ5LmdldEVsZW1lbnQoZGF0YUVsZW1lbnRUeXBlKSxcbiAgICAgICAgICBkYXRhc2V0RWxlbWVudFR5cGU6IGRhdGFzZXRFbGVtZW50VHlwZSAmJiByZWdpc3RyeS5nZXRFbGVtZW50KGRhdGFzZXRFbGVtZW50VHlwZSlcbiAgICAgICAgfSk7XG4gICAgICAgIG1ldGEuY29udHJvbGxlciA9IG5ldyBDb250cm9sbGVyQ2xhc3ModGhpcywgaSk7XG4gICAgICAgIG5ld0NvbnRyb2xsZXJzLnB1c2gobWV0YS5jb250cm9sbGVyKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLl91cGRhdGVNZXRhc2V0cygpO1xuICAgIHJldHVybiBuZXdDb250cm9sbGVycztcbiAgfVxuXG4gIC8qKlxuXHQgKiBSZXNldCB0aGUgZWxlbWVudHMgb2YgYWxsIGRhdGFzZXRzXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfcmVzZXRFbGVtZW50cygpIHtcbiAgICBlYWNoKHRoaXMuZGF0YS5kYXRhc2V0cywgKGRhdGFzZXQsIGRhdGFzZXRJbmRleCkgPT4ge1xuICAgICAgdGhpcy5nZXREYXRhc2V0TWV0YShkYXRhc2V0SW5kZXgpLmNvbnRyb2xsZXIucmVzZXQoKTtcbiAgICB9LCB0aGlzKTtcbiAgfVxuXG4gIC8qKlxuXHQqIFJlc2V0cyB0aGUgY2hhcnQgYmFjayB0byBpdHMgc3RhdGUgYmVmb3JlIHRoZSBpbml0aWFsIGFuaW1hdGlvblxuXHQqL1xuICByZXNldCgpIHtcbiAgICB0aGlzLl9yZXNldEVsZW1lbnRzKCk7XG4gICAgdGhpcy5ub3RpZnlQbHVnaW5zKCdyZXNldCcpO1xuICB9XG5cbiAgdXBkYXRlKG1vZGUpIHtcbiAgICBjb25zdCBjb25maWcgPSB0aGlzLmNvbmZpZztcblxuICAgIGNvbmZpZy51cGRhdGUoKTtcbiAgICBjb25zdCBvcHRpb25zID0gdGhpcy5fb3B0aW9ucyA9IGNvbmZpZy5jcmVhdGVSZXNvbHZlcihjb25maWcuY2hhcnRPcHRpb25TY29wZXMoKSwgdGhpcy5nZXRDb250ZXh0KCkpO1xuICAgIGNvbnN0IGFuaW1zRGlzYWJsZWQgPSB0aGlzLl9hbmltYXRpb25zRGlzYWJsZWQgPSAhb3B0aW9ucy5hbmltYXRpb247XG5cbiAgICB0aGlzLl91cGRhdGVTY2FsZXMoKTtcbiAgICB0aGlzLl9jaGVja0V2ZW50QmluZGluZ3MoKTtcbiAgICB0aGlzLl91cGRhdGVIaWRkZW5JbmRpY2VzKCk7XG5cbiAgICAvLyBwbHVnaW5zIG9wdGlvbnMgcmVmZXJlbmNlcyBtaWdodCBoYXZlIGNoYW5nZSwgbGV0J3MgaW52YWxpZGF0ZSB0aGUgY2FjaGVcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vY2hhcnRqcy9DaGFydC5qcy9pc3N1ZXMvNTExMSNpc3N1ZWNvbW1lbnQtMzU1OTM0MTY3XG4gICAgdGhpcy5fcGx1Z2lucy5pbnZhbGlkYXRlKCk7XG5cbiAgICBpZiAodGhpcy5ub3RpZnlQbHVnaW5zKCdiZWZvcmVVcGRhdGUnLCB7bW9kZSwgY2FuY2VsYWJsZTogdHJ1ZX0pID09PSBmYWxzZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIE1ha2Ugc3VyZSBkYXRhc2V0IGNvbnRyb2xsZXJzIGFyZSB1cGRhdGVkIGFuZCBuZXcgY29udHJvbGxlcnMgYXJlIHJlc2V0XG4gICAgY29uc3QgbmV3Q29udHJvbGxlcnMgPSB0aGlzLmJ1aWxkT3JVcGRhdGVDb250cm9sbGVycygpO1xuXG4gICAgdGhpcy5ub3RpZnlQbHVnaW5zKCdiZWZvcmVFbGVtZW50c1VwZGF0ZScpO1xuXG4gICAgLy8gTWFrZSBzdXJlIGFsbCBkYXRhc2V0IGNvbnRyb2xsZXJzIGhhdmUgY29ycmVjdCBtZXRhIGRhdGEgY291bnRzXG4gICAgbGV0IG1pblBhZGRpbmcgPSAwO1xuICAgIGZvciAobGV0IGkgPSAwLCBpbGVuID0gdGhpcy5kYXRhLmRhdGFzZXRzLmxlbmd0aDsgaSA8IGlsZW47IGkrKykge1xuICAgICAgY29uc3Qge2NvbnRyb2xsZXJ9ID0gdGhpcy5nZXREYXRhc2V0TWV0YShpKTtcbiAgICAgIGNvbnN0IHJlc2V0ID0gIWFuaW1zRGlzYWJsZWQgJiYgbmV3Q29udHJvbGxlcnMuaW5kZXhPZihjb250cm9sbGVyKSA9PT0gLTE7XG4gICAgICAvLyBOZXcgY29udHJvbGxlcnMgd2lsbCBiZSByZXNldCBhZnRlciB0aGUgbGF5b3V0IHBhc3MsIHNvIHdlIG9ubHkgd2FudCB0byBtb2RpZnlcbiAgICAgIC8vIGVsZW1lbnRzIGFkZGVkIHRvIG5ldyBkYXRhc2V0c1xuICAgICAgY29udHJvbGxlci5idWlsZE9yVXBkYXRlRWxlbWVudHMocmVzZXQpO1xuICAgICAgbWluUGFkZGluZyA9IE1hdGgubWF4KCtjb250cm9sbGVyLmdldE1heE92ZXJmbG93KCksIG1pblBhZGRpbmcpO1xuICAgIH1cbiAgICBtaW5QYWRkaW5nID0gdGhpcy5fbWluUGFkZGluZyA9IG9wdGlvbnMubGF5b3V0LmF1dG9QYWRkaW5nID8gbWluUGFkZGluZyA6IDA7XG4gICAgdGhpcy5fdXBkYXRlTGF5b3V0KG1pblBhZGRpbmcpO1xuXG4gICAgLy8gT25seSByZXNldCB0aGUgY29udHJvbGxlcnMgaWYgd2UgaGF2ZSBhbmltYXRpb25zXG4gICAgaWYgKCFhbmltc0Rpc2FibGVkKSB7XG4gICAgICAvLyBDYW4gb25seSByZXNldCB0aGUgbmV3IGNvbnRyb2xsZXJzIGFmdGVyIHRoZSBzY2FsZXMgaGF2ZSBiZWVuIHVwZGF0ZWRcbiAgICAgIC8vIFJlc2V0IGlzIGRvbmUgdG8gZ2V0IHRoZSBzdGFydGluZyBwb2ludCBmb3IgdGhlIGluaXRpYWwgYW5pbWF0aW9uXG4gICAgICBlYWNoKG5ld0NvbnRyb2xsZXJzLCAoY29udHJvbGxlcikgPT4ge1xuICAgICAgICBjb250cm9sbGVyLnJlc2V0KCk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICB0aGlzLl91cGRhdGVEYXRhc2V0cyhtb2RlKTtcblxuICAgIC8vIERvIHRoaXMgYmVmb3JlIHJlbmRlciBzbyB0aGF0IGFueSBwbHVnaW5zIHRoYXQgbmVlZCBmaW5hbCBzY2FsZSB1cGRhdGVzIGNhbiB1c2UgaXRcbiAgICB0aGlzLm5vdGlmeVBsdWdpbnMoJ2FmdGVyVXBkYXRlJywge21vZGV9KTtcblxuICAgIHRoaXMuX2xheWVycy5zb3J0KGNvbXBhcmUyTGV2ZWwoJ3onLCAnX2lkeCcpKTtcblxuICAgIC8vIFJlcGxheSBsYXN0IGV2ZW50IGZyb20gYmVmb3JlIHVwZGF0ZSwgb3Igc2V0IGhvdmVyIHN0eWxlcyBvbiBhY3RpdmUgZWxlbWVudHNcbiAgICBjb25zdCB7X2FjdGl2ZSwgX2xhc3RFdmVudH0gPSB0aGlzO1xuICAgIGlmIChfbGFzdEV2ZW50KSB7XG4gICAgICB0aGlzLl9ldmVudEhhbmRsZXIoX2xhc3RFdmVudCwgdHJ1ZSk7XG4gICAgfSBlbHNlIGlmIChfYWN0aXZlLmxlbmd0aCkge1xuICAgICAgdGhpcy5fdXBkYXRlSG92ZXJTdHlsZXMoX2FjdGl2ZSwgX2FjdGl2ZSwgdHJ1ZSk7XG4gICAgfVxuXG4gICAgdGhpcy5yZW5kZXIoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3VwZGF0ZVNjYWxlcygpIHtcbiAgICBlYWNoKHRoaXMuc2NhbGVzLCAoc2NhbGUpID0+IHtcbiAgICAgIGxheW91dHMucmVtb3ZlQm94KHRoaXMsIHNjYWxlKTtcbiAgICB9KTtcblxuICAgIHRoaXMuZW5zdXJlU2NhbGVzSGF2ZUlEcygpO1xuICAgIHRoaXMuYnVpbGRPclVwZGF0ZVNjYWxlcygpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfY2hlY2tFdmVudEJpbmRpbmdzKCkge1xuICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgY29uc3QgZXhpc3RpbmdFdmVudHMgPSBuZXcgU2V0KE9iamVjdC5rZXlzKHRoaXMuX2xpc3RlbmVycykpO1xuICAgIGNvbnN0IG5ld0V2ZW50cyA9IG5ldyBTZXQob3B0aW9ucy5ldmVudHMpO1xuXG4gICAgaWYgKCFzZXRzRXF1YWwoZXhpc3RpbmdFdmVudHMsIG5ld0V2ZW50cykgfHwgISF0aGlzLl9yZXNwb25zaXZlTGlzdGVuZXJzICE9PSBvcHRpb25zLnJlc3BvbnNpdmUpIHtcbiAgICAgIC8vIFRoZSBjb25maWd1cmVkIGV2ZW50cyBoYXZlIGNoYW5nZWQuIFJlYmluZC5cbiAgICAgIHRoaXMudW5iaW5kRXZlbnRzKCk7XG4gICAgICB0aGlzLmJpbmRFdmVudHMoKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF91cGRhdGVIaWRkZW5JbmRpY2VzKCkge1xuICAgIGNvbnN0IHtfaGlkZGVuSW5kaWNlc30gPSB0aGlzO1xuICAgIGNvbnN0IGNoYW5nZXMgPSB0aGlzLl9nZXRVbmlmb3JtRGF0YUNoYW5nZXMoKSB8fCBbXTtcbiAgICBmb3IgKGNvbnN0IHttZXRob2QsIHN0YXJ0LCBjb3VudH0gb2YgY2hhbmdlcykge1xuICAgICAgY29uc3QgbW92ZSA9IG1ldGhvZCA9PT0gJ19yZW1vdmVFbGVtZW50cycgPyAtY291bnQgOiBjb3VudDtcbiAgICAgIG1vdmVOdW1lcmljS2V5cyhfaGlkZGVuSW5kaWNlcywgc3RhcnQsIG1vdmUpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2dldFVuaWZvcm1EYXRhQ2hhbmdlcygpIHtcbiAgICBjb25zdCBfZGF0YUNoYW5nZXMgPSB0aGlzLl9kYXRhQ2hhbmdlcztcbiAgICBpZiAoIV9kYXRhQ2hhbmdlcyB8fCAhX2RhdGFDaGFuZ2VzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuX2RhdGFDaGFuZ2VzID0gW107XG4gICAgY29uc3QgZGF0YXNldENvdW50ID0gdGhpcy5kYXRhLmRhdGFzZXRzLmxlbmd0aDtcbiAgICBjb25zdCBtYWtlU2V0ID0gKGlkeCkgPT4gbmV3IFNldChcbiAgICAgIF9kYXRhQ2hhbmdlc1xuICAgICAgICAuZmlsdGVyKGMgPT4gY1swXSA9PT0gaWR4KVxuICAgICAgICAubWFwKChjLCBpKSA9PiBpICsgJywnICsgYy5zcGxpY2UoMSkuam9pbignLCcpKVxuICAgICk7XG5cbiAgICBjb25zdCBjaGFuZ2VTZXQgPSBtYWtlU2V0KDApO1xuICAgIGZvciAobGV0IGkgPSAxOyBpIDwgZGF0YXNldENvdW50OyBpKyspIHtcbiAgICAgIGlmICghc2V0c0VxdWFsKGNoYW5nZVNldCwgbWFrZVNldChpKSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gQXJyYXkuZnJvbShjaGFuZ2VTZXQpXG4gICAgICAubWFwKGMgPT4gYy5zcGxpdCgnLCcpKVxuICAgICAgLm1hcChhID0+ICh7bWV0aG9kOiBhWzFdLCBzdGFydDogK2FbMl0sIGNvdW50OiArYVszXX0pKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBVcGRhdGVzIHRoZSBjaGFydCBsYXlvdXQgdW5sZXNzIGEgcGx1Z2luIHJldHVybnMgYGZhbHNlYCB0byB0aGUgYGJlZm9yZUxheW91dGBcblx0ICogaG9vaywgaW4gd2hpY2ggY2FzZSwgcGx1Z2lucyB3aWxsIG5vdCBiZSBjYWxsZWQgb24gYGFmdGVyTGF5b3V0YC5cblx0ICogQHByaXZhdGVcblx0ICovXG4gIF91cGRhdGVMYXlvdXQobWluUGFkZGluZykge1xuICAgIGlmICh0aGlzLm5vdGlmeVBsdWdpbnMoJ2JlZm9yZUxheW91dCcsIHtjYW5jZWxhYmxlOiB0cnVlfSkgPT09IGZhbHNlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgbGF5b3V0cy51cGRhdGUodGhpcywgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQsIG1pblBhZGRpbmcpO1xuXG4gICAgY29uc3QgYXJlYSA9IHRoaXMuY2hhcnRBcmVhO1xuICAgIGNvbnN0IG5vQXJlYSA9IGFyZWEud2lkdGggPD0gMCB8fCBhcmVhLmhlaWdodCA8PSAwO1xuXG4gICAgdGhpcy5fbGF5ZXJzID0gW107XG4gICAgZWFjaCh0aGlzLmJveGVzLCAoYm94KSA9PiB7XG4gICAgICBpZiAobm9BcmVhICYmIGJveC5wb3NpdGlvbiA9PT0gJ2NoYXJ0QXJlYScpIHtcbiAgICAgICAgLy8gU2tpcCBkcmF3aW5nIGFuZCBjb25maWd1cmluZyBjaGFydEFyZWEgYm94ZXMgd2hlbiBjaGFydEFyZWEgaXMgemVybyBvciBuZWdhdGl2ZVxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIGNvbmZpZ3VyZSBpcyBjYWxsZWQgdHdpY2UsIG9uY2UgaW4gY29yZS5zY2FsZS51cGRhdGUgYW5kIG9uY2UgaGVyZS5cbiAgICAgIC8vIEhlcmUgdGhlIGJveGVzIGFyZSBmdWxseSB1cGRhdGVkIGFuZCBhdCB0aGVpciBmaW5hbCBwb3NpdGlvbnMuXG4gICAgICBpZiAoYm94LmNvbmZpZ3VyZSkge1xuICAgICAgICBib3guY29uZmlndXJlKCk7XG4gICAgICB9XG4gICAgICB0aGlzLl9sYXllcnMucHVzaCguLi5ib3guX2xheWVycygpKTtcbiAgICB9LCB0aGlzKTtcblxuICAgIHRoaXMuX2xheWVycy5mb3JFYWNoKChpdGVtLCBpbmRleCkgPT4ge1xuICAgICAgaXRlbS5faWR4ID0gaW5kZXg7XG4gICAgfSk7XG5cbiAgICB0aGlzLm5vdGlmeVBsdWdpbnMoJ2FmdGVyTGF5b3V0Jyk7XG4gIH1cblxuICAvKipcblx0ICogVXBkYXRlcyBhbGwgZGF0YXNldHMgdW5sZXNzIGEgcGx1Z2luIHJldHVybnMgYGZhbHNlYCB0byB0aGUgYGJlZm9yZURhdGFzZXRzVXBkYXRlYFxuXHQgKiBob29rLCBpbiB3aGljaCBjYXNlLCBwbHVnaW5zIHdpbGwgbm90IGJlIGNhbGxlZCBvbiBgYWZ0ZXJEYXRhc2V0c1VwZGF0ZWAuXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfdXBkYXRlRGF0YXNldHMobW9kZSkge1xuICAgIGlmICh0aGlzLm5vdGlmeVBsdWdpbnMoJ2JlZm9yZURhdGFzZXRzVXBkYXRlJywge21vZGUsIGNhbmNlbGFibGU6IHRydWV9KSA9PT0gZmFsc2UpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBmb3IgKGxldCBpID0gMCwgaWxlbiA9IHRoaXMuZGF0YS5kYXRhc2V0cy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICAgIHRoaXMuZ2V0RGF0YXNldE1ldGEoaSkuY29udHJvbGxlci5jb25maWd1cmUoKTtcbiAgICB9XG5cbiAgICBmb3IgKGxldCBpID0gMCwgaWxlbiA9IHRoaXMuZGF0YS5kYXRhc2V0cy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICAgIHRoaXMuX3VwZGF0ZURhdGFzZXQoaSwgaXNGdW5jdGlvbihtb2RlKSA/IG1vZGUoe2RhdGFzZXRJbmRleDogaX0pIDogbW9kZSk7XG4gICAgfVxuXG4gICAgdGhpcy5ub3RpZnlQbHVnaW5zKCdhZnRlckRhdGFzZXRzVXBkYXRlJywge21vZGV9KTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBVcGRhdGVzIGRhdGFzZXQgYXQgaW5kZXggdW5sZXNzIGEgcGx1Z2luIHJldHVybnMgYGZhbHNlYCB0byB0aGUgYGJlZm9yZURhdGFzZXRVcGRhdGVgXG5cdCAqIGhvb2ssIGluIHdoaWNoIGNhc2UsIHBsdWdpbnMgd2lsbCBub3QgYmUgY2FsbGVkIG9uIGBhZnRlckRhdGFzZXRVcGRhdGVgLlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgX3VwZGF0ZURhdGFzZXQoaW5kZXgsIG1vZGUpIHtcbiAgICBjb25zdCBtZXRhID0gdGhpcy5nZXREYXRhc2V0TWV0YShpbmRleCk7XG4gICAgY29uc3QgYXJncyA9IHttZXRhLCBpbmRleCwgbW9kZSwgY2FuY2VsYWJsZTogdHJ1ZX07XG5cbiAgICBpZiAodGhpcy5ub3RpZnlQbHVnaW5zKCdiZWZvcmVEYXRhc2V0VXBkYXRlJywgYXJncykgPT09IGZhbHNlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgbWV0YS5jb250cm9sbGVyLl91cGRhdGUobW9kZSk7XG5cbiAgICBhcmdzLmNhbmNlbGFibGUgPSBmYWxzZTtcbiAgICB0aGlzLm5vdGlmeVBsdWdpbnMoJ2FmdGVyRGF0YXNldFVwZGF0ZScsIGFyZ3MpO1xuICB9XG5cbiAgcmVuZGVyKCkge1xuICAgIGlmICh0aGlzLm5vdGlmeVBsdWdpbnMoJ2JlZm9yZVJlbmRlcicsIHtjYW5jZWxhYmxlOiB0cnVlfSkgPT09IGZhbHNlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGFuaW1hdG9yLmhhcyh0aGlzKSkge1xuICAgICAgaWYgKHRoaXMuYXR0YWNoZWQgJiYgIWFuaW1hdG9yLnJ1bm5pbmcodGhpcykpIHtcbiAgICAgICAgYW5pbWF0b3Iuc3RhcnQodGhpcyk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZHJhdygpO1xuICAgICAgb25BbmltYXRpb25zQ29tcGxldGUoe2NoYXJ0OiB0aGlzfSk7XG4gICAgfVxuICB9XG5cbiAgZHJhdygpIHtcbiAgICBsZXQgaTtcbiAgICBpZiAodGhpcy5fcmVzaXplQmVmb3JlRHJhdykge1xuICAgICAgY29uc3Qge3dpZHRoLCBoZWlnaHR9ID0gdGhpcy5fcmVzaXplQmVmb3JlRHJhdztcbiAgICAgIC8vIFVuc2V0IHBlbmRpbmcgcmVzaXplIHJlcXVlc3Qgbm93IHRvIGF2b2lkIHBvc3NpYmxlIHJlY3Vyc2lvbiB3aXRoaW4gX3Jlc2l6ZVxuICAgICAgdGhpcy5fcmVzaXplQmVmb3JlRHJhdyA9IG51bGw7XG4gICAgICB0aGlzLl9yZXNpemUod2lkdGgsIGhlaWdodCk7XG4gICAgfVxuICAgIHRoaXMuY2xlYXIoKTtcblxuICAgIGlmICh0aGlzLndpZHRoIDw9IDAgfHwgdGhpcy5oZWlnaHQgPD0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICh0aGlzLm5vdGlmeVBsdWdpbnMoJ2JlZm9yZURyYXcnLCB7Y2FuY2VsYWJsZTogdHJ1ZX0pID09PSBmYWxzZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIEJlY2F1c2Ugb2YgcGx1Z2luIGhvb2tzIChiZWZvcmUvYWZ0ZXJEYXRhc2V0c0RyYXcpLCBkYXRhc2V0cyBjYW4ndFxuICAgIC8vIGN1cnJlbnRseSBiZSBwYXJ0IG9mIGxheWVycy4gSW5zdGVhZCwgd2UgZHJhd1xuICAgIC8vIGxheWVycyA8PSAwIGJlZm9yZShkZWZhdWx0LCBiYWNrd2FyZCBjb21wYXQpLCBhbmQgdGhlIHJlc3QgYWZ0ZXJcbiAgICBjb25zdCBsYXllcnMgPSB0aGlzLl9sYXllcnM7XG4gICAgZm9yIChpID0gMDsgaSA8IGxheWVycy5sZW5ndGggJiYgbGF5ZXJzW2ldLnogPD0gMDsgKytpKSB7XG4gICAgICBsYXllcnNbaV0uZHJhdyh0aGlzLmNoYXJ0QXJlYSk7XG4gICAgfVxuXG4gICAgdGhpcy5fZHJhd0RhdGFzZXRzKCk7XG5cbiAgICAvLyBSZXN0IG9mIGxheWVyc1xuICAgIGZvciAoOyBpIDwgbGF5ZXJzLmxlbmd0aDsgKytpKSB7XG4gICAgICBsYXllcnNbaV0uZHJhdyh0aGlzLmNoYXJ0QXJlYSk7XG4gICAgfVxuXG4gICAgdGhpcy5ub3RpZnlQbHVnaW5zKCdhZnRlckRyYXcnKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgX2dldFNvcnRlZERhdGFzZXRNZXRhcyhmaWx0ZXJWaXNpYmxlKSB7XG4gICAgY29uc3QgbWV0YXNldHMgPSB0aGlzLl9zb3J0ZWRNZXRhc2V0cztcbiAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICBsZXQgaSwgaWxlbjtcblxuICAgIGZvciAoaSA9IDAsIGlsZW4gPSBtZXRhc2V0cy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICAgIGNvbnN0IG1ldGEgPSBtZXRhc2V0c1tpXTtcbiAgICAgIGlmICghZmlsdGVyVmlzaWJsZSB8fCBtZXRhLnZpc2libGUpIHtcbiAgICAgICAgcmVzdWx0LnB1c2gobWV0YSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuXHQgKiBHZXRzIHRoZSB2aXNpYmxlIGRhdGFzZXQgbWV0YXMgaW4gZHJhd2luZyBvcmRlclxuXHQgKiBAcmV0dXJuIHtvYmplY3RbXX1cblx0ICovXG4gIGdldFNvcnRlZFZpc2libGVEYXRhc2V0TWV0YXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2dldFNvcnRlZERhdGFzZXRNZXRhcyh0cnVlKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBEcmF3cyBhbGwgZGF0YXNldHMgdW5sZXNzIGEgcGx1Z2luIHJldHVybnMgYGZhbHNlYCB0byB0aGUgYGJlZm9yZURhdGFzZXRzRHJhd2Bcblx0ICogaG9vaywgaW4gd2hpY2ggY2FzZSwgcGx1Z2lucyB3aWxsIG5vdCBiZSBjYWxsZWQgb24gYGFmdGVyRGF0YXNldHNEcmF3YC5cblx0ICogQHByaXZhdGVcblx0ICovXG4gIF9kcmF3RGF0YXNldHMoKSB7XG4gICAgaWYgKHRoaXMubm90aWZ5UGx1Z2lucygnYmVmb3JlRGF0YXNldHNEcmF3Jywge2NhbmNlbGFibGU6IHRydWV9KSA9PT0gZmFsc2UpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBtZXRhc2V0cyA9IHRoaXMuZ2V0U29ydGVkVmlzaWJsZURhdGFzZXRNZXRhcygpO1xuICAgIGZvciAobGV0IGkgPSBtZXRhc2V0cy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgdGhpcy5fZHJhd0RhdGFzZXQobWV0YXNldHNbaV0pO1xuICAgIH1cblxuICAgIHRoaXMubm90aWZ5UGx1Z2lucygnYWZ0ZXJEYXRhc2V0c0RyYXcnKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBEcmF3cyBkYXRhc2V0IGF0IGluZGV4IHVubGVzcyBhIHBsdWdpbiByZXR1cm5zIGBmYWxzZWAgdG8gdGhlIGBiZWZvcmVEYXRhc2V0RHJhd2Bcblx0ICogaG9vaywgaW4gd2hpY2ggY2FzZSwgcGx1Z2lucyB3aWxsIG5vdCBiZSBjYWxsZWQgb24gYGFmdGVyRGF0YXNldERyYXdgLlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgX2RyYXdEYXRhc2V0KG1ldGEpIHtcbiAgICBjb25zdCBjdHggPSB0aGlzLmN0eDtcbiAgICBjb25zdCBjbGlwID0gbWV0YS5fY2xpcDtcbiAgICBjb25zdCB1c2VDbGlwID0gIWNsaXAuZGlzYWJsZWQ7XG4gICAgY29uc3QgYXJlYSA9IGdldERhdGFzZXRBcmVhKG1ldGEsIHRoaXMuY2hhcnRBcmVhKTtcbiAgICBjb25zdCBhcmdzID0ge1xuICAgICAgbWV0YSxcbiAgICAgIGluZGV4OiBtZXRhLmluZGV4LFxuICAgICAgY2FuY2VsYWJsZTogdHJ1ZVxuICAgIH07XG5cbiAgICBpZiAodGhpcy5ub3RpZnlQbHVnaW5zKCdiZWZvcmVEYXRhc2V0RHJhdycsIGFyZ3MpID09PSBmYWxzZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICh1c2VDbGlwKSB7XG4gICAgICBjbGlwQXJlYShjdHgsIHtcbiAgICAgICAgbGVmdDogY2xpcC5sZWZ0ID09PSBmYWxzZSA/IDAgOiBhcmVhLmxlZnQgLSBjbGlwLmxlZnQsXG4gICAgICAgIHJpZ2h0OiBjbGlwLnJpZ2h0ID09PSBmYWxzZSA/IHRoaXMud2lkdGggOiBhcmVhLnJpZ2h0ICsgY2xpcC5yaWdodCxcbiAgICAgICAgdG9wOiBjbGlwLnRvcCA9PT0gZmFsc2UgPyAwIDogYXJlYS50b3AgLSBjbGlwLnRvcCxcbiAgICAgICAgYm90dG9tOiBjbGlwLmJvdHRvbSA9PT0gZmFsc2UgPyB0aGlzLmhlaWdodCA6IGFyZWEuYm90dG9tICsgY2xpcC5ib3R0b21cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIG1ldGEuY29udHJvbGxlci5kcmF3KCk7XG5cbiAgICBpZiAodXNlQ2xpcCkge1xuICAgICAgdW5jbGlwQXJlYShjdHgpO1xuICAgIH1cblxuICAgIGFyZ3MuY2FuY2VsYWJsZSA9IGZhbHNlO1xuICAgIHRoaXMubm90aWZ5UGx1Z2lucygnYWZ0ZXJEYXRhc2V0RHJhdycsIGFyZ3MpO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrcyB3aGV0aGVyIHRoZSBnaXZlbiBwb2ludCBpcyBpbiB0aGUgY2hhcnQgYXJlYS5cbiAgICogQHBhcmFtIHtQb2ludH0gcG9pbnQgLSBpbiByZWxhdGl2ZSBjb29yZGluYXRlcyAoc2VlLCBlLmcuLCBnZXRSZWxhdGl2ZVBvc2l0aW9uKVxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICovXG4gIGlzUG9pbnRJbkFyZWEocG9pbnQpIHtcbiAgICByZXR1cm4gX2lzUG9pbnRJbkFyZWEocG9pbnQsIHRoaXMuY2hhcnRBcmVhLCB0aGlzLl9taW5QYWRkaW5nKTtcbiAgfVxuXG4gIGdldEVsZW1lbnRzQXRFdmVudEZvck1vZGUoZSwgbW9kZSwgb3B0aW9ucywgdXNlRmluYWxQb3NpdGlvbikge1xuICAgIGNvbnN0IG1ldGhvZCA9IEludGVyYWN0aW9uLm1vZGVzW21vZGVdO1xuICAgIGlmICh0eXBlb2YgbWV0aG9kID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gbWV0aG9kKHRoaXMsIGUsIG9wdGlvbnMsIHVzZUZpbmFsUG9zaXRpb24pO1xuICAgIH1cblxuICAgIHJldHVybiBbXTtcbiAgfVxuXG4gIGdldERhdGFzZXRNZXRhKGRhdGFzZXRJbmRleCkge1xuICAgIGNvbnN0IGRhdGFzZXQgPSB0aGlzLmRhdGEuZGF0YXNldHNbZGF0YXNldEluZGV4XTtcbiAgICBjb25zdCBtZXRhc2V0cyA9IHRoaXMuX21ldGFzZXRzO1xuICAgIGxldCBtZXRhID0gbWV0YXNldHMuZmlsdGVyKHggPT4geCAmJiB4Ll9kYXRhc2V0ID09PSBkYXRhc2V0KS5wb3AoKTtcblxuICAgIGlmICghbWV0YSkge1xuICAgICAgbWV0YSA9IHtcbiAgICAgICAgdHlwZTogbnVsbCxcbiAgICAgICAgZGF0YTogW10sXG4gICAgICAgIGRhdGFzZXQ6IG51bGwsXG4gICAgICAgIGNvbnRyb2xsZXI6IG51bGwsXG4gICAgICAgIGhpZGRlbjogbnVsbCxcdFx0XHQvLyBTZWUgaXNEYXRhc2V0VmlzaWJsZSgpIGNvbW1lbnRcbiAgICAgICAgeEF4aXNJRDogbnVsbCxcbiAgICAgICAgeUF4aXNJRDogbnVsbCxcbiAgICAgICAgb3JkZXI6IGRhdGFzZXQgJiYgZGF0YXNldC5vcmRlciB8fCAwLFxuICAgICAgICBpbmRleDogZGF0YXNldEluZGV4LFxuICAgICAgICBfZGF0YXNldDogZGF0YXNldCxcbiAgICAgICAgX3BhcnNlZDogW10sXG4gICAgICAgIF9zb3J0ZWQ6IGZhbHNlXG4gICAgICB9O1xuICAgICAgbWV0YXNldHMucHVzaChtZXRhKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbWV0YTtcbiAgfVxuXG4gIGdldENvbnRleHQoKSB7XG4gICAgcmV0dXJuIHRoaXMuJGNvbnRleHQgfHwgKHRoaXMuJGNvbnRleHQgPSBjcmVhdGVDb250ZXh0KG51bGwsIHtjaGFydDogdGhpcywgdHlwZTogJ2NoYXJ0J30pKTtcbiAgfVxuXG4gIGdldFZpc2libGVEYXRhc2V0Q291bnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0U29ydGVkVmlzaWJsZURhdGFzZXRNZXRhcygpLmxlbmd0aDtcbiAgfVxuXG4gIGlzRGF0YXNldFZpc2libGUoZGF0YXNldEluZGV4KSB7XG4gICAgY29uc3QgZGF0YXNldCA9IHRoaXMuZGF0YS5kYXRhc2V0c1tkYXRhc2V0SW5kZXhdO1xuICAgIGlmICghZGF0YXNldCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGNvbnN0IG1ldGEgPSB0aGlzLmdldERhdGFzZXRNZXRhKGRhdGFzZXRJbmRleCk7XG5cbiAgICAvLyBtZXRhLmhpZGRlbiBpcyBhIHBlciBjaGFydCBkYXRhc2V0IGhpZGRlbiBmbGFnIG92ZXJyaWRlIHdpdGggMyBzdGF0ZXM6IGlmIHRydWUgb3IgZmFsc2UsXG4gICAgLy8gdGhlIGRhdGFzZXQuaGlkZGVuIHZhbHVlIGlzIGlnbm9yZWQsIGVsc2UgaWYgbnVsbCwgdGhlIGRhdGFzZXQgaGlkZGVuIHN0YXRlIGlzIHJldHVybmVkLlxuICAgIHJldHVybiB0eXBlb2YgbWV0YS5oaWRkZW4gPT09ICdib29sZWFuJyA/ICFtZXRhLmhpZGRlbiA6ICFkYXRhc2V0LmhpZGRlbjtcbiAgfVxuXG4gIHNldERhdGFzZXRWaXNpYmlsaXR5KGRhdGFzZXRJbmRleCwgdmlzaWJsZSkge1xuICAgIGNvbnN0IG1ldGEgPSB0aGlzLmdldERhdGFzZXRNZXRhKGRhdGFzZXRJbmRleCk7XG4gICAgbWV0YS5oaWRkZW4gPSAhdmlzaWJsZTtcbiAgfVxuXG4gIHRvZ2dsZURhdGFWaXNpYmlsaXR5KGluZGV4KSB7XG4gICAgdGhpcy5faGlkZGVuSW5kaWNlc1tpbmRleF0gPSAhdGhpcy5faGlkZGVuSW5kaWNlc1tpbmRleF07XG4gIH1cblxuICBnZXREYXRhVmlzaWJpbGl0eShpbmRleCkge1xuICAgIHJldHVybiAhdGhpcy5faGlkZGVuSW5kaWNlc1tpbmRleF07XG4gIH1cblxuICAvKipcblx0ICogQHByaXZhdGVcblx0ICovXG4gIF91cGRhdGVWaXNpYmlsaXR5KGRhdGFzZXRJbmRleCwgZGF0YUluZGV4LCB2aXNpYmxlKSB7XG4gICAgY29uc3QgbW9kZSA9IHZpc2libGUgPyAnc2hvdycgOiAnaGlkZSc7XG4gICAgY29uc3QgbWV0YSA9IHRoaXMuZ2V0RGF0YXNldE1ldGEoZGF0YXNldEluZGV4KTtcbiAgICBjb25zdCBhbmltcyA9IG1ldGEuY29udHJvbGxlci5fcmVzb2x2ZUFuaW1hdGlvbnModW5kZWZpbmVkLCBtb2RlKTtcblxuICAgIGlmIChkZWZpbmVkKGRhdGFJbmRleCkpIHtcbiAgICAgIG1ldGEuZGF0YVtkYXRhSW5kZXhdLmhpZGRlbiA9ICF2aXNpYmxlO1xuICAgICAgdGhpcy51cGRhdGUoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zZXREYXRhc2V0VmlzaWJpbGl0eShkYXRhc2V0SW5kZXgsIHZpc2libGUpO1xuICAgICAgLy8gQW5pbWF0ZSB2aXNpYmxlIHN0YXRlLCBzbyBoaWRlIGFuaW1hdGlvbiBjYW4gYmUgc2Vlbi4gVGhpcyBjb3VsZCBiZSBoYW5kbGVkIGJldHRlciBpZiB1cGRhdGUgLyB1cGRhdGVEYXRhc2V0IHJldHVybmVkIGEgUHJvbWlzZS5cbiAgICAgIGFuaW1zLnVwZGF0ZShtZXRhLCB7dmlzaWJsZX0pO1xuICAgICAgdGhpcy51cGRhdGUoKGN0eCkgPT4gY3R4LmRhdGFzZXRJbmRleCA9PT0gZGF0YXNldEluZGV4ID8gbW9kZSA6IHVuZGVmaW5lZCk7XG4gICAgfVxuICB9XG5cbiAgaGlkZShkYXRhc2V0SW5kZXgsIGRhdGFJbmRleCkge1xuICAgIHRoaXMuX3VwZGF0ZVZpc2liaWxpdHkoZGF0YXNldEluZGV4LCBkYXRhSW5kZXgsIGZhbHNlKTtcbiAgfVxuXG4gIHNob3coZGF0YXNldEluZGV4LCBkYXRhSW5kZXgpIHtcbiAgICB0aGlzLl91cGRhdGVWaXNpYmlsaXR5KGRhdGFzZXRJbmRleCwgZGF0YUluZGV4LCB0cnVlKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgX2Rlc3Ryb3lEYXRhc2V0TWV0YShkYXRhc2V0SW5kZXgpIHtcbiAgICBjb25zdCBtZXRhID0gdGhpcy5fbWV0YXNldHNbZGF0YXNldEluZGV4XTtcbiAgICBpZiAobWV0YSAmJiBtZXRhLmNvbnRyb2xsZXIpIHtcbiAgICAgIG1ldGEuY29udHJvbGxlci5fZGVzdHJveSgpO1xuICAgIH1cbiAgICBkZWxldGUgdGhpcy5fbWV0YXNldHNbZGF0YXNldEluZGV4XTtcbiAgfVxuXG4gIF9zdG9wKCkge1xuICAgIGxldCBpLCBpbGVuO1xuICAgIHRoaXMuc3RvcCgpO1xuICAgIGFuaW1hdG9yLnJlbW92ZSh0aGlzKTtcblxuICAgIGZvciAoaSA9IDAsIGlsZW4gPSB0aGlzLmRhdGEuZGF0YXNldHMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgICB0aGlzLl9kZXN0cm95RGF0YXNldE1ldGEoaSk7XG4gICAgfVxuICB9XG5cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLm5vdGlmeVBsdWdpbnMoJ2JlZm9yZURlc3Ryb3knKTtcbiAgICBjb25zdCB7Y2FudmFzLCBjdHh9ID0gdGhpcztcblxuICAgIHRoaXMuX3N0b3AoKTtcbiAgICB0aGlzLmNvbmZpZy5jbGVhckNhY2hlKCk7XG5cbiAgICBpZiAoY2FudmFzKSB7XG4gICAgICB0aGlzLnVuYmluZEV2ZW50cygpO1xuICAgICAgY2xlYXJDYW52YXMoY2FudmFzLCBjdHgpO1xuICAgICAgdGhpcy5wbGF0Zm9ybS5yZWxlYXNlQ29udGV4dChjdHgpO1xuICAgICAgdGhpcy5jYW52YXMgPSBudWxsO1xuICAgICAgdGhpcy5jdHggPSBudWxsO1xuICAgIH1cblxuICAgIGRlbGV0ZSBpbnN0YW5jZXNbdGhpcy5pZF07XG5cbiAgICB0aGlzLm5vdGlmeVBsdWdpbnMoJ2FmdGVyRGVzdHJveScpO1xuICB9XG5cbiAgdG9CYXNlNjRJbWFnZSguLi5hcmdzKSB7XG4gICAgcmV0dXJuIHRoaXMuY2FudmFzLnRvRGF0YVVSTCguLi5hcmdzKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgYmluZEV2ZW50cygpIHtcbiAgICB0aGlzLmJpbmRVc2VyRXZlbnRzKCk7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5yZXNwb25zaXZlKSB7XG4gICAgICB0aGlzLmJpbmRSZXNwb25zaXZlRXZlbnRzKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuYXR0YWNoZWQgPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgYmluZFVzZXJFdmVudHMoKSB7XG4gICAgY29uc3QgbGlzdGVuZXJzID0gdGhpcy5fbGlzdGVuZXJzO1xuICAgIGNvbnN0IHBsYXRmb3JtID0gdGhpcy5wbGF0Zm9ybTtcblxuICAgIGNvbnN0IF9hZGQgPSAodHlwZSwgbGlzdGVuZXIpID0+IHtcbiAgICAgIHBsYXRmb3JtLmFkZEV2ZW50TGlzdGVuZXIodGhpcywgdHlwZSwgbGlzdGVuZXIpO1xuICAgICAgbGlzdGVuZXJzW3R5cGVdID0gbGlzdGVuZXI7XG4gICAgfTtcblxuICAgIGNvbnN0IGxpc3RlbmVyID0gKGUsIHgsIHkpID0+IHtcbiAgICAgIGUub2Zmc2V0WCA9IHg7XG4gICAgICBlLm9mZnNldFkgPSB5O1xuICAgICAgdGhpcy5fZXZlbnRIYW5kbGVyKGUpO1xuICAgIH07XG5cbiAgICBlYWNoKHRoaXMub3B0aW9ucy5ldmVudHMsICh0eXBlKSA9PiBfYWRkKHR5cGUsIGxpc3RlbmVyKSk7XG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGJpbmRSZXNwb25zaXZlRXZlbnRzKCkge1xuICAgIGlmICghdGhpcy5fcmVzcG9uc2l2ZUxpc3RlbmVycykge1xuICAgICAgdGhpcy5fcmVzcG9uc2l2ZUxpc3RlbmVycyA9IHt9O1xuICAgIH1cbiAgICBjb25zdCBsaXN0ZW5lcnMgPSB0aGlzLl9yZXNwb25zaXZlTGlzdGVuZXJzO1xuICAgIGNvbnN0IHBsYXRmb3JtID0gdGhpcy5wbGF0Zm9ybTtcblxuICAgIGNvbnN0IF9hZGQgPSAodHlwZSwgbGlzdGVuZXIpID0+IHtcbiAgICAgIHBsYXRmb3JtLmFkZEV2ZW50TGlzdGVuZXIodGhpcywgdHlwZSwgbGlzdGVuZXIpO1xuICAgICAgbGlzdGVuZXJzW3R5cGVdID0gbGlzdGVuZXI7XG4gICAgfTtcbiAgICBjb25zdCBfcmVtb3ZlID0gKHR5cGUsIGxpc3RlbmVyKSA9PiB7XG4gICAgICBpZiAobGlzdGVuZXJzW3R5cGVdKSB7XG4gICAgICAgIHBsYXRmb3JtLnJlbW92ZUV2ZW50TGlzdGVuZXIodGhpcywgdHlwZSwgbGlzdGVuZXIpO1xuICAgICAgICBkZWxldGUgbGlzdGVuZXJzW3R5cGVdO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBjb25zdCBsaXN0ZW5lciA9ICh3aWR0aCwgaGVpZ2h0KSA9PiB7XG4gICAgICBpZiAodGhpcy5jYW52YXMpIHtcbiAgICAgICAgdGhpcy5yZXNpemUod2lkdGgsIGhlaWdodCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGxldCBkZXRhY2hlZDsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBwcmVmZXItY29uc3RcbiAgICBjb25zdCBhdHRhY2hlZCA9ICgpID0+IHtcbiAgICAgIF9yZW1vdmUoJ2F0dGFjaCcsIGF0dGFjaGVkKTtcblxuICAgICAgdGhpcy5hdHRhY2hlZCA9IHRydWU7XG4gICAgICB0aGlzLnJlc2l6ZSgpO1xuXG4gICAgICBfYWRkKCdyZXNpemUnLCBsaXN0ZW5lcik7XG4gICAgICBfYWRkKCdkZXRhY2gnLCBkZXRhY2hlZCk7XG4gICAgfTtcblxuICAgIGRldGFjaGVkID0gKCkgPT4ge1xuICAgICAgdGhpcy5hdHRhY2hlZCA9IGZhbHNlO1xuXG4gICAgICBfcmVtb3ZlKCdyZXNpemUnLCBsaXN0ZW5lcik7XG5cbiAgICAgIC8vIFN0b3AgYW5pbWF0aW5nIGFuZCByZW1vdmUgbWV0YXNldHMsIHNvIHdoZW4gcmUtYXR0YWNoZWQsIHRoZSBhbmltYXRpb25zIHN0YXJ0IGZyb20gYmVnaW5uaW5nLlxuICAgICAgdGhpcy5fc3RvcCgpO1xuICAgICAgdGhpcy5fcmVzaXplKDAsIDApO1xuXG4gICAgICBfYWRkKCdhdHRhY2gnLCBhdHRhY2hlZCk7XG4gICAgfTtcblxuICAgIGlmIChwbGF0Zm9ybS5pc0F0dGFjaGVkKHRoaXMuY2FudmFzKSkge1xuICAgICAgYXR0YWNoZWQoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGV0YWNoZWQoKTtcbiAgICB9XG4gIH1cblxuICAvKipcblx0ICogQHByaXZhdGVcblx0ICovXG4gIHVuYmluZEV2ZW50cygpIHtcbiAgICBlYWNoKHRoaXMuX2xpc3RlbmVycywgKGxpc3RlbmVyLCB0eXBlKSA9PiB7XG4gICAgICB0aGlzLnBsYXRmb3JtLnJlbW92ZUV2ZW50TGlzdGVuZXIodGhpcywgdHlwZSwgbGlzdGVuZXIpO1xuICAgIH0pO1xuICAgIHRoaXMuX2xpc3RlbmVycyA9IHt9O1xuXG4gICAgZWFjaCh0aGlzLl9yZXNwb25zaXZlTGlzdGVuZXJzLCAobGlzdGVuZXIsIHR5cGUpID0+IHtcbiAgICAgIHRoaXMucGxhdGZvcm0ucmVtb3ZlRXZlbnRMaXN0ZW5lcih0aGlzLCB0eXBlLCBsaXN0ZW5lcik7XG4gICAgfSk7XG4gICAgdGhpcy5fcmVzcG9uc2l2ZUxpc3RlbmVycyA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIHVwZGF0ZUhvdmVyU3R5bGUoaXRlbXMsIG1vZGUsIGVuYWJsZWQpIHtcbiAgICBjb25zdCBwcmVmaXggPSBlbmFibGVkID8gJ3NldCcgOiAncmVtb3ZlJztcbiAgICBsZXQgbWV0YSwgaXRlbSwgaSwgaWxlbjtcblxuICAgIGlmIChtb2RlID09PSAnZGF0YXNldCcpIHtcbiAgICAgIG1ldGEgPSB0aGlzLmdldERhdGFzZXRNZXRhKGl0ZW1zWzBdLmRhdGFzZXRJbmRleCk7XG4gICAgICBtZXRhLmNvbnRyb2xsZXJbJ18nICsgcHJlZml4ICsgJ0RhdGFzZXRIb3ZlclN0eWxlJ10oKTtcbiAgICB9XG5cbiAgICBmb3IgKGkgPSAwLCBpbGVuID0gaXRlbXMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgICBpdGVtID0gaXRlbXNbaV07XG4gICAgICBjb25zdCBjb250cm9sbGVyID0gaXRlbSAmJiB0aGlzLmdldERhdGFzZXRNZXRhKGl0ZW0uZGF0YXNldEluZGV4KS5jb250cm9sbGVyO1xuICAgICAgaWYgKGNvbnRyb2xsZXIpIHtcbiAgICAgICAgY29udHJvbGxlcltwcmVmaXggKyAnSG92ZXJTdHlsZSddKGl0ZW0uZWxlbWVudCwgaXRlbS5kYXRhc2V0SW5kZXgsIGl0ZW0uaW5kZXgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuXHQgKiBHZXQgYWN0aXZlIChob3ZlcmVkKSBlbGVtZW50c1xuXHQgKiBAcmV0dXJucyBhcnJheVxuXHQgKi9cbiAgZ2V0QWN0aXZlRWxlbWVudHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2FjdGl2ZSB8fCBbXTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBTZXQgYWN0aXZlIChob3ZlcmVkKSBlbGVtZW50c1xuXHQgKiBAcGFyYW0ge2FycmF5fSBhY3RpdmVFbGVtZW50cyBOZXcgYWN0aXZlIGRhdGEgcG9pbnRzXG5cdCAqL1xuICBzZXRBY3RpdmVFbGVtZW50cyhhY3RpdmVFbGVtZW50cykge1xuICAgIGNvbnN0IGxhc3RBY3RpdmUgPSB0aGlzLl9hY3RpdmUgfHwgW107XG4gICAgY29uc3QgYWN0aXZlID0gYWN0aXZlRWxlbWVudHMubWFwKCh7ZGF0YXNldEluZGV4LCBpbmRleH0pID0+IHtcbiAgICAgIGNvbnN0IG1ldGEgPSB0aGlzLmdldERhdGFzZXRNZXRhKGRhdGFzZXRJbmRleCk7XG4gICAgICBpZiAoIW1ldGEpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBkYXRhc2V0IGZvdW5kIGF0IGluZGV4ICcgKyBkYXRhc2V0SW5kZXgpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBkYXRhc2V0SW5kZXgsXG4gICAgICAgIGVsZW1lbnQ6IG1ldGEuZGF0YVtpbmRleF0sXG4gICAgICAgIGluZGV4LFxuICAgICAgfTtcbiAgICB9KTtcbiAgICBjb25zdCBjaGFuZ2VkID0gIV9lbGVtZW50c0VxdWFsKGFjdGl2ZSwgbGFzdEFjdGl2ZSk7XG5cbiAgICBpZiAoY2hhbmdlZCkge1xuICAgICAgdGhpcy5fYWN0aXZlID0gYWN0aXZlO1xuICAgICAgLy8gTWFrZSBzdXJlIHdlIGRvbid0IHVzZSB0aGUgcHJldmlvdXMgbW91c2UgZXZlbnQgdG8gb3ZlcnJpZGUgdGhlIGFjdGl2ZSBlbGVtZW50cyBpbiB1cGRhdGUuXG4gICAgICB0aGlzLl9sYXN0RXZlbnQgPSBudWxsO1xuICAgICAgdGhpcy5fdXBkYXRlSG92ZXJTdHlsZXMoYWN0aXZlLCBsYXN0QWN0aXZlKTtcbiAgICB9XG4gIH1cblxuICAvKipcblx0ICogQ2FsbHMgZW5hYmxlZCBwbHVnaW5zIG9uIHRoZSBzcGVjaWZpZWQgaG9vayBhbmQgd2l0aCB0aGUgZ2l2ZW4gYXJncy5cblx0ICogVGhpcyBtZXRob2QgaW1tZWRpYXRlbHkgcmV0dXJucyBhcyBzb29uIGFzIGEgcGx1Z2luIGV4cGxpY2l0bHkgcmV0dXJucyBmYWxzZS4gVGhlXG5cdCAqIHJldHVybmVkIHZhbHVlIGNhbiBiZSB1c2VkLCBmb3IgaW5zdGFuY2UsIHRvIGludGVycnVwdCB0aGUgY3VycmVudCBhY3Rpb24uXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBob29rIC0gVGhlIG5hbWUgb2YgdGhlIHBsdWdpbiBtZXRob2QgdG8gY2FsbCAoZS5nLiAnYmVmb3JlVXBkYXRlJykuXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBbYXJnc10gLSBFeHRyYSBhcmd1bWVudHMgdG8gYXBwbHkgdG8gdGhlIGhvb2sgY2FsbC5cbiAgICogQHBhcmFtIHtpbXBvcnQoJy4vY29yZS5wbHVnaW5zLmpzJykuZmlsdGVyQ2FsbGJhY2t9IFtmaWx0ZXJdIC0gRmlsdGVyaW5nIGZ1bmN0aW9uIGZvciBsaW1pdGluZyB3aGljaCBwbHVnaW5zIGFyZSBub3RpZmllZFxuXHQgKiBAcmV0dXJucyB7Ym9vbGVhbn0gZmFsc2UgaWYgYW55IG9mIHRoZSBwbHVnaW5zIHJldHVybiBmYWxzZSwgZWxzZSByZXR1cm5zIHRydWUuXG5cdCAqL1xuICBub3RpZnlQbHVnaW5zKGhvb2ssIGFyZ3MsIGZpbHRlcikge1xuICAgIHJldHVybiB0aGlzLl9wbHVnaW5zLm5vdGlmeSh0aGlzLCBob29rLCBhcmdzLCBmaWx0ZXIpO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIGEgcGx1Z2luIHdpdGggdGhlIHNwZWNpZmljIElEIGlzIHJlZ2lzdGVyZWQgYW5kIGVuYWJsZWRcbiAgICogQHBhcmFtIHtzdHJpbmd9IHBsdWdpbklkIC0gVGhlIElEIG9mIHRoZSBwbHVnaW4gb2Ygd2hpY2ggdG8gY2hlY2sgaWYgaXQgaXMgZW5hYmxlZFxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICovXG4gIGlzUGx1Z2luRW5hYmxlZChwbHVnaW5JZCkge1xuICAgIHJldHVybiB0aGlzLl9wbHVnaW5zLl9jYWNoZS5maWx0ZXIocCA9PiBwLnBsdWdpbi5pZCA9PT0gcGx1Z2luSWQpLmxlbmd0aCA9PT0gMTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgX3VwZGF0ZUhvdmVyU3R5bGVzKGFjdGl2ZSwgbGFzdEFjdGl2ZSwgcmVwbGF5KSB7XG4gICAgY29uc3QgaG92ZXJPcHRpb25zID0gdGhpcy5vcHRpb25zLmhvdmVyO1xuICAgIGNvbnN0IGRpZmYgPSAoYSwgYikgPT4gYS5maWx0ZXIoeCA9PiAhYi5zb21lKHkgPT4geC5kYXRhc2V0SW5kZXggPT09IHkuZGF0YXNldEluZGV4ICYmIHguaW5kZXggPT09IHkuaW5kZXgpKTtcbiAgICBjb25zdCBkZWFjdGl2YXRlZCA9IGRpZmYobGFzdEFjdGl2ZSwgYWN0aXZlKTtcbiAgICBjb25zdCBhY3RpdmF0ZWQgPSByZXBsYXkgPyBhY3RpdmUgOiBkaWZmKGFjdGl2ZSwgbGFzdEFjdGl2ZSk7XG5cbiAgICBpZiAoZGVhY3RpdmF0ZWQubGVuZ3RoKSB7XG4gICAgICB0aGlzLnVwZGF0ZUhvdmVyU3R5bGUoZGVhY3RpdmF0ZWQsIGhvdmVyT3B0aW9ucy5tb2RlLCBmYWxzZSk7XG4gICAgfVxuXG4gICAgaWYgKGFjdGl2YXRlZC5sZW5ndGggJiYgaG92ZXJPcHRpb25zLm1vZGUpIHtcbiAgICAgIHRoaXMudXBkYXRlSG92ZXJTdHlsZShhY3RpdmF0ZWQsIGhvdmVyT3B0aW9ucy5tb2RlLCB0cnVlKTtcbiAgICB9XG4gIH1cblxuICAvKipcblx0ICogQHByaXZhdGVcblx0ICovXG4gIF9ldmVudEhhbmRsZXIoZSwgcmVwbGF5KSB7XG4gICAgY29uc3QgYXJncyA9IHtcbiAgICAgIGV2ZW50OiBlLFxuICAgICAgcmVwbGF5LFxuICAgICAgY2FuY2VsYWJsZTogdHJ1ZSxcbiAgICAgIGluQ2hhcnRBcmVhOiB0aGlzLmlzUG9pbnRJbkFyZWEoZSlcbiAgICB9O1xuICAgIGNvbnN0IGV2ZW50RmlsdGVyID0gKHBsdWdpbikgPT4gKHBsdWdpbi5vcHRpb25zLmV2ZW50cyB8fCB0aGlzLm9wdGlvbnMuZXZlbnRzKS5pbmNsdWRlcyhlLm5hdGl2ZS50eXBlKTtcblxuICAgIGlmICh0aGlzLm5vdGlmeVBsdWdpbnMoJ2JlZm9yZUV2ZW50JywgYXJncywgZXZlbnRGaWx0ZXIpID09PSBmYWxzZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IGNoYW5nZWQgPSB0aGlzLl9oYW5kbGVFdmVudChlLCByZXBsYXksIGFyZ3MuaW5DaGFydEFyZWEpO1xuXG4gICAgYXJncy5jYW5jZWxhYmxlID0gZmFsc2U7XG4gICAgdGhpcy5ub3RpZnlQbHVnaW5zKCdhZnRlckV2ZW50JywgYXJncywgZXZlbnRGaWx0ZXIpO1xuXG4gICAgaWYgKGNoYW5nZWQgfHwgYXJncy5jaGFuZ2VkKSB7XG4gICAgICB0aGlzLnJlbmRlcigpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG5cdCAqIEhhbmRsZSBhbiBldmVudFxuXHQgKiBAcGFyYW0ge0NoYXJ0RXZlbnR9IGUgdGhlIGV2ZW50IHRvIGhhbmRsZVxuXHQgKiBAcGFyYW0ge2Jvb2xlYW59IFtyZXBsYXldIC0gdHJ1ZSBpZiB0aGUgZXZlbnQgd2FzIHJlcGxheWVkIGJ5IGB1cGRhdGVgXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2luQ2hhcnRBcmVhXSAtIHRydWUgaWYgdGhlIGV2ZW50IGlzIGluc2lkZSBjaGFydEFyZWFcblx0ICogQHJldHVybiB7Ym9vbGVhbn0gdHJ1ZSBpZiB0aGUgY2hhcnQgbmVlZHMgdG8gcmUtcmVuZGVyXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfaGFuZGxlRXZlbnQoZSwgcmVwbGF5LCBpbkNoYXJ0QXJlYSkge1xuICAgIGNvbnN0IHtfYWN0aXZlOiBsYXN0QWN0aXZlID0gW10sIG9wdGlvbnN9ID0gdGhpcztcblxuICAgIC8vIElmIHRoZSBldmVudCBpcyByZXBsYXllZCBmcm9tIGB1cGRhdGVgLCB3ZSBzaG91bGQgZXZhbHVhdGUgd2l0aCB0aGUgZmluYWwgcG9zaXRpb25zLlxuICAgIC8vXG4gICAgLy8gVGhlIGByZXBsYXlgOlxuICAgIC8vIEl0J3MgdGhlIGxhc3QgZXZlbnQgKGV4Y2x1ZGluZyBjbGljaykgdGhhdCBoYXMgb2NjdXJyZWQgYmVmb3JlIGB1cGRhdGVgLlxuICAgIC8vIFNvIG1vdXNlIGhhcyBub3QgbW92ZWQuIEl0J3MgYWxzbyBvdmVyIHRoZSBjaGFydCwgYmVjYXVzZSB0aGVyZSBpcyBhIGByZXBsYXlgLlxuICAgIC8vXG4gICAgLy8gVGhlIHdoeTpcbiAgICAvLyBJZiBhbmltYXRpb25zIGFyZSBhY3RpdmUsIHRoZSBlbGVtZW50cyBoYXZlbid0IG1vdmVkIHlldCBjb21wYXJlZCB0byBzdGF0ZSBiZWZvcmUgdXBkYXRlLlxuICAgIC8vIEJ1dCBpZiB0aGV5IHdpbGwsIHdlIGFyZSBhY3RpdmF0aW5nIHRoZSBlbGVtZW50cyB0aGF0IHdvdWxkIGJlIGFjdGl2ZSwgaWYgdGhpcyBjaGVja1xuICAgIC8vIHdhcyBkb25lIGFmdGVyIHRoZSBhbmltYXRpb25zIGhhdmUgY29tcGxldGVkLiA9PiBcImZpbmFsIHBvc2l0aW9uc1wiLlxuICAgIC8vIElmIHRoZXJlIGlzIG5vIGFuaW1hdGlvbnMsIHRoZSBcImZpbmFsXCIgYW5kIFwiY3VycmVudFwiIHBvc2l0aW9ucyBhcmUgZXF1YWwuXG4gICAgLy8gVGhpcyBpcyBkb25lIHNvIHdlIGRvIG5vdCBoYXZlIHRvIGV2YWx1YXRlIHRoZSBhY3RpdmUgZWxlbWVudHMgZWFjaCBhbmltYXRpb24gZnJhbWVcbiAgICAvLyAtIGl0IHdvdWxkIGJlIGV4cGVuc2l2ZS5cbiAgICBjb25zdCB1c2VGaW5hbFBvc2l0aW9uID0gcmVwbGF5O1xuICAgIGNvbnN0IGFjdGl2ZSA9IHRoaXMuX2dldEFjdGl2ZUVsZW1lbnRzKGUsIGxhc3RBY3RpdmUsIGluQ2hhcnRBcmVhLCB1c2VGaW5hbFBvc2l0aW9uKTtcbiAgICBjb25zdCBpc0NsaWNrID0gX2lzQ2xpY2tFdmVudChlKTtcbiAgICBjb25zdCBsYXN0RXZlbnQgPSBkZXRlcm1pbmVMYXN0RXZlbnQoZSwgdGhpcy5fbGFzdEV2ZW50LCBpbkNoYXJ0QXJlYSwgaXNDbGljayk7XG5cbiAgICBpZiAoaW5DaGFydEFyZWEpIHtcbiAgICAgIC8vIFNldCBfbGFzdEV2ZW50IHRvIG51bGwgd2hpbGUgd2UgYXJlIHByb2Nlc3NpbmcgdGhlIGV2ZW50IGhhbmRsZXJzLlxuICAgICAgLy8gVGhpcyBwcmV2ZW50cyByZWN1cnNpb24gaWYgdGhlIGhhbmRsZXIgY2FsbHMgY2hhcnQudXBkYXRlKClcbiAgICAgIHRoaXMuX2xhc3RFdmVudCA9IG51bGw7XG5cbiAgICAgIC8vIEludm9rZSBvbkhvdmVyIGhvb2tcbiAgICAgIGNhbGxDYWxsYmFjayhvcHRpb25zLm9uSG92ZXIsIFtlLCBhY3RpdmUsIHRoaXNdLCB0aGlzKTtcblxuICAgICAgaWYgKGlzQ2xpY2spIHtcbiAgICAgICAgY2FsbENhbGxiYWNrKG9wdGlvbnMub25DbGljaywgW2UsIGFjdGl2ZSwgdGhpc10sIHRoaXMpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IGNoYW5nZWQgPSAhX2VsZW1lbnRzRXF1YWwoYWN0aXZlLCBsYXN0QWN0aXZlKTtcbiAgICBpZiAoY2hhbmdlZCB8fCByZXBsYXkpIHtcbiAgICAgIHRoaXMuX2FjdGl2ZSA9IGFjdGl2ZTtcbiAgICAgIHRoaXMuX3VwZGF0ZUhvdmVyU3R5bGVzKGFjdGl2ZSwgbGFzdEFjdGl2ZSwgcmVwbGF5KTtcbiAgICB9XG5cbiAgICB0aGlzLl9sYXN0RXZlbnQgPSBsYXN0RXZlbnQ7XG5cbiAgICByZXR1cm4gY2hhbmdlZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0NoYXJ0RXZlbnR9IGUgLSBUaGUgZXZlbnRcbiAgICogQHBhcmFtIHtpbXBvcnQoJy4uL3R5cGVzL2luZGV4LmpzJykuQWN0aXZlRWxlbWVudFtdfSBsYXN0QWN0aXZlIC0gUHJldmlvdXNseSBhY3RpdmUgZWxlbWVudHNcbiAgICogQHBhcmFtIHtib29sZWFufSBpbkNoYXJ0QXJlYSAtIElzIHRoZSBldmVudCBpbnNpZGUgY2hhcnRBcmVhXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gdXNlRmluYWxQb3NpdGlvbiAtIFNob3VsZCB0aGUgZXZhbHVhdGlvbiBiZSBkb25lIHdpdGggY3VycmVudCBvciBmaW5hbCAoYWZ0ZXIgYW5pbWF0aW9uKSBlbGVtZW50IHBvc2l0aW9uc1xuICAgKiBAcmV0dXJucyB7aW1wb3J0KCcuLi90eXBlcy9pbmRleC5qcycpLkFjdGl2ZUVsZW1lbnRbXX0gLSBUaGUgYWN0aXZlIGVsZW1lbnRzXG4gICAqIEBwcmF2YXRlXG4gICAqL1xuICBfZ2V0QWN0aXZlRWxlbWVudHMoZSwgbGFzdEFjdGl2ZSwgaW5DaGFydEFyZWEsIHVzZUZpbmFsUG9zaXRpb24pIHtcbiAgICBpZiAoZS50eXBlID09PSAnbW91c2VvdXQnKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuXG4gICAgaWYgKCFpbkNoYXJ0QXJlYSkge1xuICAgICAgLy8gTGV0IHVzZXIgY29udHJvbCB0aGUgYWN0aXZlIGVsZW1lbnRzIG91dHNpZGUgY2hhcnRBcmVhLiBFZy4gdXNpbmcgTGVnZW5kLlxuICAgICAgcmV0dXJuIGxhc3RBY3RpdmU7XG4gICAgfVxuXG4gICAgY29uc3QgaG92ZXJPcHRpb25zID0gdGhpcy5vcHRpb25zLmhvdmVyO1xuICAgIHJldHVybiB0aGlzLmdldEVsZW1lbnRzQXRFdmVudEZvck1vZGUoZSwgaG92ZXJPcHRpb25zLm1vZGUsIGhvdmVyT3B0aW9ucywgdXNlRmluYWxQb3NpdGlvbik7XG4gIH1cbn1cblxuLy8gQHRzLWlnbm9yZVxuZnVuY3Rpb24gaW52YWxpZGF0ZVBsdWdpbnMoKSB7XG4gIHJldHVybiBlYWNoKENoYXJ0Lmluc3RhbmNlcywgKGNoYXJ0KSA9PiBjaGFydC5fcGx1Z2lucy5pbnZhbGlkYXRlKCkpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBDaGFydDtcbiIsICJpbXBvcnQgRWxlbWVudCBmcm9tICcuLi9jb3JlL2NvcmUuZWxlbWVudC5qcyc7XG5pbXBvcnQge19hbmdsZUJldHdlZW4sIGdldEFuZ2xlRnJvbVBvaW50LCBUQVUsIEhBTEZfUEksIHZhbHVlT3JEZWZhdWx0fSBmcm9tICcuLi9oZWxwZXJzL2luZGV4LmpzJztcbmltcG9ydCB7UEksIF9pc0JldHdlZW4sIF9saW1pdFZhbHVlfSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMubWF0aC5qcyc7XG5pbXBvcnQge19yZWFkVmFsdWVUb1Byb3BzfSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMub3B0aW9ucy5qcyc7XG5pbXBvcnQgdHlwZSB7QXJjT3B0aW9ucywgUG9pbnR9IGZyb20gJy4uL3R5cGVzL2luZGV4LmpzJztcblxuXG5mdW5jdGlvbiBjbGlwQXJjKGN0eDogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJELCBlbGVtZW50OiBBcmNFbGVtZW50LCBlbmRBbmdsZTogbnVtYmVyKSB7XG4gIGNvbnN0IHtzdGFydEFuZ2xlLCBwaXhlbE1hcmdpbiwgeCwgeSwgb3V0ZXJSYWRpdXMsIGlubmVyUmFkaXVzfSA9IGVsZW1lbnQ7XG4gIGxldCBhbmdsZU1hcmdpbiA9IHBpeGVsTWFyZ2luIC8gb3V0ZXJSYWRpdXM7XG5cbiAgLy8gRHJhdyBhbiBpbm5lciBib3JkZXIgYnkgY2xpcHBpbmcgdGhlIGFyYyBhbmQgZHJhd2luZyBhIGRvdWJsZS13aWR0aCBib3JkZXJcbiAgLy8gRW5sYXJnZSB0aGUgY2xpcHBpbmcgYXJjIGJ5IDAuMzMgcGl4ZWxzIHRvIGVsaW1pbmF0ZSBnbGl0Y2hlcyBiZXR3ZWVuIGJvcmRlcnNcbiAgY3R4LmJlZ2luUGF0aCgpO1xuICBjdHguYXJjKHgsIHksIG91dGVyUmFkaXVzLCBzdGFydEFuZ2xlIC0gYW5nbGVNYXJnaW4sIGVuZEFuZ2xlICsgYW5nbGVNYXJnaW4pO1xuICBpZiAoaW5uZXJSYWRpdXMgPiBwaXhlbE1hcmdpbikge1xuICAgIGFuZ2xlTWFyZ2luID0gcGl4ZWxNYXJnaW4gLyBpbm5lclJhZGl1cztcbiAgICBjdHguYXJjKHgsIHksIGlubmVyUmFkaXVzLCBlbmRBbmdsZSArIGFuZ2xlTWFyZ2luLCBzdGFydEFuZ2xlIC0gYW5nbGVNYXJnaW4sIHRydWUpO1xuICB9IGVsc2Uge1xuICAgIGN0eC5hcmMoeCwgeSwgcGl4ZWxNYXJnaW4sIGVuZEFuZ2xlICsgSEFMRl9QSSwgc3RhcnRBbmdsZSAtIEhBTEZfUEkpO1xuICB9XG4gIGN0eC5jbG9zZVBhdGgoKTtcbiAgY3R4LmNsaXAoKTtcbn1cblxuZnVuY3Rpb24gdG9SYWRpdXNDb3JuZXJzKHZhbHVlKSB7XG4gIHJldHVybiBfcmVhZFZhbHVlVG9Qcm9wcyh2YWx1ZSwgWydvdXRlclN0YXJ0JywgJ291dGVyRW5kJywgJ2lubmVyU3RhcnQnLCAnaW5uZXJFbmQnXSk7XG59XG5cbi8qKlxuICogUGFyc2UgYm9yZGVyIHJhZGl1cyBmcm9tIHRoZSBwcm92aWRlZCBvcHRpb25zXG4gKi9cbmZ1bmN0aW9uIHBhcnNlQm9yZGVyUmFkaXVzKGFyYzogQXJjRWxlbWVudCwgaW5uZXJSYWRpdXM6IG51bWJlciwgb3V0ZXJSYWRpdXM6IG51bWJlciwgYW5nbGVEZWx0YTogbnVtYmVyKSB7XG4gIGNvbnN0IG8gPSB0b1JhZGl1c0Nvcm5lcnMoYXJjLm9wdGlvbnMuYm9yZGVyUmFkaXVzKTtcbiAgY29uc3QgaGFsZlRoaWNrbmVzcyA9IChvdXRlclJhZGl1cyAtIGlubmVyUmFkaXVzKSAvIDI7XG4gIGNvbnN0IGlubmVyTGltaXQgPSBNYXRoLm1pbihoYWxmVGhpY2tuZXNzLCBhbmdsZURlbHRhICogaW5uZXJSYWRpdXMgLyAyKTtcblxuICAvLyBPdXRlciBsaW1pdHMgYXJlIGNvbXBsaWNhdGVkLiBXZSB3YW50IHRvIGNvbXB1dGUgdGhlIGF2YWlsYWJsZSBhbmd1bGFyIGRpc3RhbmNlIGF0XG4gIC8vIGEgcmFkaXVzIG9mIG91dGVyUmFkaXVzIC0gYm9yZGVyUmFkaXVzIGJlY2F1c2UgZm9yIHNtYWxsIGFuZ3VsYXIgZGlzdGFuY2VzLCB0aGlzIHRlcm0gbGltaXRzLlxuICAvLyBXZSBjb21wdXRlIGF0IHIgPSBvdXRlclJhZGl1cyAtIGJvcmRlclJhZGl1cyBiZWNhdXNlIHRoaXMgY2lyY2xlIGRlZmluZXMgdGhlIGNlbnRlciBvZiB0aGUgYm9yZGVyIGNvcm5lcnMuXG4gIC8vXG4gIC8vIElmIHRoZSBib3JkZXJSYWRpdXMgaXMgbGFyZ2UsIHRoYXQgdmFsdWUgY2FuIGJlY29tZSBuZWdhdGl2ZS5cbiAgLy8gVGhpcyBjYXVzZXMgdGhlIG91dGVyIGJvcmRlcnMgdG8gbG9zZSB0aGVpciByYWRpdXMgZW50aXJlbHksIHdoaWNoIGlzIHJhdGhlciB1bmV4cGVjdGVkLiBUbyBzb2x2ZSB0aGF0LCBpZiBib3JkZXJSYWRpdXMgPiBvdXRlclJhZGl1c1xuICAvLyB3ZSBrbm93IHRoYXQgdGhlIHRoaWNrbmVzcyB0ZXJtIHdpbGwgZG9taW5hdGUgYW5kIGNvbXB1dGUgdGhlIGxpbWl0cyBhdCB0aGF0IHBvaW50XG4gIGNvbnN0IGNvbXB1dGVPdXRlckxpbWl0ID0gKHZhbCkgPT4ge1xuICAgIGNvbnN0IG91dGVyQXJjTGltaXQgPSAob3V0ZXJSYWRpdXMgLSBNYXRoLm1pbihoYWxmVGhpY2tuZXNzLCB2YWwpKSAqIGFuZ2xlRGVsdGEgLyAyO1xuICAgIHJldHVybiBfbGltaXRWYWx1ZSh2YWwsIDAsIE1hdGgubWluKGhhbGZUaGlja25lc3MsIG91dGVyQXJjTGltaXQpKTtcbiAgfTtcblxuICByZXR1cm4ge1xuICAgIG91dGVyU3RhcnQ6IGNvbXB1dGVPdXRlckxpbWl0KG8ub3V0ZXJTdGFydCksXG4gICAgb3V0ZXJFbmQ6IGNvbXB1dGVPdXRlckxpbWl0KG8ub3V0ZXJFbmQpLFxuICAgIGlubmVyU3RhcnQ6IF9saW1pdFZhbHVlKG8uaW5uZXJTdGFydCwgMCwgaW5uZXJMaW1pdCksXG4gICAgaW5uZXJFbmQ6IF9saW1pdFZhbHVlKG8uaW5uZXJFbmQsIDAsIGlubmVyTGltaXQpLFxuICB9O1xufVxuXG4vKipcbiAqIENvbnZlcnQgKHIsIPCdnIMpIHRvICh4LCB5KVxuICovXG5mdW5jdGlvbiByVGhldGFUb1hZKHI6IG51bWJlciwgdGhldGE6IG51bWJlciwgeDogbnVtYmVyLCB5OiBudW1iZXIpIHtcbiAgcmV0dXJuIHtcbiAgICB4OiB4ICsgciAqIE1hdGguY29zKHRoZXRhKSxcbiAgICB5OiB5ICsgciAqIE1hdGguc2luKHRoZXRhKSxcbiAgfTtcbn1cblxuXG4vKipcbiAqIFBhdGggdGhlIGFyYywgcmVzcGVjdGluZyBib3JkZXIgcmFkaXVzIGJ5IHNlcGFyYXRpbmcgaW50byBsZWZ0IGFuZCByaWdodCBoYWx2ZXMuXG4gKlxuICogICBTdGFydCAgICAgIEVuZFxuICpcbiAqICAgIDEtLS0+YS0tLT4yICAgIE91dGVyXG4gKiAgIC8gICAgICAgICAgIFxcXG4gKiAgIDggICAgICAgICAgIDNcbiAqICAgfCAgICAgICAgICAgfFxuICogICB8ICAgICAgICAgICB8XG4gKiAgIDcgICAgICAgICAgIDRcbiAqICAgXFwgICAgICAgICAgIC9cbiAqICAgIDY8LS0tYjwtLS01ICAgIElubmVyXG4gKi9cbmZ1bmN0aW9uIHBhdGhBcmMoXG4gIGN0eDogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJELFxuICBlbGVtZW50OiBBcmNFbGVtZW50LFxuICBvZmZzZXQ6IG51bWJlcixcbiAgc3BhY2luZzogbnVtYmVyLFxuICBlbmQ6IG51bWJlcixcbiAgY2lyY3VsYXI6IGJvb2xlYW4sXG4pIHtcbiAgY29uc3Qge3gsIHksIHN0YXJ0QW5nbGU6IHN0YXJ0LCBwaXhlbE1hcmdpbiwgaW5uZXJSYWRpdXM6IGlubmVyUn0gPSBlbGVtZW50O1xuXG4gIGNvbnN0IG91dGVyUmFkaXVzID0gTWF0aC5tYXgoZWxlbWVudC5vdXRlclJhZGl1cyArIHNwYWNpbmcgKyBvZmZzZXQgLSBwaXhlbE1hcmdpbiwgMCk7XG4gIGNvbnN0IGlubmVyUmFkaXVzID0gaW5uZXJSID4gMCA/IGlubmVyUiArIHNwYWNpbmcgKyBvZmZzZXQgKyBwaXhlbE1hcmdpbiA6IDA7XG5cbiAgbGV0IHNwYWNpbmdPZmZzZXQgPSAwO1xuICBjb25zdCBhbHBoYSA9IGVuZCAtIHN0YXJ0O1xuXG4gIGlmIChzcGFjaW5nKSB7XG4gICAgLy8gV2hlbiBzcGFjaW5nIGlzIHByZXNlbnQsIGl0IGlzIHRoZSBzYW1lIGZvciBhbGwgaXRlbXNcbiAgICAvLyBTbyB3ZSBhZGp1c3QgdGhlIHN0YXJ0IGFuZCBlbmQgYW5nbGUgb2YgdGhlIGFyYyBzdWNoIHRoYXRcbiAgICAvLyB0aGUgZGlzdGFuY2UgaXMgdGhlIHNhbWUgYXMgaXQgd291bGQgYmUgd2l0aG91dCB0aGUgc3BhY2luZ1xuICAgIGNvbnN0IG5vU3BhY2luZ0lubmVyUmFkaXVzID0gaW5uZXJSID4gMCA/IGlubmVyUiAtIHNwYWNpbmcgOiAwO1xuICAgIGNvbnN0IG5vU3BhY2luZ091dGVyUmFkaXVzID0gb3V0ZXJSYWRpdXMgPiAwID8gb3V0ZXJSYWRpdXMgLSBzcGFjaW5nIDogMDtcbiAgICBjb25zdCBhdk5vZ1NwYWNpbmdSYWRpdXMgPSAobm9TcGFjaW5nSW5uZXJSYWRpdXMgKyBub1NwYWNpbmdPdXRlclJhZGl1cykgLyAyO1xuICAgIGNvbnN0IGFkanVzdGVkQW5nbGUgPSBhdk5vZ1NwYWNpbmdSYWRpdXMgIT09IDAgPyAoYWxwaGEgKiBhdk5vZ1NwYWNpbmdSYWRpdXMpIC8gKGF2Tm9nU3BhY2luZ1JhZGl1cyArIHNwYWNpbmcpIDogYWxwaGE7XG4gICAgc3BhY2luZ09mZnNldCA9IChhbHBoYSAtIGFkanVzdGVkQW5nbGUpIC8gMjtcbiAgfVxuXG4gIGNvbnN0IGJldGEgPSBNYXRoLm1heCgwLjAwMSwgYWxwaGEgKiBvdXRlclJhZGl1cyAtIG9mZnNldCAvIFBJKSAvIG91dGVyUmFkaXVzO1xuICBjb25zdCBhbmdsZU9mZnNldCA9IChhbHBoYSAtIGJldGEpIC8gMjtcbiAgY29uc3Qgc3RhcnRBbmdsZSA9IHN0YXJ0ICsgYW5nbGVPZmZzZXQgKyBzcGFjaW5nT2Zmc2V0O1xuICBjb25zdCBlbmRBbmdsZSA9IGVuZCAtIGFuZ2xlT2Zmc2V0IC0gc3BhY2luZ09mZnNldDtcbiAgY29uc3Qge291dGVyU3RhcnQsIG91dGVyRW5kLCBpbm5lclN0YXJ0LCBpbm5lckVuZH0gPSBwYXJzZUJvcmRlclJhZGl1cyhlbGVtZW50LCBpbm5lclJhZGl1cywgb3V0ZXJSYWRpdXMsIGVuZEFuZ2xlIC0gc3RhcnRBbmdsZSk7XG5cbiAgY29uc3Qgb3V0ZXJTdGFydEFkanVzdGVkUmFkaXVzID0gb3V0ZXJSYWRpdXMgLSBvdXRlclN0YXJ0O1xuICBjb25zdCBvdXRlckVuZEFkanVzdGVkUmFkaXVzID0gb3V0ZXJSYWRpdXMgLSBvdXRlckVuZDtcbiAgY29uc3Qgb3V0ZXJTdGFydEFkanVzdGVkQW5nbGUgPSBzdGFydEFuZ2xlICsgb3V0ZXJTdGFydCAvIG91dGVyU3RhcnRBZGp1c3RlZFJhZGl1cztcbiAgY29uc3Qgb3V0ZXJFbmRBZGp1c3RlZEFuZ2xlID0gZW5kQW5nbGUgLSBvdXRlckVuZCAvIG91dGVyRW5kQWRqdXN0ZWRSYWRpdXM7XG5cbiAgY29uc3QgaW5uZXJTdGFydEFkanVzdGVkUmFkaXVzID0gaW5uZXJSYWRpdXMgKyBpbm5lclN0YXJ0O1xuICBjb25zdCBpbm5lckVuZEFkanVzdGVkUmFkaXVzID0gaW5uZXJSYWRpdXMgKyBpbm5lckVuZDtcbiAgY29uc3QgaW5uZXJTdGFydEFkanVzdGVkQW5nbGUgPSBzdGFydEFuZ2xlICsgaW5uZXJTdGFydCAvIGlubmVyU3RhcnRBZGp1c3RlZFJhZGl1cztcbiAgY29uc3QgaW5uZXJFbmRBZGp1c3RlZEFuZ2xlID0gZW5kQW5nbGUgLSBpbm5lckVuZCAvIGlubmVyRW5kQWRqdXN0ZWRSYWRpdXM7XG5cbiAgY3R4LmJlZ2luUGF0aCgpO1xuXG4gIGlmIChjaXJjdWxhcikge1xuICAgIC8vIFRoZSBmaXJzdCBhcmMgc2VnbWVudHMgZnJvbSBwb2ludCAxIHRvIHBvaW50IGEgdG8gcG9pbnQgMlxuICAgIGNvbnN0IG91dGVyTWlkQWRqdXN0ZWRBbmdsZSA9IChvdXRlclN0YXJ0QWRqdXN0ZWRBbmdsZSArIG91dGVyRW5kQWRqdXN0ZWRBbmdsZSkgLyAyO1xuICAgIGN0eC5hcmMoeCwgeSwgb3V0ZXJSYWRpdXMsIG91dGVyU3RhcnRBZGp1c3RlZEFuZ2xlLCBvdXRlck1pZEFkanVzdGVkQW5nbGUpO1xuICAgIGN0eC5hcmMoeCwgeSwgb3V0ZXJSYWRpdXMsIG91dGVyTWlkQWRqdXN0ZWRBbmdsZSwgb3V0ZXJFbmRBZGp1c3RlZEFuZ2xlKTtcblxuICAgIC8vIFRoZSBjb3JuZXIgc2VnbWVudCBmcm9tIHBvaW50IDIgdG8gcG9pbnQgM1xuICAgIGlmIChvdXRlckVuZCA+IDApIHtcbiAgICAgIGNvbnN0IHBDZW50ZXIgPSByVGhldGFUb1hZKG91dGVyRW5kQWRqdXN0ZWRSYWRpdXMsIG91dGVyRW5kQWRqdXN0ZWRBbmdsZSwgeCwgeSk7XG4gICAgICBjdHguYXJjKHBDZW50ZXIueCwgcENlbnRlci55LCBvdXRlckVuZCwgb3V0ZXJFbmRBZGp1c3RlZEFuZ2xlLCBlbmRBbmdsZSArIEhBTEZfUEkpO1xuICAgIH1cblxuICAgIC8vIFRoZSBsaW5lIGZyb20gcG9pbnQgMyB0byBwb2ludCA0XG4gICAgY29uc3QgcDQgPSByVGhldGFUb1hZKGlubmVyRW5kQWRqdXN0ZWRSYWRpdXMsIGVuZEFuZ2xlLCB4LCB5KTtcbiAgICBjdHgubGluZVRvKHA0LngsIHA0LnkpO1xuXG4gICAgLy8gVGhlIGNvcm5lciBzZWdtZW50IGZyb20gcG9pbnQgNCB0byBwb2ludCA1XG4gICAgaWYgKGlubmVyRW5kID4gMCkge1xuICAgICAgY29uc3QgcENlbnRlciA9IHJUaGV0YVRvWFkoaW5uZXJFbmRBZGp1c3RlZFJhZGl1cywgaW5uZXJFbmRBZGp1c3RlZEFuZ2xlLCB4LCB5KTtcbiAgICAgIGN0eC5hcmMocENlbnRlci54LCBwQ2VudGVyLnksIGlubmVyRW5kLCBlbmRBbmdsZSArIEhBTEZfUEksIGlubmVyRW5kQWRqdXN0ZWRBbmdsZSArIE1hdGguUEkpO1xuICAgIH1cblxuICAgIC8vIFRoZSBpbm5lciBhcmMgZnJvbSBwb2ludCA1IHRvIHBvaW50IGIgdG8gcG9pbnQgNlxuICAgIGNvbnN0IGlubmVyTWlkQWRqdXN0ZWRBbmdsZSA9ICgoZW5kQW5nbGUgLSAoaW5uZXJFbmQgLyBpbm5lclJhZGl1cykpICsgKHN0YXJ0QW5nbGUgKyAoaW5uZXJTdGFydCAvIGlubmVyUmFkaXVzKSkpIC8gMjtcbiAgICBjdHguYXJjKHgsIHksIGlubmVyUmFkaXVzLCBlbmRBbmdsZSAtIChpbm5lckVuZCAvIGlubmVyUmFkaXVzKSwgaW5uZXJNaWRBZGp1c3RlZEFuZ2xlLCB0cnVlKTtcbiAgICBjdHguYXJjKHgsIHksIGlubmVyUmFkaXVzLCBpbm5lck1pZEFkanVzdGVkQW5nbGUsIHN0YXJ0QW5nbGUgKyAoaW5uZXJTdGFydCAvIGlubmVyUmFkaXVzKSwgdHJ1ZSk7XG5cbiAgICAvLyBUaGUgY29ybmVyIHNlZ21lbnQgZnJvbSBwb2ludCA2IHRvIHBvaW50IDdcbiAgICBpZiAoaW5uZXJTdGFydCA+IDApIHtcbiAgICAgIGNvbnN0IHBDZW50ZXIgPSByVGhldGFUb1hZKGlubmVyU3RhcnRBZGp1c3RlZFJhZGl1cywgaW5uZXJTdGFydEFkanVzdGVkQW5nbGUsIHgsIHkpO1xuICAgICAgY3R4LmFyYyhwQ2VudGVyLngsIHBDZW50ZXIueSwgaW5uZXJTdGFydCwgaW5uZXJTdGFydEFkanVzdGVkQW5nbGUgKyBNYXRoLlBJLCBzdGFydEFuZ2xlIC0gSEFMRl9QSSk7XG4gICAgfVxuXG4gICAgLy8gVGhlIGxpbmUgZnJvbSBwb2ludCA3IHRvIHBvaW50IDhcbiAgICBjb25zdCBwOCA9IHJUaGV0YVRvWFkob3V0ZXJTdGFydEFkanVzdGVkUmFkaXVzLCBzdGFydEFuZ2xlLCB4LCB5KTtcbiAgICBjdHgubGluZVRvKHA4LngsIHA4LnkpO1xuXG4gICAgLy8gVGhlIGNvcm5lciBzZWdtZW50IGZyb20gcG9pbnQgOCB0byBwb2ludCAxXG4gICAgaWYgKG91dGVyU3RhcnQgPiAwKSB7XG4gICAgICBjb25zdCBwQ2VudGVyID0gclRoZXRhVG9YWShvdXRlclN0YXJ0QWRqdXN0ZWRSYWRpdXMsIG91dGVyU3RhcnRBZGp1c3RlZEFuZ2xlLCB4LCB5KTtcbiAgICAgIGN0eC5hcmMocENlbnRlci54LCBwQ2VudGVyLnksIG91dGVyU3RhcnQsIHN0YXJ0QW5nbGUgLSBIQUxGX1BJLCBvdXRlclN0YXJ0QWRqdXN0ZWRBbmdsZSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGN0eC5tb3ZlVG8oeCwgeSk7XG5cbiAgICBjb25zdCBvdXRlclN0YXJ0WCA9IE1hdGguY29zKG91dGVyU3RhcnRBZGp1c3RlZEFuZ2xlKSAqIG91dGVyUmFkaXVzICsgeDtcbiAgICBjb25zdCBvdXRlclN0YXJ0WSA9IE1hdGguc2luKG91dGVyU3RhcnRBZGp1c3RlZEFuZ2xlKSAqIG91dGVyUmFkaXVzICsgeTtcbiAgICBjdHgubGluZVRvKG91dGVyU3RhcnRYLCBvdXRlclN0YXJ0WSk7XG5cbiAgICBjb25zdCBvdXRlckVuZFggPSBNYXRoLmNvcyhvdXRlckVuZEFkanVzdGVkQW5nbGUpICogb3V0ZXJSYWRpdXMgKyB4O1xuICAgIGNvbnN0IG91dGVyRW5kWSA9IE1hdGguc2luKG91dGVyRW5kQWRqdXN0ZWRBbmdsZSkgKiBvdXRlclJhZGl1cyArIHk7XG4gICAgY3R4LmxpbmVUbyhvdXRlckVuZFgsIG91dGVyRW5kWSk7XG4gIH1cblxuICBjdHguY2xvc2VQYXRoKCk7XG59XG5cbmZ1bmN0aW9uIGRyYXdBcmMoXG4gIGN0eDogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJELFxuICBlbGVtZW50OiBBcmNFbGVtZW50LFxuICBvZmZzZXQ6IG51bWJlcixcbiAgc3BhY2luZzogbnVtYmVyLFxuICBjaXJjdWxhcjogYm9vbGVhbixcbikge1xuICBjb25zdCB7ZnVsbENpcmNsZXMsIHN0YXJ0QW5nbGUsIGNpcmN1bWZlcmVuY2V9ID0gZWxlbWVudDtcbiAgbGV0IGVuZEFuZ2xlID0gZWxlbWVudC5lbmRBbmdsZTtcbiAgaWYgKGZ1bGxDaXJjbGVzKSB7XG4gICAgcGF0aEFyYyhjdHgsIGVsZW1lbnQsIG9mZnNldCwgc3BhY2luZywgZW5kQW5nbGUsIGNpcmN1bGFyKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGZ1bGxDaXJjbGVzOyArK2kpIHtcbiAgICAgIGN0eC5maWxsKCk7XG4gICAgfVxuICAgIGlmICghaXNOYU4oY2lyY3VtZmVyZW5jZSkpIHtcbiAgICAgIGVuZEFuZ2xlID0gc3RhcnRBbmdsZSArIChjaXJjdW1mZXJlbmNlICUgVEFVIHx8IFRBVSk7XG4gICAgfVxuICB9XG4gIHBhdGhBcmMoY3R4LCBlbGVtZW50LCBvZmZzZXQsIHNwYWNpbmcsIGVuZEFuZ2xlLCBjaXJjdWxhcik7XG4gIGN0eC5maWxsKCk7XG4gIHJldHVybiBlbmRBbmdsZTtcbn1cblxuZnVuY3Rpb24gZHJhd0JvcmRlcihcbiAgY3R4OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQsXG4gIGVsZW1lbnQ6IEFyY0VsZW1lbnQsXG4gIG9mZnNldDogbnVtYmVyLFxuICBzcGFjaW5nOiBudW1iZXIsXG4gIGNpcmN1bGFyOiBib29sZWFuLFxuKSB7XG4gIGNvbnN0IHtmdWxsQ2lyY2xlcywgc3RhcnRBbmdsZSwgY2lyY3VtZmVyZW5jZSwgb3B0aW9uc30gPSBlbGVtZW50O1xuICBjb25zdCB7Ym9yZGVyV2lkdGgsIGJvcmRlckpvaW5TdHlsZSwgYm9yZGVyRGFzaCwgYm9yZGVyRGFzaE9mZnNldH0gPSBvcHRpb25zO1xuICBjb25zdCBpbm5lciA9IG9wdGlvbnMuYm9yZGVyQWxpZ24gPT09ICdpbm5lcic7XG5cbiAgaWYgKCFib3JkZXJXaWR0aCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGN0eC5zZXRMaW5lRGFzaChib3JkZXJEYXNoIHx8IFtdKTtcbiAgY3R4LmxpbmVEYXNoT2Zmc2V0ID0gYm9yZGVyRGFzaE9mZnNldDtcblxuICBpZiAoaW5uZXIpIHtcbiAgICBjdHgubGluZVdpZHRoID0gYm9yZGVyV2lkdGggKiAyO1xuICAgIGN0eC5saW5lSm9pbiA9IGJvcmRlckpvaW5TdHlsZSB8fCAncm91bmQnO1xuICB9IGVsc2Uge1xuICAgIGN0eC5saW5lV2lkdGggPSBib3JkZXJXaWR0aDtcbiAgICBjdHgubGluZUpvaW4gPSBib3JkZXJKb2luU3R5bGUgfHwgJ2JldmVsJztcbiAgfVxuXG4gIGxldCBlbmRBbmdsZSA9IGVsZW1lbnQuZW5kQW5nbGU7XG4gIGlmIChmdWxsQ2lyY2xlcykge1xuICAgIHBhdGhBcmMoY3R4LCBlbGVtZW50LCBvZmZzZXQsIHNwYWNpbmcsIGVuZEFuZ2xlLCBjaXJjdWxhcik7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBmdWxsQ2lyY2xlczsgKytpKSB7XG4gICAgICBjdHguc3Ryb2tlKCk7XG4gICAgfVxuICAgIGlmICghaXNOYU4oY2lyY3VtZmVyZW5jZSkpIHtcbiAgICAgIGVuZEFuZ2xlID0gc3RhcnRBbmdsZSArIChjaXJjdW1mZXJlbmNlICUgVEFVIHx8IFRBVSk7XG4gICAgfVxuICB9XG5cbiAgaWYgKGlubmVyKSB7XG4gICAgY2xpcEFyYyhjdHgsIGVsZW1lbnQsIGVuZEFuZ2xlKTtcbiAgfVxuXG4gIGlmICghZnVsbENpcmNsZXMpIHtcbiAgICBwYXRoQXJjKGN0eCwgZWxlbWVudCwgb2Zmc2V0LCBzcGFjaW5nLCBlbmRBbmdsZSwgY2lyY3VsYXIpO1xuICAgIGN0eC5zdHJva2UoKTtcbiAgfVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIEFyY1Byb3BzIGV4dGVuZHMgUG9pbnQge1xuICBzdGFydEFuZ2xlOiBudW1iZXI7XG4gIGVuZEFuZ2xlOiBudW1iZXI7XG4gIGlubmVyUmFkaXVzOiBudW1iZXI7XG4gIG91dGVyUmFkaXVzOiBudW1iZXI7XG4gIGNpcmN1bWZlcmVuY2U6IG51bWJlcjtcbn1cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQXJjRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ8QXJjUHJvcHMsIEFyY09wdGlvbnM+IHtcblxuICBzdGF0aWMgaWQgPSAnYXJjJztcblxuICBzdGF0aWMgZGVmYXVsdHMgPSB7XG4gICAgYm9yZGVyQWxpZ246ICdjZW50ZXInLFxuICAgIGJvcmRlckNvbG9yOiAnI2ZmZicsXG4gICAgYm9yZGVyRGFzaDogW10sXG4gICAgYm9yZGVyRGFzaE9mZnNldDogMCxcbiAgICBib3JkZXJKb2luU3R5bGU6IHVuZGVmaW5lZCxcbiAgICBib3JkZXJSYWRpdXM6IDAsXG4gICAgYm9yZGVyV2lkdGg6IDIsXG4gICAgb2Zmc2V0OiAwLFxuICAgIHNwYWNpbmc6IDAsXG4gICAgYW5nbGU6IHVuZGVmaW5lZCxcbiAgICBjaXJjdWxhcjogdHJ1ZSxcbiAgfTtcblxuICBzdGF0aWMgZGVmYXVsdFJvdXRlcyA9IHtcbiAgICBiYWNrZ3JvdW5kQ29sb3I6ICdiYWNrZ3JvdW5kQ29sb3InXG4gIH07XG5cbiAgc3RhdGljIGRlc2NyaXB0b3JzID0ge1xuICAgIF9zY3JpcHRhYmxlOiB0cnVlLFxuICAgIF9pbmRleGFibGU6IChuYW1lKSA9PiBuYW1lICE9PSAnYm9yZGVyRGFzaCdcbiAgfTtcblxuICBjaXJjdW1mZXJlbmNlOiBudW1iZXI7XG4gIGVuZEFuZ2xlOiBudW1iZXI7XG4gIGZ1bGxDaXJjbGVzOiBudW1iZXI7XG4gIGlubmVyUmFkaXVzOiBudW1iZXI7XG4gIG91dGVyUmFkaXVzOiBudW1iZXI7XG4gIHBpeGVsTWFyZ2luOiBudW1iZXI7XG4gIHN0YXJ0QW5nbGU6IG51bWJlcjtcblxuICBjb25zdHJ1Y3RvcihjZmcpIHtcbiAgICBzdXBlcigpO1xuXG4gICAgdGhpcy5vcHRpb25zID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuY2lyY3VtZmVyZW5jZSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnN0YXJ0QW5nbGUgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5lbmRBbmdsZSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmlubmVyUmFkaXVzID0gdW5kZWZpbmVkO1xuICAgIHRoaXMub3V0ZXJSYWRpdXMgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5waXhlbE1hcmdpbiA9IDA7XG4gICAgdGhpcy5mdWxsQ2lyY2xlcyA9IDA7XG5cbiAgICBpZiAoY2ZnKSB7XG4gICAgICBPYmplY3QuYXNzaWduKHRoaXMsIGNmZyk7XG4gICAgfVxuICB9XG5cbiAgaW5SYW5nZShjaGFydFg6IG51bWJlciwgY2hhcnRZOiBudW1iZXIsIHVzZUZpbmFsUG9zaXRpb246IGJvb2xlYW4pIHtcbiAgICBjb25zdCBwb2ludCA9IHRoaXMuZ2V0UHJvcHMoWyd4JywgJ3knXSwgdXNlRmluYWxQb3NpdGlvbik7XG4gICAgY29uc3Qge2FuZ2xlLCBkaXN0YW5jZX0gPSBnZXRBbmdsZUZyb21Qb2ludChwb2ludCwge3g6IGNoYXJ0WCwgeTogY2hhcnRZfSk7XG4gICAgY29uc3Qge3N0YXJ0QW5nbGUsIGVuZEFuZ2xlLCBpbm5lclJhZGl1cywgb3V0ZXJSYWRpdXMsIGNpcmN1bWZlcmVuY2V9ID0gdGhpcy5nZXRQcm9wcyhbXG4gICAgICAnc3RhcnRBbmdsZScsXG4gICAgICAnZW5kQW5nbGUnLFxuICAgICAgJ2lubmVyUmFkaXVzJyxcbiAgICAgICdvdXRlclJhZGl1cycsXG4gICAgICAnY2lyY3VtZmVyZW5jZSdcbiAgICBdLCB1c2VGaW5hbFBvc2l0aW9uKTtcbiAgICBjb25zdCByQWRqdXN0ID0gKHRoaXMub3B0aW9ucy5zcGFjaW5nICsgdGhpcy5vcHRpb25zLmJvcmRlcldpZHRoKSAvIDI7XG4gICAgY29uc3QgX2NpcmN1bWZlcmVuY2UgPSB2YWx1ZU9yRGVmYXVsdChjaXJjdW1mZXJlbmNlLCBlbmRBbmdsZSAtIHN0YXJ0QW5nbGUpO1xuICAgIGNvbnN0IG5vblplcm9CZXR3ZWVuID0gX2FuZ2xlQmV0d2VlbihhbmdsZSwgc3RhcnRBbmdsZSwgZW5kQW5nbGUpICYmIHN0YXJ0QW5nbGUgIT09IGVuZEFuZ2xlO1xuICAgIGNvbnN0IGJldHdlZW5BbmdsZXMgPSBfY2lyY3VtZmVyZW5jZSA+PSBUQVUgfHwgbm9uWmVyb0JldHdlZW47XG4gICAgY29uc3Qgd2l0aGluUmFkaXVzID0gX2lzQmV0d2VlbihkaXN0YW5jZSwgaW5uZXJSYWRpdXMgKyByQWRqdXN0LCBvdXRlclJhZGl1cyArIHJBZGp1c3QpO1xuXG4gICAgcmV0dXJuIChiZXR3ZWVuQW5nbGVzICYmIHdpdGhpblJhZGl1cyk7XG4gIH1cblxuICBnZXRDZW50ZXJQb2ludCh1c2VGaW5hbFBvc2l0aW9uOiBib29sZWFuKSB7XG4gICAgY29uc3Qge3gsIHksIHN0YXJ0QW5nbGUsIGVuZEFuZ2xlLCBpbm5lclJhZGl1cywgb3V0ZXJSYWRpdXN9ID0gdGhpcy5nZXRQcm9wcyhbXG4gICAgICAneCcsXG4gICAgICAneScsXG4gICAgICAnc3RhcnRBbmdsZScsXG4gICAgICAnZW5kQW5nbGUnLFxuICAgICAgJ2lubmVyUmFkaXVzJyxcbiAgICAgICdvdXRlclJhZGl1cydcbiAgICBdLCB1c2VGaW5hbFBvc2l0aW9uKTtcbiAgICBjb25zdCB7b2Zmc2V0LCBzcGFjaW5nfSA9IHRoaXMub3B0aW9ucztcbiAgICBjb25zdCBoYWxmQW5nbGUgPSAoc3RhcnRBbmdsZSArIGVuZEFuZ2xlKSAvIDI7XG4gICAgY29uc3QgaGFsZlJhZGl1cyA9IChpbm5lclJhZGl1cyArIG91dGVyUmFkaXVzICsgc3BhY2luZyArIG9mZnNldCkgLyAyO1xuICAgIHJldHVybiB7XG4gICAgICB4OiB4ICsgTWF0aC5jb3MoaGFsZkFuZ2xlKSAqIGhhbGZSYWRpdXMsXG4gICAgICB5OiB5ICsgTWF0aC5zaW4oaGFsZkFuZ2xlKSAqIGhhbGZSYWRpdXNcbiAgICB9O1xuICB9XG5cbiAgdG9vbHRpcFBvc2l0aW9uKHVzZUZpbmFsUG9zaXRpb246IGJvb2xlYW4pIHtcbiAgICByZXR1cm4gdGhpcy5nZXRDZW50ZXJQb2ludCh1c2VGaW5hbFBvc2l0aW9uKTtcbiAgfVxuXG4gIGRyYXcoY3R4OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQpIHtcbiAgICBjb25zdCB7b3B0aW9ucywgY2lyY3VtZmVyZW5jZX0gPSB0aGlzO1xuICAgIGNvbnN0IG9mZnNldCA9IChvcHRpb25zLm9mZnNldCB8fCAwKSAvIDQ7XG4gICAgY29uc3Qgc3BhY2luZyA9IChvcHRpb25zLnNwYWNpbmcgfHwgMCkgLyAyO1xuICAgIGNvbnN0IGNpcmN1bGFyID0gb3B0aW9ucy5jaXJjdWxhcjtcbiAgICB0aGlzLnBpeGVsTWFyZ2luID0gKG9wdGlvbnMuYm9yZGVyQWxpZ24gPT09ICdpbm5lcicpID8gMC4zMyA6IDA7XG4gICAgdGhpcy5mdWxsQ2lyY2xlcyA9IGNpcmN1bWZlcmVuY2UgPiBUQVUgPyBNYXRoLmZsb29yKGNpcmN1bWZlcmVuY2UgLyBUQVUpIDogMDtcblxuICAgIGlmIChjaXJjdW1mZXJlbmNlID09PSAwIHx8IHRoaXMuaW5uZXJSYWRpdXMgPCAwIHx8IHRoaXMub3V0ZXJSYWRpdXMgPCAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY3R4LnNhdmUoKTtcblxuICAgIGNvbnN0IGhhbGZBbmdsZSA9ICh0aGlzLnN0YXJ0QW5nbGUgKyB0aGlzLmVuZEFuZ2xlKSAvIDI7XG4gICAgY3R4LnRyYW5zbGF0ZShNYXRoLmNvcyhoYWxmQW5nbGUpICogb2Zmc2V0LCBNYXRoLnNpbihoYWxmQW5nbGUpICogb2Zmc2V0KTtcbiAgICBjb25zdCBmaXggPSAxIC0gTWF0aC5zaW4oTWF0aC5taW4oUEksIGNpcmN1bWZlcmVuY2UgfHwgMCkpO1xuICAgIGNvbnN0IHJhZGl1c09mZnNldCA9IG9mZnNldCAqIGZpeDtcblxuICAgIGN0eC5maWxsU3R5bGUgPSBvcHRpb25zLmJhY2tncm91bmRDb2xvcjtcbiAgICBjdHguc3Ryb2tlU3R5bGUgPSBvcHRpb25zLmJvcmRlckNvbG9yO1xuXG4gICAgZHJhd0FyYyhjdHgsIHRoaXMsIHJhZGl1c09mZnNldCwgc3BhY2luZywgY2lyY3VsYXIpO1xuICAgIGRyYXdCb3JkZXIoY3R4LCB0aGlzLCByYWRpdXNPZmZzZXQsIHNwYWNpbmcsIGNpcmN1bGFyKTtcblxuICAgIGN0eC5yZXN0b3JlKCk7XG4gIH1cbn1cbiIsICJpbXBvcnQgRWxlbWVudCBmcm9tICcuLi9jb3JlL2NvcmUuZWxlbWVudC5qcyc7XG5pbXBvcnQge19iZXppZXJJbnRlcnBvbGF0aW9uLCBfcG9pbnRJbkxpbmUsIF9zdGVwcGVkSW50ZXJwb2xhdGlvbn0gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLmludGVycG9sYXRpb24uanMnO1xuaW1wb3J0IHtfY29tcHV0ZVNlZ21lbnRzLCBfYm91bmRTZWdtZW50c30gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLnNlZ21lbnQuanMnO1xuaW1wb3J0IHtfc3RlcHBlZExpbmVUbywgX2JlemllckN1cnZlVG99IGZyb20gJy4uL2hlbHBlcnMvaGVscGVycy5jYW52YXMuanMnO1xuaW1wb3J0IHtfdXBkYXRlQmV6aWVyQ29udHJvbFBvaW50c30gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLmN1cnZlLmpzJztcbmltcG9ydCB7dmFsdWVPckRlZmF1bHR9IGZyb20gJy4uL2hlbHBlcnMvaW5kZXguanMnO1xuXG4vKipcbiAqIEB0eXBlZGVmIHsgaW1wb3J0KCcuL2VsZW1lbnQucG9pbnQuanMnKS5kZWZhdWx0IH0gUG9pbnRFbGVtZW50XG4gKi9cblxuZnVuY3Rpb24gc2V0U3R5bGUoY3R4LCBvcHRpb25zLCBzdHlsZSA9IG9wdGlvbnMpIHtcbiAgY3R4LmxpbmVDYXAgPSB2YWx1ZU9yRGVmYXVsdChzdHlsZS5ib3JkZXJDYXBTdHlsZSwgb3B0aW9ucy5ib3JkZXJDYXBTdHlsZSk7XG4gIGN0eC5zZXRMaW5lRGFzaCh2YWx1ZU9yRGVmYXVsdChzdHlsZS5ib3JkZXJEYXNoLCBvcHRpb25zLmJvcmRlckRhc2gpKTtcbiAgY3R4LmxpbmVEYXNoT2Zmc2V0ID0gdmFsdWVPckRlZmF1bHQoc3R5bGUuYm9yZGVyRGFzaE9mZnNldCwgb3B0aW9ucy5ib3JkZXJEYXNoT2Zmc2V0KTtcbiAgY3R4LmxpbmVKb2luID0gdmFsdWVPckRlZmF1bHQoc3R5bGUuYm9yZGVySm9pblN0eWxlLCBvcHRpb25zLmJvcmRlckpvaW5TdHlsZSk7XG4gIGN0eC5saW5lV2lkdGggPSB2YWx1ZU9yRGVmYXVsdChzdHlsZS5ib3JkZXJXaWR0aCwgb3B0aW9ucy5ib3JkZXJXaWR0aCk7XG4gIGN0eC5zdHJva2VTdHlsZSA9IHZhbHVlT3JEZWZhdWx0KHN0eWxlLmJvcmRlckNvbG9yLCBvcHRpb25zLmJvcmRlckNvbG9yKTtcbn1cblxuZnVuY3Rpb24gbGluZVRvKGN0eCwgcHJldmlvdXMsIHRhcmdldCkge1xuICBjdHgubGluZVRvKHRhcmdldC54LCB0YXJnZXQueSk7XG59XG5cbi8qKlxuICogQHJldHVybnMge2FueX1cbiAqL1xuZnVuY3Rpb24gZ2V0TGluZU1ldGhvZChvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zLnN0ZXBwZWQpIHtcbiAgICByZXR1cm4gX3N0ZXBwZWRMaW5lVG87XG4gIH1cblxuICBpZiAob3B0aW9ucy50ZW5zaW9uIHx8IG9wdGlvbnMuY3ViaWNJbnRlcnBvbGF0aW9uTW9kZSA9PT0gJ21vbm90b25lJykge1xuICAgIHJldHVybiBfYmV6aWVyQ3VydmVUbztcbiAgfVxuXG4gIHJldHVybiBsaW5lVG87XG59XG5cbmZ1bmN0aW9uIHBhdGhWYXJzKHBvaW50cywgc2VnbWVudCwgcGFyYW1zID0ge30pIHtcbiAgY29uc3QgY291bnQgPSBwb2ludHMubGVuZ3RoO1xuICBjb25zdCB7c3RhcnQ6IHBhcmFtc1N0YXJ0ID0gMCwgZW5kOiBwYXJhbXNFbmQgPSBjb3VudCAtIDF9ID0gcGFyYW1zO1xuICBjb25zdCB7c3RhcnQ6IHNlZ21lbnRTdGFydCwgZW5kOiBzZWdtZW50RW5kfSA9IHNlZ21lbnQ7XG4gIGNvbnN0IHN0YXJ0ID0gTWF0aC5tYXgocGFyYW1zU3RhcnQsIHNlZ21lbnRTdGFydCk7XG4gIGNvbnN0IGVuZCA9IE1hdGgubWluKHBhcmFtc0VuZCwgc2VnbWVudEVuZCk7XG4gIGNvbnN0IG91dHNpZGUgPSBwYXJhbXNTdGFydCA8IHNlZ21lbnRTdGFydCAmJiBwYXJhbXNFbmQgPCBzZWdtZW50U3RhcnQgfHwgcGFyYW1zU3RhcnQgPiBzZWdtZW50RW5kICYmIHBhcmFtc0VuZCA+IHNlZ21lbnRFbmQ7XG5cbiAgcmV0dXJuIHtcbiAgICBjb3VudCxcbiAgICBzdGFydCxcbiAgICBsb29wOiBzZWdtZW50Lmxvb3AsXG4gICAgaWxlbjogZW5kIDwgc3RhcnQgJiYgIW91dHNpZGUgPyBjb3VudCArIGVuZCAtIHN0YXJ0IDogZW5kIC0gc3RhcnRcbiAgfTtcbn1cblxuLyoqXG4gKiBDcmVhdGUgcGF0aCBmcm9tIHBvaW50cywgZ3JvdXBpbmcgYnkgdHJ1bmNhdGVkIHgtY29vcmRpbmF0ZVxuICogUG9pbnRzIG5lZWQgdG8gYmUgaW4gb3JkZXIgYnkgeC1jb29yZGluYXRlIGZvciB0aGlzIHRvIHdvcmsgZWZmaWNpZW50bHlcbiAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfFBhdGgyRH0gY3R4IC0gQ29udGV4dFxuICogQHBhcmFtIHtMaW5lRWxlbWVudH0gbGluZVxuICogQHBhcmFtIHtvYmplY3R9IHNlZ21lbnRcbiAqIEBwYXJhbSB7bnVtYmVyfSBzZWdtZW50LnN0YXJ0IC0gc3RhcnQgaW5kZXggb2YgdGhlIHNlZ21lbnQsIHJlZmVycmluZyB0aGUgcG9pbnRzIGFycmF5XG4gKiBAcGFyYW0ge251bWJlcn0gc2VnbWVudC5lbmQgLSBlbmQgaW5kZXggb2YgdGhlIHNlZ21lbnQsIHJlZmVycmluZyB0aGUgcG9pbnRzIGFycmF5XG4gKiBAcGFyYW0ge2Jvb2xlYW59IHNlZ21lbnQubG9vcCAtIGluZGljYXRlcyB0aGF0IHRoZSBzZWdtZW50IGlzIGEgbG9vcFxuICogQHBhcmFtIHtvYmplY3R9IHBhcmFtc1xuICogQHBhcmFtIHtib29sZWFufSBwYXJhbXMubW92ZSAtIG1vdmUgdG8gc3RhcnRpbmcgcG9pbnQgKHZzIGxpbmUgdG8gaXQpXG4gKiBAcGFyYW0ge2Jvb2xlYW59IHBhcmFtcy5yZXZlcnNlIC0gcGF0aCB0aGUgc2VnbWVudCBmcm9tIGVuZCB0byBzdGFydFxuICogQHBhcmFtIHtudW1iZXJ9IHBhcmFtcy5zdGFydCAtIGxpbWl0IHNlZ21lbnQgdG8gcG9pbnRzIHN0YXJ0aW5nIGZyb20gYHN0YXJ0YCBpbmRleFxuICogQHBhcmFtIHtudW1iZXJ9IHBhcmFtcy5lbmQgLSBsaW1pdCBzZWdtZW50IHRvIHBvaW50cyBlbmRpbmcgYXQgYHN0YXJ0YCArIGBjb3VudGAgaW5kZXhcbiAqL1xuZnVuY3Rpb24gcGF0aFNlZ21lbnQoY3R4LCBsaW5lLCBzZWdtZW50LCBwYXJhbXMpIHtcbiAgY29uc3Qge3BvaW50cywgb3B0aW9uc30gPSBsaW5lO1xuICBjb25zdCB7Y291bnQsIHN0YXJ0LCBsb29wLCBpbGVufSA9IHBhdGhWYXJzKHBvaW50cywgc2VnbWVudCwgcGFyYW1zKTtcbiAgY29uc3QgbGluZU1ldGhvZCA9IGdldExpbmVNZXRob2Qob3B0aW9ucyk7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBwcmVmZXItY29uc3RcbiAgbGV0IHttb3ZlID0gdHJ1ZSwgcmV2ZXJzZX0gPSBwYXJhbXMgfHwge307XG4gIGxldCBpLCBwb2ludCwgcHJldjtcblxuICBmb3IgKGkgPSAwOyBpIDw9IGlsZW47ICsraSkge1xuICAgIHBvaW50ID0gcG9pbnRzWyhzdGFydCArIChyZXZlcnNlID8gaWxlbiAtIGkgOiBpKSkgJSBjb3VudF07XG5cbiAgICBpZiAocG9pbnQuc2tpcCkge1xuICAgICAgLy8gSWYgdGhlcmUgaXMgYSBza2lwcGVkIHBvaW50IGluc2lkZSBhIHNlZ21lbnQsIHNwYW5HYXBzIG11c3QgYmUgdHJ1ZVxuICAgICAgY29udGludWU7XG4gICAgfSBlbHNlIGlmIChtb3ZlKSB7XG4gICAgICBjdHgubW92ZVRvKHBvaW50LngsIHBvaW50LnkpO1xuICAgICAgbW92ZSA9IGZhbHNlO1xuICAgIH0gZWxzZSB7XG4gICAgICBsaW5lTWV0aG9kKGN0eCwgcHJldiwgcG9pbnQsIHJldmVyc2UsIG9wdGlvbnMuc3RlcHBlZCk7XG4gICAgfVxuXG4gICAgcHJldiA9IHBvaW50O1xuICB9XG5cbiAgaWYgKGxvb3ApIHtcbiAgICBwb2ludCA9IHBvaW50c1soc3RhcnQgKyAocmV2ZXJzZSA/IGlsZW4gOiAwKSkgJSBjb3VudF07XG4gICAgbGluZU1ldGhvZChjdHgsIHByZXYsIHBvaW50LCByZXZlcnNlLCBvcHRpb25zLnN0ZXBwZWQpO1xuICB9XG5cbiAgcmV0dXJuICEhbG9vcDtcbn1cblxuLyoqXG4gKiBDcmVhdGUgcGF0aCBmcm9tIHBvaW50cywgZ3JvdXBpbmcgYnkgdHJ1bmNhdGVkIHgtY29vcmRpbmF0ZVxuICogUG9pbnRzIG5lZWQgdG8gYmUgaW4gb3JkZXIgYnkgeC1jb29yZGluYXRlIGZvciB0aGlzIHRvIHdvcmsgZWZmaWNpZW50bHlcbiAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfFBhdGgyRH0gY3R4IC0gQ29udGV4dFxuICogQHBhcmFtIHtMaW5lRWxlbWVudH0gbGluZVxuICogQHBhcmFtIHtvYmplY3R9IHNlZ21lbnRcbiAqIEBwYXJhbSB7bnVtYmVyfSBzZWdtZW50LnN0YXJ0IC0gc3RhcnQgaW5kZXggb2YgdGhlIHNlZ21lbnQsIHJlZmVycmluZyB0aGUgcG9pbnRzIGFycmF5XG4gKiBAcGFyYW0ge251bWJlcn0gc2VnbWVudC5lbmQgLSBlbmQgaW5kZXggb2YgdGhlIHNlZ21lbnQsIHJlZmVycmluZyB0aGUgcG9pbnRzIGFycmF5XG4gKiBAcGFyYW0ge2Jvb2xlYW59IHNlZ21lbnQubG9vcCAtIGluZGljYXRlcyB0aGF0IHRoZSBzZWdtZW50IGlzIGEgbG9vcFxuICogQHBhcmFtIHtvYmplY3R9IHBhcmFtc1xuICogQHBhcmFtIHtib29sZWFufSBwYXJhbXMubW92ZSAtIG1vdmUgdG8gc3RhcnRpbmcgcG9pbnQgKHZzIGxpbmUgdG8gaXQpXG4gKiBAcGFyYW0ge2Jvb2xlYW59IHBhcmFtcy5yZXZlcnNlIC0gcGF0aCB0aGUgc2VnbWVudCBmcm9tIGVuZCB0byBzdGFydFxuICogQHBhcmFtIHtudW1iZXJ9IHBhcmFtcy5zdGFydCAtIGxpbWl0IHNlZ21lbnQgdG8gcG9pbnRzIHN0YXJ0aW5nIGZyb20gYHN0YXJ0YCBpbmRleFxuICogQHBhcmFtIHtudW1iZXJ9IHBhcmFtcy5lbmQgLSBsaW1pdCBzZWdtZW50IHRvIHBvaW50cyBlbmRpbmcgYXQgYHN0YXJ0YCArIGBjb3VudGAgaW5kZXhcbiAqL1xuZnVuY3Rpb24gZmFzdFBhdGhTZWdtZW50KGN0eCwgbGluZSwgc2VnbWVudCwgcGFyYW1zKSB7XG4gIGNvbnN0IHBvaW50cyA9IGxpbmUucG9pbnRzO1xuICBjb25zdCB7Y291bnQsIHN0YXJ0LCBpbGVufSA9IHBhdGhWYXJzKHBvaW50cywgc2VnbWVudCwgcGFyYW1zKTtcbiAgY29uc3Qge21vdmUgPSB0cnVlLCByZXZlcnNlfSA9IHBhcmFtcyB8fCB7fTtcbiAgbGV0IGF2Z1ggPSAwO1xuICBsZXQgY291bnRYID0gMDtcbiAgbGV0IGksIHBvaW50LCBwcmV2WCwgbWluWSwgbWF4WSwgbGFzdFk7XG5cbiAgY29uc3QgcG9pbnRJbmRleCA9IChpbmRleCkgPT4gKHN0YXJ0ICsgKHJldmVyc2UgPyBpbGVuIC0gaW5kZXggOiBpbmRleCkpICUgY291bnQ7XG4gIGNvbnN0IGRyYXdYID0gKCkgPT4ge1xuICAgIGlmIChtaW5ZICE9PSBtYXhZKSB7XG4gICAgICAvLyBEcmF3IGxpbmUgdG8gbWF4WSBhbmQgbWluWSwgdXNpbmcgdGhlIGF2ZXJhZ2UgeC1jb29yZGluYXRlXG4gICAgICBjdHgubGluZVRvKGF2Z1gsIG1heFkpO1xuICAgICAgY3R4LmxpbmVUbyhhdmdYLCBtaW5ZKTtcbiAgICAgIC8vIExpbmUgdG8geS12YWx1ZSBvZiBsYXN0IHBvaW50IGluIGdyb3VwLiBTbyB0aGUgbGluZSBjb250aW51ZXNcbiAgICAgIC8vIGZyb20gY29ycmVjdCBwb3NpdGlvbi4gTm90IHVzaW5nIG1vdmUsIHRvIGhhdmUgc29saWQgcGF0aC5cbiAgICAgIGN0eC5saW5lVG8oYXZnWCwgbGFzdFkpO1xuICAgIH1cbiAgfTtcblxuICBpZiAobW92ZSkge1xuICAgIHBvaW50ID0gcG9pbnRzW3BvaW50SW5kZXgoMCldO1xuICAgIGN0eC5tb3ZlVG8ocG9pbnQueCwgcG9pbnQueSk7XG4gIH1cblxuICBmb3IgKGkgPSAwOyBpIDw9IGlsZW47ICsraSkge1xuICAgIHBvaW50ID0gcG9pbnRzW3BvaW50SW5kZXgoaSldO1xuXG4gICAgaWYgKHBvaW50LnNraXApIHtcbiAgICAgIC8vIElmIHRoZXJlIGlzIGEgc2tpcHBlZCBwb2ludCBpbnNpZGUgYSBzZWdtZW50LCBzcGFuR2FwcyBtdXN0IGJlIHRydWVcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGNvbnN0IHggPSBwb2ludC54O1xuICAgIGNvbnN0IHkgPSBwb2ludC55O1xuICAgIGNvbnN0IHRydW5jWCA9IHggfCAwOyAvLyB0cnVuY2F0ZWQgeC1jb29yZGluYXRlXG5cbiAgICBpZiAodHJ1bmNYID09PSBwcmV2WCkge1xuICAgICAgLy8gRGV0ZXJtaW5lIGBtaW5ZYCAvIGBtYXhZYCBhbmQgYGF2Z1hgIHdoaWxlIHdlIHN0YXkgd2l0aGluIHNhbWUgeC1wb3NpdGlvblxuICAgICAgaWYgKHkgPCBtaW5ZKSB7XG4gICAgICAgIG1pblkgPSB5O1xuICAgICAgfSBlbHNlIGlmICh5ID4gbWF4WSkge1xuICAgICAgICBtYXhZID0geTtcbiAgICAgIH1cbiAgICAgIC8vIEZvciBmaXJzdCBwb2ludCBpbiBncm91cCwgY291bnRYIGlzIGAwYCwgc28gYXZlcmFnZSB3aWxsIGJlIGB4YCAvIDEuXG4gICAgICBhdmdYID0gKGNvdW50WCAqIGF2Z1ggKyB4KSAvICsrY291bnRYO1xuICAgIH0gZWxzZSB7XG4gICAgICBkcmF3WCgpO1xuICAgICAgLy8gRHJhdyBsaW5lIHRvIG5leHQgeC1wb3NpdGlvbiwgdXNpbmcgdGhlIGZpcnN0IChvciBvbmx5KVxuICAgICAgLy8geS12YWx1ZSBpbiB0aGF0IGdyb3VwXG4gICAgICBjdHgubGluZVRvKHgsIHkpO1xuXG4gICAgICBwcmV2WCA9IHRydW5jWDtcbiAgICAgIGNvdW50WCA9IDA7XG4gICAgICBtaW5ZID0gbWF4WSA9IHk7XG4gICAgfVxuICAgIC8vIEtlZXAgdHJhY2sgb2YgdGhlIGxhc3QgeS12YWx1ZSBpbiBncm91cFxuICAgIGxhc3RZID0geTtcbiAgfVxuICBkcmF3WCgpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7TGluZUVsZW1lbnR9IGxpbmUgLSB0aGUgbGluZVxuICogQHJldHVybnMge2Z1bmN0aW9ufVxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gX2dldFNlZ21lbnRNZXRob2QobGluZSkge1xuICBjb25zdCBvcHRzID0gbGluZS5vcHRpb25zO1xuICBjb25zdCBib3JkZXJEYXNoID0gb3B0cy5ib3JkZXJEYXNoICYmIG9wdHMuYm9yZGVyRGFzaC5sZW5ndGg7XG4gIGNvbnN0IHVzZUZhc3RQYXRoID0gIWxpbmUuX2RlY2ltYXRlZCAmJiAhbGluZS5fbG9vcCAmJiAhb3B0cy50ZW5zaW9uICYmIG9wdHMuY3ViaWNJbnRlcnBvbGF0aW9uTW9kZSAhPT0gJ21vbm90b25lJyAmJiAhb3B0cy5zdGVwcGVkICYmICFib3JkZXJEYXNoO1xuICByZXR1cm4gdXNlRmFzdFBhdGggPyBmYXN0UGF0aFNlZ21lbnQgOiBwYXRoU2VnbWVudDtcbn1cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBfZ2V0SW50ZXJwb2xhdGlvbk1ldGhvZChvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zLnN0ZXBwZWQpIHtcbiAgICByZXR1cm4gX3N0ZXBwZWRJbnRlcnBvbGF0aW9uO1xuICB9XG5cbiAgaWYgKG9wdGlvbnMudGVuc2lvbiB8fCBvcHRpb25zLmN1YmljSW50ZXJwb2xhdGlvbk1vZGUgPT09ICdtb25vdG9uZScpIHtcbiAgICByZXR1cm4gX2JlemllckludGVycG9sYXRpb247XG4gIH1cblxuICByZXR1cm4gX3BvaW50SW5MaW5lO1xufVxuXG5mdW5jdGlvbiBzdHJva2VQYXRoV2l0aENhY2hlKGN0eCwgbGluZSwgc3RhcnQsIGNvdW50KSB7XG4gIGxldCBwYXRoID0gbGluZS5fcGF0aDtcbiAgaWYgKCFwYXRoKSB7XG4gICAgcGF0aCA9IGxpbmUuX3BhdGggPSBuZXcgUGF0aDJEKCk7XG4gICAgaWYgKGxpbmUucGF0aChwYXRoLCBzdGFydCwgY291bnQpKSB7XG4gICAgICBwYXRoLmNsb3NlUGF0aCgpO1xuICAgIH1cbiAgfVxuICBzZXRTdHlsZShjdHgsIGxpbmUub3B0aW9ucyk7XG4gIGN0eC5zdHJva2UocGF0aCk7XG59XG5cbmZ1bmN0aW9uIHN0cm9rZVBhdGhEaXJlY3QoY3R4LCBsaW5lLCBzdGFydCwgY291bnQpIHtcbiAgY29uc3Qge3NlZ21lbnRzLCBvcHRpb25zfSA9IGxpbmU7XG4gIGNvbnN0IHNlZ21lbnRNZXRob2QgPSBfZ2V0U2VnbWVudE1ldGhvZChsaW5lKTtcblxuICBmb3IgKGNvbnN0IHNlZ21lbnQgb2Ygc2VnbWVudHMpIHtcbiAgICBzZXRTdHlsZShjdHgsIG9wdGlvbnMsIHNlZ21lbnQuc3R5bGUpO1xuICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICBpZiAoc2VnbWVudE1ldGhvZChjdHgsIGxpbmUsIHNlZ21lbnQsIHtzdGFydCwgZW5kOiBzdGFydCArIGNvdW50IC0gMX0pKSB7XG4gICAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgfVxuICAgIGN0eC5zdHJva2UoKTtcbiAgfVxufVxuXG5jb25zdCB1c2VQYXRoMkQgPSB0eXBlb2YgUGF0aDJEID09PSAnZnVuY3Rpb24nO1xuXG5mdW5jdGlvbiBkcmF3KGN0eCwgbGluZSwgc3RhcnQsIGNvdW50KSB7XG4gIGlmICh1c2VQYXRoMkQgJiYgIWxpbmUub3B0aW9ucy5zZWdtZW50KSB7XG4gICAgc3Ryb2tlUGF0aFdpdGhDYWNoZShjdHgsIGxpbmUsIHN0YXJ0LCBjb3VudCk7XG4gIH0gZWxzZSB7XG4gICAgc3Ryb2tlUGF0aERpcmVjdChjdHgsIGxpbmUsIHN0YXJ0LCBjb3VudCk7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTGluZUVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50IHtcblxuICBzdGF0aWMgaWQgPSAnbGluZSc7XG5cbiAgLyoqXG4gICAqIEB0eXBlIHthbnl9XG4gICAqL1xuICBzdGF0aWMgZGVmYXVsdHMgPSB7XG4gICAgYm9yZGVyQ2FwU3R5bGU6ICdidXR0JyxcbiAgICBib3JkZXJEYXNoOiBbXSxcbiAgICBib3JkZXJEYXNoT2Zmc2V0OiAwLFxuICAgIGJvcmRlckpvaW5TdHlsZTogJ21pdGVyJyxcbiAgICBib3JkZXJXaWR0aDogMyxcbiAgICBjYXBCZXppZXJQb2ludHM6IHRydWUsXG4gICAgY3ViaWNJbnRlcnBvbGF0aW9uTW9kZTogJ2RlZmF1bHQnLFxuICAgIGZpbGw6IGZhbHNlLFxuICAgIHNwYW5HYXBzOiBmYWxzZSxcbiAgICBzdGVwcGVkOiBmYWxzZSxcbiAgICB0ZW5zaW9uOiAwLFxuICB9O1xuXG4gIC8qKlxuICAgKiBAdHlwZSB7YW55fVxuICAgKi9cbiAgc3RhdGljIGRlZmF1bHRSb3V0ZXMgPSB7XG4gICAgYmFja2dyb3VuZENvbG9yOiAnYmFja2dyb3VuZENvbG9yJyxcbiAgICBib3JkZXJDb2xvcjogJ2JvcmRlckNvbG9yJ1xuICB9O1xuXG5cbiAgc3RhdGljIGRlc2NyaXB0b3JzID0ge1xuICAgIF9zY3JpcHRhYmxlOiB0cnVlLFxuICAgIF9pbmRleGFibGU6IChuYW1lKSA9PiBuYW1lICE9PSAnYm9yZGVyRGFzaCcgJiYgbmFtZSAhPT0gJ2ZpbGwnLFxuICB9O1xuXG5cbiAgY29uc3RydWN0b3IoY2ZnKSB7XG4gICAgc3VwZXIoKTtcblxuICAgIHRoaXMuYW5pbWF0ZWQgPSB0cnVlO1xuICAgIHRoaXMub3B0aW9ucyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9jaGFydCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9sb29wID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX2Z1bGxMb29wID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX3BhdGggPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fcG9pbnRzID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX3NlZ21lbnRzID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX2RlY2ltYXRlZCA9IGZhbHNlO1xuICAgIHRoaXMuX3BvaW50c1VwZGF0ZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9kYXRhc2V0SW5kZXggPSB1bmRlZmluZWQ7XG5cbiAgICBpZiAoY2ZnKSB7XG4gICAgICBPYmplY3QuYXNzaWduKHRoaXMsIGNmZyk7XG4gICAgfVxuICB9XG5cbiAgdXBkYXRlQ29udHJvbFBvaW50cyhjaGFydEFyZWEsIGluZGV4QXhpcykge1xuICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgaWYgKChvcHRpb25zLnRlbnNpb24gfHwgb3B0aW9ucy5jdWJpY0ludGVycG9sYXRpb25Nb2RlID09PSAnbW9ub3RvbmUnKSAmJiAhb3B0aW9ucy5zdGVwcGVkICYmICF0aGlzLl9wb2ludHNVcGRhdGVkKSB7XG4gICAgICBjb25zdCBsb29wID0gb3B0aW9ucy5zcGFuR2FwcyA/IHRoaXMuX2xvb3AgOiB0aGlzLl9mdWxsTG9vcDtcbiAgICAgIF91cGRhdGVCZXppZXJDb250cm9sUG9pbnRzKHRoaXMuX3BvaW50cywgb3B0aW9ucywgY2hhcnRBcmVhLCBsb29wLCBpbmRleEF4aXMpO1xuICAgICAgdGhpcy5fcG9pbnRzVXBkYXRlZCA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgc2V0IHBvaW50cyhwb2ludHMpIHtcbiAgICB0aGlzLl9wb2ludHMgPSBwb2ludHM7XG4gICAgZGVsZXRlIHRoaXMuX3NlZ21lbnRzO1xuICAgIGRlbGV0ZSB0aGlzLl9wYXRoO1xuICAgIHRoaXMuX3BvaW50c1VwZGF0ZWQgPSBmYWxzZTtcbiAgfVxuXG4gIGdldCBwb2ludHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3BvaW50cztcbiAgfVxuXG4gIGdldCBzZWdtZW50cygpIHtcbiAgICByZXR1cm4gdGhpcy5fc2VnbWVudHMgfHwgKHRoaXMuX3NlZ21lbnRzID0gX2NvbXB1dGVTZWdtZW50cyh0aGlzLCB0aGlzLm9wdGlvbnMuc2VnbWVudCkpO1xuICB9XG5cbiAgLyoqXG5cdCAqIEZpcnN0IG5vbi1za2lwcGVkIHBvaW50IG9uIHRoaXMgbGluZVxuXHQgKiBAcmV0dXJucyB7UG9pbnRFbGVtZW50fHVuZGVmaW5lZH1cblx0ICovXG4gIGZpcnN0KCkge1xuICAgIGNvbnN0IHNlZ21lbnRzID0gdGhpcy5zZWdtZW50cztcbiAgICBjb25zdCBwb2ludHMgPSB0aGlzLnBvaW50cztcbiAgICByZXR1cm4gc2VnbWVudHMubGVuZ3RoICYmIHBvaW50c1tzZWdtZW50c1swXS5zdGFydF07XG4gIH1cblxuICAvKipcblx0ICogTGFzdCBub24tc2tpcHBlZCBwb2ludCBvbiB0aGlzIGxpbmVcblx0ICogQHJldHVybnMge1BvaW50RWxlbWVudHx1bmRlZmluZWR9XG5cdCAqL1xuICBsYXN0KCkge1xuICAgIGNvbnN0IHNlZ21lbnRzID0gdGhpcy5zZWdtZW50cztcbiAgICBjb25zdCBwb2ludHMgPSB0aGlzLnBvaW50cztcbiAgICBjb25zdCBjb3VudCA9IHNlZ21lbnRzLmxlbmd0aDtcbiAgICByZXR1cm4gY291bnQgJiYgcG9pbnRzW3NlZ21lbnRzW2NvdW50IC0gMV0uZW5kXTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBJbnRlcnBvbGF0ZSBhIHBvaW50IGluIHRoaXMgbGluZSBhdCB0aGUgc2FtZSB2YWx1ZSBvbiBgcHJvcGVydHlgIGFzXG5cdCAqIHRoZSByZWZlcmVuY2UgYHBvaW50YCBwcm92aWRlZFxuXHQgKiBAcGFyYW0ge1BvaW50RWxlbWVudH0gcG9pbnQgLSB0aGUgcmVmZXJlbmNlIHBvaW50XG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eSAtIHRoZSBwcm9wZXJ0eSB0byBtYXRjaCBvblxuXHQgKiBAcmV0dXJucyB7UG9pbnRFbGVtZW50fHVuZGVmaW5lZH1cblx0ICovXG4gIGludGVycG9sYXRlKHBvaW50LCBwcm9wZXJ0eSkge1xuICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgY29uc3QgdmFsdWUgPSBwb2ludFtwcm9wZXJ0eV07XG4gICAgY29uc3QgcG9pbnRzID0gdGhpcy5wb2ludHM7XG4gICAgY29uc3Qgc2VnbWVudHMgPSBfYm91bmRTZWdtZW50cyh0aGlzLCB7cHJvcGVydHksIHN0YXJ0OiB2YWx1ZSwgZW5kOiB2YWx1ZX0pO1xuXG4gICAgaWYgKCFzZWdtZW50cy5sZW5ndGgpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICBjb25zdCBfaW50ZXJwb2xhdGUgPSBfZ2V0SW50ZXJwb2xhdGlvbk1ldGhvZChvcHRpb25zKTtcbiAgICBsZXQgaSwgaWxlbjtcbiAgICBmb3IgKGkgPSAwLCBpbGVuID0gc2VnbWVudHMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgICBjb25zdCB7c3RhcnQsIGVuZH0gPSBzZWdtZW50c1tpXTtcbiAgICAgIGNvbnN0IHAxID0gcG9pbnRzW3N0YXJ0XTtcbiAgICAgIGNvbnN0IHAyID0gcG9pbnRzW2VuZF07XG4gICAgICBpZiAocDEgPT09IHAyKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKHAxKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBjb25zdCB0ID0gTWF0aC5hYnMoKHZhbHVlIC0gcDFbcHJvcGVydHldKSAvIChwMltwcm9wZXJ0eV0gLSBwMVtwcm9wZXJ0eV0pKTtcbiAgICAgIGNvbnN0IGludGVycG9sYXRlZCA9IF9pbnRlcnBvbGF0ZShwMSwgcDIsIHQsIG9wdGlvbnMuc3RlcHBlZCk7XG4gICAgICBpbnRlcnBvbGF0ZWRbcHJvcGVydHldID0gcG9pbnRbcHJvcGVydHldO1xuICAgICAgcmVzdWx0LnB1c2goaW50ZXJwb2xhdGVkKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdC5sZW5ndGggPT09IDEgPyByZXN1bHRbMF0gOiByZXN1bHQ7XG4gIH1cblxuICAvKipcblx0ICogQXBwZW5kIGEgc2VnbWVudCBvZiB0aGlzIGxpbmUgdG8gY3VycmVudCBwYXRoLlxuXHQgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4XG5cdCAqIEBwYXJhbSB7b2JqZWN0fSBzZWdtZW50XG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBzZWdtZW50LnN0YXJ0IC0gc3RhcnQgaW5kZXggb2YgdGhlIHNlZ21lbnQsIHJlZmVycmluZyB0aGUgcG9pbnRzIGFycmF5XG4gXHQgKiBAcGFyYW0ge251bWJlcn0gc2VnbWVudC5lbmQgLSBlbmQgaW5kZXggb2YgdGhlIHNlZ21lbnQsIHJlZmVycmluZyB0aGUgcG9pbnRzIGFycmF5XG4gXHQgKiBAcGFyYW0ge2Jvb2xlYW59IHNlZ21lbnQubG9vcCAtIGluZGljYXRlcyB0aGF0IHRoZSBzZWdtZW50IGlzIGEgbG9vcFxuXHQgKiBAcGFyYW0ge29iamVjdH0gcGFyYW1zXG5cdCAqIEBwYXJhbSB7Ym9vbGVhbn0gcGFyYW1zLm1vdmUgLSBtb3ZlIHRvIHN0YXJ0aW5nIHBvaW50ICh2cyBsaW5lIHRvIGl0KVxuXHQgKiBAcGFyYW0ge2Jvb2xlYW59IHBhcmFtcy5yZXZlcnNlIC0gcGF0aCB0aGUgc2VnbWVudCBmcm9tIGVuZCB0byBzdGFydFxuXHQgKiBAcGFyYW0ge251bWJlcn0gcGFyYW1zLnN0YXJ0IC0gbGltaXQgc2VnbWVudCB0byBwb2ludHMgc3RhcnRpbmcgZnJvbSBgc3RhcnRgIGluZGV4XG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBwYXJhbXMuZW5kIC0gbGltaXQgc2VnbWVudCB0byBwb2ludHMgZW5kaW5nIGF0IGBzdGFydGAgKyBgY291bnRgIGluZGV4XG5cdCAqIEByZXR1cm5zIHt1bmRlZmluZWR8Ym9vbGVhbn0gLSB0cnVlIGlmIHRoZSBzZWdtZW50IGlzIGEgZnVsbCBsb29wIChwYXRoIHNob3VsZCBiZSBjbG9zZWQpXG5cdCAqL1xuICBwYXRoU2VnbWVudChjdHgsIHNlZ21lbnQsIHBhcmFtcykge1xuICAgIGNvbnN0IHNlZ21lbnRNZXRob2QgPSBfZ2V0U2VnbWVudE1ldGhvZCh0aGlzKTtcbiAgICByZXR1cm4gc2VnbWVudE1ldGhvZChjdHgsIHRoaXMsIHNlZ21lbnQsIHBhcmFtcyk7XG4gIH1cblxuICAvKipcblx0ICogQXBwZW5kIGFsbCBzZWdtZW50cyBvZiB0aGlzIGxpbmUgdG8gY3VycmVudCBwYXRoLlxuXHQgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRHxQYXRoMkR9IGN0eFxuXHQgKiBAcGFyYW0ge251bWJlcn0gW3N0YXJ0XVxuXHQgKiBAcGFyYW0ge251bWJlcn0gW2NvdW50XVxuXHQgKiBAcmV0dXJucyB7dW5kZWZpbmVkfGJvb2xlYW59IC0gdHJ1ZSBpZiBsaW5lIGlzIGEgZnVsbCBsb29wIChwYXRoIHNob3VsZCBiZSBjbG9zZWQpXG5cdCAqL1xuICBwYXRoKGN0eCwgc3RhcnQsIGNvdW50KSB7XG4gICAgY29uc3Qgc2VnbWVudHMgPSB0aGlzLnNlZ21lbnRzO1xuICAgIGNvbnN0IHNlZ21lbnRNZXRob2QgPSBfZ2V0U2VnbWVudE1ldGhvZCh0aGlzKTtcbiAgICBsZXQgbG9vcCA9IHRoaXMuX2xvb3A7XG5cbiAgICBzdGFydCA9IHN0YXJ0IHx8IDA7XG4gICAgY291bnQgPSBjb3VudCB8fCAodGhpcy5wb2ludHMubGVuZ3RoIC0gc3RhcnQpO1xuXG4gICAgZm9yIChjb25zdCBzZWdtZW50IG9mIHNlZ21lbnRzKSB7XG4gICAgICBsb29wICY9IHNlZ21lbnRNZXRob2QoY3R4LCB0aGlzLCBzZWdtZW50LCB7c3RhcnQsIGVuZDogc3RhcnQgKyBjb3VudCAtIDF9KTtcbiAgICB9XG4gICAgcmV0dXJuICEhbG9vcDtcbiAgfVxuXG4gIC8qKlxuXHQgKiBEcmF3XG5cdCAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcblx0ICogQHBhcmFtIHtvYmplY3R9IGNoYXJ0QXJlYVxuXHQgKiBAcGFyYW0ge251bWJlcn0gW3N0YXJ0XVxuXHQgKiBAcGFyYW0ge251bWJlcn0gW2NvdW50XVxuXHQgKi9cbiAgZHJhdyhjdHgsIGNoYXJ0QXJlYSwgc3RhcnQsIGNvdW50KSB7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMub3B0aW9ucyB8fCB7fTtcbiAgICBjb25zdCBwb2ludHMgPSB0aGlzLnBvaW50cyB8fCBbXTtcblxuICAgIGlmIChwb2ludHMubGVuZ3RoICYmIG9wdGlvbnMuYm9yZGVyV2lkdGgpIHtcbiAgICAgIGN0eC5zYXZlKCk7XG5cbiAgICAgIGRyYXcoY3R4LCB0aGlzLCBzdGFydCwgY291bnQpO1xuXG4gICAgICBjdHgucmVzdG9yZSgpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmFuaW1hdGVkKSB7XG4gICAgICAvLyBXaGVuIGxpbmUgaXMgYW5pbWF0ZWQsIHRoZSBjb250cm9sIHBvaW50cyBhbmQgcGF0aCBhcmUgbm90IGNhY2hlZC5cbiAgICAgIHRoaXMuX3BvaW50c1VwZGF0ZWQgPSBmYWxzZTtcbiAgICAgIHRoaXMuX3BhdGggPSB1bmRlZmluZWQ7XG4gICAgfVxuICB9XG59XG4iLCAiaW1wb3J0IEVsZW1lbnQgZnJvbSAnLi4vY29yZS9jb3JlLmVsZW1lbnQuanMnO1xuaW1wb3J0IHtkcmF3UG9pbnQsIF9pc1BvaW50SW5BcmVhfSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMuY2FudmFzLmpzJztcbmltcG9ydCB0eXBlIHtcbiAgQ2FydGVzaWFuUGFyc2VkRGF0YSxcbiAgQ2hhcnRBcmVhLFxuICBQb2ludCxcbiAgUG9pbnRIb3Zlck9wdGlvbnMsXG4gIFBvaW50T3B0aW9ucyxcbn0gZnJvbSAnLi4vdHlwZXMvaW5kZXguanMnO1xuXG5mdW5jdGlvbiBpblJhbmdlKGVsOiBQb2ludEVsZW1lbnQsIHBvczogbnVtYmVyLCBheGlzOiAneCcgfCAneScsIHVzZUZpbmFsUG9zaXRpb24/OiBib29sZWFuKSB7XG4gIGNvbnN0IG9wdGlvbnMgPSBlbC5vcHRpb25zO1xuICBjb25zdCB7W2F4aXNdOiB2YWx1ZX0gPSBlbC5nZXRQcm9wcyhbYXhpc10sIHVzZUZpbmFsUG9zaXRpb24pO1xuXG4gIHJldHVybiAoTWF0aC5hYnMocG9zIC0gdmFsdWUpIDwgb3B0aW9ucy5yYWRpdXMgKyBvcHRpb25zLmhpdFJhZGl1cyk7XG59XG5cbmV4cG9ydCB0eXBlIFBvaW50UHJvcHMgPSBQb2ludFxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBQb2ludEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50PFBvaW50UHJvcHMsIFBvaW50T3B0aW9ucyAmIFBvaW50SG92ZXJPcHRpb25zPiB7XG5cbiAgc3RhdGljIGlkID0gJ3BvaW50JztcblxuICBwYXJzZWQ6IENhcnRlc2lhblBhcnNlZERhdGE7XG4gIHNraXA/OiBib29sZWFuO1xuICBzdG9wPzogYm9vbGVhbjtcblxuICAvKipcbiAgICogQHR5cGUge2FueX1cbiAgICovXG4gIHN0YXRpYyBkZWZhdWx0cyA9IHtcbiAgICBib3JkZXJXaWR0aDogMSxcbiAgICBoaXRSYWRpdXM6IDEsXG4gICAgaG92ZXJCb3JkZXJXaWR0aDogMSxcbiAgICBob3ZlclJhZGl1czogNCxcbiAgICBwb2ludFN0eWxlOiAnY2lyY2xlJyxcbiAgICByYWRpdXM6IDMsXG4gICAgcm90YXRpb246IDBcbiAgfTtcblxuICAvKipcbiAgICogQHR5cGUge2FueX1cbiAgICovXG4gIHN0YXRpYyBkZWZhdWx0Um91dGVzID0ge1xuICAgIGJhY2tncm91bmRDb2xvcjogJ2JhY2tncm91bmRDb2xvcicsXG4gICAgYm9yZGVyQ29sb3I6ICdib3JkZXJDb2xvcidcbiAgfTtcblxuICBjb25zdHJ1Y3RvcihjZmcpIHtcbiAgICBzdXBlcigpO1xuXG4gICAgdGhpcy5vcHRpb25zID0gdW5kZWZpbmVkO1xuICAgIHRoaXMucGFyc2VkID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuc2tpcCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnN0b3AgPSB1bmRlZmluZWQ7XG5cbiAgICBpZiAoY2ZnKSB7XG4gICAgICBPYmplY3QuYXNzaWduKHRoaXMsIGNmZyk7XG4gICAgfVxuICB9XG5cbiAgaW5SYW5nZShtb3VzZVg6IG51bWJlciwgbW91c2VZOiBudW1iZXIsIHVzZUZpbmFsUG9zaXRpb24/OiBib29sZWFuKSB7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICBjb25zdCB7eCwgeX0gPSB0aGlzLmdldFByb3BzKFsneCcsICd5J10sIHVzZUZpbmFsUG9zaXRpb24pO1xuICAgIHJldHVybiAoKE1hdGgucG93KG1vdXNlWCAtIHgsIDIpICsgTWF0aC5wb3cobW91c2VZIC0geSwgMikpIDwgTWF0aC5wb3cob3B0aW9ucy5oaXRSYWRpdXMgKyBvcHRpb25zLnJhZGl1cywgMikpO1xuICB9XG5cbiAgaW5YUmFuZ2UobW91c2VYOiBudW1iZXIsIHVzZUZpbmFsUG9zaXRpb24/OiBib29sZWFuKSB7XG4gICAgcmV0dXJuIGluUmFuZ2UodGhpcywgbW91c2VYLCAneCcsIHVzZUZpbmFsUG9zaXRpb24pO1xuICB9XG5cbiAgaW5ZUmFuZ2UobW91c2VZOiBudW1iZXIsIHVzZUZpbmFsUG9zaXRpb24/OiBib29sZWFuKSB7XG4gICAgcmV0dXJuIGluUmFuZ2UodGhpcywgbW91c2VZLCAneScsIHVzZUZpbmFsUG9zaXRpb24pO1xuICB9XG5cbiAgZ2V0Q2VudGVyUG9pbnQodXNlRmluYWxQb3NpdGlvbj86IGJvb2xlYW4pIHtcbiAgICBjb25zdCB7eCwgeX0gPSB0aGlzLmdldFByb3BzKFsneCcsICd5J10sIHVzZUZpbmFsUG9zaXRpb24pO1xuICAgIHJldHVybiB7eCwgeX07XG4gIH1cblxuICBzaXplKG9wdGlvbnM/OiBQYXJ0aWFsPFBvaW50T3B0aW9ucyAmIFBvaW50SG92ZXJPcHRpb25zPikge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHRoaXMub3B0aW9ucyB8fCB7fTtcbiAgICBsZXQgcmFkaXVzID0gb3B0aW9ucy5yYWRpdXMgfHwgMDtcbiAgICByYWRpdXMgPSBNYXRoLm1heChyYWRpdXMsIHJhZGl1cyAmJiBvcHRpb25zLmhvdmVyUmFkaXVzIHx8IDApO1xuICAgIGNvbnN0IGJvcmRlcldpZHRoID0gcmFkaXVzICYmIG9wdGlvbnMuYm9yZGVyV2lkdGggfHwgMDtcbiAgICByZXR1cm4gKHJhZGl1cyArIGJvcmRlcldpZHRoKSAqIDI7XG4gIH1cblxuICBkcmF3KGN0eDogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJELCBhcmVhOiBDaGFydEFyZWEpIHtcbiAgICBjb25zdCBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuXG4gICAgaWYgKHRoaXMuc2tpcCB8fCBvcHRpb25zLnJhZGl1cyA8IDAuMSB8fCAhX2lzUG9pbnRJbkFyZWEodGhpcywgYXJlYSwgdGhpcy5zaXplKG9wdGlvbnMpIC8gMikpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjdHguc3Ryb2tlU3R5bGUgPSBvcHRpb25zLmJvcmRlckNvbG9yO1xuICAgIGN0eC5saW5lV2lkdGggPSBvcHRpb25zLmJvcmRlcldpZHRoO1xuICAgIGN0eC5maWxsU3R5bGUgPSBvcHRpb25zLmJhY2tncm91bmRDb2xvcjtcbiAgICBkcmF3UG9pbnQoY3R4LCBvcHRpb25zLCB0aGlzLngsIHRoaXMueSk7XG4gIH1cblxuICBnZXRSYW5nZSgpIHtcbiAgICBjb25zdCBvcHRpb25zID0gdGhpcy5vcHRpb25zIHx8IHt9O1xuICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgRmFsbGJhY2tzIHNob3VsZCBuZXZlciBiZSBoaXQgaW4gcHJhY3RpY2VcbiAgICByZXR1cm4gb3B0aW9ucy5yYWRpdXMgKyBvcHRpb25zLmhpdFJhZGl1cztcbiAgfVxufVxuIiwgImltcG9ydCBFbGVtZW50IGZyb20gJy4uL2NvcmUvY29yZS5lbGVtZW50LmpzJztcbmltcG9ydCB7aXNPYmplY3QsIF9pc0JldHdlZW4sIF9saW1pdFZhbHVlfSBmcm9tICcuLi9oZWxwZXJzL2luZGV4LmpzJztcbmltcG9ydCB7YWRkUm91bmRlZFJlY3RQYXRofSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMuY2FudmFzLmpzJztcbmltcG9ydCB7dG9UUkJMLCB0b1RSQkxDb3JuZXJzfSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMub3B0aW9ucy5qcyc7XG5cbi8qKiBAdHlwZWRlZiB7eyB4OiBudW1iZXIsIHk6IG51bWJlciwgYmFzZTogbnVtYmVyLCBob3Jpem9udGFsOiBib29sZWFuLCB3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlciB9fSBCYXJQcm9wcyAqL1xuXG4vKipcbiAqIEhlbHBlciBmdW5jdGlvbiB0byBnZXQgdGhlIGJvdW5kcyBvZiB0aGUgYmFyIHJlZ2FyZGxlc3Mgb2YgdGhlIG9yaWVudGF0aW9uXG4gKiBAcGFyYW0ge0JhckVsZW1lbnR9IGJhciB0aGUgYmFyXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFt1c2VGaW5hbFBvc2l0aW9uXVxuICogQHJldHVybiB7b2JqZWN0fSBib3VuZHMgb2YgdGhlIGJhclxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gZ2V0QmFyQm91bmRzKGJhciwgdXNlRmluYWxQb3NpdGlvbikge1xuICBjb25zdCB7eCwgeSwgYmFzZSwgd2lkdGgsIGhlaWdodH0gPSAvKiogQHR5cGUge0JhclByb3BzfSAqLyAoYmFyLmdldFByb3BzKFsneCcsICd5JywgJ2Jhc2UnLCAnd2lkdGgnLCAnaGVpZ2h0J10sIHVzZUZpbmFsUG9zaXRpb24pKTtcblxuICBsZXQgbGVmdCwgcmlnaHQsIHRvcCwgYm90dG9tLCBoYWxmO1xuXG4gIGlmIChiYXIuaG9yaXpvbnRhbCkge1xuICAgIGhhbGYgPSBoZWlnaHQgLyAyO1xuICAgIGxlZnQgPSBNYXRoLm1pbih4LCBiYXNlKTtcbiAgICByaWdodCA9IE1hdGgubWF4KHgsIGJhc2UpO1xuICAgIHRvcCA9IHkgLSBoYWxmO1xuICAgIGJvdHRvbSA9IHkgKyBoYWxmO1xuICB9IGVsc2Uge1xuICAgIGhhbGYgPSB3aWR0aCAvIDI7XG4gICAgbGVmdCA9IHggLSBoYWxmO1xuICAgIHJpZ2h0ID0geCArIGhhbGY7XG4gICAgdG9wID0gTWF0aC5taW4oeSwgYmFzZSk7XG4gICAgYm90dG9tID0gTWF0aC5tYXgoeSwgYmFzZSk7XG4gIH1cblxuICByZXR1cm4ge2xlZnQsIHRvcCwgcmlnaHQsIGJvdHRvbX07XG59XG5cbmZ1bmN0aW9uIHNraXBPckxpbWl0KHNraXAsIHZhbHVlLCBtaW4sIG1heCkge1xuICByZXR1cm4gc2tpcCA/IDAgOiBfbGltaXRWYWx1ZSh2YWx1ZSwgbWluLCBtYXgpO1xufVxuXG5mdW5jdGlvbiBwYXJzZUJvcmRlcldpZHRoKGJhciwgbWF4VywgbWF4SCkge1xuICBjb25zdCB2YWx1ZSA9IGJhci5vcHRpb25zLmJvcmRlcldpZHRoO1xuICBjb25zdCBza2lwID0gYmFyLmJvcmRlclNraXBwZWQ7XG4gIGNvbnN0IG8gPSB0b1RSQkwodmFsdWUpO1xuXG4gIHJldHVybiB7XG4gICAgdDogc2tpcE9yTGltaXQoc2tpcC50b3AsIG8udG9wLCAwLCBtYXhIKSxcbiAgICByOiBza2lwT3JMaW1pdChza2lwLnJpZ2h0LCBvLnJpZ2h0LCAwLCBtYXhXKSxcbiAgICBiOiBza2lwT3JMaW1pdChza2lwLmJvdHRvbSwgby5ib3R0b20sIDAsIG1heEgpLFxuICAgIGw6IHNraXBPckxpbWl0KHNraXAubGVmdCwgby5sZWZ0LCAwLCBtYXhXKVxuICB9O1xufVxuXG5mdW5jdGlvbiBwYXJzZUJvcmRlclJhZGl1cyhiYXIsIG1heFcsIG1heEgpIHtcbiAgY29uc3Qge2VuYWJsZUJvcmRlclJhZGl1c30gPSBiYXIuZ2V0UHJvcHMoWydlbmFibGVCb3JkZXJSYWRpdXMnXSk7XG4gIGNvbnN0IHZhbHVlID0gYmFyLm9wdGlvbnMuYm9yZGVyUmFkaXVzO1xuICBjb25zdCBvID0gdG9UUkJMQ29ybmVycyh2YWx1ZSk7XG4gIGNvbnN0IG1heFIgPSBNYXRoLm1pbihtYXhXLCBtYXhIKTtcbiAgY29uc3Qgc2tpcCA9IGJhci5ib3JkZXJTa2lwcGVkO1xuXG4gIC8vIElmIHRoZSB2YWx1ZSBpcyBhbiBvYmplY3QsIGFzc3VtZSB0aGUgdXNlciBrbm93cyB3aGF0IHRoZXkgYXJlIGRvaW5nXG4gIC8vIGFuZCBhcHBseSBhcyBkaXJlY3RlZC5cbiAgY29uc3QgZW5hYmxlQm9yZGVyID0gZW5hYmxlQm9yZGVyUmFkaXVzIHx8IGlzT2JqZWN0KHZhbHVlKTtcblxuICByZXR1cm4ge1xuICAgIHRvcExlZnQ6IHNraXBPckxpbWl0KCFlbmFibGVCb3JkZXIgfHwgc2tpcC50b3AgfHwgc2tpcC5sZWZ0LCBvLnRvcExlZnQsIDAsIG1heFIpLFxuICAgIHRvcFJpZ2h0OiBza2lwT3JMaW1pdCghZW5hYmxlQm9yZGVyIHx8IHNraXAudG9wIHx8IHNraXAucmlnaHQsIG8udG9wUmlnaHQsIDAsIG1heFIpLFxuICAgIGJvdHRvbUxlZnQ6IHNraXBPckxpbWl0KCFlbmFibGVCb3JkZXIgfHwgc2tpcC5ib3R0b20gfHwgc2tpcC5sZWZ0LCBvLmJvdHRvbUxlZnQsIDAsIG1heFIpLFxuICAgIGJvdHRvbVJpZ2h0OiBza2lwT3JMaW1pdCghZW5hYmxlQm9yZGVyIHx8IHNraXAuYm90dG9tIHx8IHNraXAucmlnaHQsIG8uYm90dG9tUmlnaHQsIDAsIG1heFIpXG4gIH07XG59XG5cbmZ1bmN0aW9uIGJvdW5kaW5nUmVjdHMoYmFyKSB7XG4gIGNvbnN0IGJvdW5kcyA9IGdldEJhckJvdW5kcyhiYXIpO1xuICBjb25zdCB3aWR0aCA9IGJvdW5kcy5yaWdodCAtIGJvdW5kcy5sZWZ0O1xuICBjb25zdCBoZWlnaHQgPSBib3VuZHMuYm90dG9tIC0gYm91bmRzLnRvcDtcbiAgY29uc3QgYm9yZGVyID0gcGFyc2VCb3JkZXJXaWR0aChiYXIsIHdpZHRoIC8gMiwgaGVpZ2h0IC8gMik7XG4gIGNvbnN0IHJhZGl1cyA9IHBhcnNlQm9yZGVyUmFkaXVzKGJhciwgd2lkdGggLyAyLCBoZWlnaHQgLyAyKTtcblxuICByZXR1cm4ge1xuICAgIG91dGVyOiB7XG4gICAgICB4OiBib3VuZHMubGVmdCxcbiAgICAgIHk6IGJvdW5kcy50b3AsXG4gICAgICB3OiB3aWR0aCxcbiAgICAgIGg6IGhlaWdodCxcbiAgICAgIHJhZGl1c1xuICAgIH0sXG4gICAgaW5uZXI6IHtcbiAgICAgIHg6IGJvdW5kcy5sZWZ0ICsgYm9yZGVyLmwsXG4gICAgICB5OiBib3VuZHMudG9wICsgYm9yZGVyLnQsXG4gICAgICB3OiB3aWR0aCAtIGJvcmRlci5sIC0gYm9yZGVyLnIsXG4gICAgICBoOiBoZWlnaHQgLSBib3JkZXIudCAtIGJvcmRlci5iLFxuICAgICAgcmFkaXVzOiB7XG4gICAgICAgIHRvcExlZnQ6IE1hdGgubWF4KDAsIHJhZGl1cy50b3BMZWZ0IC0gTWF0aC5tYXgoYm9yZGVyLnQsIGJvcmRlci5sKSksXG4gICAgICAgIHRvcFJpZ2h0OiBNYXRoLm1heCgwLCByYWRpdXMudG9wUmlnaHQgLSBNYXRoLm1heChib3JkZXIudCwgYm9yZGVyLnIpKSxcbiAgICAgICAgYm90dG9tTGVmdDogTWF0aC5tYXgoMCwgcmFkaXVzLmJvdHRvbUxlZnQgLSBNYXRoLm1heChib3JkZXIuYiwgYm9yZGVyLmwpKSxcbiAgICAgICAgYm90dG9tUmlnaHQ6IE1hdGgubWF4KDAsIHJhZGl1cy5ib3R0b21SaWdodCAtIE1hdGgubWF4KGJvcmRlci5iLCBib3JkZXIucikpLFxuICAgICAgfVxuICAgIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gaW5SYW5nZShiYXIsIHgsIHksIHVzZUZpbmFsUG9zaXRpb24pIHtcbiAgY29uc3Qgc2tpcFggPSB4ID09PSBudWxsO1xuICBjb25zdCBza2lwWSA9IHkgPT09IG51bGw7XG4gIGNvbnN0IHNraXBCb3RoID0gc2tpcFggJiYgc2tpcFk7XG4gIGNvbnN0IGJvdW5kcyA9IGJhciAmJiAhc2tpcEJvdGggJiYgZ2V0QmFyQm91bmRzKGJhciwgdXNlRmluYWxQb3NpdGlvbik7XG5cbiAgcmV0dXJuIGJvdW5kc1xuXHRcdCYmIChza2lwWCB8fCBfaXNCZXR3ZWVuKHgsIGJvdW5kcy5sZWZ0LCBib3VuZHMucmlnaHQpKVxuXHRcdCYmIChza2lwWSB8fCBfaXNCZXR3ZWVuKHksIGJvdW5kcy50b3AsIGJvdW5kcy5ib3R0b20pKTtcbn1cblxuZnVuY3Rpb24gaGFzUmFkaXVzKHJhZGl1cykge1xuICByZXR1cm4gcmFkaXVzLnRvcExlZnQgfHwgcmFkaXVzLnRvcFJpZ2h0IHx8IHJhZGl1cy5ib3R0b21MZWZ0IHx8IHJhZGl1cy5ib3R0b21SaWdodDtcbn1cblxuLyoqXG4gKiBBZGQgYSBwYXRoIG9mIGEgcmVjdGFuZ2xlIHRvIHRoZSBjdXJyZW50IHN1Yi1wYXRoXG4gKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IENvbnRleHRcbiAqIEBwYXJhbSB7Kn0gcmVjdCBCb3VuZGluZyByZWN0XG4gKi9cbmZ1bmN0aW9uIGFkZE5vcm1hbFJlY3RQYXRoKGN0eCwgcmVjdCkge1xuICBjdHgucmVjdChyZWN0LngsIHJlY3QueSwgcmVjdC53LCByZWN0LmgpO1xufVxuXG5mdW5jdGlvbiBpbmZsYXRlUmVjdChyZWN0LCBhbW91bnQsIHJlZlJlY3QgPSB7fSkge1xuICBjb25zdCB4ID0gcmVjdC54ICE9PSByZWZSZWN0LnggPyAtYW1vdW50IDogMDtcbiAgY29uc3QgeSA9IHJlY3QueSAhPT0gcmVmUmVjdC55ID8gLWFtb3VudCA6IDA7XG4gIGNvbnN0IHcgPSAocmVjdC54ICsgcmVjdC53ICE9PSByZWZSZWN0LnggKyByZWZSZWN0LncgPyBhbW91bnQgOiAwKSAtIHg7XG4gIGNvbnN0IGggPSAocmVjdC55ICsgcmVjdC5oICE9PSByZWZSZWN0LnkgKyByZWZSZWN0LmggPyBhbW91bnQgOiAwKSAtIHk7XG4gIHJldHVybiB7XG4gICAgeDogcmVjdC54ICsgeCxcbiAgICB5OiByZWN0LnkgKyB5LFxuICAgIHc6IHJlY3QudyArIHcsXG4gICAgaDogcmVjdC5oICsgaCxcbiAgICByYWRpdXM6IHJlY3QucmFkaXVzXG4gIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEJhckVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50IHtcblxuICBzdGF0aWMgaWQgPSAnYmFyJztcblxuICAvKipcbiAgICogQHR5cGUge2FueX1cbiAgICovXG4gIHN0YXRpYyBkZWZhdWx0cyA9IHtcbiAgICBib3JkZXJTa2lwcGVkOiAnc3RhcnQnLFxuICAgIGJvcmRlcldpZHRoOiAwLFxuICAgIGJvcmRlclJhZGl1czogMCxcbiAgICBpbmZsYXRlQW1vdW50OiAnYXV0bycsXG4gICAgcG9pbnRTdHlsZTogdW5kZWZpbmVkXG4gIH07XG5cbiAgLyoqXG4gICAqIEB0eXBlIHthbnl9XG4gICAqL1xuICBzdGF0aWMgZGVmYXVsdFJvdXRlcyA9IHtcbiAgICBiYWNrZ3JvdW5kQ29sb3I6ICdiYWNrZ3JvdW5kQ29sb3InLFxuICAgIGJvcmRlckNvbG9yOiAnYm9yZGVyQ29sb3InXG4gIH07XG5cbiAgY29uc3RydWN0b3IoY2ZnKSB7XG4gICAgc3VwZXIoKTtcblxuICAgIHRoaXMub3B0aW9ucyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmhvcml6b250YWwgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5iYXNlID0gdW5kZWZpbmVkO1xuICAgIHRoaXMud2lkdGggPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5oZWlnaHQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5pbmZsYXRlQW1vdW50ID0gdW5kZWZpbmVkO1xuXG4gICAgaWYgKGNmZykge1xuICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLCBjZmcpO1xuICAgIH1cbiAgfVxuXG4gIGRyYXcoY3R4KSB7XG4gICAgY29uc3Qge2luZmxhdGVBbW91bnQsIG9wdGlvbnM6IHtib3JkZXJDb2xvciwgYmFja2dyb3VuZENvbG9yfX0gPSB0aGlzO1xuICAgIGNvbnN0IHtpbm5lciwgb3V0ZXJ9ID0gYm91bmRpbmdSZWN0cyh0aGlzKTtcbiAgICBjb25zdCBhZGRSZWN0UGF0aCA9IGhhc1JhZGl1cyhvdXRlci5yYWRpdXMpID8gYWRkUm91bmRlZFJlY3RQYXRoIDogYWRkTm9ybWFsUmVjdFBhdGg7XG5cbiAgICBjdHguc2F2ZSgpO1xuXG4gICAgaWYgKG91dGVyLncgIT09IGlubmVyLncgfHwgb3V0ZXIuaCAhPT0gaW5uZXIuaCkge1xuICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgYWRkUmVjdFBhdGgoY3R4LCBpbmZsYXRlUmVjdChvdXRlciwgaW5mbGF0ZUFtb3VudCwgaW5uZXIpKTtcbiAgICAgIGN0eC5jbGlwKCk7XG4gICAgICBhZGRSZWN0UGF0aChjdHgsIGluZmxhdGVSZWN0KGlubmVyLCAtaW5mbGF0ZUFtb3VudCwgb3V0ZXIpKTtcbiAgICAgIGN0eC5maWxsU3R5bGUgPSBib3JkZXJDb2xvcjtcbiAgICAgIGN0eC5maWxsKCdldmVub2RkJyk7XG4gICAgfVxuXG4gICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgIGFkZFJlY3RQYXRoKGN0eCwgaW5mbGF0ZVJlY3QoaW5uZXIsIGluZmxhdGVBbW91bnQpKTtcbiAgICBjdHguZmlsbFN0eWxlID0gYmFja2dyb3VuZENvbG9yO1xuICAgIGN0eC5maWxsKCk7XG5cbiAgICBjdHgucmVzdG9yZSgpO1xuICB9XG5cbiAgaW5SYW5nZShtb3VzZVgsIG1vdXNlWSwgdXNlRmluYWxQb3NpdGlvbikge1xuICAgIHJldHVybiBpblJhbmdlKHRoaXMsIG1vdXNlWCwgbW91c2VZLCB1c2VGaW5hbFBvc2l0aW9uKTtcbiAgfVxuXG4gIGluWFJhbmdlKG1vdXNlWCwgdXNlRmluYWxQb3NpdGlvbikge1xuICAgIHJldHVybiBpblJhbmdlKHRoaXMsIG1vdXNlWCwgbnVsbCwgdXNlRmluYWxQb3NpdGlvbik7XG4gIH1cblxuICBpbllSYW5nZShtb3VzZVksIHVzZUZpbmFsUG9zaXRpb24pIHtcbiAgICByZXR1cm4gaW5SYW5nZSh0aGlzLCBudWxsLCBtb3VzZVksIHVzZUZpbmFsUG9zaXRpb24pO1xuICB9XG5cbiAgZ2V0Q2VudGVyUG9pbnQodXNlRmluYWxQb3NpdGlvbikge1xuICAgIGNvbnN0IHt4LCB5LCBiYXNlLCBob3Jpem9udGFsfSA9IC8qKiBAdHlwZSB7QmFyUHJvcHN9ICovICh0aGlzLmdldFByb3BzKFsneCcsICd5JywgJ2Jhc2UnLCAnaG9yaXpvbnRhbCddLCB1c2VGaW5hbFBvc2l0aW9uKSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHg6IGhvcml6b250YWwgPyAoeCArIGJhc2UpIC8gMiA6IHgsXG4gICAgICB5OiBob3Jpem9udGFsID8geSA6ICh5ICsgYmFzZSkgLyAyXG4gICAgfTtcbiAgfVxuXG4gIGdldFJhbmdlKGF4aXMpIHtcbiAgICByZXR1cm4gYXhpcyA9PT0gJ3gnID8gdGhpcy53aWR0aCAvIDIgOiB0aGlzLmhlaWdodCAvIDI7XG4gIH1cbn1cbiIsICJpbXBvcnQge0RvdWdobnV0Q29udHJvbGxlciwgUG9sYXJBcmVhQ29udHJvbGxlcn0gZnJvbSAnLi4vaW5kZXguanMnO1xuaW1wb3J0IHR5cGUge0NoYXJ0LCBDaGFydERhdGFzZXR9IGZyb20gJy4uL3R5cGVzLmpzJztcblxuZXhwb3J0IGludGVyZmFjZSBDb2xvcnNQbHVnaW5PcHRpb25zIHtcbiAgZW5hYmxlZD86IGJvb2xlYW47XG4gIGZvcmNlT3ZlcnJpZGU/OiBib29sZWFuO1xufVxuXG5pbnRlcmZhY2UgQ29sb3JzRGVzY3JpcHRvciB7XG4gIGJhY2tncm91bmRDb2xvcj86IHVua25vd247XG4gIGJvcmRlckNvbG9yPzogdW5rbm93bjtcbn1cblxuY29uc3QgQk9SREVSX0NPTE9SUyA9IFtcbiAgJ3JnYig1NCwgMTYyLCAyMzUpJywgLy8gYmx1ZVxuICAncmdiKDI1NSwgOTksIDEzMiknLCAvLyByZWRcbiAgJ3JnYigyNTUsIDE1OSwgNjQpJywgLy8gb3JhbmdlXG4gICdyZ2IoMjU1LCAyMDUsIDg2KScsIC8vIHllbGxvd1xuICAncmdiKDc1LCAxOTIsIDE5MiknLCAvLyBncmVlblxuICAncmdiKDE1MywgMTAyLCAyNTUpJywgLy8gcHVycGxlXG4gICdyZ2IoMjAxLCAyMDMsIDIwNyknIC8vIGdyZXlcbl07XG5cbi8vIEJvcmRlciBjb2xvcnMgd2l0aCA1MCUgdHJhbnNwYXJlbmN5XG5jb25zdCBCQUNLR1JPVU5EX0NPTE9SUyA9IC8qICNfX1BVUkVfXyAqLyBCT1JERVJfQ09MT1JTLm1hcChjb2xvciA9PiBjb2xvci5yZXBsYWNlKCdyZ2IoJywgJ3JnYmEoJykucmVwbGFjZSgnKScsICcsIDAuNSknKSk7XG5cbmZ1bmN0aW9uIGdldEJvcmRlckNvbG9yKGk6IG51bWJlcikge1xuICByZXR1cm4gQk9SREVSX0NPTE9SU1tpICUgQk9SREVSX0NPTE9SUy5sZW5ndGhdO1xufVxuXG5mdW5jdGlvbiBnZXRCYWNrZ3JvdW5kQ29sb3IoaTogbnVtYmVyKSB7XG4gIHJldHVybiBCQUNLR1JPVU5EX0NPTE9SU1tpICUgQkFDS0dST1VORF9DT0xPUlMubGVuZ3RoXTtcbn1cblxuZnVuY3Rpb24gY29sb3JpemVEZWZhdWx0RGF0YXNldChkYXRhc2V0OiBDaGFydERhdGFzZXQsIGk6IG51bWJlcikge1xuICBkYXRhc2V0LmJvcmRlckNvbG9yID0gZ2V0Qm9yZGVyQ29sb3IoaSk7XG4gIGRhdGFzZXQuYmFja2dyb3VuZENvbG9yID0gZ2V0QmFja2dyb3VuZENvbG9yKGkpO1xuXG4gIHJldHVybiArK2k7XG59XG5cbmZ1bmN0aW9uIGNvbG9yaXplRG91Z2hudXREYXRhc2V0KGRhdGFzZXQ6IENoYXJ0RGF0YXNldCwgaTogbnVtYmVyKSB7XG4gIGRhdGFzZXQuYmFja2dyb3VuZENvbG9yID0gZGF0YXNldC5kYXRhLm1hcCgoKSA9PiBnZXRCb3JkZXJDb2xvcihpKyspKTtcblxuICByZXR1cm4gaTtcbn1cblxuZnVuY3Rpb24gY29sb3JpemVQb2xhckFyZWFEYXRhc2V0KGRhdGFzZXQ6IENoYXJ0RGF0YXNldCwgaTogbnVtYmVyKSB7XG4gIGRhdGFzZXQuYmFja2dyb3VuZENvbG9yID0gZGF0YXNldC5kYXRhLm1hcCgoKSA9PiBnZXRCYWNrZ3JvdW5kQ29sb3IoaSsrKSk7XG5cbiAgcmV0dXJuIGk7XG59XG5cbmZ1bmN0aW9uIGdldENvbG9yaXplcihjaGFydDogQ2hhcnQpIHtcbiAgbGV0IGkgPSAwO1xuXG4gIHJldHVybiAoZGF0YXNldDogQ2hhcnREYXRhc2V0LCBkYXRhc2V0SW5kZXg6IG51bWJlcikgPT4ge1xuICAgIGNvbnN0IGNvbnRyb2xsZXIgPSBjaGFydC5nZXREYXRhc2V0TWV0YShkYXRhc2V0SW5kZXgpLmNvbnRyb2xsZXI7XG5cbiAgICBpZiAoY29udHJvbGxlciBpbnN0YW5jZW9mIERvdWdobnV0Q29udHJvbGxlcikge1xuICAgICAgaSA9IGNvbG9yaXplRG91Z2hudXREYXRhc2V0KGRhdGFzZXQsIGkpO1xuICAgIH0gZWxzZSBpZiAoY29udHJvbGxlciBpbnN0YW5jZW9mIFBvbGFyQXJlYUNvbnRyb2xsZXIpIHtcbiAgICAgIGkgPSBjb2xvcml6ZVBvbGFyQXJlYURhdGFzZXQoZGF0YXNldCwgaSk7XG4gICAgfSBlbHNlIGlmIChjb250cm9sbGVyKSB7XG4gICAgICBpID0gY29sb3JpemVEZWZhdWx0RGF0YXNldChkYXRhc2V0LCBpKTtcbiAgICB9XG4gIH07XG59XG5cbmZ1bmN0aW9uIGNvbnRhaW5zQ29sb3JzRGVmaW5pdGlvbnMoXG4gIGRlc2NyaXB0b3JzOiBDb2xvcnNEZXNjcmlwdG9yW10gfCBSZWNvcmQ8c3RyaW5nLCBDb2xvcnNEZXNjcmlwdG9yPlxuKSB7XG4gIGxldCBrOiBudW1iZXIgfCBzdHJpbmc7XG5cbiAgZm9yIChrIGluIGRlc2NyaXB0b3JzKSB7XG4gICAgaWYgKGRlc2NyaXB0b3JzW2tdLmJvcmRlckNvbG9yIHx8IGRlc2NyaXB0b3JzW2tdLmJhY2tncm91bmRDb2xvcikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBjb250YWluc0NvbG9yc0RlZmluaXRpb24oXG4gIGRlc2NyaXB0b3I6IENvbG9yc0Rlc2NyaXB0b3Jcbikge1xuICByZXR1cm4gZGVzY3JpcHRvciAmJiAoZGVzY3JpcHRvci5ib3JkZXJDb2xvciB8fCBkZXNjcmlwdG9yLmJhY2tncm91bmRDb2xvcik7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgaWQ6ICdjb2xvcnMnLFxuXG4gIGRlZmF1bHRzOiB7XG4gICAgZW5hYmxlZDogdHJ1ZSxcbiAgICBmb3JjZU92ZXJyaWRlOiBmYWxzZVxuICB9IGFzIENvbG9yc1BsdWdpbk9wdGlvbnMsXG5cbiAgYmVmb3JlTGF5b3V0KGNoYXJ0OiBDaGFydCwgX2FyZ3MsIG9wdGlvbnM6IENvbG9yc1BsdWdpbk9wdGlvbnMpIHtcbiAgICBpZiAoIW9wdGlvbnMuZW5hYmxlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IHtcbiAgICAgIGRhdGE6IHtkYXRhc2V0c30sXG4gICAgICBvcHRpb25zOiBjaGFydE9wdGlvbnNcbiAgICB9ID0gY2hhcnQuY29uZmlnO1xuICAgIGNvbnN0IHtlbGVtZW50c30gPSBjaGFydE9wdGlvbnM7XG5cbiAgICBpZiAoIW9wdGlvbnMuZm9yY2VPdmVycmlkZSAmJiAoY29udGFpbnNDb2xvcnNEZWZpbml0aW9ucyhkYXRhc2V0cykgfHwgY29udGFpbnNDb2xvcnNEZWZpbml0aW9uKGNoYXJ0T3B0aW9ucykgfHwgKGVsZW1lbnRzICYmIGNvbnRhaW5zQ29sb3JzRGVmaW5pdGlvbnMoZWxlbWVudHMpKSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBjb2xvcml6ZXIgPSBnZXRDb2xvcml6ZXIoY2hhcnQpO1xuXG4gICAgZGF0YXNldHMuZm9yRWFjaChjb2xvcml6ZXIpO1xuICB9XG59O1xuIiwgImltcG9ydCB7X2xpbWl0VmFsdWUsIF9sb29rdXBCeUtleSwgaXNOdWxsT3JVbmRlZiwgcmVzb2x2ZX0gZnJvbSAnLi4vaGVscGVycy9pbmRleC5qcyc7XG5cbmZ1bmN0aW9uIGx0dGJEZWNpbWF0aW9uKGRhdGEsIHN0YXJ0LCBjb3VudCwgYXZhaWxhYmxlV2lkdGgsIG9wdGlvbnMpIHtcbiAgLyoqXG4gICAqIEltcGxlbWVudGF0aW9uIG9mIHRoZSBMYXJnZXN0IFRyaWFuZ2xlIFRocmVlIEJ1Y2tldHMgYWxnb3JpdGhtLlxuICAgKlxuICAgKiBUaGlzIGltcGxlbWVudGF0aW9uIGlzIGJhc2VkIG9uIHRoZSBvcmlnaW5hbCBpbXBsZW1lbnRhdGlvbiBieSBTdmVpbm4gU3RlaW5hcnNzb25cbiAgICogaW4gaHR0cHM6Ly9naXRodWIuY29tL3N2ZWlubi1zdGVpbmFyc3Nvbi9mbG90LWRvd25zYW1wbGUvYmxvYi9tYXN0ZXIvanF1ZXJ5LmZsb3QuZG93bnNhbXBsZS5qc1xuICAgKlxuICAgKiBUaGUgb3JpZ2luYWwgaW1wbGVtZW50YXRpb24gaXMgTUlUIGxpY2Vuc2VkLlxuICAgKi9cbiAgY29uc3Qgc2FtcGxlcyA9IG9wdGlvbnMuc2FtcGxlcyB8fCBhdmFpbGFibGVXaWR0aDtcbiAgLy8gVGhlcmUgYXJlIGxlc3MgcG9pbnRzIHRoYW4gdGhlIHRocmVzaG9sZCwgcmV0dXJuaW5nIHRoZSB3aG9sZSBhcnJheVxuICBpZiAoc2FtcGxlcyA+PSBjb3VudCkge1xuICAgIHJldHVybiBkYXRhLnNsaWNlKHN0YXJ0LCBzdGFydCArIGNvdW50KTtcbiAgfVxuXG4gIGNvbnN0IGRlY2ltYXRlZCA9IFtdO1xuXG4gIGNvbnN0IGJ1Y2tldFdpZHRoID0gKGNvdW50IC0gMikgLyAoc2FtcGxlcyAtIDIpO1xuICBsZXQgc2FtcGxlZEluZGV4ID0gMDtcbiAgY29uc3QgZW5kSW5kZXggPSBzdGFydCArIGNvdW50IC0gMTtcbiAgLy8gU3RhcnRpbmcgZnJvbSBvZmZzZXRcbiAgbGV0IGEgPSBzdGFydDtcbiAgbGV0IGksIG1heEFyZWFQb2ludCwgbWF4QXJlYSwgYXJlYSwgbmV4dEE7XG5cbiAgZGVjaW1hdGVkW3NhbXBsZWRJbmRleCsrXSA9IGRhdGFbYV07XG5cbiAgZm9yIChpID0gMDsgaSA8IHNhbXBsZXMgLSAyOyBpKyspIHtcbiAgICBsZXQgYXZnWCA9IDA7XG4gICAgbGV0IGF2Z1kgPSAwO1xuICAgIGxldCBqO1xuXG4gICAgLy8gQWRkaW5nIG9mZnNldFxuICAgIGNvbnN0IGF2Z1JhbmdlU3RhcnQgPSBNYXRoLmZsb29yKChpICsgMSkgKiBidWNrZXRXaWR0aCkgKyAxICsgc3RhcnQ7XG4gICAgY29uc3QgYXZnUmFuZ2VFbmQgPSBNYXRoLm1pbihNYXRoLmZsb29yKChpICsgMikgKiBidWNrZXRXaWR0aCkgKyAxLCBjb3VudCkgKyBzdGFydDtcbiAgICBjb25zdCBhdmdSYW5nZUxlbmd0aCA9IGF2Z1JhbmdlRW5kIC0gYXZnUmFuZ2VTdGFydDtcblxuICAgIGZvciAoaiA9IGF2Z1JhbmdlU3RhcnQ7IGogPCBhdmdSYW5nZUVuZDsgaisrKSB7XG4gICAgICBhdmdYICs9IGRhdGFbal0ueDtcbiAgICAgIGF2Z1kgKz0gZGF0YVtqXS55O1xuICAgIH1cblxuICAgIGF2Z1ggLz0gYXZnUmFuZ2VMZW5ndGg7XG4gICAgYXZnWSAvPSBhdmdSYW5nZUxlbmd0aDtcblxuICAgIC8vIEFkZGluZyBvZmZzZXRcbiAgICBjb25zdCByYW5nZU9mZnMgPSBNYXRoLmZsb29yKGkgKiBidWNrZXRXaWR0aCkgKyAxICsgc3RhcnQ7XG4gICAgY29uc3QgcmFuZ2VUbyA9IE1hdGgubWluKE1hdGguZmxvb3IoKGkgKyAxKSAqIGJ1Y2tldFdpZHRoKSArIDEsIGNvdW50KSArIHN0YXJ0O1xuICAgIGNvbnN0IHt4OiBwb2ludEF4LCB5OiBwb2ludEF5fSA9IGRhdGFbYV07XG5cbiAgICAvLyBOb3RlIHRoYXQgdGhpcyBpcyBjaGFuZ2VkIGZyb20gdGhlIG9yaWdpbmFsIGFsZ29yaXRobSB3aGljaCBpbml0aWFsaXplcyB0aGVzZVxuICAgIC8vIHZhbHVlcyB0byAxLiBUaGUgcmVhc29uIGZvciB0aGlzIGNoYW5nZSBpcyB0aGF0IGlmIHRoZSBhcmVhIGlzIHNtYWxsLCBuZXh0QVxuICAgIC8vIHdvdWxkIG5ldmVyIGJlIHNldCBhbmQgdGh1cyBhIGNyYXNoIHdvdWxkIG9jY3VyIGluIHRoZSBuZXh0IGxvb3AgYXMgYGFgIHdvdWxkIGJlY29tZVxuICAgIC8vIGB1bmRlZmluZWRgLiBTaW5jZSB0aGUgYXJlYSBpcyBhbHdheXMgcG9zaXRpdmUsIGJ1dCBjb3VsZCBiZSAwIGluIHRoZSBjYXNlIG9mIGEgZmxhdCB0cmFjZSxcbiAgICAvLyBpbml0aWFsaXppbmcgd2l0aCBhIG5lZ2F0aXZlIG51bWJlciBpcyB0aGUgY29ycmVjdCBzb2x1dGlvbi5cbiAgICBtYXhBcmVhID0gYXJlYSA9IC0xO1xuXG4gICAgZm9yIChqID0gcmFuZ2VPZmZzOyBqIDwgcmFuZ2VUbzsgaisrKSB7XG4gICAgICBhcmVhID0gMC41ICogTWF0aC5hYnMoXG4gICAgICAgIChwb2ludEF4IC0gYXZnWCkgKiAoZGF0YVtqXS55IC0gcG9pbnRBeSkgLVxuICAgICAgICAocG9pbnRBeCAtIGRhdGFbal0ueCkgKiAoYXZnWSAtIHBvaW50QXkpXG4gICAgICApO1xuXG4gICAgICBpZiAoYXJlYSA+IG1heEFyZWEpIHtcbiAgICAgICAgbWF4QXJlYSA9IGFyZWE7XG4gICAgICAgIG1heEFyZWFQb2ludCA9IGRhdGFbal07XG4gICAgICAgIG5leHRBID0gajtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBkZWNpbWF0ZWRbc2FtcGxlZEluZGV4KytdID0gbWF4QXJlYVBvaW50O1xuICAgIGEgPSBuZXh0QTtcbiAgfVxuXG4gIC8vIEluY2x1ZGUgdGhlIGxhc3QgcG9pbnRcbiAgZGVjaW1hdGVkW3NhbXBsZWRJbmRleCsrXSA9IGRhdGFbZW5kSW5kZXhdO1xuXG4gIHJldHVybiBkZWNpbWF0ZWQ7XG59XG5cbmZ1bmN0aW9uIG1pbk1heERlY2ltYXRpb24oZGF0YSwgc3RhcnQsIGNvdW50LCBhdmFpbGFibGVXaWR0aCkge1xuICBsZXQgYXZnWCA9IDA7XG4gIGxldCBjb3VudFggPSAwO1xuICBsZXQgaSwgcG9pbnQsIHgsIHksIHByZXZYLCBtaW5JbmRleCwgbWF4SW5kZXgsIHN0YXJ0SW5kZXgsIG1pblksIG1heFk7XG4gIGNvbnN0IGRlY2ltYXRlZCA9IFtdO1xuICBjb25zdCBlbmRJbmRleCA9IHN0YXJ0ICsgY291bnQgLSAxO1xuXG4gIGNvbnN0IHhNaW4gPSBkYXRhW3N0YXJ0XS54O1xuICBjb25zdCB4TWF4ID0gZGF0YVtlbmRJbmRleF0ueDtcbiAgY29uc3QgZHggPSB4TWF4IC0geE1pbjtcblxuICBmb3IgKGkgPSBzdGFydDsgaSA8IHN0YXJ0ICsgY291bnQ7ICsraSkge1xuICAgIHBvaW50ID0gZGF0YVtpXTtcbiAgICB4ID0gKHBvaW50LnggLSB4TWluKSAvIGR4ICogYXZhaWxhYmxlV2lkdGg7XG4gICAgeSA9IHBvaW50Lnk7XG4gICAgY29uc3QgdHJ1bmNYID0geCB8IDA7XG5cbiAgICBpZiAodHJ1bmNYID09PSBwcmV2WCkge1xuICAgICAgLy8gRGV0ZXJtaW5lIGBtaW5ZYCAvIGBtYXhZYCBhbmQgYGF2Z1hgIHdoaWxlIHdlIHN0YXkgd2l0aGluIHNhbWUgeC1wb3NpdGlvblxuICAgICAgaWYgKHkgPCBtaW5ZKSB7XG4gICAgICAgIG1pblkgPSB5O1xuICAgICAgICBtaW5JbmRleCA9IGk7XG4gICAgICB9IGVsc2UgaWYgKHkgPiBtYXhZKSB7XG4gICAgICAgIG1heFkgPSB5O1xuICAgICAgICBtYXhJbmRleCA9IGk7XG4gICAgICB9XG4gICAgICAvLyBGb3IgZmlyc3QgcG9pbnQgaW4gZ3JvdXAsIGNvdW50WCBpcyBgMGAsIHNvIGF2ZXJhZ2Ugd2lsbCBiZSBgeGAgLyAxLlxuICAgICAgLy8gVXNlIHBvaW50LnggaGVyZSBiZWNhdXNlIHdlJ3JlIGNvbXB1dGluZyB0aGUgYXZlcmFnZSBkYXRhIGB4YCB2YWx1ZVxuICAgICAgYXZnWCA9IChjb3VudFggKiBhdmdYICsgcG9pbnQueCkgLyArK2NvdW50WDtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gUHVzaCB1cCB0byA0IHBvaW50cywgMyBmb3IgdGhlIGxhc3QgaW50ZXJ2YWwgYW5kIHRoZSBmaXJzdCBwb2ludCBmb3IgdGhpcyBpbnRlcnZhbFxuICAgICAgY29uc3QgbGFzdEluZGV4ID0gaSAtIDE7XG5cbiAgICAgIGlmICghaXNOdWxsT3JVbmRlZihtaW5JbmRleCkgJiYgIWlzTnVsbE9yVW5kZWYobWF4SW5kZXgpKSB7XG4gICAgICAgIC8vIFRoZSBpbnRlcnZhbCBpcyBkZWZpbmVkIGJ5IDQgcG9pbnRzOiBzdGFydCwgbWluLCBtYXgsIGVuZC5cbiAgICAgICAgLy8gVGhlIHN0YXJ0aW5nIHBvaW50IGlzIGFscmVhZHkgY29uc2lkZXJlZCBhdCB0aGlzIHBvaW50LCBzbyB3ZSBuZWVkIHRvIGRldGVybWluZSB3aGljaFxuICAgICAgICAvLyBvZiB0aGUgb3RoZXIgcG9pbnRzIHRvIGFkZC4gV2UgbmVlZCB0byBzb3J0IHRoZXNlIHBvaW50cyB0byBlbnN1cmUgdGhlIGRlY2ltYXRlZCBkYXRhXG4gICAgICAgIC8vIGlzIHN0aWxsIHNvcnRlZCBhbmQgdGhlbiBlbnN1cmUgdGhlcmUgYXJlIG5vIGR1cGxpY2F0ZXMuXG4gICAgICAgIGNvbnN0IGludGVybWVkaWF0ZUluZGV4MSA9IE1hdGgubWluKG1pbkluZGV4LCBtYXhJbmRleCk7XG4gICAgICAgIGNvbnN0IGludGVybWVkaWF0ZUluZGV4MiA9IE1hdGgubWF4KG1pbkluZGV4LCBtYXhJbmRleCk7XG5cbiAgICAgICAgaWYgKGludGVybWVkaWF0ZUluZGV4MSAhPT0gc3RhcnRJbmRleCAmJiBpbnRlcm1lZGlhdGVJbmRleDEgIT09IGxhc3RJbmRleCkge1xuICAgICAgICAgIGRlY2ltYXRlZC5wdXNoKHtcbiAgICAgICAgICAgIC4uLmRhdGFbaW50ZXJtZWRpYXRlSW5kZXgxXSxcbiAgICAgICAgICAgIHg6IGF2Z1gsXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGludGVybWVkaWF0ZUluZGV4MiAhPT0gc3RhcnRJbmRleCAmJiBpbnRlcm1lZGlhdGVJbmRleDIgIT09IGxhc3RJbmRleCkge1xuICAgICAgICAgIGRlY2ltYXRlZC5wdXNoKHtcbiAgICAgICAgICAgIC4uLmRhdGFbaW50ZXJtZWRpYXRlSW5kZXgyXSxcbiAgICAgICAgICAgIHg6IGF2Z1hcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBsYXN0SW5kZXggPT09IHN0YXJ0SW5kZXggd2lsbCBvY2N1ciB3aGVuIGEgcmFuZ2UgaGFzIG9ubHkgMSBwb2ludCB3aGljaCBjb3VsZFxuICAgICAgLy8gaGFwcGVuIHdpdGggdmVyeSB1bmV2ZW4gZGF0YVxuICAgICAgaWYgKGkgPiAwICYmIGxhc3RJbmRleCAhPT0gc3RhcnRJbmRleCkge1xuICAgICAgICAvLyBMYXN0IHBvaW50IGluIHRoZSBwcmV2aW91cyBpbnRlcnZhbFxuICAgICAgICBkZWNpbWF0ZWQucHVzaChkYXRhW2xhc3RJbmRleF0pO1xuICAgICAgfVxuXG4gICAgICAvLyBTdGFydCBvZiB0aGUgbmV3IGludGVydmFsXG4gICAgICBkZWNpbWF0ZWQucHVzaChwb2ludCk7XG4gICAgICBwcmV2WCA9IHRydW5jWDtcbiAgICAgIGNvdW50WCA9IDA7XG4gICAgICBtaW5ZID0gbWF4WSA9IHk7XG4gICAgICBtaW5JbmRleCA9IG1heEluZGV4ID0gc3RhcnRJbmRleCA9IGk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGRlY2ltYXRlZDtcbn1cblxuZnVuY3Rpb24gY2xlYW5EZWNpbWF0ZWREYXRhc2V0KGRhdGFzZXQpIHtcbiAgaWYgKGRhdGFzZXQuX2RlY2ltYXRlZCkge1xuICAgIGNvbnN0IGRhdGEgPSBkYXRhc2V0Ll9kYXRhO1xuICAgIGRlbGV0ZSBkYXRhc2V0Ll9kZWNpbWF0ZWQ7XG4gICAgZGVsZXRlIGRhdGFzZXQuX2RhdGE7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGRhdGFzZXQsICdkYXRhJywge1xuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgdmFsdWU6IGRhdGEsXG4gICAgfSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gY2xlYW5EZWNpbWF0ZWREYXRhKGNoYXJ0KSB7XG4gIGNoYXJ0LmRhdGEuZGF0YXNldHMuZm9yRWFjaCgoZGF0YXNldCkgPT4ge1xuICAgIGNsZWFuRGVjaW1hdGVkRGF0YXNldChkYXRhc2V0KTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGdldFN0YXJ0QW5kQ291bnRPZlZpc2libGVQb2ludHNTaW1wbGlmaWVkKG1ldGEsIHBvaW50cykge1xuICBjb25zdCBwb2ludENvdW50ID0gcG9pbnRzLmxlbmd0aDtcblxuICBsZXQgc3RhcnQgPSAwO1xuICBsZXQgY291bnQ7XG5cbiAgY29uc3Qge2lTY2FsZX0gPSBtZXRhO1xuICBjb25zdCB7bWluLCBtYXgsIG1pbkRlZmluZWQsIG1heERlZmluZWR9ID0gaVNjYWxlLmdldFVzZXJCb3VuZHMoKTtcblxuICBpZiAobWluRGVmaW5lZCkge1xuICAgIHN0YXJ0ID0gX2xpbWl0VmFsdWUoX2xvb2t1cEJ5S2V5KHBvaW50cywgaVNjYWxlLmF4aXMsIG1pbikubG8sIDAsIHBvaW50Q291bnQgLSAxKTtcbiAgfVxuICBpZiAobWF4RGVmaW5lZCkge1xuICAgIGNvdW50ID0gX2xpbWl0VmFsdWUoX2xvb2t1cEJ5S2V5KHBvaW50cywgaVNjYWxlLmF4aXMsIG1heCkuaGkgKyAxLCBzdGFydCwgcG9pbnRDb3VudCkgLSBzdGFydDtcbiAgfSBlbHNlIHtcbiAgICBjb3VudCA9IHBvaW50Q291bnQgLSBzdGFydDtcbiAgfVxuXG4gIHJldHVybiB7c3RhcnQsIGNvdW50fTtcbn1cblxuZXhwb3J0IGRlZmF1bHQge1xuICBpZDogJ2RlY2ltYXRpb24nLFxuXG4gIGRlZmF1bHRzOiB7XG4gICAgYWxnb3JpdGhtOiAnbWluLW1heCcsXG4gICAgZW5hYmxlZDogZmFsc2UsXG4gIH0sXG5cbiAgYmVmb3JlRWxlbWVudHNVcGRhdGU6IChjaGFydCwgYXJncywgb3B0aW9ucykgPT4ge1xuICAgIGlmICghb3B0aW9ucy5lbmFibGVkKSB7XG4gICAgICAvLyBUaGUgZGVjaW1hdGlvbiBwbHVnaW4gbWF5IGhhdmUgYmVlbiBwcmV2aW91c2x5IGVuYWJsZWQuIE5lZWQgdG8gcmVtb3ZlIG9sZCBgZGF0YXNldC5fZGF0YWAgaGFuZGxlcnNcbiAgICAgIGNsZWFuRGVjaW1hdGVkRGF0YShjaGFydCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gQXNzdW1lIHRoZSBlbnRpcmUgY2hhcnQgaXMgYXZhaWxhYmxlIHRvIHNob3cgYSBmZXcgbW9yZSBwb2ludHMgdGhhbiBuZWVkZWRcbiAgICBjb25zdCBhdmFpbGFibGVXaWR0aCA9IGNoYXJ0LndpZHRoO1xuXG4gICAgY2hhcnQuZGF0YS5kYXRhc2V0cy5mb3JFYWNoKChkYXRhc2V0LCBkYXRhc2V0SW5kZXgpID0+IHtcbiAgICAgIGNvbnN0IHtfZGF0YSwgaW5kZXhBeGlzfSA9IGRhdGFzZXQ7XG4gICAgICBjb25zdCBtZXRhID0gY2hhcnQuZ2V0RGF0YXNldE1ldGEoZGF0YXNldEluZGV4KTtcbiAgICAgIGNvbnN0IGRhdGEgPSBfZGF0YSB8fCBkYXRhc2V0LmRhdGE7XG5cbiAgICAgIGlmIChyZXNvbHZlKFtpbmRleEF4aXMsIGNoYXJ0Lm9wdGlvbnMuaW5kZXhBeGlzXSkgPT09ICd5Jykge1xuICAgICAgICAvLyBEZWNpbWF0aW9uIGlzIG9ubHkgc3VwcG9ydGVkIGZvciBsaW5lcyB0aGF0IGhhdmUgYW4gWCBpbmRleEF4aXNcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoIW1ldGEuY29udHJvbGxlci5zdXBwb3J0c0RlY2ltYXRpb24pIHtcbiAgICAgICAgLy8gT25seSBsaW5lIGRhdGFzZXRzIGFyZSBzdXBwb3J0ZWRcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBjb25zdCB4QXhpcyA9IGNoYXJ0LnNjYWxlc1ttZXRhLnhBeGlzSURdO1xuICAgICAgaWYgKHhBeGlzLnR5cGUgIT09ICdsaW5lYXInICYmIHhBeGlzLnR5cGUgIT09ICd0aW1lJykge1xuICAgICAgICAvLyBPbmx5IGxpbmVhciBpbnRlcnBvbGF0aW9uIGlzIHN1cHBvcnRlZFxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmIChjaGFydC5vcHRpb25zLnBhcnNpbmcpIHtcbiAgICAgICAgLy8gUGx1Z2luIG9ubHkgc3VwcG9ydHMgZGF0YSB0aGF0IGRvZXMgbm90IG5lZWQgcGFyc2luZ1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGxldCB7c3RhcnQsIGNvdW50fSA9IGdldFN0YXJ0QW5kQ291bnRPZlZpc2libGVQb2ludHNTaW1wbGlmaWVkKG1ldGEsIGRhdGEpO1xuICAgICAgY29uc3QgdGhyZXNob2xkID0gb3B0aW9ucy50aHJlc2hvbGQgfHwgNCAqIGF2YWlsYWJsZVdpZHRoO1xuICAgICAgaWYgKGNvdW50IDw9IHRocmVzaG9sZCkge1xuICAgICAgICAvLyBObyBkZWNpbWF0aW9uIGlzIHJlcXVpcmVkIHVudGlsIHdlIGFyZSBhYm92ZSB0aGlzIHRocmVzaG9sZFxuICAgICAgICBjbGVhbkRlY2ltYXRlZERhdGFzZXQoZGF0YXNldCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKGlzTnVsbE9yVW5kZWYoX2RhdGEpKSB7XG4gICAgICAgIC8vIEZpcnN0IHRpbWUgd2UgYXJlIHNlZWluZyB0aGlzIGRhdGFzZXRcbiAgICAgICAgLy8gV2Ugb3ZlcnJpZGUgdGhlICdkYXRhJyBwcm9wZXJ0eSB3aXRoIGEgc2V0dGVyIHRoYXQgc3RvcmVzIHRoZVxuICAgICAgICAvLyByYXcgZGF0YSBpbiBfZGF0YSwgYnV0IHJlYWRzIHRoZSBkZWNpbWF0ZWQgZGF0YSBmcm9tIF9kZWNpbWF0ZWRcbiAgICAgICAgZGF0YXNldC5fZGF0YSA9IGRhdGE7XG4gICAgICAgIGRlbGV0ZSBkYXRhc2V0LmRhdGE7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShkYXRhc2V0LCAnZGF0YScsIHtcbiAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RlY2ltYXRlZDtcbiAgICAgICAgICB9LFxuICAgICAgICAgIHNldDogZnVuY3Rpb24oZCkge1xuICAgICAgICAgICAgdGhpcy5fZGF0YSA9IGQ7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgLy8gUG9pbnQgdGhlIGNoYXJ0IHRvIHRoZSBkZWNpbWF0ZWQgZGF0YVxuICAgICAgbGV0IGRlY2ltYXRlZDtcbiAgICAgIHN3aXRjaCAob3B0aW9ucy5hbGdvcml0aG0pIHtcbiAgICAgIGNhc2UgJ2x0dGInOlxuICAgICAgICBkZWNpbWF0ZWQgPSBsdHRiRGVjaW1hdGlvbihkYXRhLCBzdGFydCwgY291bnQsIGF2YWlsYWJsZVdpZHRoLCBvcHRpb25zKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdtaW4tbWF4JzpcbiAgICAgICAgZGVjaW1hdGVkID0gbWluTWF4RGVjaW1hdGlvbihkYXRhLCBzdGFydCwgY291bnQsIGF2YWlsYWJsZVdpZHRoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIGRlY2ltYXRpb24gYWxnb3JpdGhtICcke29wdGlvbnMuYWxnb3JpdGhtfSdgKTtcbiAgICAgIH1cblxuICAgICAgZGF0YXNldC5fZGVjaW1hdGVkID0gZGVjaW1hdGVkO1xuICAgIH0pO1xuICB9LFxuXG4gIGRlc3Ryb3koY2hhcnQpIHtcbiAgICBjbGVhbkRlY2ltYXRlZERhdGEoY2hhcnQpO1xuICB9XG59O1xuIiwgImltcG9ydCB7X2JvdW5kU2VnbWVudCwgX2JvdW5kU2VnbWVudHMsIF9ub3JtYWxpemVBbmdsZX0gZnJvbSAnLi4vLi4vaGVscGVycy9pbmRleC5qcyc7XG5cbmV4cG9ydCBmdW5jdGlvbiBfc2VnbWVudHMobGluZSwgdGFyZ2V0LCBwcm9wZXJ0eSkge1xuICBjb25zdCBzZWdtZW50cyA9IGxpbmUuc2VnbWVudHM7XG4gIGNvbnN0IHBvaW50cyA9IGxpbmUucG9pbnRzO1xuICBjb25zdCB0cG9pbnRzID0gdGFyZ2V0LnBvaW50cztcbiAgY29uc3QgcGFydHMgPSBbXTtcblxuICBmb3IgKGNvbnN0IHNlZ21lbnQgb2Ygc2VnbWVudHMpIHtcbiAgICBsZXQge3N0YXJ0LCBlbmR9ID0gc2VnbWVudDtcbiAgICBlbmQgPSBfZmluZFNlZ21lbnRFbmQoc3RhcnQsIGVuZCwgcG9pbnRzKTtcblxuICAgIGNvbnN0IGJvdW5kcyA9IF9nZXRCb3VuZHMocHJvcGVydHksIHBvaW50c1tzdGFydF0sIHBvaW50c1tlbmRdLCBzZWdtZW50Lmxvb3ApO1xuXG4gICAgaWYgKCF0YXJnZXQuc2VnbWVudHMpIHtcbiAgICAgIC8vIFNwZWNpYWwgY2FzZSBmb3IgYm91bmRhcnkgbm90IHN1cHBvcnRpbmcgYHNlZ21lbnRzYCAoc2ltcGxlQXJjKVxuICAgICAgLy8gQm91bmRzIGFyZSBwcm92aWRlZCBhcyBgdGFyZ2V0YCBmb3IgcGFydGlhbCBjaXJjbGUsIG9yIHVuZGVmaW5lZCBmb3IgZnVsbCBjaXJjbGVcbiAgICAgIHBhcnRzLnB1c2goe1xuICAgICAgICBzb3VyY2U6IHNlZ21lbnQsXG4gICAgICAgIHRhcmdldDogYm91bmRzLFxuICAgICAgICBzdGFydDogcG9pbnRzW3N0YXJ0XSxcbiAgICAgICAgZW5kOiBwb2ludHNbZW5kXVxuICAgICAgfSk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvLyBHZXQgYWxsIHNlZ21lbnRzIGZyb20gYHRhcmdldGAgdGhhdCBpbnRlcnNlY3QgdGhlIGJvdW5kcyBvZiBjdXJyZW50IHNlZ21lbnQgb2YgYGxpbmVgXG4gICAgY29uc3QgdGFyZ2V0U2VnbWVudHMgPSBfYm91bmRTZWdtZW50cyh0YXJnZXQsIGJvdW5kcyk7XG5cbiAgICBmb3IgKGNvbnN0IHRndCBvZiB0YXJnZXRTZWdtZW50cykge1xuICAgICAgY29uc3Qgc3ViQm91bmRzID0gX2dldEJvdW5kcyhwcm9wZXJ0eSwgdHBvaW50c1t0Z3Quc3RhcnRdLCB0cG9pbnRzW3RndC5lbmRdLCB0Z3QubG9vcCk7XG4gICAgICBjb25zdCBmaWxsU291cmNlcyA9IF9ib3VuZFNlZ21lbnQoc2VnbWVudCwgcG9pbnRzLCBzdWJCb3VuZHMpO1xuXG4gICAgICBmb3IgKGNvbnN0IGZpbGxTb3VyY2Ugb2YgZmlsbFNvdXJjZXMpIHtcbiAgICAgICAgcGFydHMucHVzaCh7XG4gICAgICAgICAgc291cmNlOiBmaWxsU291cmNlLFxuICAgICAgICAgIHRhcmdldDogdGd0LFxuICAgICAgICAgIHN0YXJ0OiB7XG4gICAgICAgICAgICBbcHJvcGVydHldOiBfZ2V0RWRnZShib3VuZHMsIHN1YkJvdW5kcywgJ3N0YXJ0JywgTWF0aC5tYXgpXG4gICAgICAgICAgfSxcbiAgICAgICAgICBlbmQ6IHtcbiAgICAgICAgICAgIFtwcm9wZXJ0eV06IF9nZXRFZGdlKGJvdW5kcywgc3ViQm91bmRzLCAnZW5kJywgTWF0aC5taW4pXG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHBhcnRzO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gX2dldEJvdW5kcyhwcm9wZXJ0eSwgZmlyc3QsIGxhc3QsIGxvb3ApIHtcbiAgaWYgKGxvb3ApIHtcbiAgICByZXR1cm47XG4gIH1cbiAgbGV0IHN0YXJ0ID0gZmlyc3RbcHJvcGVydHldO1xuICBsZXQgZW5kID0gbGFzdFtwcm9wZXJ0eV07XG5cbiAgaWYgKHByb3BlcnR5ID09PSAnYW5nbGUnKSB7XG4gICAgc3RhcnQgPSBfbm9ybWFsaXplQW5nbGUoc3RhcnQpO1xuICAgIGVuZCA9IF9ub3JtYWxpemVBbmdsZShlbmQpO1xuICB9XG4gIHJldHVybiB7cHJvcGVydHksIHN0YXJ0LCBlbmR9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gX3BvaW50c0Zyb21TZWdtZW50cyhib3VuZGFyeSwgbGluZSkge1xuICBjb25zdCB7eCA9IG51bGwsIHkgPSBudWxsfSA9IGJvdW5kYXJ5IHx8IHt9O1xuICBjb25zdCBsaW5lUG9pbnRzID0gbGluZS5wb2ludHM7XG4gIGNvbnN0IHBvaW50cyA9IFtdO1xuICBsaW5lLnNlZ21lbnRzLmZvckVhY2goKHtzdGFydCwgZW5kfSkgPT4ge1xuICAgIGVuZCA9IF9maW5kU2VnbWVudEVuZChzdGFydCwgZW5kLCBsaW5lUG9pbnRzKTtcbiAgICBjb25zdCBmaXJzdCA9IGxpbmVQb2ludHNbc3RhcnRdO1xuICAgIGNvbnN0IGxhc3QgPSBsaW5lUG9pbnRzW2VuZF07XG4gICAgaWYgKHkgIT09IG51bGwpIHtcbiAgICAgIHBvaW50cy5wdXNoKHt4OiBmaXJzdC54LCB5fSk7XG4gICAgICBwb2ludHMucHVzaCh7eDogbGFzdC54LCB5fSk7XG4gICAgfSBlbHNlIGlmICh4ICE9PSBudWxsKSB7XG4gICAgICBwb2ludHMucHVzaCh7eCwgeTogZmlyc3QueX0pO1xuICAgICAgcG9pbnRzLnB1c2goe3gsIHk6IGxhc3QueX0pO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBwb2ludHM7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBfZmluZFNlZ21lbnRFbmQoc3RhcnQsIGVuZCwgcG9pbnRzKSB7XG4gIGZvciAoO2VuZCA+IHN0YXJ0OyBlbmQtLSkge1xuICAgIGNvbnN0IHBvaW50ID0gcG9pbnRzW2VuZF07XG4gICAgaWYgKCFpc05hTihwb2ludC54KSAmJiAhaXNOYU4ocG9pbnQueSkpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZW5kO1xufVxuXG5mdW5jdGlvbiBfZ2V0RWRnZShhLCBiLCBwcm9wLCBmbikge1xuICBpZiAoYSAmJiBiKSB7XG4gICAgcmV0dXJuIGZuKGFbcHJvcF0sIGJbcHJvcF0pO1xuICB9XG4gIHJldHVybiBhID8gYVtwcm9wXSA6IGIgPyBiW3Byb3BdIDogMDtcbn1cbiIsICIvKipcbiAqIEB0eXBlZGVmIHsgaW1wb3J0KCcuLi8uLi9jb3JlL2NvcmUuY29udHJvbGxlci5qcycpLmRlZmF1bHQgfSBDaGFydFxuICogQHR5cGVkZWYgeyBpbXBvcnQoJy4uLy4uL2NvcmUvY29yZS5zY2FsZS5qcycpLmRlZmF1bHQgfSBTY2FsZVxuICogQHR5cGVkZWYgeyBpbXBvcnQoJy4uLy4uL2VsZW1lbnRzL2VsZW1lbnQucG9pbnQuanMnKS5kZWZhdWx0IH0gUG9pbnRFbGVtZW50XG4gKi9cblxuaW1wb3J0IHtMaW5lRWxlbWVudH0gZnJvbSAnLi4vLi4vZWxlbWVudHMvaW5kZXguanMnO1xuaW1wb3J0IHtpc0FycmF5fSBmcm9tICcuLi8uLi9oZWxwZXJzL2luZGV4LmpzJztcbmltcG9ydCB7X3BvaW50c0Zyb21TZWdtZW50c30gZnJvbSAnLi9maWxsZXIuc2VnbWVudC5qcyc7XG5cbi8qKlxuICogQHBhcmFtIHtQb2ludEVsZW1lbnRbXSB8IHsgeDogbnVtYmVyOyB5OiBudW1iZXI7IH19IGJvdW5kYXJ5XG4gKiBAcGFyYW0ge0xpbmVFbGVtZW50fSBsaW5lXG4gKiBAcmV0dXJuIHtMaW5lRWxlbWVudD99XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBfY3JlYXRlQm91bmRhcnlMaW5lKGJvdW5kYXJ5LCBsaW5lKSB7XG4gIGxldCBwb2ludHMgPSBbXTtcbiAgbGV0IF9sb29wID0gZmFsc2U7XG5cbiAgaWYgKGlzQXJyYXkoYm91bmRhcnkpKSB7XG4gICAgX2xvb3AgPSB0cnVlO1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBwb2ludHMgPSBib3VuZGFyeTtcbiAgfSBlbHNlIHtcbiAgICBwb2ludHMgPSBfcG9pbnRzRnJvbVNlZ21lbnRzKGJvdW5kYXJ5LCBsaW5lKTtcbiAgfVxuXG4gIHJldHVybiBwb2ludHMubGVuZ3RoID8gbmV3IExpbmVFbGVtZW50KHtcbiAgICBwb2ludHMsXG4gICAgb3B0aW9uczoge3RlbnNpb246IDB9LFxuICAgIF9sb29wLFxuICAgIF9mdWxsTG9vcDogX2xvb3BcbiAgfSkgOiBudWxsO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gX3Nob3VsZEFwcGx5RmlsbChzb3VyY2UpIHtcbiAgcmV0dXJuIHNvdXJjZSAmJiBzb3VyY2UuZmlsbCAhPT0gZmFsc2U7XG59XG4iLCAiaW1wb3J0IHtpc09iamVjdCwgaXNGaW5pdGUsIHZhbHVlT3JEZWZhdWx0fSBmcm9tICcuLi8uLi9oZWxwZXJzL2hlbHBlcnMuY29yZS5qcyc7XG5cbi8qKlxuICogQHR5cGVkZWYgeyBpbXBvcnQoJy4uLy4uL2NvcmUvY29yZS5zY2FsZS5qcycpLmRlZmF1bHQgfSBTY2FsZVxuICogQHR5cGVkZWYgeyBpbXBvcnQoJy4uLy4uL2VsZW1lbnRzL2VsZW1lbnQubGluZS5qcycpLmRlZmF1bHQgfSBMaW5lRWxlbWVudFxuICogQHR5cGVkZWYgeyBpbXBvcnQoJy4uLy4uL3R5cGVzL2luZGV4LmpzJykuRmlsbFRhcmdldCB9IEZpbGxUYXJnZXRcbiAqIEB0eXBlZGVmIHsgaW1wb3J0KCcuLi8uLi90eXBlcy9pbmRleC5qcycpLkNvbXBsZXhGaWxsVGFyZ2V0IH0gQ29tcGxleEZpbGxUYXJnZXRcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gX3Jlc29sdmVUYXJnZXQoc291cmNlcywgaW5kZXgsIHByb3BhZ2F0ZSkge1xuICBjb25zdCBzb3VyY2UgPSBzb3VyY2VzW2luZGV4XTtcbiAgbGV0IGZpbGwgPSBzb3VyY2UuZmlsbDtcbiAgY29uc3QgdmlzaXRlZCA9IFtpbmRleF07XG4gIGxldCB0YXJnZXQ7XG5cbiAgaWYgKCFwcm9wYWdhdGUpIHtcbiAgICByZXR1cm4gZmlsbDtcbiAgfVxuXG4gIHdoaWxlIChmaWxsICE9PSBmYWxzZSAmJiB2aXNpdGVkLmluZGV4T2YoZmlsbCkgPT09IC0xKSB7XG4gICAgaWYgKCFpc0Zpbml0ZShmaWxsKSkge1xuICAgICAgcmV0dXJuIGZpbGw7XG4gICAgfVxuXG4gICAgdGFyZ2V0ID0gc291cmNlc1tmaWxsXTtcbiAgICBpZiAoIXRhcmdldCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmICh0YXJnZXQudmlzaWJsZSkge1xuICAgICAgcmV0dXJuIGZpbGw7XG4gICAgfVxuXG4gICAgdmlzaXRlZC5wdXNoKGZpbGwpO1xuICAgIGZpbGwgPSB0YXJnZXQuZmlsbDtcbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0xpbmVFbGVtZW50fSBsaW5lXG4gKiBAcGFyYW0ge251bWJlcn0gaW5kZXhcbiAqIEBwYXJhbSB7bnVtYmVyfSBjb3VudFxuICovXG5leHBvcnQgZnVuY3Rpb24gX2RlY29kZUZpbGwobGluZSwgaW5kZXgsIGNvdW50KSB7XG4gIC8qKiBAdHlwZSB7c3RyaW5nIHwge3ZhbHVlOiBudW1iZXJ9fSAqL1xuICBjb25zdCBmaWxsID0gcGFyc2VGaWxsT3B0aW9uKGxpbmUpO1xuXG4gIGlmIChpc09iamVjdChmaWxsKSkge1xuICAgIHJldHVybiBpc05hTihmaWxsLnZhbHVlKSA/IGZhbHNlIDogZmlsbDtcbiAgfVxuXG4gIGxldCB0YXJnZXQgPSBwYXJzZUZsb2F0KGZpbGwpO1xuXG4gIGlmIChpc0Zpbml0ZSh0YXJnZXQpICYmIE1hdGguZmxvb3IodGFyZ2V0KSA9PT0gdGFyZ2V0KSB7XG4gICAgcmV0dXJuIGRlY29kZVRhcmdldEluZGV4KGZpbGxbMF0sIGluZGV4LCB0YXJnZXQsIGNvdW50KTtcbiAgfVxuXG4gIHJldHVybiBbJ29yaWdpbicsICdzdGFydCcsICdlbmQnLCAnc3RhY2snLCAnc2hhcGUnXS5pbmRleE9mKGZpbGwpID49IDAgJiYgZmlsbDtcbn1cblxuZnVuY3Rpb24gZGVjb2RlVGFyZ2V0SW5kZXgoZmlyc3RDaCwgaW5kZXgsIHRhcmdldCwgY291bnQpIHtcbiAgaWYgKGZpcnN0Q2ggPT09ICctJyB8fCBmaXJzdENoID09PSAnKycpIHtcbiAgICB0YXJnZXQgPSBpbmRleCArIHRhcmdldDtcbiAgfVxuXG4gIGlmICh0YXJnZXQgPT09IGluZGV4IHx8IHRhcmdldCA8IDAgfHwgdGFyZ2V0ID49IGNvdW50KSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIHRhcmdldDtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0ZpbGxUYXJnZXQgfCBDb21wbGV4RmlsbFRhcmdldH0gZmlsbFxuICogQHBhcmFtIHtTY2FsZX0gc2NhbGVcbiAqIEByZXR1cm5zIHtudW1iZXIgfCBudWxsfVxuICovXG5leHBvcnQgZnVuY3Rpb24gX2dldFRhcmdldFBpeGVsKGZpbGwsIHNjYWxlKSB7XG4gIGxldCBwaXhlbCA9IG51bGw7XG4gIGlmIChmaWxsID09PSAnc3RhcnQnKSB7XG4gICAgcGl4ZWwgPSBzY2FsZS5ib3R0b207XG4gIH0gZWxzZSBpZiAoZmlsbCA9PT0gJ2VuZCcpIHtcbiAgICBwaXhlbCA9IHNjYWxlLnRvcDtcbiAgfSBlbHNlIGlmIChpc09iamVjdChmaWxsKSkge1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBwaXhlbCA9IHNjYWxlLmdldFBpeGVsRm9yVmFsdWUoZmlsbC52YWx1ZSk7XG4gIH0gZWxzZSBpZiAoc2NhbGUuZ2V0QmFzZVBpeGVsKSB7XG4gICAgcGl4ZWwgPSBzY2FsZS5nZXRCYXNlUGl4ZWwoKTtcbiAgfVxuICByZXR1cm4gcGl4ZWw7XG59XG5cbi8qKlxuICogQHBhcmFtIHtGaWxsVGFyZ2V0IHwgQ29tcGxleEZpbGxUYXJnZXR9IGZpbGxcbiAqIEBwYXJhbSB7U2NhbGV9IHNjYWxlXG4gKiBAcGFyYW0ge251bWJlcn0gc3RhcnRWYWx1ZVxuICogQHJldHVybnMge251bWJlciB8IHVuZGVmaW5lZH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIF9nZXRUYXJnZXRWYWx1ZShmaWxsLCBzY2FsZSwgc3RhcnRWYWx1ZSkge1xuICBsZXQgdmFsdWU7XG5cbiAgaWYgKGZpbGwgPT09ICdzdGFydCcpIHtcbiAgICB2YWx1ZSA9IHN0YXJ0VmFsdWU7XG4gIH0gZWxzZSBpZiAoZmlsbCA9PT0gJ2VuZCcpIHtcbiAgICB2YWx1ZSA9IHNjYWxlLm9wdGlvbnMucmV2ZXJzZSA/IHNjYWxlLm1pbiA6IHNjYWxlLm1heDtcbiAgfSBlbHNlIGlmIChpc09iamVjdChmaWxsKSkge1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICB2YWx1ZSA9IGZpbGwudmFsdWU7XG4gIH0gZWxzZSB7XG4gICAgdmFsdWUgPSBzY2FsZS5nZXRCYXNlVmFsdWUoKTtcbiAgfVxuICByZXR1cm4gdmFsdWU7XG59XG5cbi8qKlxuICogQHBhcmFtIHtMaW5lRWxlbWVudH0gbGluZVxuICovXG5mdW5jdGlvbiBwYXJzZUZpbGxPcHRpb24obGluZSkge1xuICBjb25zdCBvcHRpb25zID0gbGluZS5vcHRpb25zO1xuICBjb25zdCBmaWxsT3B0aW9uID0gb3B0aW9ucy5maWxsO1xuICBsZXQgZmlsbCA9IHZhbHVlT3JEZWZhdWx0KGZpbGxPcHRpb24gJiYgZmlsbE9wdGlvbi50YXJnZXQsIGZpbGxPcHRpb24pO1xuXG4gIGlmIChmaWxsID09PSB1bmRlZmluZWQpIHtcbiAgICBmaWxsID0gISFvcHRpb25zLmJhY2tncm91bmRDb2xvcjtcbiAgfVxuXG4gIGlmIChmaWxsID09PSBmYWxzZSB8fCBmaWxsID09PSBudWxsKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKGZpbGwgPT09IHRydWUpIHtcbiAgICByZXR1cm4gJ29yaWdpbic7XG4gIH1cbiAgcmV0dXJuIGZpbGw7XG59XG4iLCAiLyoqXG4gKiBAdHlwZWRlZiB7IGltcG9ydCgnLi4vLi4vY29yZS9jb3JlLmNvbnRyb2xsZXIuanMnKS5kZWZhdWx0IH0gQ2hhcnRcbiAqIEB0eXBlZGVmIHsgaW1wb3J0KCcuLi8uLi9jb3JlL2NvcmUuc2NhbGUuanMnKS5kZWZhdWx0IH0gU2NhbGVcbiAqIEB0eXBlZGVmIHsgaW1wb3J0KCcuLi8uLi9lbGVtZW50cy9lbGVtZW50LnBvaW50LmpzJykuZGVmYXVsdCB9IFBvaW50RWxlbWVudFxuICovXG5cbmltcG9ydCB7TGluZUVsZW1lbnR9IGZyb20gJy4uLy4uL2VsZW1lbnRzL2luZGV4LmpzJztcbmltcG9ydCB7X2lzQmV0d2Vlbn0gZnJvbSAnLi4vLi4vaGVscGVycy9pbmRleC5qcyc7XG5pbXBvcnQge19jcmVhdGVCb3VuZGFyeUxpbmV9IGZyb20gJy4vZmlsbGVyLmhlbHBlci5qcyc7XG5cbi8qKlxuICogQHBhcmFtIHt7IGNoYXJ0OiBDaGFydDsgc2NhbGU6IFNjYWxlOyBpbmRleDogbnVtYmVyOyBsaW5lOiBMaW5lRWxlbWVudDsgfX0gc291cmNlXG4gKiBAcmV0dXJuIHtMaW5lRWxlbWVudH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIF9idWlsZFN0YWNrTGluZShzb3VyY2UpIHtcbiAgY29uc3Qge3NjYWxlLCBpbmRleCwgbGluZX0gPSBzb3VyY2U7XG4gIGNvbnN0IHBvaW50cyA9IFtdO1xuICBjb25zdCBzZWdtZW50cyA9IGxpbmUuc2VnbWVudHM7XG4gIGNvbnN0IHNvdXJjZVBvaW50cyA9IGxpbmUucG9pbnRzO1xuICBjb25zdCBsaW5lc0JlbG93ID0gZ2V0TGluZXNCZWxvdyhzY2FsZSwgaW5kZXgpO1xuICBsaW5lc0JlbG93LnB1c2goX2NyZWF0ZUJvdW5kYXJ5TGluZSh7eDogbnVsbCwgeTogc2NhbGUuYm90dG9tfSwgbGluZSkpO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc2VnbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBzZWdtZW50ID0gc2VnbWVudHNbaV07XG4gICAgZm9yIChsZXQgaiA9IHNlZ21lbnQuc3RhcnQ7IGogPD0gc2VnbWVudC5lbmQ7IGorKykge1xuICAgICAgYWRkUG9pbnRzQmVsb3cocG9pbnRzLCBzb3VyY2VQb2ludHNbal0sIGxpbmVzQmVsb3cpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbmV3IExpbmVFbGVtZW50KHtwb2ludHMsIG9wdGlvbnM6IHt9fSk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtTY2FsZX0gc2NhbGVcbiAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleFxuICogQHJldHVybiB7TGluZUVsZW1lbnRbXX1cbiAqL1xuZnVuY3Rpb24gZ2V0TGluZXNCZWxvdyhzY2FsZSwgaW5kZXgpIHtcbiAgY29uc3QgYmVsb3cgPSBbXTtcbiAgY29uc3QgbWV0YXMgPSBzY2FsZS5nZXRNYXRjaGluZ1Zpc2libGVNZXRhcygnbGluZScpO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbWV0YXMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBtZXRhID0gbWV0YXNbaV07XG4gICAgaWYgKG1ldGEuaW5kZXggPT09IGluZGV4KSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgaWYgKCFtZXRhLmhpZGRlbikge1xuICAgICAgYmVsb3cudW5zaGlmdChtZXRhLmRhdGFzZXQpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gYmVsb3c7XG59XG5cbi8qKlxuICogQHBhcmFtIHtQb2ludEVsZW1lbnRbXX0gcG9pbnRzXG4gKiBAcGFyYW0ge1BvaW50RWxlbWVudH0gc291cmNlUG9pbnRcbiAqIEBwYXJhbSB7TGluZUVsZW1lbnRbXX0gbGluZXNCZWxvd1xuICovXG5mdW5jdGlvbiBhZGRQb2ludHNCZWxvdyhwb2ludHMsIHNvdXJjZVBvaW50LCBsaW5lc0JlbG93KSB7XG4gIGNvbnN0IHBvc3Rwb25lZCA9IFtdO1xuICBmb3IgKGxldCBqID0gMDsgaiA8IGxpbmVzQmVsb3cubGVuZ3RoOyBqKyspIHtcbiAgICBjb25zdCBsaW5lID0gbGluZXNCZWxvd1tqXTtcbiAgICBjb25zdCB7Zmlyc3QsIGxhc3QsIHBvaW50fSA9IGZpbmRQb2ludChsaW5lLCBzb3VyY2VQb2ludCwgJ3gnKTtcblxuICAgIGlmICghcG9pbnQgfHwgKGZpcnN0ICYmIGxhc3QpKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKGZpcnN0KSB7XG4gICAgICAvLyBGaXJzdCBwb2ludCBvZiBhbiBzZWdtZW50IC0+IG5lZWQgdG8gYWRkIGFub3RoZXIgcG9pbnQgYmVmb3JlIHRoaXMsXG4gICAgICAvLyBmcm9tIG5leHQgbGluZSBiZWxvdy5cbiAgICAgIHBvc3Rwb25lZC51bnNoaWZ0KHBvaW50KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcG9pbnRzLnB1c2gocG9pbnQpO1xuICAgICAgaWYgKCFsYXN0KSB7XG4gICAgICAgIC8vIEluIHRoZSBtaWRkbGUgb2YgYW4gc2VnbWVudCwgbm8gbmVlZCB0byBhZGQgbW9yZSBwb2ludHMuXG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBwb2ludHMucHVzaCguLi5wb3N0cG9uZWQpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7TGluZUVsZW1lbnR9IGxpbmVcbiAqIEBwYXJhbSB7UG9pbnRFbGVtZW50fSBzb3VyY2VQb2ludFxuICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5XG4gKiBAcmV0dXJucyB7e3BvaW50PzogUG9pbnRFbGVtZW50LCBmaXJzdD86IGJvb2xlYW4sIGxhc3Q/OiBib29sZWFufX1cbiAqL1xuZnVuY3Rpb24gZmluZFBvaW50KGxpbmUsIHNvdXJjZVBvaW50LCBwcm9wZXJ0eSkge1xuICBjb25zdCBwb2ludCA9IGxpbmUuaW50ZXJwb2xhdGUoc291cmNlUG9pbnQsIHByb3BlcnR5KTtcbiAgaWYgKCFwb2ludCkge1xuICAgIHJldHVybiB7fTtcbiAgfVxuXG4gIGNvbnN0IHBvaW50VmFsdWUgPSBwb2ludFtwcm9wZXJ0eV07XG4gIGNvbnN0IHNlZ21lbnRzID0gbGluZS5zZWdtZW50cztcbiAgY29uc3QgbGluZVBvaW50cyA9IGxpbmUucG9pbnRzO1xuICBsZXQgZmlyc3QgPSBmYWxzZTtcbiAgbGV0IGxhc3QgPSBmYWxzZTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzZWdtZW50cy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IHNlZ21lbnQgPSBzZWdtZW50c1tpXTtcbiAgICBjb25zdCBmaXJzdFZhbHVlID0gbGluZVBvaW50c1tzZWdtZW50LnN0YXJ0XVtwcm9wZXJ0eV07XG4gICAgY29uc3QgbGFzdFZhbHVlID0gbGluZVBvaW50c1tzZWdtZW50LmVuZF1bcHJvcGVydHldO1xuICAgIGlmIChfaXNCZXR3ZWVuKHBvaW50VmFsdWUsIGZpcnN0VmFsdWUsIGxhc3RWYWx1ZSkpIHtcbiAgICAgIGZpcnN0ID0gcG9pbnRWYWx1ZSA9PT0gZmlyc3RWYWx1ZTtcbiAgICAgIGxhc3QgPSBwb2ludFZhbHVlID09PSBsYXN0VmFsdWU7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHtmaXJzdCwgbGFzdCwgcG9pbnR9O1xufVxuIiwgImltcG9ydCB7VEFVfSBmcm9tICcuLi8uLi9oZWxwZXJzL2luZGV4LmpzJztcblxuLy8gVE9ETzogdXNlIGVsZW1lbnRzLkFyY0VsZW1lbnQgaW5zdGVhZFxuZXhwb3J0IGNsYXNzIHNpbXBsZUFyYyB7XG4gIGNvbnN0cnVjdG9yKG9wdHMpIHtcbiAgICB0aGlzLnggPSBvcHRzLng7XG4gICAgdGhpcy55ID0gb3B0cy55O1xuICAgIHRoaXMucmFkaXVzID0gb3B0cy5yYWRpdXM7XG4gIH1cblxuICBwYXRoU2VnbWVudChjdHgsIGJvdW5kcywgb3B0cykge1xuICAgIGNvbnN0IHt4LCB5LCByYWRpdXN9ID0gdGhpcztcbiAgICBib3VuZHMgPSBib3VuZHMgfHwge3N0YXJ0OiAwLCBlbmQ6IFRBVX07XG4gICAgY3R4LmFyYyh4LCB5LCByYWRpdXMsIGJvdW5kcy5lbmQsIGJvdW5kcy5zdGFydCwgdHJ1ZSk7XG4gICAgcmV0dXJuICFvcHRzLmJvdW5kcztcbiAgfVxuXG4gIGludGVycG9sYXRlKHBvaW50KSB7XG4gICAgY29uc3Qge3gsIHksIHJhZGl1c30gPSB0aGlzO1xuICAgIGNvbnN0IGFuZ2xlID0gcG9pbnQuYW5nbGU7XG4gICAgcmV0dXJuIHtcbiAgICAgIHg6IHggKyBNYXRoLmNvcyhhbmdsZSkgKiByYWRpdXMsXG4gICAgICB5OiB5ICsgTWF0aC5zaW4oYW5nbGUpICogcmFkaXVzLFxuICAgICAgYW5nbGVcbiAgICB9O1xuICB9XG59XG4iLCAiaW1wb3J0IHtpc0Zpbml0ZX0gZnJvbSAnLi4vLi4vaGVscGVycy9pbmRleC5qcyc7XG5pbXBvcnQge19jcmVhdGVCb3VuZGFyeUxpbmV9IGZyb20gJy4vZmlsbGVyLmhlbHBlci5qcyc7XG5pbXBvcnQge19nZXRUYXJnZXRQaXhlbCwgX2dldFRhcmdldFZhbHVlfSBmcm9tICcuL2ZpbGxlci5vcHRpb25zLmpzJztcbmltcG9ydCB7X2J1aWxkU3RhY2tMaW5lfSBmcm9tICcuL2ZpbGxlci50YXJnZXQuc3RhY2suanMnO1xuaW1wb3J0IHtzaW1wbGVBcmN9IGZyb20gJy4vc2ltcGxlQXJjLmpzJztcblxuLyoqXG4gKiBAdHlwZWRlZiB7IGltcG9ydCgnLi4vLi4vY29yZS9jb3JlLmNvbnRyb2xsZXIuanMnKS5kZWZhdWx0IH0gQ2hhcnRcbiAqIEB0eXBlZGVmIHsgaW1wb3J0KCcuLi8uLi9jb3JlL2NvcmUuc2NhbGUuanMnKS5kZWZhdWx0IH0gU2NhbGVcbiAqIEB0eXBlZGVmIHsgaW1wb3J0KCcuLi8uLi9lbGVtZW50cy9lbGVtZW50LnBvaW50LmpzJykuZGVmYXVsdCB9IFBvaW50RWxlbWVudFxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBfZ2V0VGFyZ2V0KHNvdXJjZSkge1xuICBjb25zdCB7Y2hhcnQsIGZpbGwsIGxpbmV9ID0gc291cmNlO1xuXG4gIGlmIChpc0Zpbml0ZShmaWxsKSkge1xuICAgIHJldHVybiBnZXRMaW5lQnlJbmRleChjaGFydCwgZmlsbCk7XG4gIH1cblxuICBpZiAoZmlsbCA9PT0gJ3N0YWNrJykge1xuICAgIHJldHVybiBfYnVpbGRTdGFja0xpbmUoc291cmNlKTtcbiAgfVxuXG4gIGlmIChmaWxsID09PSAnc2hhcGUnKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBjb25zdCBib3VuZGFyeSA9IGNvbXB1dGVCb3VuZGFyeShzb3VyY2UpO1xuXG4gIGlmIChib3VuZGFyeSBpbnN0YW5jZW9mIHNpbXBsZUFyYykge1xuICAgIHJldHVybiBib3VuZGFyeTtcbiAgfVxuXG4gIHJldHVybiBfY3JlYXRlQm91bmRhcnlMaW5lKGJvdW5kYXJ5LCBsaW5lKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0NoYXJ0fSBjaGFydFxuICogQHBhcmFtIHtudW1iZXJ9IGluZGV4XG4gKi9cbmZ1bmN0aW9uIGdldExpbmVCeUluZGV4KGNoYXJ0LCBpbmRleCkge1xuICBjb25zdCBtZXRhID0gY2hhcnQuZ2V0RGF0YXNldE1ldGEoaW5kZXgpO1xuICBjb25zdCB2aXNpYmxlID0gbWV0YSAmJiBjaGFydC5pc0RhdGFzZXRWaXNpYmxlKGluZGV4KTtcbiAgcmV0dXJuIHZpc2libGUgPyBtZXRhLmRhdGFzZXQgOiBudWxsO1xufVxuXG5mdW5jdGlvbiBjb21wdXRlQm91bmRhcnkoc291cmNlKSB7XG4gIGNvbnN0IHNjYWxlID0gc291cmNlLnNjYWxlIHx8IHt9O1xuXG4gIGlmIChzY2FsZS5nZXRQb2ludFBvc2l0aW9uRm9yVmFsdWUpIHtcbiAgICByZXR1cm4gY29tcHV0ZUNpcmN1bGFyQm91bmRhcnkoc291cmNlKTtcbiAgfVxuICByZXR1cm4gY29tcHV0ZUxpbmVhckJvdW5kYXJ5KHNvdXJjZSk7XG59XG5cblxuZnVuY3Rpb24gY29tcHV0ZUxpbmVhckJvdW5kYXJ5KHNvdXJjZSkge1xuICBjb25zdCB7c2NhbGUgPSB7fSwgZmlsbH0gPSBzb3VyY2U7XG4gIGNvbnN0IHBpeGVsID0gX2dldFRhcmdldFBpeGVsKGZpbGwsIHNjYWxlKTtcblxuICBpZiAoaXNGaW5pdGUocGl4ZWwpKSB7XG4gICAgY29uc3QgaG9yaXpvbnRhbCA9IHNjYWxlLmlzSG9yaXpvbnRhbCgpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIHg6IGhvcml6b250YWwgPyBwaXhlbCA6IG51bGwsXG4gICAgICB5OiBob3Jpem9udGFsID8gbnVsbCA6IHBpeGVsXG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG5mdW5jdGlvbiBjb21wdXRlQ2lyY3VsYXJCb3VuZGFyeShzb3VyY2UpIHtcbiAgY29uc3Qge3NjYWxlLCBmaWxsfSA9IHNvdXJjZTtcbiAgY29uc3Qgb3B0aW9ucyA9IHNjYWxlLm9wdGlvbnM7XG4gIGNvbnN0IGxlbmd0aCA9IHNjYWxlLmdldExhYmVscygpLmxlbmd0aDtcbiAgY29uc3Qgc3RhcnQgPSBvcHRpb25zLnJldmVyc2UgPyBzY2FsZS5tYXggOiBzY2FsZS5taW47XG4gIGNvbnN0IHZhbHVlID0gX2dldFRhcmdldFZhbHVlKGZpbGwsIHNjYWxlLCBzdGFydCk7XG4gIGNvbnN0IHRhcmdldCA9IFtdO1xuXG4gIGlmIChvcHRpb25zLmdyaWQuY2lyY3VsYXIpIHtcbiAgICBjb25zdCBjZW50ZXIgPSBzY2FsZS5nZXRQb2ludFBvc2l0aW9uRm9yVmFsdWUoMCwgc3RhcnQpO1xuICAgIHJldHVybiBuZXcgc2ltcGxlQXJjKHtcbiAgICAgIHg6IGNlbnRlci54LFxuICAgICAgeTogY2VudGVyLnksXG4gICAgICByYWRpdXM6IHNjYWxlLmdldERpc3RhbmNlRnJvbUNlbnRlckZvclZhbHVlKHZhbHVlKVxuICAgIH0pO1xuICB9XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIHRhcmdldC5wdXNoKHNjYWxlLmdldFBvaW50UG9zaXRpb25Gb3JWYWx1ZShpLCB2YWx1ZSkpO1xuICB9XG4gIHJldHVybiB0YXJnZXQ7XG59XG5cbiIsICJpbXBvcnQge2NsaXBBcmVhLCB1bmNsaXBBcmVhfSBmcm9tICcuLi8uLi9oZWxwZXJzL2luZGV4LmpzJztcbmltcG9ydCB7X2ZpbmRTZWdtZW50RW5kLCBfZ2V0Qm91bmRzLCBfc2VnbWVudHN9IGZyb20gJy4vZmlsbGVyLnNlZ21lbnQuanMnO1xuaW1wb3J0IHtfZ2V0VGFyZ2V0fSBmcm9tICcuL2ZpbGxlci50YXJnZXQuanMnO1xuXG5leHBvcnQgZnVuY3Rpb24gX2RyYXdmaWxsKGN0eCwgc291cmNlLCBhcmVhKSB7XG4gIGNvbnN0IHRhcmdldCA9IF9nZXRUYXJnZXQoc291cmNlKTtcbiAgY29uc3Qge2xpbmUsIHNjYWxlLCBheGlzfSA9IHNvdXJjZTtcbiAgY29uc3QgbGluZU9wdHMgPSBsaW5lLm9wdGlvbnM7XG4gIGNvbnN0IGZpbGxPcHRpb24gPSBsaW5lT3B0cy5maWxsO1xuICBjb25zdCBjb2xvciA9IGxpbmVPcHRzLmJhY2tncm91bmRDb2xvcjtcbiAgY29uc3Qge2Fib3ZlID0gY29sb3IsIGJlbG93ID0gY29sb3J9ID0gZmlsbE9wdGlvbiB8fCB7fTtcbiAgaWYgKHRhcmdldCAmJiBsaW5lLnBvaW50cy5sZW5ndGgpIHtcbiAgICBjbGlwQXJlYShjdHgsIGFyZWEpO1xuICAgIGRvRmlsbChjdHgsIHtsaW5lLCB0YXJnZXQsIGFib3ZlLCBiZWxvdywgYXJlYSwgc2NhbGUsIGF4aXN9KTtcbiAgICB1bmNsaXBBcmVhKGN0eCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZG9GaWxsKGN0eCwgY2ZnKSB7XG4gIGNvbnN0IHtsaW5lLCB0YXJnZXQsIGFib3ZlLCBiZWxvdywgYXJlYSwgc2NhbGV9ID0gY2ZnO1xuICBjb25zdCBwcm9wZXJ0eSA9IGxpbmUuX2xvb3AgPyAnYW5nbGUnIDogY2ZnLmF4aXM7XG5cbiAgY3R4LnNhdmUoKTtcblxuICBpZiAocHJvcGVydHkgPT09ICd4JyAmJiBiZWxvdyAhPT0gYWJvdmUpIHtcbiAgICBjbGlwVmVydGljYWwoY3R4LCB0YXJnZXQsIGFyZWEudG9wKTtcbiAgICBmaWxsKGN0eCwge2xpbmUsIHRhcmdldCwgY29sb3I6IGFib3ZlLCBzY2FsZSwgcHJvcGVydHl9KTtcbiAgICBjdHgucmVzdG9yZSgpO1xuICAgIGN0eC5zYXZlKCk7XG4gICAgY2xpcFZlcnRpY2FsKGN0eCwgdGFyZ2V0LCBhcmVhLmJvdHRvbSk7XG4gIH1cbiAgZmlsbChjdHgsIHtsaW5lLCB0YXJnZXQsIGNvbG9yOiBiZWxvdywgc2NhbGUsIHByb3BlcnR5fSk7XG5cbiAgY3R4LnJlc3RvcmUoKTtcbn1cblxuZnVuY3Rpb24gY2xpcFZlcnRpY2FsKGN0eCwgdGFyZ2V0LCBjbGlwWSkge1xuICBjb25zdCB7c2VnbWVudHMsIHBvaW50c30gPSB0YXJnZXQ7XG4gIGxldCBmaXJzdCA9IHRydWU7XG4gIGxldCBsaW5lTG9vcCA9IGZhbHNlO1xuXG4gIGN0eC5iZWdpblBhdGgoKTtcbiAgZm9yIChjb25zdCBzZWdtZW50IG9mIHNlZ21lbnRzKSB7XG4gICAgY29uc3Qge3N0YXJ0LCBlbmR9ID0gc2VnbWVudDtcbiAgICBjb25zdCBmaXJzdFBvaW50ID0gcG9pbnRzW3N0YXJ0XTtcbiAgICBjb25zdCBsYXN0UG9pbnQgPSBwb2ludHNbX2ZpbmRTZWdtZW50RW5kKHN0YXJ0LCBlbmQsIHBvaW50cyldO1xuICAgIGlmIChmaXJzdCkge1xuICAgICAgY3R4Lm1vdmVUbyhmaXJzdFBvaW50LngsIGZpcnN0UG9pbnQueSk7XG4gICAgICBmaXJzdCA9IGZhbHNlO1xuICAgIH0gZWxzZSB7XG4gICAgICBjdHgubGluZVRvKGZpcnN0UG9pbnQueCwgY2xpcFkpO1xuICAgICAgY3R4LmxpbmVUbyhmaXJzdFBvaW50LngsIGZpcnN0UG9pbnQueSk7XG4gICAgfVxuICAgIGxpbmVMb29wID0gISF0YXJnZXQucGF0aFNlZ21lbnQoY3R4LCBzZWdtZW50LCB7bW92ZTogbGluZUxvb3B9KTtcbiAgICBpZiAobGluZUxvb3ApIHtcbiAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY3R4LmxpbmVUbyhsYXN0UG9pbnQueCwgY2xpcFkpO1xuICAgIH1cbiAgfVxuXG4gIGN0eC5saW5lVG8odGFyZ2V0LmZpcnN0KCkueCwgY2xpcFkpO1xuICBjdHguY2xvc2VQYXRoKCk7XG4gIGN0eC5jbGlwKCk7XG59XG5cbmZ1bmN0aW9uIGZpbGwoY3R4LCBjZmcpIHtcbiAgY29uc3Qge2xpbmUsIHRhcmdldCwgcHJvcGVydHksIGNvbG9yLCBzY2FsZX0gPSBjZmc7XG4gIGNvbnN0IHNlZ21lbnRzID0gX3NlZ21lbnRzKGxpbmUsIHRhcmdldCwgcHJvcGVydHkpO1xuXG4gIGZvciAoY29uc3Qge3NvdXJjZTogc3JjLCB0YXJnZXQ6IHRndCwgc3RhcnQsIGVuZH0gb2Ygc2VnbWVudHMpIHtcbiAgICBjb25zdCB7c3R5bGU6IHtiYWNrZ3JvdW5kQ29sb3IgPSBjb2xvcn0gPSB7fX0gPSBzcmM7XG4gICAgY29uc3Qgbm90U2hhcGUgPSB0YXJnZXQgIT09IHRydWU7XG5cbiAgICBjdHguc2F2ZSgpO1xuICAgIGN0eC5maWxsU3R5bGUgPSBiYWNrZ3JvdW5kQ29sb3I7XG5cbiAgICBjbGlwQm91bmRzKGN0eCwgc2NhbGUsIG5vdFNoYXBlICYmIF9nZXRCb3VuZHMocHJvcGVydHksIHN0YXJ0LCBlbmQpKTtcblxuICAgIGN0eC5iZWdpblBhdGgoKTtcblxuICAgIGNvbnN0IGxpbmVMb29wID0gISFsaW5lLnBhdGhTZWdtZW50KGN0eCwgc3JjKTtcblxuICAgIGxldCBsb29wO1xuICAgIGlmIChub3RTaGFwZSkge1xuICAgICAgaWYgKGxpbmVMb29wKSB7XG4gICAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGludGVycG9sYXRlZExpbmVUbyhjdHgsIHRhcmdldCwgZW5kLCBwcm9wZXJ0eSk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHRhcmdldExvb3AgPSAhIXRhcmdldC5wYXRoU2VnbWVudChjdHgsIHRndCwge21vdmU6IGxpbmVMb29wLCByZXZlcnNlOiB0cnVlfSk7XG4gICAgICBsb29wID0gbGluZUxvb3AgJiYgdGFyZ2V0TG9vcDtcbiAgICAgIGlmICghbG9vcCkge1xuICAgICAgICBpbnRlcnBvbGF0ZWRMaW5lVG8oY3R4LCB0YXJnZXQsIHN0YXJ0LCBwcm9wZXJ0eSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgIGN0eC5maWxsKGxvb3AgPyAnZXZlbm9kZCcgOiAnbm9uemVybycpO1xuXG4gICAgY3R4LnJlc3RvcmUoKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjbGlwQm91bmRzKGN0eCwgc2NhbGUsIGJvdW5kcykge1xuICBjb25zdCB7dG9wLCBib3R0b219ID0gc2NhbGUuY2hhcnQuY2hhcnRBcmVhO1xuICBjb25zdCB7cHJvcGVydHksIHN0YXJ0LCBlbmR9ID0gYm91bmRzIHx8IHt9O1xuICBpZiAocHJvcGVydHkgPT09ICd4Jykge1xuICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICBjdHgucmVjdChzdGFydCwgdG9wLCBlbmQgLSBzdGFydCwgYm90dG9tIC0gdG9wKTtcbiAgICBjdHguY2xpcCgpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGludGVycG9sYXRlZExpbmVUbyhjdHgsIHRhcmdldCwgcG9pbnQsIHByb3BlcnR5KSB7XG4gIGNvbnN0IGludGVycG9sYXRlZFBvaW50ID0gdGFyZ2V0LmludGVycG9sYXRlKHBvaW50LCBwcm9wZXJ0eSk7XG4gIGlmIChpbnRlcnBvbGF0ZWRQb2ludCkge1xuICAgIGN0eC5saW5lVG8oaW50ZXJwb2xhdGVkUG9pbnQueCwgaW50ZXJwb2xhdGVkUG9pbnQueSk7XG4gIH1cbn1cblxuIiwgIi8qKlxuICogUGx1Z2luIGJhc2VkIG9uIGRpc2N1c3Npb24gZnJvbSB0aGUgZm9sbG93aW5nIENoYXJ0LmpzIGlzc3VlczpcbiAqIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2NoYXJ0anMvQ2hhcnQuanMvaXNzdWVzLzIzODAjaXNzdWVjb21tZW50LTI3OTk2MTU2OVxuICogQHNlZSBodHRwczovL2dpdGh1Yi5jb20vY2hhcnRqcy9DaGFydC5qcy9pc3N1ZXMvMjQ0MCNpc3N1ZWNvbW1lbnQtMjU2NDYxODk3XG4gKi9cblxuaW1wb3J0IExpbmVFbGVtZW50IGZyb20gJy4uLy4uL2VsZW1lbnRzL2VsZW1lbnQubGluZS5qcyc7XG5pbXBvcnQge19kcmF3ZmlsbH0gZnJvbSAnLi9maWxsZXIuZHJhd2luZy5qcyc7XG5pbXBvcnQge19zaG91bGRBcHBseUZpbGx9IGZyb20gJy4vZmlsbGVyLmhlbHBlci5qcyc7XG5pbXBvcnQge19kZWNvZGVGaWxsLCBfcmVzb2x2ZVRhcmdldH0gZnJvbSAnLi9maWxsZXIub3B0aW9ucy5qcyc7XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgaWQ6ICdmaWxsZXInLFxuXG4gIGFmdGVyRGF0YXNldHNVcGRhdGUoY2hhcnQsIF9hcmdzLCBvcHRpb25zKSB7XG4gICAgY29uc3QgY291bnQgPSAoY2hhcnQuZGF0YS5kYXRhc2V0cyB8fCBbXSkubGVuZ3RoO1xuICAgIGNvbnN0IHNvdXJjZXMgPSBbXTtcbiAgICBsZXQgbWV0YSwgaSwgbGluZSwgc291cmNlO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IGNvdW50OyArK2kpIHtcbiAgICAgIG1ldGEgPSBjaGFydC5nZXREYXRhc2V0TWV0YShpKTtcbiAgICAgIGxpbmUgPSBtZXRhLmRhdGFzZXQ7XG4gICAgICBzb3VyY2UgPSBudWxsO1xuXG4gICAgICBpZiAobGluZSAmJiBsaW5lLm9wdGlvbnMgJiYgbGluZSBpbnN0YW5jZW9mIExpbmVFbGVtZW50KSB7XG4gICAgICAgIHNvdXJjZSA9IHtcbiAgICAgICAgICB2aXNpYmxlOiBjaGFydC5pc0RhdGFzZXRWaXNpYmxlKGkpLFxuICAgICAgICAgIGluZGV4OiBpLFxuICAgICAgICAgIGZpbGw6IF9kZWNvZGVGaWxsKGxpbmUsIGksIGNvdW50KSxcbiAgICAgICAgICBjaGFydCxcbiAgICAgICAgICBheGlzOiBtZXRhLmNvbnRyb2xsZXIub3B0aW9ucy5pbmRleEF4aXMsXG4gICAgICAgICAgc2NhbGU6IG1ldGEudlNjYWxlLFxuICAgICAgICAgIGxpbmUsXG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIG1ldGEuJGZpbGxlciA9IHNvdXJjZTtcbiAgICAgIHNvdXJjZXMucHVzaChzb3VyY2UpO1xuICAgIH1cblxuICAgIGZvciAoaSA9IDA7IGkgPCBjb3VudDsgKytpKSB7XG4gICAgICBzb3VyY2UgPSBzb3VyY2VzW2ldO1xuICAgICAgaWYgKCFzb3VyY2UgfHwgc291cmNlLmZpbGwgPT09IGZhbHNlKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBzb3VyY2UuZmlsbCA9IF9yZXNvbHZlVGFyZ2V0KHNvdXJjZXMsIGksIG9wdGlvbnMucHJvcGFnYXRlKTtcbiAgICB9XG4gIH0sXG5cbiAgYmVmb3JlRHJhdyhjaGFydCwgX2FyZ3MsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBkcmF3ID0gb3B0aW9ucy5kcmF3VGltZSA9PT0gJ2JlZm9yZURyYXcnO1xuICAgIGNvbnN0IG1ldGFzZXRzID0gY2hhcnQuZ2V0U29ydGVkVmlzaWJsZURhdGFzZXRNZXRhcygpO1xuICAgIGNvbnN0IGFyZWEgPSBjaGFydC5jaGFydEFyZWE7XG4gICAgZm9yIChsZXQgaSA9IG1ldGFzZXRzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICBjb25zdCBzb3VyY2UgPSBtZXRhc2V0c1tpXS4kZmlsbGVyO1xuICAgICAgaWYgKCFzb3VyY2UpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIHNvdXJjZS5saW5lLnVwZGF0ZUNvbnRyb2xQb2ludHMoYXJlYSwgc291cmNlLmF4aXMpO1xuICAgICAgaWYgKGRyYXcgJiYgc291cmNlLmZpbGwpIHtcbiAgICAgICAgX2RyYXdmaWxsKGNoYXJ0LmN0eCwgc291cmNlLCBhcmVhKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgYmVmb3JlRGF0YXNldHNEcmF3KGNoYXJ0LCBfYXJncywgb3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zLmRyYXdUaW1lICE9PSAnYmVmb3JlRGF0YXNldHNEcmF3Jykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IG1ldGFzZXRzID0gY2hhcnQuZ2V0U29ydGVkVmlzaWJsZURhdGFzZXRNZXRhcygpO1xuICAgIGZvciAobGV0IGkgPSBtZXRhc2V0cy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgY29uc3Qgc291cmNlID0gbWV0YXNldHNbaV0uJGZpbGxlcjtcblxuICAgICAgaWYgKF9zaG91bGRBcHBseUZpbGwoc291cmNlKSkge1xuICAgICAgICBfZHJhd2ZpbGwoY2hhcnQuY3R4LCBzb3VyY2UsIGNoYXJ0LmNoYXJ0QXJlYSk7XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIGJlZm9yZURhdGFzZXREcmF3KGNoYXJ0LCBhcmdzLCBvcHRpb25zKSB7XG4gICAgY29uc3Qgc291cmNlID0gYXJncy5tZXRhLiRmaWxsZXI7XG5cbiAgICBpZiAoIV9zaG91bGRBcHBseUZpbGwoc291cmNlKSB8fCBvcHRpb25zLmRyYXdUaW1lICE9PSAnYmVmb3JlRGF0YXNldERyYXcnKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgX2RyYXdmaWxsKGNoYXJ0LmN0eCwgc291cmNlLCBjaGFydC5jaGFydEFyZWEpO1xuICB9LFxuXG4gIGRlZmF1bHRzOiB7XG4gICAgcHJvcGFnYXRlOiB0cnVlLFxuICAgIGRyYXdUaW1lOiAnYmVmb3JlRGF0YXNldERyYXcnXG4gIH1cbn07XG4iLCAiaW1wb3J0IGRlZmF1bHRzIGZyb20gJy4uL2NvcmUvY29yZS5kZWZhdWx0cy5qcyc7XG5pbXBvcnQgRWxlbWVudCBmcm9tICcuLi9jb3JlL2NvcmUuZWxlbWVudC5qcyc7XG5pbXBvcnQgbGF5b3V0cyBmcm9tICcuLi9jb3JlL2NvcmUubGF5b3V0cy5qcyc7XG5pbXBvcnQge2FkZFJvdW5kZWRSZWN0UGF0aCwgZHJhd1BvaW50TGVnZW5kLCByZW5kZXJUZXh0fSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMuY2FudmFzLmpzJztcbmltcG9ydCB7XG4gIF9pc0JldHdlZW4sXG4gIGNhbGxiYWNrIGFzIGNhbGwsXG4gIGNsaXBBcmVhLFxuICBnZXRSdGxBZGFwdGVyLFxuICBvdmVycmlkZVRleHREaXJlY3Rpb24sXG4gIHJlc3RvcmVUZXh0RGlyZWN0aW9uLFxuICB0b0ZvbnQsXG4gIHRvUGFkZGluZyxcbiAgdW5jbGlwQXJlYSxcbiAgdmFsdWVPckRlZmF1bHQsXG59IGZyb20gJy4uL2hlbHBlcnMvaW5kZXguanMnO1xuaW1wb3J0IHtfYWxpZ25TdGFydEVuZCwgX3RleHRYLCBfdG9MZWZ0UmlnaHRDZW50ZXJ9IGZyb20gJy4uL2hlbHBlcnMvaGVscGVycy5leHRyYXMuanMnO1xuaW1wb3J0IHt0b1RSQkxDb3JuZXJzfSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMub3B0aW9ucy5qcyc7XG5cbi8qKlxuICogQHR5cGVkZWYgeyBpbXBvcnQoJy4uL3R5cGVzL2luZGV4LmpzJykuQ2hhcnRFdmVudCB9IENoYXJ0RXZlbnRcbiAqL1xuXG5jb25zdCBnZXRCb3hTaXplID0gKGxhYmVsT3B0cywgZm9udFNpemUpID0+IHtcbiAgbGV0IHtib3hIZWlnaHQgPSBmb250U2l6ZSwgYm94V2lkdGggPSBmb250U2l6ZX0gPSBsYWJlbE9wdHM7XG5cbiAgaWYgKGxhYmVsT3B0cy51c2VQb2ludFN0eWxlKSB7XG4gICAgYm94SGVpZ2h0ID0gTWF0aC5taW4oYm94SGVpZ2h0LCBmb250U2l6ZSk7XG4gICAgYm94V2lkdGggPSBsYWJlbE9wdHMucG9pbnRTdHlsZVdpZHRoIHx8IE1hdGgubWluKGJveFdpZHRoLCBmb250U2l6ZSk7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGJveFdpZHRoLFxuICAgIGJveEhlaWdodCxcbiAgICBpdGVtSGVpZ2h0OiBNYXRoLm1heChmb250U2l6ZSwgYm94SGVpZ2h0KVxuICB9O1xufTtcblxuY29uc3QgaXRlbXNFcXVhbCA9IChhLCBiKSA9PiBhICE9PSBudWxsICYmIGIgIT09IG51bGwgJiYgYS5kYXRhc2V0SW5kZXggPT09IGIuZGF0YXNldEluZGV4ICYmIGEuaW5kZXggPT09IGIuaW5kZXg7XG5cbmV4cG9ydCBjbGFzcyBMZWdlbmQgZXh0ZW5kcyBFbGVtZW50IHtcblxuICAvKipcblx0ICogQHBhcmFtIHt7IGN0eDogYW55OyBvcHRpb25zOiBhbnk7IGNoYXJ0OiBhbnk7IH19IGNvbmZpZ1xuXHQgKi9cbiAgY29uc3RydWN0b3IoY29uZmlnKSB7XG4gICAgc3VwZXIoKTtcblxuICAgIHRoaXMuX2FkZGVkID0gZmFsc2U7XG5cbiAgICAvLyBDb250YWlucyBoaXQgYm94ZXMgZm9yIGVhY2ggZGF0YXNldCAoaW4gZGF0YXNldCBvcmRlcilcbiAgICB0aGlzLmxlZ2VuZEhpdEJveGVzID0gW107XG5cbiAgICAvKipcbiBcdFx0ICogQHByaXZhdGVcbiBcdFx0ICovXG4gICAgdGhpcy5faG92ZXJlZEl0ZW0gPSBudWxsO1xuXG4gICAgLy8gQXJlIHdlIGluIGRvdWdobnV0IG1vZGUgd2hpY2ggaGFzIGEgZGlmZmVyZW50IGRhdGEgdHlwZVxuICAgIHRoaXMuZG91Z2hudXRNb2RlID0gZmFsc2U7XG5cbiAgICB0aGlzLmNoYXJ0ID0gY29uZmlnLmNoYXJ0O1xuICAgIHRoaXMub3B0aW9ucyA9IGNvbmZpZy5vcHRpb25zO1xuICAgIHRoaXMuY3R4ID0gY29uZmlnLmN0eDtcbiAgICB0aGlzLmxlZ2VuZEl0ZW1zID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuY29sdW1uU2l6ZXMgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5saW5lV2lkdGhzID0gdW5kZWZpbmVkO1xuICAgIHRoaXMubWF4SGVpZ2h0ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMubWF4V2lkdGggPSB1bmRlZmluZWQ7XG4gICAgdGhpcy50b3AgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5ib3R0b20gPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5sZWZ0ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMucmlnaHQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5oZWlnaHQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy53aWR0aCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9tYXJnaW5zID0gdW5kZWZpbmVkO1xuICAgIHRoaXMucG9zaXRpb24gPSB1bmRlZmluZWQ7XG4gICAgdGhpcy53ZWlnaHQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5mdWxsU2l6ZSA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIHVwZGF0ZShtYXhXaWR0aCwgbWF4SGVpZ2h0LCBtYXJnaW5zKSB7XG4gICAgdGhpcy5tYXhXaWR0aCA9IG1heFdpZHRoO1xuICAgIHRoaXMubWF4SGVpZ2h0ID0gbWF4SGVpZ2h0O1xuICAgIHRoaXMuX21hcmdpbnMgPSBtYXJnaW5zO1xuXG4gICAgdGhpcy5zZXREaW1lbnNpb25zKCk7XG4gICAgdGhpcy5idWlsZExhYmVscygpO1xuICAgIHRoaXMuZml0KCk7XG4gIH1cblxuICBzZXREaW1lbnNpb25zKCkge1xuICAgIGlmICh0aGlzLmlzSG9yaXpvbnRhbCgpKSB7XG4gICAgICB0aGlzLndpZHRoID0gdGhpcy5tYXhXaWR0aDtcbiAgICAgIHRoaXMubGVmdCA9IHRoaXMuX21hcmdpbnMubGVmdDtcbiAgICAgIHRoaXMucmlnaHQgPSB0aGlzLndpZHRoO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmhlaWdodCA9IHRoaXMubWF4SGVpZ2h0O1xuICAgICAgdGhpcy50b3AgPSB0aGlzLl9tYXJnaW5zLnRvcDtcbiAgICAgIHRoaXMuYm90dG9tID0gdGhpcy5oZWlnaHQ7XG4gICAgfVxuICB9XG5cbiAgYnVpbGRMYWJlbHMoKSB7XG4gICAgY29uc3QgbGFiZWxPcHRzID0gdGhpcy5vcHRpb25zLmxhYmVscyB8fCB7fTtcbiAgICBsZXQgbGVnZW5kSXRlbXMgPSBjYWxsKGxhYmVsT3B0cy5nZW5lcmF0ZUxhYmVscywgW3RoaXMuY2hhcnRdLCB0aGlzKSB8fCBbXTtcblxuICAgIGlmIChsYWJlbE9wdHMuZmlsdGVyKSB7XG4gICAgICBsZWdlbmRJdGVtcyA9IGxlZ2VuZEl0ZW1zLmZpbHRlcigoaXRlbSkgPT4gbGFiZWxPcHRzLmZpbHRlcihpdGVtLCB0aGlzLmNoYXJ0LmRhdGEpKTtcbiAgICB9XG5cbiAgICBpZiAobGFiZWxPcHRzLnNvcnQpIHtcbiAgICAgIGxlZ2VuZEl0ZW1zID0gbGVnZW5kSXRlbXMuc29ydCgoYSwgYikgPT4gbGFiZWxPcHRzLnNvcnQoYSwgYiwgdGhpcy5jaGFydC5kYXRhKSk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMub3B0aW9ucy5yZXZlcnNlKSB7XG4gICAgICBsZWdlbmRJdGVtcy5yZXZlcnNlKCk7XG4gICAgfVxuXG4gICAgdGhpcy5sZWdlbmRJdGVtcyA9IGxlZ2VuZEl0ZW1zO1xuICB9XG5cbiAgZml0KCkge1xuICAgIGNvbnN0IHtvcHRpb25zLCBjdHh9ID0gdGhpcztcblxuICAgIC8vIFRoZSBsZWdlbmQgbWF5IG5vdCBiZSBkaXNwbGF5ZWQgZm9yIGEgdmFyaWV0eSBvZiByZWFzb25zIGluY2x1ZGluZ1xuICAgIC8vIHRoZSBmYWN0IHRoYXQgdGhlIGRlZmF1bHRzIGdvdCBzZXQgdG8gYGZhbHNlYC5cbiAgICAvLyBXaGVuIHRoZSBsZWdlbmQgaXMgbm90IGRpc3BsYXllZCwgdGhlcmUgYXJlIG5vIGd1YXJhbnRlZXMgdGhhdCB0aGUgb3B0aW9uc1xuICAgIC8vIGFyZSBjb3JyZWN0bHkgZm9ybWF0dGVkIHNvIHdlIG5lZWQgdG8gYmFpbCBvdXQgYXMgZWFybHkgYXMgcG9zc2libGUuXG4gICAgaWYgKCFvcHRpb25zLmRpc3BsYXkpIHtcbiAgICAgIHRoaXMud2lkdGggPSB0aGlzLmhlaWdodCA9IDA7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgbGFiZWxPcHRzID0gb3B0aW9ucy5sYWJlbHM7XG4gICAgY29uc3QgbGFiZWxGb250ID0gdG9Gb250KGxhYmVsT3B0cy5mb250KTtcbiAgICBjb25zdCBmb250U2l6ZSA9IGxhYmVsRm9udC5zaXplO1xuICAgIGNvbnN0IHRpdGxlSGVpZ2h0ID0gdGhpcy5fY29tcHV0ZVRpdGxlSGVpZ2h0KCk7XG4gICAgY29uc3Qge2JveFdpZHRoLCBpdGVtSGVpZ2h0fSA9IGdldEJveFNpemUobGFiZWxPcHRzLCBmb250U2l6ZSk7XG5cbiAgICBsZXQgd2lkdGgsIGhlaWdodDtcblxuICAgIGN0eC5mb250ID0gbGFiZWxGb250LnN0cmluZztcblxuICAgIGlmICh0aGlzLmlzSG9yaXpvbnRhbCgpKSB7XG4gICAgICB3aWR0aCA9IHRoaXMubWF4V2lkdGg7IC8vIGZpbGwgYWxsIHRoZSB3aWR0aFxuICAgICAgaGVpZ2h0ID0gdGhpcy5fZml0Um93cyh0aXRsZUhlaWdodCwgZm9udFNpemUsIGJveFdpZHRoLCBpdGVtSGVpZ2h0KSArIDEwO1xuICAgIH0gZWxzZSB7XG4gICAgICBoZWlnaHQgPSB0aGlzLm1heEhlaWdodDsgLy8gZmlsbCBhbGwgdGhlIGhlaWdodFxuICAgICAgd2lkdGggPSB0aGlzLl9maXRDb2xzKHRpdGxlSGVpZ2h0LCBsYWJlbEZvbnQsIGJveFdpZHRoLCBpdGVtSGVpZ2h0KSArIDEwO1xuICAgIH1cblxuICAgIHRoaXMud2lkdGggPSBNYXRoLm1pbih3aWR0aCwgb3B0aW9ucy5tYXhXaWR0aCB8fCB0aGlzLm1heFdpZHRoKTtcbiAgICB0aGlzLmhlaWdodCA9IE1hdGgubWluKGhlaWdodCwgb3B0aW9ucy5tYXhIZWlnaHQgfHwgdGhpcy5tYXhIZWlnaHQpO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfZml0Um93cyh0aXRsZUhlaWdodCwgZm9udFNpemUsIGJveFdpZHRoLCBpdGVtSGVpZ2h0KSB7XG4gICAgY29uc3Qge2N0eCwgbWF4V2lkdGgsIG9wdGlvbnM6IHtsYWJlbHM6IHtwYWRkaW5nfX19ID0gdGhpcztcbiAgICBjb25zdCBoaXRib3hlcyA9IHRoaXMubGVnZW5kSGl0Qm94ZXMgPSBbXTtcbiAgICAvLyBXaWR0aCBvZiBlYWNoIGxpbmUgb2YgbGVnZW5kIGJveGVzLiBMYWJlbHMgd3JhcCBvbnRvIG11bHRpcGxlIGxpbmVzIHdoZW4gdGhlcmUgYXJlIHRvbyBtYW55IHRvIGZpdCBvbiBvbmVcbiAgICBjb25zdCBsaW5lV2lkdGhzID0gdGhpcy5saW5lV2lkdGhzID0gWzBdO1xuICAgIGNvbnN0IGxpbmVIZWlnaHQgPSBpdGVtSGVpZ2h0ICsgcGFkZGluZztcbiAgICBsZXQgdG90YWxIZWlnaHQgPSB0aXRsZUhlaWdodDtcblxuICAgIGN0eC50ZXh0QWxpZ24gPSAnbGVmdCc7XG4gICAgY3R4LnRleHRCYXNlbGluZSA9ICdtaWRkbGUnO1xuXG4gICAgbGV0IHJvdyA9IC0xO1xuICAgIGxldCB0b3AgPSAtbGluZUhlaWdodDtcbiAgICB0aGlzLmxlZ2VuZEl0ZW1zLmZvckVhY2goKGxlZ2VuZEl0ZW0sIGkpID0+IHtcbiAgICAgIGNvbnN0IGl0ZW1XaWR0aCA9IGJveFdpZHRoICsgKGZvbnRTaXplIC8gMikgKyBjdHgubWVhc3VyZVRleHQobGVnZW5kSXRlbS50ZXh0KS53aWR0aDtcblxuICAgICAgaWYgKGkgPT09IDAgfHwgbGluZVdpZHRoc1tsaW5lV2lkdGhzLmxlbmd0aCAtIDFdICsgaXRlbVdpZHRoICsgMiAqIHBhZGRpbmcgPiBtYXhXaWR0aCkge1xuICAgICAgICB0b3RhbEhlaWdodCArPSBsaW5lSGVpZ2h0O1xuICAgICAgICBsaW5lV2lkdGhzW2xpbmVXaWR0aHMubGVuZ3RoIC0gKGkgPiAwID8gMCA6IDEpXSA9IDA7XG4gICAgICAgIHRvcCArPSBsaW5lSGVpZ2h0O1xuICAgICAgICByb3crKztcbiAgICAgIH1cblxuICAgICAgaGl0Ym94ZXNbaV0gPSB7bGVmdDogMCwgdG9wLCByb3csIHdpZHRoOiBpdGVtV2lkdGgsIGhlaWdodDogaXRlbUhlaWdodH07XG5cbiAgICAgIGxpbmVXaWR0aHNbbGluZVdpZHRocy5sZW5ndGggLSAxXSArPSBpdGVtV2lkdGggKyBwYWRkaW5nO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHRvdGFsSGVpZ2h0O1xuICB9XG5cbiAgX2ZpdENvbHModGl0bGVIZWlnaHQsIGxhYmVsRm9udCwgYm94V2lkdGgsIF9pdGVtSGVpZ2h0KSB7XG4gICAgY29uc3Qge2N0eCwgbWF4SGVpZ2h0LCBvcHRpb25zOiB7bGFiZWxzOiB7cGFkZGluZ319fSA9IHRoaXM7XG4gICAgY29uc3QgaGl0Ym94ZXMgPSB0aGlzLmxlZ2VuZEhpdEJveGVzID0gW107XG4gICAgY29uc3QgY29sdW1uU2l6ZXMgPSB0aGlzLmNvbHVtblNpemVzID0gW107XG4gICAgY29uc3QgaGVpZ2h0TGltaXQgPSBtYXhIZWlnaHQgLSB0aXRsZUhlaWdodDtcblxuICAgIGxldCB0b3RhbFdpZHRoID0gcGFkZGluZztcbiAgICBsZXQgY3VycmVudENvbFdpZHRoID0gMDtcbiAgICBsZXQgY3VycmVudENvbEhlaWdodCA9IDA7XG5cbiAgICBsZXQgbGVmdCA9IDA7XG4gICAgbGV0IGNvbCA9IDA7XG5cbiAgICB0aGlzLmxlZ2VuZEl0ZW1zLmZvckVhY2goKGxlZ2VuZEl0ZW0sIGkpID0+IHtcbiAgICAgIGNvbnN0IHtpdGVtV2lkdGgsIGl0ZW1IZWlnaHR9ID0gY2FsY3VsYXRlSXRlbVNpemUoYm94V2lkdGgsIGxhYmVsRm9udCwgY3R4LCBsZWdlbmRJdGVtLCBfaXRlbUhlaWdodCk7XG5cbiAgICAgIC8vIElmIHRvbyB0YWxsLCBnbyB0byBuZXcgY29sdW1uXG4gICAgICBpZiAoaSA+IDAgJiYgY3VycmVudENvbEhlaWdodCArIGl0ZW1IZWlnaHQgKyAyICogcGFkZGluZyA+IGhlaWdodExpbWl0KSB7XG4gICAgICAgIHRvdGFsV2lkdGggKz0gY3VycmVudENvbFdpZHRoICsgcGFkZGluZztcbiAgICAgICAgY29sdW1uU2l6ZXMucHVzaCh7d2lkdGg6IGN1cnJlbnRDb2xXaWR0aCwgaGVpZ2h0OiBjdXJyZW50Q29sSGVpZ2h0fSk7IC8vIHByZXZpb3VzIGNvbHVtbiBzaXplXG4gICAgICAgIGxlZnQgKz0gY3VycmVudENvbFdpZHRoICsgcGFkZGluZztcbiAgICAgICAgY29sKys7XG4gICAgICAgIGN1cnJlbnRDb2xXaWR0aCA9IGN1cnJlbnRDb2xIZWlnaHQgPSAwO1xuICAgICAgfVxuXG4gICAgICAvLyBTdG9yZSB0aGUgaGl0Ym94IHdpZHRoIGFuZCBoZWlnaHQgaGVyZS4gRmluYWwgcG9zaXRpb24gd2lsbCBiZSB1cGRhdGVkIGluIGBkcmF3YFxuICAgICAgaGl0Ym94ZXNbaV0gPSB7bGVmdCwgdG9wOiBjdXJyZW50Q29sSGVpZ2h0LCBjb2wsIHdpZHRoOiBpdGVtV2lkdGgsIGhlaWdodDogaXRlbUhlaWdodH07XG5cbiAgICAgIC8vIEdldCBtYXggd2lkdGhcbiAgICAgIGN1cnJlbnRDb2xXaWR0aCA9IE1hdGgubWF4KGN1cnJlbnRDb2xXaWR0aCwgaXRlbVdpZHRoKTtcbiAgICAgIGN1cnJlbnRDb2xIZWlnaHQgKz0gaXRlbUhlaWdodCArIHBhZGRpbmc7XG4gICAgfSk7XG5cbiAgICB0b3RhbFdpZHRoICs9IGN1cnJlbnRDb2xXaWR0aDtcbiAgICBjb2x1bW5TaXplcy5wdXNoKHt3aWR0aDogY3VycmVudENvbFdpZHRoLCBoZWlnaHQ6IGN1cnJlbnRDb2xIZWlnaHR9KTsgLy8gcHJldmlvdXMgY29sdW1uIHNpemVcblxuICAgIHJldHVybiB0b3RhbFdpZHRoO1xuICB9XG5cbiAgYWRqdXN0SGl0Qm94ZXMoKSB7XG4gICAgaWYgKCF0aGlzLm9wdGlvbnMuZGlzcGxheSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB0aXRsZUhlaWdodCA9IHRoaXMuX2NvbXB1dGVUaXRsZUhlaWdodCgpO1xuICAgIGNvbnN0IHtsZWdlbmRIaXRCb3hlczogaGl0Ym94ZXMsIG9wdGlvbnM6IHthbGlnbiwgbGFiZWxzOiB7cGFkZGluZ30sIHJ0bH19ID0gdGhpcztcbiAgICBjb25zdCBydGxIZWxwZXIgPSBnZXRSdGxBZGFwdGVyKHJ0bCwgdGhpcy5sZWZ0LCB0aGlzLndpZHRoKTtcbiAgICBpZiAodGhpcy5pc0hvcml6b250YWwoKSkge1xuICAgICAgbGV0IHJvdyA9IDA7XG4gICAgICBsZXQgbGVmdCA9IF9hbGlnblN0YXJ0RW5kKGFsaWduLCB0aGlzLmxlZnQgKyBwYWRkaW5nLCB0aGlzLnJpZ2h0IC0gdGhpcy5saW5lV2lkdGhzW3Jvd10pO1xuICAgICAgZm9yIChjb25zdCBoaXRib3ggb2YgaGl0Ym94ZXMpIHtcbiAgICAgICAgaWYgKHJvdyAhPT0gaGl0Ym94LnJvdykge1xuICAgICAgICAgIHJvdyA9IGhpdGJveC5yb3c7XG4gICAgICAgICAgbGVmdCA9IF9hbGlnblN0YXJ0RW5kKGFsaWduLCB0aGlzLmxlZnQgKyBwYWRkaW5nLCB0aGlzLnJpZ2h0IC0gdGhpcy5saW5lV2lkdGhzW3Jvd10pO1xuICAgICAgICB9XG4gICAgICAgIGhpdGJveC50b3AgKz0gdGhpcy50b3AgKyB0aXRsZUhlaWdodCArIHBhZGRpbmc7XG4gICAgICAgIGhpdGJveC5sZWZ0ID0gcnRsSGVscGVyLmxlZnRGb3JMdHIocnRsSGVscGVyLngobGVmdCksIGhpdGJveC53aWR0aCk7XG4gICAgICAgIGxlZnQgKz0gaGl0Ym94LndpZHRoICsgcGFkZGluZztcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgbGV0IGNvbCA9IDA7XG4gICAgICBsZXQgdG9wID0gX2FsaWduU3RhcnRFbmQoYWxpZ24sIHRoaXMudG9wICsgdGl0bGVIZWlnaHQgKyBwYWRkaW5nLCB0aGlzLmJvdHRvbSAtIHRoaXMuY29sdW1uU2l6ZXNbY29sXS5oZWlnaHQpO1xuICAgICAgZm9yIChjb25zdCBoaXRib3ggb2YgaGl0Ym94ZXMpIHtcbiAgICAgICAgaWYgKGhpdGJveC5jb2wgIT09IGNvbCkge1xuICAgICAgICAgIGNvbCA9IGhpdGJveC5jb2w7XG4gICAgICAgICAgdG9wID0gX2FsaWduU3RhcnRFbmQoYWxpZ24sIHRoaXMudG9wICsgdGl0bGVIZWlnaHQgKyBwYWRkaW5nLCB0aGlzLmJvdHRvbSAtIHRoaXMuY29sdW1uU2l6ZXNbY29sXS5oZWlnaHQpO1xuICAgICAgICB9XG4gICAgICAgIGhpdGJveC50b3AgPSB0b3A7XG4gICAgICAgIGhpdGJveC5sZWZ0ICs9IHRoaXMubGVmdCArIHBhZGRpbmc7XG4gICAgICAgIGhpdGJveC5sZWZ0ID0gcnRsSGVscGVyLmxlZnRGb3JMdHIocnRsSGVscGVyLngoaGl0Ym94LmxlZnQpLCBoaXRib3gud2lkdGgpO1xuICAgICAgICB0b3AgKz0gaGl0Ym94LmhlaWdodCArIHBhZGRpbmc7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaXNIb3Jpem9udGFsKCkge1xuICAgIHJldHVybiB0aGlzLm9wdGlvbnMucG9zaXRpb24gPT09ICd0b3AnIHx8IHRoaXMub3B0aW9ucy5wb3NpdGlvbiA9PT0gJ2JvdHRvbSc7XG4gIH1cblxuICBkcmF3KCkge1xuICAgIGlmICh0aGlzLm9wdGlvbnMuZGlzcGxheSkge1xuICAgICAgY29uc3QgY3R4ID0gdGhpcy5jdHg7XG4gICAgICBjbGlwQXJlYShjdHgsIHRoaXMpO1xuXG4gICAgICB0aGlzLl9kcmF3KCk7XG5cbiAgICAgIHVuY2xpcEFyZWEoY3R4KTtcbiAgICB9XG4gIH1cblxuICAvKipcblx0ICogQHByaXZhdGVcblx0ICovXG4gIF9kcmF3KCkge1xuICAgIGNvbnN0IHtvcHRpb25zOiBvcHRzLCBjb2x1bW5TaXplcywgbGluZVdpZHRocywgY3R4fSA9IHRoaXM7XG4gICAgY29uc3Qge2FsaWduLCBsYWJlbHM6IGxhYmVsT3B0c30gPSBvcHRzO1xuICAgIGNvbnN0IGRlZmF1bHRDb2xvciA9IGRlZmF1bHRzLmNvbG9yO1xuICAgIGNvbnN0IHJ0bEhlbHBlciA9IGdldFJ0bEFkYXB0ZXIob3B0cy5ydGwsIHRoaXMubGVmdCwgdGhpcy53aWR0aCk7XG4gICAgY29uc3QgbGFiZWxGb250ID0gdG9Gb250KGxhYmVsT3B0cy5mb250KTtcbiAgICBjb25zdCB7cGFkZGluZ30gPSBsYWJlbE9wdHM7XG4gICAgY29uc3QgZm9udFNpemUgPSBsYWJlbEZvbnQuc2l6ZTtcbiAgICBjb25zdCBoYWxmRm9udFNpemUgPSBmb250U2l6ZSAvIDI7XG4gICAgbGV0IGN1cnNvcjtcblxuICAgIHRoaXMuZHJhd1RpdGxlKCk7XG5cbiAgICAvLyBDYW52YXMgc2V0dXBcbiAgICBjdHgudGV4dEFsaWduID0gcnRsSGVscGVyLnRleHRBbGlnbignbGVmdCcpO1xuICAgIGN0eC50ZXh0QmFzZWxpbmUgPSAnbWlkZGxlJztcbiAgICBjdHgubGluZVdpZHRoID0gMC41O1xuICAgIGN0eC5mb250ID0gbGFiZWxGb250LnN0cmluZztcblxuICAgIGNvbnN0IHtib3hXaWR0aCwgYm94SGVpZ2h0LCBpdGVtSGVpZ2h0fSA9IGdldEJveFNpemUobGFiZWxPcHRzLCBmb250U2l6ZSk7XG5cbiAgICAvLyBjdXJyZW50IHBvc2l0aW9uXG4gICAgY29uc3QgZHJhd0xlZ2VuZEJveCA9IGZ1bmN0aW9uKHgsIHksIGxlZ2VuZEl0ZW0pIHtcbiAgICAgIGlmIChpc05hTihib3hXaWR0aCkgfHwgYm94V2lkdGggPD0gMCB8fCBpc05hTihib3hIZWlnaHQpIHx8IGJveEhlaWdodCA8IDApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBTZXQgdGhlIGN0eCBmb3IgdGhlIGJveFxuICAgICAgY3R4LnNhdmUoKTtcblxuICAgICAgY29uc3QgbGluZVdpZHRoID0gdmFsdWVPckRlZmF1bHQobGVnZW5kSXRlbS5saW5lV2lkdGgsIDEpO1xuICAgICAgY3R4LmZpbGxTdHlsZSA9IHZhbHVlT3JEZWZhdWx0KGxlZ2VuZEl0ZW0uZmlsbFN0eWxlLCBkZWZhdWx0Q29sb3IpO1xuICAgICAgY3R4LmxpbmVDYXAgPSB2YWx1ZU9yRGVmYXVsdChsZWdlbmRJdGVtLmxpbmVDYXAsICdidXR0Jyk7XG4gICAgICBjdHgubGluZURhc2hPZmZzZXQgPSB2YWx1ZU9yRGVmYXVsdChsZWdlbmRJdGVtLmxpbmVEYXNoT2Zmc2V0LCAwKTtcbiAgICAgIGN0eC5saW5lSm9pbiA9IHZhbHVlT3JEZWZhdWx0KGxlZ2VuZEl0ZW0ubGluZUpvaW4sICdtaXRlcicpO1xuICAgICAgY3R4LmxpbmVXaWR0aCA9IGxpbmVXaWR0aDtcbiAgICAgIGN0eC5zdHJva2VTdHlsZSA9IHZhbHVlT3JEZWZhdWx0KGxlZ2VuZEl0ZW0uc3Ryb2tlU3R5bGUsIGRlZmF1bHRDb2xvcik7XG5cbiAgICAgIGN0eC5zZXRMaW5lRGFzaCh2YWx1ZU9yRGVmYXVsdChsZWdlbmRJdGVtLmxpbmVEYXNoLCBbXSkpO1xuXG4gICAgICBpZiAobGFiZWxPcHRzLnVzZVBvaW50U3R5bGUpIHtcbiAgICAgICAgLy8gUmVjYWxjdWxhdGUgeCBhbmQgeSBmb3IgZHJhd1BvaW50KCkgYmVjYXVzZSBpdHMgZXhwZWN0aW5nXG4gICAgICAgIC8vIHggYW5kIHkgdG8gYmUgY2VudGVyIG9mIGZpZ3VyZSAoaW5zdGVhZCBvZiB0b3AgbGVmdClcbiAgICAgICAgY29uc3QgZHJhd09wdGlvbnMgPSB7XG4gICAgICAgICAgcmFkaXVzOiBib3hIZWlnaHQgKiBNYXRoLlNRUlQyIC8gMixcbiAgICAgICAgICBwb2ludFN0eWxlOiBsZWdlbmRJdGVtLnBvaW50U3R5bGUsXG4gICAgICAgICAgcm90YXRpb246IGxlZ2VuZEl0ZW0ucm90YXRpb24sXG4gICAgICAgICAgYm9yZGVyV2lkdGg6IGxpbmVXaWR0aFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBjZW50ZXJYID0gcnRsSGVscGVyLnhQbHVzKHgsIGJveFdpZHRoIC8gMik7XG4gICAgICAgIGNvbnN0IGNlbnRlclkgPSB5ICsgaGFsZkZvbnRTaXplO1xuXG4gICAgICAgIC8vIERyYXcgcG9pbnRTdHlsZSBhcyBsZWdlbmQgc3ltYm9sXG4gICAgICAgIGRyYXdQb2ludExlZ2VuZChjdHgsIGRyYXdPcHRpb25zLCBjZW50ZXJYLCBjZW50ZXJZLCBsYWJlbE9wdHMucG9pbnRTdHlsZVdpZHRoICYmIGJveFdpZHRoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIERyYXcgYm94IGFzIGxlZ2VuZCBzeW1ib2xcbiAgICAgICAgLy8gQWRqdXN0IHBvc2l0aW9uIHdoZW4gYm94SGVpZ2h0IDwgZm9udFNpemUgKHdhbnQgaXQgY2VudGVyZWQpXG4gICAgICAgIGNvbnN0IHlCb3hUb3AgPSB5ICsgTWF0aC5tYXgoKGZvbnRTaXplIC0gYm94SGVpZ2h0KSAvIDIsIDApO1xuICAgICAgICBjb25zdCB4Qm94TGVmdCA9IHJ0bEhlbHBlci5sZWZ0Rm9yTHRyKHgsIGJveFdpZHRoKTtcbiAgICAgICAgY29uc3QgYm9yZGVyUmFkaXVzID0gdG9UUkJMQ29ybmVycyhsZWdlbmRJdGVtLmJvcmRlclJhZGl1cyk7XG5cbiAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuXG4gICAgICAgIGlmIChPYmplY3QudmFsdWVzKGJvcmRlclJhZGl1cykuc29tZSh2ID0+IHYgIT09IDApKSB7XG4gICAgICAgICAgYWRkUm91bmRlZFJlY3RQYXRoKGN0eCwge1xuICAgICAgICAgICAgeDogeEJveExlZnQsXG4gICAgICAgICAgICB5OiB5Qm94VG9wLFxuICAgICAgICAgICAgdzogYm94V2lkdGgsXG4gICAgICAgICAgICBoOiBib3hIZWlnaHQsXG4gICAgICAgICAgICByYWRpdXM6IGJvcmRlclJhZGl1cyxcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjdHgucmVjdCh4Qm94TGVmdCwgeUJveFRvcCwgYm94V2lkdGgsIGJveEhlaWdodCk7XG4gICAgICAgIH1cblxuICAgICAgICBjdHguZmlsbCgpO1xuICAgICAgICBpZiAobGluZVdpZHRoICE9PSAwKSB7XG4gICAgICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgfTtcblxuICAgIGNvbnN0IGZpbGxUZXh0ID0gZnVuY3Rpb24oeCwgeSwgbGVnZW5kSXRlbSkge1xuICAgICAgcmVuZGVyVGV4dChjdHgsIGxlZ2VuZEl0ZW0udGV4dCwgeCwgeSArIChpdGVtSGVpZ2h0IC8gMiksIGxhYmVsRm9udCwge1xuICAgICAgICBzdHJpa2V0aHJvdWdoOiBsZWdlbmRJdGVtLmhpZGRlbixcbiAgICAgICAgdGV4dEFsaWduOiBydGxIZWxwZXIudGV4dEFsaWduKGxlZ2VuZEl0ZW0udGV4dEFsaWduKVxuICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8vIEhvcml6b250YWxcbiAgICBjb25zdCBpc0hvcml6b250YWwgPSB0aGlzLmlzSG9yaXpvbnRhbCgpO1xuICAgIGNvbnN0IHRpdGxlSGVpZ2h0ID0gdGhpcy5fY29tcHV0ZVRpdGxlSGVpZ2h0KCk7XG4gICAgaWYgKGlzSG9yaXpvbnRhbCkge1xuICAgICAgY3Vyc29yID0ge1xuICAgICAgICB4OiBfYWxpZ25TdGFydEVuZChhbGlnbiwgdGhpcy5sZWZ0ICsgcGFkZGluZywgdGhpcy5yaWdodCAtIGxpbmVXaWR0aHNbMF0pLFxuICAgICAgICB5OiB0aGlzLnRvcCArIHBhZGRpbmcgKyB0aXRsZUhlaWdodCxcbiAgICAgICAgbGluZTogMFxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgY3Vyc29yID0ge1xuICAgICAgICB4OiB0aGlzLmxlZnQgKyBwYWRkaW5nLFxuICAgICAgICB5OiBfYWxpZ25TdGFydEVuZChhbGlnbiwgdGhpcy50b3AgKyB0aXRsZUhlaWdodCArIHBhZGRpbmcsIHRoaXMuYm90dG9tIC0gY29sdW1uU2l6ZXNbMF0uaGVpZ2h0KSxcbiAgICAgICAgbGluZTogMFxuICAgICAgfTtcbiAgICB9XG5cbiAgICBvdmVycmlkZVRleHREaXJlY3Rpb24odGhpcy5jdHgsIG9wdHMudGV4dERpcmVjdGlvbik7XG5cbiAgICBjb25zdCBsaW5lSGVpZ2h0ID0gaXRlbUhlaWdodCArIHBhZGRpbmc7XG4gICAgdGhpcy5sZWdlbmRJdGVtcy5mb3JFYWNoKChsZWdlbmRJdGVtLCBpKSA9PiB7XG4gICAgICBjdHguc3Ryb2tlU3R5bGUgPSBsZWdlbmRJdGVtLmZvbnRDb2xvcjsgLy8gZm9yIHN0cmlrZXRocm91Z2ggZWZmZWN0XG4gICAgICBjdHguZmlsbFN0eWxlID0gbGVnZW5kSXRlbS5mb250Q29sb3I7IC8vIHJlbmRlciBpbiBjb3JyZWN0IGNvbG91clxuXG4gICAgICBjb25zdCB0ZXh0V2lkdGggPSBjdHgubWVhc3VyZVRleHQobGVnZW5kSXRlbS50ZXh0KS53aWR0aDtcbiAgICAgIGNvbnN0IHRleHRBbGlnbiA9IHJ0bEhlbHBlci50ZXh0QWxpZ24obGVnZW5kSXRlbS50ZXh0QWxpZ24gfHwgKGxlZ2VuZEl0ZW0udGV4dEFsaWduID0gbGFiZWxPcHRzLnRleHRBbGlnbikpO1xuICAgICAgY29uc3Qgd2lkdGggPSBib3hXaWR0aCArIGhhbGZGb250U2l6ZSArIHRleHRXaWR0aDtcbiAgICAgIGxldCB4ID0gY3Vyc29yLng7XG4gICAgICBsZXQgeSA9IGN1cnNvci55O1xuXG4gICAgICBydGxIZWxwZXIuc2V0V2lkdGgodGhpcy53aWR0aCk7XG5cbiAgICAgIGlmIChpc0hvcml6b250YWwpIHtcbiAgICAgICAgaWYgKGkgPiAwICYmIHggKyB3aWR0aCArIHBhZGRpbmcgPiB0aGlzLnJpZ2h0KSB7XG4gICAgICAgICAgeSA9IGN1cnNvci55ICs9IGxpbmVIZWlnaHQ7XG4gICAgICAgICAgY3Vyc29yLmxpbmUrKztcbiAgICAgICAgICB4ID0gY3Vyc29yLnggPSBfYWxpZ25TdGFydEVuZChhbGlnbiwgdGhpcy5sZWZ0ICsgcGFkZGluZywgdGhpcy5yaWdodCAtIGxpbmVXaWR0aHNbY3Vyc29yLmxpbmVdKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChpID4gMCAmJiB5ICsgbGluZUhlaWdodCA+IHRoaXMuYm90dG9tKSB7XG4gICAgICAgIHggPSBjdXJzb3IueCA9IHggKyBjb2x1bW5TaXplc1tjdXJzb3IubGluZV0ud2lkdGggKyBwYWRkaW5nO1xuICAgICAgICBjdXJzb3IubGluZSsrO1xuICAgICAgICB5ID0gY3Vyc29yLnkgPSBfYWxpZ25TdGFydEVuZChhbGlnbiwgdGhpcy50b3AgKyB0aXRsZUhlaWdodCArIHBhZGRpbmcsIHRoaXMuYm90dG9tIC0gY29sdW1uU2l6ZXNbY3Vyc29yLmxpbmVdLmhlaWdodCk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHJlYWxYID0gcnRsSGVscGVyLngoeCk7XG5cbiAgICAgIGRyYXdMZWdlbmRCb3gocmVhbFgsIHksIGxlZ2VuZEl0ZW0pO1xuXG4gICAgICB4ID0gX3RleHRYKHRleHRBbGlnbiwgeCArIGJveFdpZHRoICsgaGFsZkZvbnRTaXplLCBpc0hvcml6b250YWwgPyB4ICsgd2lkdGggOiB0aGlzLnJpZ2h0LCBvcHRzLnJ0bCk7XG5cbiAgICAgIC8vIEZpbGwgdGhlIGFjdHVhbCBsYWJlbFxuICAgICAgZmlsbFRleHQocnRsSGVscGVyLngoeCksIHksIGxlZ2VuZEl0ZW0pO1xuXG4gICAgICBpZiAoaXNIb3Jpem9udGFsKSB7XG4gICAgICAgIGN1cnNvci54ICs9IHdpZHRoICsgcGFkZGluZztcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGxlZ2VuZEl0ZW0udGV4dCAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgY29uc3QgZm9udExpbmVIZWlnaHQgPSBsYWJlbEZvbnQubGluZUhlaWdodDtcbiAgICAgICAgY3Vyc29yLnkgKz0gY2FsY3VsYXRlTGVnZW5kSXRlbUhlaWdodChsZWdlbmRJdGVtLCBmb250TGluZUhlaWdodCkgKyBwYWRkaW5nO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY3Vyc29yLnkgKz0gbGluZUhlaWdodDtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHJlc3RvcmVUZXh0RGlyZWN0aW9uKHRoaXMuY3R4LCBvcHRzLnRleHREaXJlY3Rpb24pO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG4gIGRyYXdUaXRsZSgpIHtcbiAgICBjb25zdCBvcHRzID0gdGhpcy5vcHRpb25zO1xuICAgIGNvbnN0IHRpdGxlT3B0cyA9IG9wdHMudGl0bGU7XG4gICAgY29uc3QgdGl0bGVGb250ID0gdG9Gb250KHRpdGxlT3B0cy5mb250KTtcbiAgICBjb25zdCB0aXRsZVBhZGRpbmcgPSB0b1BhZGRpbmcodGl0bGVPcHRzLnBhZGRpbmcpO1xuXG4gICAgaWYgKCF0aXRsZU9wdHMuZGlzcGxheSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IHJ0bEhlbHBlciA9IGdldFJ0bEFkYXB0ZXIob3B0cy5ydGwsIHRoaXMubGVmdCwgdGhpcy53aWR0aCk7XG4gICAgY29uc3QgY3R4ID0gdGhpcy5jdHg7XG4gICAgY29uc3QgcG9zaXRpb24gPSB0aXRsZU9wdHMucG9zaXRpb247XG4gICAgY29uc3QgaGFsZkZvbnRTaXplID0gdGl0bGVGb250LnNpemUgLyAyO1xuICAgIGNvbnN0IHRvcFBhZGRpbmdQbHVzSGFsZkZvbnRTaXplID0gdGl0bGVQYWRkaW5nLnRvcCArIGhhbGZGb250U2l6ZTtcbiAgICBsZXQgeTtcblxuICAgIC8vIFRoZXNlIGRlZmF1bHRzIGFyZSB1c2VkIHdoZW4gdGhlIGxlZ2VuZCBpcyB2ZXJ0aWNhbC5cbiAgICAvLyBXaGVuIGhvcml6b250YWwsIHRoZXkgYXJlIGNvbXB1dGVkIGJlbG93LlxuICAgIGxldCBsZWZ0ID0gdGhpcy5sZWZ0O1xuICAgIGxldCBtYXhXaWR0aCA9IHRoaXMud2lkdGg7XG5cbiAgICBpZiAodGhpcy5pc0hvcml6b250YWwoKSkge1xuICAgICAgLy8gTW92ZSBsZWZ0IC8gcmlnaHQgc28gdGhhdCB0aGUgdGl0bGUgaXMgYWJvdmUgdGhlIGxlZ2VuZCBsaW5lc1xuICAgICAgbWF4V2lkdGggPSBNYXRoLm1heCguLi50aGlzLmxpbmVXaWR0aHMpO1xuICAgICAgeSA9IHRoaXMudG9wICsgdG9wUGFkZGluZ1BsdXNIYWxmRm9udFNpemU7XG4gICAgICBsZWZ0ID0gX2FsaWduU3RhcnRFbmQob3B0cy5hbGlnbiwgbGVmdCwgdGhpcy5yaWdodCAtIG1heFdpZHRoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gTW92ZSBkb3duIHNvIHRoYXQgdGhlIHRpdGxlIGlzIGFib3ZlIHRoZSBsZWdlbmQgc3RhY2sgaW4gZXZlcnkgYWxpZ25tZW50XG4gICAgICBjb25zdCBtYXhIZWlnaHQgPSB0aGlzLmNvbHVtblNpemVzLnJlZHVjZSgoYWNjLCBzaXplKSA9PiBNYXRoLm1heChhY2MsIHNpemUuaGVpZ2h0KSwgMCk7XG4gICAgICB5ID0gdG9wUGFkZGluZ1BsdXNIYWxmRm9udFNpemUgKyBfYWxpZ25TdGFydEVuZChvcHRzLmFsaWduLCB0aGlzLnRvcCwgdGhpcy5ib3R0b20gLSBtYXhIZWlnaHQgLSBvcHRzLmxhYmVscy5wYWRkaW5nIC0gdGhpcy5fY29tcHV0ZVRpdGxlSGVpZ2h0KCkpO1xuICAgIH1cblxuICAgIC8vIE5vdyB0aGF0IHdlIGtub3cgdGhlIGxlZnQgZWRnZSBvZiB0aGUgaW5uZXIgbGVnZW5kIGJveCwgY29tcHV0ZSB0aGUgY29ycmVjdFxuICAgIC8vIFggY29vcmRpbmF0ZSBmcm9tIHRoZSB0aXRsZSBhbGlnbm1lbnRcbiAgICBjb25zdCB4ID0gX2FsaWduU3RhcnRFbmQocG9zaXRpb24sIGxlZnQsIGxlZnQgKyBtYXhXaWR0aCk7XG5cbiAgICAvLyBDYW52YXMgc2V0dXBcbiAgICBjdHgudGV4dEFsaWduID0gcnRsSGVscGVyLnRleHRBbGlnbihfdG9MZWZ0UmlnaHRDZW50ZXIocG9zaXRpb24pKTtcbiAgICBjdHgudGV4dEJhc2VsaW5lID0gJ21pZGRsZSc7XG4gICAgY3R4LnN0cm9rZVN0eWxlID0gdGl0bGVPcHRzLmNvbG9yO1xuICAgIGN0eC5maWxsU3R5bGUgPSB0aXRsZU9wdHMuY29sb3I7XG4gICAgY3R4LmZvbnQgPSB0aXRsZUZvbnQuc3RyaW5nO1xuXG4gICAgcmVuZGVyVGV4dChjdHgsIHRpdGxlT3B0cy50ZXh0LCB4LCB5LCB0aXRsZUZvbnQpO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfY29tcHV0ZVRpdGxlSGVpZ2h0KCkge1xuICAgIGNvbnN0IHRpdGxlT3B0cyA9IHRoaXMub3B0aW9ucy50aXRsZTtcbiAgICBjb25zdCB0aXRsZUZvbnQgPSB0b0ZvbnQodGl0bGVPcHRzLmZvbnQpO1xuICAgIGNvbnN0IHRpdGxlUGFkZGluZyA9IHRvUGFkZGluZyh0aXRsZU9wdHMucGFkZGluZyk7XG4gICAgcmV0dXJuIHRpdGxlT3B0cy5kaXNwbGF5ID8gdGl0bGVGb250LmxpbmVIZWlnaHQgKyB0aXRsZVBhZGRpbmcuaGVpZ2h0IDogMDtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgX2dldExlZ2VuZEl0ZW1BdCh4LCB5KSB7XG4gICAgbGV0IGksIGhpdEJveCwgbGg7XG5cbiAgICBpZiAoX2lzQmV0d2Vlbih4LCB0aGlzLmxlZnQsIHRoaXMucmlnaHQpXG4gICAgICAmJiBfaXNCZXR3ZWVuKHksIHRoaXMudG9wLCB0aGlzLmJvdHRvbSkpIHtcbiAgICAgIC8vIFNlZSBpZiB3ZSBhcmUgdG91Y2hpbmcgb25lIG9mIHRoZSBkYXRhc2V0IGJveGVzXG4gICAgICBsaCA9IHRoaXMubGVnZW5kSGl0Qm94ZXM7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGgubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgaGl0Qm94ID0gbGhbaV07XG5cbiAgICAgICAgaWYgKF9pc0JldHdlZW4oeCwgaGl0Qm94LmxlZnQsIGhpdEJveC5sZWZ0ICsgaGl0Qm94LndpZHRoKVxuICAgICAgICAgICYmIF9pc0JldHdlZW4oeSwgaGl0Qm94LnRvcCwgaGl0Qm94LnRvcCArIGhpdEJveC5oZWlnaHQpKSB7XG4gICAgICAgICAgLy8gVG91Y2hpbmcgYW4gZWxlbWVudFxuICAgICAgICAgIHJldHVybiB0aGlzLmxlZ2VuZEl0ZW1zW2ldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvKipcblx0ICogSGFuZGxlIGFuIGV2ZW50XG5cdCAqIEBwYXJhbSB7Q2hhcnRFdmVudH0gZSAtIFRoZSBldmVudCB0byBoYW5kbGVcblx0ICovXG4gIGhhbmRsZUV2ZW50KGUpIHtcbiAgICBjb25zdCBvcHRzID0gdGhpcy5vcHRpb25zO1xuICAgIGlmICghaXNMaXN0ZW5lZChlLnR5cGUsIG9wdHMpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gQ2hhcnQgZXZlbnQgYWxyZWFkeSBoYXMgcmVsYXRpdmUgcG9zaXRpb24gaW4gaXRcbiAgICBjb25zdCBob3ZlcmVkSXRlbSA9IHRoaXMuX2dldExlZ2VuZEl0ZW1BdChlLngsIGUueSk7XG5cbiAgICBpZiAoZS50eXBlID09PSAnbW91c2Vtb3ZlJyB8fCBlLnR5cGUgPT09ICdtb3VzZW91dCcpIHtcbiAgICAgIGNvbnN0IHByZXZpb3VzID0gdGhpcy5faG92ZXJlZEl0ZW07XG4gICAgICBjb25zdCBzYW1lSXRlbSA9IGl0ZW1zRXF1YWwocHJldmlvdXMsIGhvdmVyZWRJdGVtKTtcbiAgICAgIGlmIChwcmV2aW91cyAmJiAhc2FtZUl0ZW0pIHtcbiAgICAgICAgY2FsbChvcHRzLm9uTGVhdmUsIFtlLCBwcmV2aW91cywgdGhpc10sIHRoaXMpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9ob3ZlcmVkSXRlbSA9IGhvdmVyZWRJdGVtO1xuXG4gICAgICBpZiAoaG92ZXJlZEl0ZW0gJiYgIXNhbWVJdGVtKSB7XG4gICAgICAgIGNhbGwob3B0cy5vbkhvdmVyLCBbZSwgaG92ZXJlZEl0ZW0sIHRoaXNdLCB0aGlzKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGhvdmVyZWRJdGVtKSB7XG4gICAgICBjYWxsKG9wdHMub25DbGljaywgW2UsIGhvdmVyZWRJdGVtLCB0aGlzXSwgdGhpcyk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNhbGN1bGF0ZUl0ZW1TaXplKGJveFdpZHRoLCBsYWJlbEZvbnQsIGN0eCwgbGVnZW5kSXRlbSwgX2l0ZW1IZWlnaHQpIHtcbiAgY29uc3QgaXRlbVdpZHRoID0gY2FsY3VsYXRlSXRlbVdpZHRoKGxlZ2VuZEl0ZW0sIGJveFdpZHRoLCBsYWJlbEZvbnQsIGN0eCk7XG4gIGNvbnN0IGl0ZW1IZWlnaHQgPSBjYWxjdWxhdGVJdGVtSGVpZ2h0KF9pdGVtSGVpZ2h0LCBsZWdlbmRJdGVtLCBsYWJlbEZvbnQubGluZUhlaWdodCk7XG4gIHJldHVybiB7aXRlbVdpZHRoLCBpdGVtSGVpZ2h0fTtcbn1cblxuZnVuY3Rpb24gY2FsY3VsYXRlSXRlbVdpZHRoKGxlZ2VuZEl0ZW0sIGJveFdpZHRoLCBsYWJlbEZvbnQsIGN0eCkge1xuICBsZXQgbGVnZW5kSXRlbVRleHQgPSBsZWdlbmRJdGVtLnRleHQ7XG4gIGlmIChsZWdlbmRJdGVtVGV4dCAmJiB0eXBlb2YgbGVnZW5kSXRlbVRleHQgIT09ICdzdHJpbmcnKSB7XG4gICAgbGVnZW5kSXRlbVRleHQgPSBsZWdlbmRJdGVtVGV4dC5yZWR1Y2UoKGEsIGIpID0+IGEubGVuZ3RoID4gYi5sZW5ndGggPyBhIDogYik7XG4gIH1cbiAgcmV0dXJuIGJveFdpZHRoICsgKGxhYmVsRm9udC5zaXplIC8gMikgKyBjdHgubWVhc3VyZVRleHQobGVnZW5kSXRlbVRleHQpLndpZHRoO1xufVxuXG5mdW5jdGlvbiBjYWxjdWxhdGVJdGVtSGVpZ2h0KF9pdGVtSGVpZ2h0LCBsZWdlbmRJdGVtLCBmb250TGluZUhlaWdodCkge1xuICBsZXQgaXRlbUhlaWdodCA9IF9pdGVtSGVpZ2h0O1xuICBpZiAodHlwZW9mIGxlZ2VuZEl0ZW0udGV4dCAhPT0gJ3N0cmluZycpIHtcbiAgICBpdGVtSGVpZ2h0ID0gY2FsY3VsYXRlTGVnZW5kSXRlbUhlaWdodChsZWdlbmRJdGVtLCBmb250TGluZUhlaWdodCk7XG4gIH1cbiAgcmV0dXJuIGl0ZW1IZWlnaHQ7XG59XG5cbmZ1bmN0aW9uIGNhbGN1bGF0ZUxlZ2VuZEl0ZW1IZWlnaHQobGVnZW5kSXRlbSwgZm9udExpbmVIZWlnaHQpIHtcbiAgY29uc3QgbGFiZWxIZWlnaHQgPSBsZWdlbmRJdGVtLnRleHQgPyBsZWdlbmRJdGVtLnRleHQubGVuZ3RoIDogMDtcbiAgcmV0dXJuIGZvbnRMaW5lSGVpZ2h0ICogbGFiZWxIZWlnaHQ7XG59XG5cbmZ1bmN0aW9uIGlzTGlzdGVuZWQodHlwZSwgb3B0cykge1xuICBpZiAoKHR5cGUgPT09ICdtb3VzZW1vdmUnIHx8IHR5cGUgPT09ICdtb3VzZW91dCcpICYmIChvcHRzLm9uSG92ZXIgfHwgb3B0cy5vbkxlYXZlKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmIChvcHRzLm9uQ2xpY2sgJiYgKHR5cGUgPT09ICdjbGljaycgfHwgdHlwZSA9PT0gJ21vdXNldXAnKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuZXhwb3J0IGRlZmF1bHQge1xuICBpZDogJ2xlZ2VuZCcsXG5cbiAgLyoqXG5cdCAqIEZvciB0ZXN0c1xuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgX2VsZW1lbnQ6IExlZ2VuZCxcblxuICBzdGFydChjaGFydCwgX2FyZ3MsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBsZWdlbmQgPSBjaGFydC5sZWdlbmQgPSBuZXcgTGVnZW5kKHtjdHg6IGNoYXJ0LmN0eCwgb3B0aW9ucywgY2hhcnR9KTtcbiAgICBsYXlvdXRzLmNvbmZpZ3VyZShjaGFydCwgbGVnZW5kLCBvcHRpb25zKTtcbiAgICBsYXlvdXRzLmFkZEJveChjaGFydCwgbGVnZW5kKTtcbiAgfSxcblxuICBzdG9wKGNoYXJ0KSB7XG4gICAgbGF5b3V0cy5yZW1vdmVCb3goY2hhcnQsIGNoYXJ0LmxlZ2VuZCk7XG4gICAgZGVsZXRlIGNoYXJ0LmxlZ2VuZDtcbiAgfSxcblxuICAvLyBEdXJpbmcgdGhlIGJlZm9yZVVwZGF0ZSBzdGVwLCB0aGUgbGF5b3V0IGNvbmZpZ3VyYXRpb24gbmVlZHMgdG8gcnVuXG4gIC8vIFRoaXMgZW5zdXJlcyB0aGF0IGlmIHRoZSBsZWdlbmQgcG9zaXRpb24gY2hhbmdlcyAodmlhIGFuIG9wdGlvbiB1cGRhdGUpXG4gIC8vIHRoZSBsYXlvdXQgc3lzdGVtIHJlc3BlY3RzIHRoZSBjaGFuZ2UuIFNlZSBodHRwczovL2dpdGh1Yi5jb20vY2hhcnRqcy9DaGFydC5qcy9pc3N1ZXMvNzUyN1xuICBiZWZvcmVVcGRhdGUoY2hhcnQsIF9hcmdzLCBvcHRpb25zKSB7XG4gICAgY29uc3QgbGVnZW5kID0gY2hhcnQubGVnZW5kO1xuICAgIGxheW91dHMuY29uZmlndXJlKGNoYXJ0LCBsZWdlbmQsIG9wdGlvbnMpO1xuICAgIGxlZ2VuZC5vcHRpb25zID0gb3B0aW9ucztcbiAgfSxcblxuICAvLyBUaGUgbGFiZWxzIG5lZWQgdG8gYmUgYnVpbHQgYWZ0ZXIgZGF0YXNldHMgYXJlIHVwZGF0ZWQgdG8gZW5zdXJlIHRoYXQgY29sb3JzXG4gIC8vIGFuZCBvdGhlciBzdHlsaW5nIGFyZSBjb3JyZWN0LiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2NoYXJ0anMvQ2hhcnQuanMvaXNzdWVzLzY5NjhcbiAgYWZ0ZXJVcGRhdGUoY2hhcnQpIHtcbiAgICBjb25zdCBsZWdlbmQgPSBjaGFydC5sZWdlbmQ7XG4gICAgbGVnZW5kLmJ1aWxkTGFiZWxzKCk7XG4gICAgbGVnZW5kLmFkanVzdEhpdEJveGVzKCk7XG4gIH0sXG5cblxuICBhZnRlckV2ZW50KGNoYXJ0LCBhcmdzKSB7XG4gICAgaWYgKCFhcmdzLnJlcGxheSkge1xuICAgICAgY2hhcnQubGVnZW5kLmhhbmRsZUV2ZW50KGFyZ3MuZXZlbnQpO1xuICAgIH1cbiAgfSxcblxuICBkZWZhdWx0czoge1xuICAgIGRpc3BsYXk6IHRydWUsXG4gICAgcG9zaXRpb246ICd0b3AnLFxuICAgIGFsaWduOiAnY2VudGVyJyxcbiAgICBmdWxsU2l6ZTogdHJ1ZSxcbiAgICByZXZlcnNlOiBmYWxzZSxcbiAgICB3ZWlnaHQ6IDEwMDAsXG5cbiAgICAvLyBhIGNhbGxiYWNrIHRoYXQgd2lsbCBoYW5kbGVcbiAgICBvbkNsaWNrKGUsIGxlZ2VuZEl0ZW0sIGxlZ2VuZCkge1xuICAgICAgY29uc3QgaW5kZXggPSBsZWdlbmRJdGVtLmRhdGFzZXRJbmRleDtcbiAgICAgIGNvbnN0IGNpID0gbGVnZW5kLmNoYXJ0O1xuICAgICAgaWYgKGNpLmlzRGF0YXNldFZpc2libGUoaW5kZXgpKSB7XG4gICAgICAgIGNpLmhpZGUoaW5kZXgpO1xuICAgICAgICBsZWdlbmRJdGVtLmhpZGRlbiA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjaS5zaG93KGluZGV4KTtcbiAgICAgICAgbGVnZW5kSXRlbS5oaWRkZW4gPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgb25Ib3ZlcjogbnVsbCxcbiAgICBvbkxlYXZlOiBudWxsLFxuXG4gICAgbGFiZWxzOiB7XG4gICAgICBjb2xvcjogKGN0eCkgPT4gY3R4LmNoYXJ0Lm9wdGlvbnMuY29sb3IsXG4gICAgICBib3hXaWR0aDogNDAsXG4gICAgICBwYWRkaW5nOiAxMCxcbiAgICAgIC8vIEdlbmVyYXRlcyBsYWJlbHMgc2hvd24gaW4gdGhlIGxlZ2VuZFxuICAgICAgLy8gVmFsaWQgcHJvcGVydGllcyB0byByZXR1cm46XG4gICAgICAvLyB0ZXh0IDogdGV4dCB0byBkaXNwbGF5XG4gICAgICAvLyBmaWxsU3R5bGUgOiBmaWxsIG9mIGNvbG91cmVkIGJveFxuICAgICAgLy8gc3Ryb2tlU3R5bGU6IHN0cm9rZSBvZiBjb2xvdXJlZCBib3hcbiAgICAgIC8vIGhpZGRlbiA6IGlmIHRoaXMgbGVnZW5kIGl0ZW0gcmVmZXJzIHRvIGEgaGlkZGVuIGl0ZW1cbiAgICAgIC8vIGxpbmVDYXAgOiBjYXAgc3R5bGUgZm9yIGxpbmVcbiAgICAgIC8vIGxpbmVEYXNoXG4gICAgICAvLyBsaW5lRGFzaE9mZnNldCA6XG4gICAgICAvLyBsaW5lSm9pbiA6XG4gICAgICAvLyBsaW5lV2lkdGggOlxuICAgICAgZ2VuZXJhdGVMYWJlbHMoY2hhcnQpIHtcbiAgICAgICAgY29uc3QgZGF0YXNldHMgPSBjaGFydC5kYXRhLmRhdGFzZXRzO1xuICAgICAgICBjb25zdCB7bGFiZWxzOiB7dXNlUG9pbnRTdHlsZSwgcG9pbnRTdHlsZSwgdGV4dEFsaWduLCBjb2xvciwgdXNlQm9yZGVyUmFkaXVzLCBib3JkZXJSYWRpdXN9fSA9IGNoYXJ0LmxlZ2VuZC5vcHRpb25zO1xuXG4gICAgICAgIHJldHVybiBjaGFydC5fZ2V0U29ydGVkRGF0YXNldE1ldGFzKCkubWFwKChtZXRhKSA9PiB7XG4gICAgICAgICAgY29uc3Qgc3R5bGUgPSBtZXRhLmNvbnRyb2xsZXIuZ2V0U3R5bGUodXNlUG9pbnRTdHlsZSA/IDAgOiB1bmRlZmluZWQpO1xuICAgICAgICAgIGNvbnN0IGJvcmRlcldpZHRoID0gdG9QYWRkaW5nKHN0eWxlLmJvcmRlcldpZHRoKTtcblxuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0ZXh0OiBkYXRhc2V0c1ttZXRhLmluZGV4XS5sYWJlbCxcbiAgICAgICAgICAgIGZpbGxTdHlsZTogc3R5bGUuYmFja2dyb3VuZENvbG9yLFxuICAgICAgICAgICAgZm9udENvbG9yOiBjb2xvcixcbiAgICAgICAgICAgIGhpZGRlbjogIW1ldGEudmlzaWJsZSxcbiAgICAgICAgICAgIGxpbmVDYXA6IHN0eWxlLmJvcmRlckNhcFN0eWxlLFxuICAgICAgICAgICAgbGluZURhc2g6IHN0eWxlLmJvcmRlckRhc2gsXG4gICAgICAgICAgICBsaW5lRGFzaE9mZnNldDogc3R5bGUuYm9yZGVyRGFzaE9mZnNldCxcbiAgICAgICAgICAgIGxpbmVKb2luOiBzdHlsZS5ib3JkZXJKb2luU3R5bGUsXG4gICAgICAgICAgICBsaW5lV2lkdGg6IChib3JkZXJXaWR0aC53aWR0aCArIGJvcmRlcldpZHRoLmhlaWdodCkgLyA0LFxuICAgICAgICAgICAgc3Ryb2tlU3R5bGU6IHN0eWxlLmJvcmRlckNvbG9yLFxuICAgICAgICAgICAgcG9pbnRTdHlsZTogcG9pbnRTdHlsZSB8fCBzdHlsZS5wb2ludFN0eWxlLFxuICAgICAgICAgICAgcm90YXRpb246IHN0eWxlLnJvdGF0aW9uLFxuICAgICAgICAgICAgdGV4dEFsaWduOiB0ZXh0QWxpZ24gfHwgc3R5bGUudGV4dEFsaWduLFxuICAgICAgICAgICAgYm9yZGVyUmFkaXVzOiB1c2VCb3JkZXJSYWRpdXMgJiYgKGJvcmRlclJhZGl1cyB8fCBzdHlsZS5ib3JkZXJSYWRpdXMpLFxuXG4gICAgICAgICAgICAvLyBCZWxvdyBpcyBleHRyYSBkYXRhIHVzZWQgZm9yIHRvZ2dsaW5nIHRoZSBkYXRhc2V0c1xuICAgICAgICAgICAgZGF0YXNldEluZGV4OiBtZXRhLmluZGV4XG4gICAgICAgICAgfTtcbiAgICAgICAgfSwgdGhpcyk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIHRpdGxlOiB7XG4gICAgICBjb2xvcjogKGN0eCkgPT4gY3R4LmNoYXJ0Lm9wdGlvbnMuY29sb3IsXG4gICAgICBkaXNwbGF5OiBmYWxzZSxcbiAgICAgIHBvc2l0aW9uOiAnY2VudGVyJyxcbiAgICAgIHRleHQ6ICcnLFxuICAgIH1cbiAgfSxcblxuICBkZXNjcmlwdG9yczoge1xuICAgIF9zY3JpcHRhYmxlOiAobmFtZSkgPT4gIW5hbWUuc3RhcnRzV2l0aCgnb24nKSxcbiAgICBsYWJlbHM6IHtcbiAgICAgIF9zY3JpcHRhYmxlOiAobmFtZSkgPT4gIVsnZ2VuZXJhdGVMYWJlbHMnLCAnZmlsdGVyJywgJ3NvcnQnXS5pbmNsdWRlcyhuYW1lKSxcbiAgICB9XG4gIH0sXG59O1xuIiwgImltcG9ydCBFbGVtZW50IGZyb20gJy4uL2NvcmUvY29yZS5lbGVtZW50LmpzJztcbmltcG9ydCBsYXlvdXRzIGZyb20gJy4uL2NvcmUvY29yZS5sYXlvdXRzLmpzJztcbmltcG9ydCB7UEksIGlzQXJyYXksIHRvUGFkZGluZywgdG9Gb250fSBmcm9tICcuLi9oZWxwZXJzL2luZGV4LmpzJztcbmltcG9ydCB7X3RvTGVmdFJpZ2h0Q2VudGVyLCBfYWxpZ25TdGFydEVuZH0gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLmV4dHJhcy5qcyc7XG5pbXBvcnQge3JlbmRlclRleHR9IGZyb20gJy4uL2hlbHBlcnMvaGVscGVycy5jYW52YXMuanMnO1xuXG5leHBvcnQgY2xhc3MgVGl0bGUgZXh0ZW5kcyBFbGVtZW50IHtcbiAgLyoqXG5cdCAqIEBwYXJhbSB7eyBjdHg6IGFueTsgb3B0aW9uczogYW55OyBjaGFydDogYW55OyB9fSBjb25maWdcblx0ICovXG4gIGNvbnN0cnVjdG9yKGNvbmZpZykge1xuICAgIHN1cGVyKCk7XG5cbiAgICB0aGlzLmNoYXJ0ID0gY29uZmlnLmNoYXJ0O1xuICAgIHRoaXMub3B0aW9ucyA9IGNvbmZpZy5vcHRpb25zO1xuICAgIHRoaXMuY3R4ID0gY29uZmlnLmN0eDtcbiAgICB0aGlzLl9wYWRkaW5nID0gdW5kZWZpbmVkO1xuICAgIHRoaXMudG9wID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuYm90dG9tID0gdW5kZWZpbmVkO1xuICAgIHRoaXMubGVmdCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnJpZ2h0ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMud2lkdGggPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5oZWlnaHQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5wb3NpdGlvbiA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLndlaWdodCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmZ1bGxTaXplID0gdW5kZWZpbmVkO1xuICB9XG5cbiAgdXBkYXRlKG1heFdpZHRoLCBtYXhIZWlnaHQpIHtcbiAgICBjb25zdCBvcHRzID0gdGhpcy5vcHRpb25zO1xuXG4gICAgdGhpcy5sZWZ0ID0gMDtcbiAgICB0aGlzLnRvcCA9IDA7XG5cbiAgICBpZiAoIW9wdHMuZGlzcGxheSkge1xuICAgICAgdGhpcy53aWR0aCA9IHRoaXMuaGVpZ2h0ID0gdGhpcy5yaWdodCA9IHRoaXMuYm90dG9tID0gMDtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLndpZHRoID0gdGhpcy5yaWdodCA9IG1heFdpZHRoO1xuICAgIHRoaXMuaGVpZ2h0ID0gdGhpcy5ib3R0b20gPSBtYXhIZWlnaHQ7XG5cbiAgICBjb25zdCBsaW5lQ291bnQgPSBpc0FycmF5KG9wdHMudGV4dCkgPyBvcHRzLnRleHQubGVuZ3RoIDogMTtcbiAgICB0aGlzLl9wYWRkaW5nID0gdG9QYWRkaW5nKG9wdHMucGFkZGluZyk7XG4gICAgY29uc3QgdGV4dFNpemUgPSBsaW5lQ291bnQgKiB0b0ZvbnQob3B0cy5mb250KS5saW5lSGVpZ2h0ICsgdGhpcy5fcGFkZGluZy5oZWlnaHQ7XG5cbiAgICBpZiAodGhpcy5pc0hvcml6b250YWwoKSkge1xuICAgICAgdGhpcy5oZWlnaHQgPSB0ZXh0U2l6ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy53aWR0aCA9IHRleHRTaXplO1xuICAgIH1cbiAgfVxuXG4gIGlzSG9yaXpvbnRhbCgpIHtcbiAgICBjb25zdCBwb3MgPSB0aGlzLm9wdGlvbnMucG9zaXRpb247XG4gICAgcmV0dXJuIHBvcyA9PT0gJ3RvcCcgfHwgcG9zID09PSAnYm90dG9tJztcbiAgfVxuXG4gIF9kcmF3QXJncyhvZmZzZXQpIHtcbiAgICBjb25zdCB7dG9wLCBsZWZ0LCBib3R0b20sIHJpZ2h0LCBvcHRpb25zfSA9IHRoaXM7XG4gICAgY29uc3QgYWxpZ24gPSBvcHRpb25zLmFsaWduO1xuICAgIGxldCByb3RhdGlvbiA9IDA7XG4gICAgbGV0IG1heFdpZHRoLCB0aXRsZVgsIHRpdGxlWTtcblxuICAgIGlmICh0aGlzLmlzSG9yaXpvbnRhbCgpKSB7XG4gICAgICB0aXRsZVggPSBfYWxpZ25TdGFydEVuZChhbGlnbiwgbGVmdCwgcmlnaHQpO1xuICAgICAgdGl0bGVZID0gdG9wICsgb2Zmc2V0O1xuICAgICAgbWF4V2lkdGggPSByaWdodCAtIGxlZnQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChvcHRpb25zLnBvc2l0aW9uID09PSAnbGVmdCcpIHtcbiAgICAgICAgdGl0bGVYID0gbGVmdCArIG9mZnNldDtcbiAgICAgICAgdGl0bGVZID0gX2FsaWduU3RhcnRFbmQoYWxpZ24sIGJvdHRvbSwgdG9wKTtcbiAgICAgICAgcm90YXRpb24gPSBQSSAqIC0wLjU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aXRsZVggPSByaWdodCAtIG9mZnNldDtcbiAgICAgICAgdGl0bGVZID0gX2FsaWduU3RhcnRFbmQoYWxpZ24sIHRvcCwgYm90dG9tKTtcbiAgICAgICAgcm90YXRpb24gPSBQSSAqIDAuNTtcbiAgICAgIH1cbiAgICAgIG1heFdpZHRoID0gYm90dG9tIC0gdG9wO1xuICAgIH1cbiAgICByZXR1cm4ge3RpdGxlWCwgdGl0bGVZLCBtYXhXaWR0aCwgcm90YXRpb259O1xuICB9XG5cbiAgZHJhdygpIHtcbiAgICBjb25zdCBjdHggPSB0aGlzLmN0eDtcbiAgICBjb25zdCBvcHRzID0gdGhpcy5vcHRpb25zO1xuXG4gICAgaWYgKCFvcHRzLmRpc3BsYXkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBmb250T3B0cyA9IHRvRm9udChvcHRzLmZvbnQpO1xuICAgIGNvbnN0IGxpbmVIZWlnaHQgPSBmb250T3B0cy5saW5lSGVpZ2h0O1xuICAgIGNvbnN0IG9mZnNldCA9IGxpbmVIZWlnaHQgLyAyICsgdGhpcy5fcGFkZGluZy50b3A7XG4gICAgY29uc3Qge3RpdGxlWCwgdGl0bGVZLCBtYXhXaWR0aCwgcm90YXRpb259ID0gdGhpcy5fZHJhd0FyZ3Mob2Zmc2V0KTtcblxuICAgIHJlbmRlclRleHQoY3R4LCBvcHRzLnRleHQsIDAsIDAsIGZvbnRPcHRzLCB7XG4gICAgICBjb2xvcjogb3B0cy5jb2xvcixcbiAgICAgIG1heFdpZHRoLFxuICAgICAgcm90YXRpb24sXG4gICAgICB0ZXh0QWxpZ246IF90b0xlZnRSaWdodENlbnRlcihvcHRzLmFsaWduKSxcbiAgICAgIHRleHRCYXNlbGluZTogJ21pZGRsZScsXG4gICAgICB0cmFuc2xhdGlvbjogW3RpdGxlWCwgdGl0bGVZXSxcbiAgICB9KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjcmVhdGVUaXRsZShjaGFydCwgdGl0bGVPcHRzKSB7XG4gIGNvbnN0IHRpdGxlID0gbmV3IFRpdGxlKHtcbiAgICBjdHg6IGNoYXJ0LmN0eCxcbiAgICBvcHRpb25zOiB0aXRsZU9wdHMsXG4gICAgY2hhcnRcbiAgfSk7XG5cbiAgbGF5b3V0cy5jb25maWd1cmUoY2hhcnQsIHRpdGxlLCB0aXRsZU9wdHMpO1xuICBsYXlvdXRzLmFkZEJveChjaGFydCwgdGl0bGUpO1xuICBjaGFydC50aXRsZUJsb2NrID0gdGl0bGU7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgaWQ6ICd0aXRsZScsXG5cbiAgLyoqXG5cdCAqIEZvciB0ZXN0c1xuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgX2VsZW1lbnQ6IFRpdGxlLFxuXG4gIHN0YXJ0KGNoYXJ0LCBfYXJncywgb3B0aW9ucykge1xuICAgIGNyZWF0ZVRpdGxlKGNoYXJ0LCBvcHRpb25zKTtcbiAgfSxcblxuICBzdG9wKGNoYXJ0KSB7XG4gICAgY29uc3QgdGl0bGVCbG9jayA9IGNoYXJ0LnRpdGxlQmxvY2s7XG4gICAgbGF5b3V0cy5yZW1vdmVCb3goY2hhcnQsIHRpdGxlQmxvY2spO1xuICAgIGRlbGV0ZSBjaGFydC50aXRsZUJsb2NrO1xuICB9LFxuXG4gIGJlZm9yZVVwZGF0ZShjaGFydCwgX2FyZ3MsIG9wdGlvbnMpIHtcbiAgICBjb25zdCB0aXRsZSA9IGNoYXJ0LnRpdGxlQmxvY2s7XG4gICAgbGF5b3V0cy5jb25maWd1cmUoY2hhcnQsIHRpdGxlLCBvcHRpb25zKTtcbiAgICB0aXRsZS5vcHRpb25zID0gb3B0aW9ucztcbiAgfSxcblxuICBkZWZhdWx0czoge1xuICAgIGFsaWduOiAnY2VudGVyJyxcbiAgICBkaXNwbGF5OiBmYWxzZSxcbiAgICBmb250OiB7XG4gICAgICB3ZWlnaHQ6ICdib2xkJyxcbiAgICB9LFxuICAgIGZ1bGxTaXplOiB0cnVlLFxuICAgIHBhZGRpbmc6IDEwLFxuICAgIHBvc2l0aW9uOiAndG9wJyxcbiAgICB0ZXh0OiAnJyxcbiAgICB3ZWlnaHQ6IDIwMDAgICAgICAgICAvLyBieSBkZWZhdWx0IGdyZWF0ZXIgdGhhbiBsZWdlbmQgKDEwMDApIHRvIGJlIGFib3ZlXG4gIH0sXG5cbiAgZGVmYXVsdFJvdXRlczoge1xuICAgIGNvbG9yOiAnY29sb3InXG4gIH0sXG5cbiAgZGVzY3JpcHRvcnM6IHtcbiAgICBfc2NyaXB0YWJsZTogdHJ1ZSxcbiAgICBfaW5kZXhhYmxlOiBmYWxzZSxcbiAgfSxcbn07XG4iLCAiaW1wb3J0IHtUaXRsZX0gZnJvbSAnLi9wbHVnaW4udGl0bGUuanMnO1xuaW1wb3J0IGxheW91dHMgZnJvbSAnLi4vY29yZS9jb3JlLmxheW91dHMuanMnO1xuXG5jb25zdCBtYXAgPSBuZXcgV2Vha01hcCgpO1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIGlkOiAnc3VidGl0bGUnLFxuXG4gIHN0YXJ0KGNoYXJ0LCBfYXJncywgb3B0aW9ucykge1xuICAgIGNvbnN0IHRpdGxlID0gbmV3IFRpdGxlKHtcbiAgICAgIGN0eDogY2hhcnQuY3R4LFxuICAgICAgb3B0aW9ucyxcbiAgICAgIGNoYXJ0XG4gICAgfSk7XG5cbiAgICBsYXlvdXRzLmNvbmZpZ3VyZShjaGFydCwgdGl0bGUsIG9wdGlvbnMpO1xuICAgIGxheW91dHMuYWRkQm94KGNoYXJ0LCB0aXRsZSk7XG4gICAgbWFwLnNldChjaGFydCwgdGl0bGUpO1xuICB9LFxuXG4gIHN0b3AoY2hhcnQpIHtcbiAgICBsYXlvdXRzLnJlbW92ZUJveChjaGFydCwgbWFwLmdldChjaGFydCkpO1xuICAgIG1hcC5kZWxldGUoY2hhcnQpO1xuICB9LFxuXG4gIGJlZm9yZVVwZGF0ZShjaGFydCwgX2FyZ3MsIG9wdGlvbnMpIHtcbiAgICBjb25zdCB0aXRsZSA9IG1hcC5nZXQoY2hhcnQpO1xuICAgIGxheW91dHMuY29uZmlndXJlKGNoYXJ0LCB0aXRsZSwgb3B0aW9ucyk7XG4gICAgdGl0bGUub3B0aW9ucyA9IG9wdGlvbnM7XG4gIH0sXG5cbiAgZGVmYXVsdHM6IHtcbiAgICBhbGlnbjogJ2NlbnRlcicsXG4gICAgZGlzcGxheTogZmFsc2UsXG4gICAgZm9udDoge1xuICAgICAgd2VpZ2h0OiAnbm9ybWFsJyxcbiAgICB9LFxuICAgIGZ1bGxTaXplOiB0cnVlLFxuICAgIHBhZGRpbmc6IDAsXG4gICAgcG9zaXRpb246ICd0b3AnLFxuICAgIHRleHQ6ICcnLFxuICAgIHdlaWdodDogMTUwMCAgICAgICAgIC8vIGJ5IGRlZmF1bHQgZ3JlYXRlciB0aGFuIGxlZ2VuZCAoMTAwMCkgYW5kIHNtYWxsZXIgdGhhbiB0aXRsZSAoMjAwMClcbiAgfSxcblxuICBkZWZhdWx0Um91dGVzOiB7XG4gICAgY29sb3I6ICdjb2xvcidcbiAgfSxcblxuICBkZXNjcmlwdG9yczoge1xuICAgIF9zY3JpcHRhYmxlOiB0cnVlLFxuICAgIF9pbmRleGFibGU6IGZhbHNlLFxuICB9LFxufTtcbiIsICJpbXBvcnQgQW5pbWF0aW9ucyBmcm9tICcuLi9jb3JlL2NvcmUuYW5pbWF0aW9ucy5qcyc7XG5pbXBvcnQgRWxlbWVudCBmcm9tICcuLi9jb3JlL2NvcmUuZWxlbWVudC5qcyc7XG5pbXBvcnQge2FkZFJvdW5kZWRSZWN0UGF0aH0gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLmNhbnZhcy5qcyc7XG5pbXBvcnQge2VhY2gsIG5vb3AsIGlzTnVsbE9yVW5kZWYsIGlzQXJyYXksIF9lbGVtZW50c0VxdWFsLCBpc09iamVjdH0gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLmNvcmUuanMnO1xuaW1wb3J0IHt0b0ZvbnQsIHRvUGFkZGluZywgdG9UUkJMQ29ybmVyc30gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLm9wdGlvbnMuanMnO1xuaW1wb3J0IHtnZXRSdGxBZGFwdGVyLCBvdmVycmlkZVRleHREaXJlY3Rpb24sIHJlc3RvcmVUZXh0RGlyZWN0aW9ufSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMucnRsLmpzJztcbmltcG9ydCB7ZGlzdGFuY2VCZXR3ZWVuUG9pbnRzLCBfbGltaXRWYWx1ZX0gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLm1hdGguanMnO1xuaW1wb3J0IHtjcmVhdGVDb250ZXh0LCBkcmF3UG9pbnR9IGZyb20gJy4uL2hlbHBlcnMvaW5kZXguanMnO1xuXG4vKipcbiAqIEB0eXBlZGVmIHsgaW1wb3J0KCcuLi9wbGF0Zm9ybS9wbGF0Zm9ybS5iYXNlLmpzJykuQ2hhcnQgfSBDaGFydFxuICogQHR5cGVkZWYgeyBpbXBvcnQoJy4uL3R5cGVzL2luZGV4LmpzJykuQ2hhcnRFdmVudCB9IENoYXJ0RXZlbnRcbiAqIEB0eXBlZGVmIHsgaW1wb3J0KCcuLi90eXBlcy9pbmRleC5qcycpLkFjdGl2ZUVsZW1lbnQgfSBBY3RpdmVFbGVtZW50XG4gKiBAdHlwZWRlZiB7IGltcG9ydCgnLi4vY29yZS9jb3JlLmludGVyYWN0aW9uLmpzJykuSW50ZXJhY3Rpb25JdGVtIH0gSW50ZXJhY3Rpb25JdGVtXG4gKi9cblxuY29uc3QgcG9zaXRpb25lcnMgPSB7XG4gIC8qKlxuXHQgKiBBdmVyYWdlIG1vZGUgcGxhY2VzIHRoZSB0b29sdGlwIGF0IHRoZSBhdmVyYWdlIHBvc2l0aW9uIG9mIHRoZSBlbGVtZW50cyBzaG93blxuXHQgKi9cbiAgYXZlcmFnZShpdGVtcykge1xuICAgIGlmICghaXRlbXMubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgbGV0IGksIGxlbjtcbiAgICBsZXQgeFNldCA9IG5ldyBTZXQoKTtcbiAgICBsZXQgeSA9IDA7XG4gICAgbGV0IGNvdW50ID0gMDtcblxuICAgIGZvciAoaSA9IDAsIGxlbiA9IGl0ZW1zLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICBjb25zdCBlbCA9IGl0ZW1zW2ldLmVsZW1lbnQ7XG4gICAgICBpZiAoZWwgJiYgZWwuaGFzVmFsdWUoKSkge1xuICAgICAgICBjb25zdCBwb3MgPSBlbC50b29sdGlwUG9zaXRpb24oKTtcbiAgICAgICAgeFNldC5hZGQocG9zLngpO1xuICAgICAgICB5ICs9IHBvcy55O1xuICAgICAgICArK2NvdW50O1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIE5vIHZpc2libGUgaXRlbXMgd2hlcmUgZm91bmQsIHJldHVybiBmYWxzZSBzbyB3ZSBkb24ndCBoYXZlIHRvIGRpdmlkZSBieSAwIHdoaWNoIHJlZHVjZXMgaW4gTmFOXG4gICAgaWYgKGNvdW50ID09PSAwIHx8IHhTZXQuc2l6ZSA9PT0gMCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGNvbnN0IHhBdmVyYWdlID0gWy4uLnhTZXRdLnJlZHVjZSgoYSwgYikgPT4gYSArIGIpIC8geFNldC5zaXplO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIHg6IHhBdmVyYWdlLFxuICAgICAgeTogeSAvIGNvdW50XG4gICAgfTtcbiAgfSxcblxuICAvKipcblx0ICogR2V0cyB0aGUgdG9vbHRpcCBwb3NpdGlvbiBuZWFyZXN0IG9mIHRoZSBpdGVtIG5lYXJlc3QgdG8gdGhlIGV2ZW50IHBvc2l0aW9uXG5cdCAqL1xuICBuZWFyZXN0KGl0ZW1zLCBldmVudFBvc2l0aW9uKSB7XG4gICAgaWYgKCFpdGVtcy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBsZXQgeCA9IGV2ZW50UG9zaXRpb24ueDtcbiAgICBsZXQgeSA9IGV2ZW50UG9zaXRpb24ueTtcbiAgICBsZXQgbWluRGlzdGFuY2UgPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7XG4gICAgbGV0IGksIGxlbiwgbmVhcmVzdEVsZW1lbnQ7XG5cbiAgICBmb3IgKGkgPSAwLCBsZW4gPSBpdGVtcy5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgICAgY29uc3QgZWwgPSBpdGVtc1tpXS5lbGVtZW50O1xuICAgICAgaWYgKGVsICYmIGVsLmhhc1ZhbHVlKCkpIHtcbiAgICAgICAgY29uc3QgY2VudGVyID0gZWwuZ2V0Q2VudGVyUG9pbnQoKTtcbiAgICAgICAgY29uc3QgZCA9IGRpc3RhbmNlQmV0d2VlblBvaW50cyhldmVudFBvc2l0aW9uLCBjZW50ZXIpO1xuXG4gICAgICAgIGlmIChkIDwgbWluRGlzdGFuY2UpIHtcbiAgICAgICAgICBtaW5EaXN0YW5jZSA9IGQ7XG4gICAgICAgICAgbmVhcmVzdEVsZW1lbnQgPSBlbDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChuZWFyZXN0RWxlbWVudCkge1xuICAgICAgY29uc3QgdHAgPSBuZWFyZXN0RWxlbWVudC50b29sdGlwUG9zaXRpb24oKTtcbiAgICAgIHggPSB0cC54O1xuICAgICAgeSA9IHRwLnk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHgsXG4gICAgICB5XG4gICAgfTtcbiAgfVxufTtcblxuLy8gSGVscGVyIHRvIHB1c2ggb3IgY29uY2F0IGJhc2VkIG9uIGlmIHRoZSAybmQgcGFyYW1ldGVyIGlzIGFuIGFycmF5IG9yIG5vdFxuZnVuY3Rpb24gcHVzaE9yQ29uY2F0KGJhc2UsIHRvUHVzaCkge1xuICBpZiAodG9QdXNoKSB7XG4gICAgaWYgKGlzQXJyYXkodG9QdXNoKSkge1xuICAgICAgLy8gYmFzZSA9IGJhc2UuY29uY2F0KHRvUHVzaCk7XG4gICAgICBBcnJheS5wcm90b3R5cGUucHVzaC5hcHBseShiYXNlLCB0b1B1c2gpO1xuICAgIH0gZWxzZSB7XG4gICAgICBiYXNlLnB1c2godG9QdXNoKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gYmFzZTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGFycmF5IG9mIHN0cmluZ3Mgc3BsaXQgYnkgbmV3bGluZVxuICogQHBhcmFtIHsqfSBzdHIgLSBUaGUgdmFsdWUgdG8gc3BsaXQgYnkgbmV3bGluZS5cbiAqIEByZXR1cm5zIHtzdHJpbmd8c3RyaW5nW119IHZhbHVlIGlmIG5ld2xpbmUgcHJlc2VudCAtIFJldHVybmVkIGZyb20gU3RyaW5nIHNwbGl0KCkgbWV0aG9kXG4gKiBAZnVuY3Rpb25cbiAqL1xuZnVuY3Rpb24gc3BsaXROZXdsaW5lcyhzdHIpIHtcbiAgaWYgKCh0eXBlb2Ygc3RyID09PSAnc3RyaW5nJyB8fCBzdHIgaW5zdGFuY2VvZiBTdHJpbmcpICYmIHN0ci5pbmRleE9mKCdcXG4nKSA+IC0xKSB7XG4gICAgcmV0dXJuIHN0ci5zcGxpdCgnXFxuJyk7XG4gIH1cbiAgcmV0dXJuIHN0cjtcbn1cblxuXG4vKipcbiAqIFByaXZhdGUgaGVscGVyIHRvIGNyZWF0ZSBhIHRvb2x0aXAgaXRlbSBtb2RlbFxuICogQHBhcmFtIHtDaGFydH0gY2hhcnRcbiAqIEBwYXJhbSB7QWN0aXZlRWxlbWVudH0gaXRlbSAtIHtlbGVtZW50LCBpbmRleCwgZGF0YXNldEluZGV4fSB0byBjcmVhdGUgdGhlIHRvb2x0aXAgaXRlbSBmb3JcbiAqIEByZXR1cm4gbmV3IHRvb2x0aXAgaXRlbVxuICovXG5mdW5jdGlvbiBjcmVhdGVUb29sdGlwSXRlbShjaGFydCwgaXRlbSkge1xuICBjb25zdCB7ZWxlbWVudCwgZGF0YXNldEluZGV4LCBpbmRleH0gPSBpdGVtO1xuICBjb25zdCBjb250cm9sbGVyID0gY2hhcnQuZ2V0RGF0YXNldE1ldGEoZGF0YXNldEluZGV4KS5jb250cm9sbGVyO1xuICBjb25zdCB7bGFiZWwsIHZhbHVlfSA9IGNvbnRyb2xsZXIuZ2V0TGFiZWxBbmRWYWx1ZShpbmRleCk7XG5cbiAgcmV0dXJuIHtcbiAgICBjaGFydCxcbiAgICBsYWJlbCxcbiAgICBwYXJzZWQ6IGNvbnRyb2xsZXIuZ2V0UGFyc2VkKGluZGV4KSxcbiAgICByYXc6IGNoYXJ0LmRhdGEuZGF0YXNldHNbZGF0YXNldEluZGV4XS5kYXRhW2luZGV4XSxcbiAgICBmb3JtYXR0ZWRWYWx1ZTogdmFsdWUsXG4gICAgZGF0YXNldDogY29udHJvbGxlci5nZXREYXRhc2V0KCksXG4gICAgZGF0YUluZGV4OiBpbmRleCxcbiAgICBkYXRhc2V0SW5kZXgsXG4gICAgZWxlbWVudFxuICB9O1xufVxuXG4vKipcbiAqIEdldCB0aGUgc2l6ZSBvZiB0aGUgdG9vbHRpcFxuICovXG5mdW5jdGlvbiBnZXRUb29sdGlwU2l6ZSh0b29sdGlwLCBvcHRpb25zKSB7XG4gIGNvbnN0IGN0eCA9IHRvb2x0aXAuY2hhcnQuY3R4O1xuICBjb25zdCB7Ym9keSwgZm9vdGVyLCB0aXRsZX0gPSB0b29sdGlwO1xuICBjb25zdCB7Ym94V2lkdGgsIGJveEhlaWdodH0gPSBvcHRpb25zO1xuICBjb25zdCBib2R5Rm9udCA9IHRvRm9udChvcHRpb25zLmJvZHlGb250KTtcbiAgY29uc3QgdGl0bGVGb250ID0gdG9Gb250KG9wdGlvbnMudGl0bGVGb250KTtcbiAgY29uc3QgZm9vdGVyRm9udCA9IHRvRm9udChvcHRpb25zLmZvb3RlckZvbnQpO1xuICBjb25zdCB0aXRsZUxpbmVDb3VudCA9IHRpdGxlLmxlbmd0aDtcbiAgY29uc3QgZm9vdGVyTGluZUNvdW50ID0gZm9vdGVyLmxlbmd0aDtcbiAgY29uc3QgYm9keUxpbmVJdGVtQ291bnQgPSBib2R5Lmxlbmd0aDtcblxuICBjb25zdCBwYWRkaW5nID0gdG9QYWRkaW5nKG9wdGlvbnMucGFkZGluZyk7XG4gIGxldCBoZWlnaHQgPSBwYWRkaW5nLmhlaWdodDtcbiAgbGV0IHdpZHRoID0gMDtcblxuICAvLyBDb3VudCBvZiBhbGwgbGluZXMgaW4gdGhlIGJvZHlcbiAgbGV0IGNvbWJpbmVkQm9keUxlbmd0aCA9IGJvZHkucmVkdWNlKChjb3VudCwgYm9keUl0ZW0pID0+IGNvdW50ICsgYm9keUl0ZW0uYmVmb3JlLmxlbmd0aCArIGJvZHlJdGVtLmxpbmVzLmxlbmd0aCArIGJvZHlJdGVtLmFmdGVyLmxlbmd0aCwgMCk7XG4gIGNvbWJpbmVkQm9keUxlbmd0aCArPSB0b29sdGlwLmJlZm9yZUJvZHkubGVuZ3RoICsgdG9vbHRpcC5hZnRlckJvZHkubGVuZ3RoO1xuXG4gIGlmICh0aXRsZUxpbmVDb3VudCkge1xuICAgIGhlaWdodCArPSB0aXRsZUxpbmVDb3VudCAqIHRpdGxlRm9udC5saW5lSGVpZ2h0XG5cdFx0XHQrICh0aXRsZUxpbmVDb3VudCAtIDEpICogb3B0aW9ucy50aXRsZVNwYWNpbmdcblx0XHRcdCsgb3B0aW9ucy50aXRsZU1hcmdpbkJvdHRvbTtcbiAgfVxuICBpZiAoY29tYmluZWRCb2R5TGVuZ3RoKSB7XG4gICAgLy8gQm9keSBsaW5lcyBtYXkgaW5jbHVkZSBzb21lIGV4dHJhIGhlaWdodCBkZXBlbmRpbmcgb24gYm94SGVpZ2h0XG4gICAgY29uc3QgYm9keUxpbmVIZWlnaHQgPSBvcHRpb25zLmRpc3BsYXlDb2xvcnMgPyBNYXRoLm1heChib3hIZWlnaHQsIGJvZHlGb250LmxpbmVIZWlnaHQpIDogYm9keUZvbnQubGluZUhlaWdodDtcbiAgICBoZWlnaHQgKz0gYm9keUxpbmVJdGVtQ291bnQgKiBib2R5TGluZUhlaWdodFxuXHRcdFx0KyAoY29tYmluZWRCb2R5TGVuZ3RoIC0gYm9keUxpbmVJdGVtQ291bnQpICogYm9keUZvbnQubGluZUhlaWdodFxuXHRcdFx0KyAoY29tYmluZWRCb2R5TGVuZ3RoIC0gMSkgKiBvcHRpb25zLmJvZHlTcGFjaW5nO1xuICB9XG4gIGlmIChmb290ZXJMaW5lQ291bnQpIHtcbiAgICBoZWlnaHQgKz0gb3B0aW9ucy5mb290ZXJNYXJnaW5Ub3Bcblx0XHRcdCsgZm9vdGVyTGluZUNvdW50ICogZm9vdGVyRm9udC5saW5lSGVpZ2h0XG5cdFx0XHQrIChmb290ZXJMaW5lQ291bnQgLSAxKSAqIG9wdGlvbnMuZm9vdGVyU3BhY2luZztcbiAgfVxuXG4gIC8vIFRpdGxlIHdpZHRoXG4gIGxldCB3aWR0aFBhZGRpbmcgPSAwO1xuICBjb25zdCBtYXhMaW5lV2lkdGggPSBmdW5jdGlvbihsaW5lKSB7XG4gICAgd2lkdGggPSBNYXRoLm1heCh3aWR0aCwgY3R4Lm1lYXN1cmVUZXh0KGxpbmUpLndpZHRoICsgd2lkdGhQYWRkaW5nKTtcbiAgfTtcblxuICBjdHguc2F2ZSgpO1xuXG4gIGN0eC5mb250ID0gdGl0bGVGb250LnN0cmluZztcbiAgZWFjaCh0b29sdGlwLnRpdGxlLCBtYXhMaW5lV2lkdGgpO1xuXG4gIC8vIEJvZHkgd2lkdGhcbiAgY3R4LmZvbnQgPSBib2R5Rm9udC5zdHJpbmc7XG4gIGVhY2godG9vbHRpcC5iZWZvcmVCb2R5LmNvbmNhdCh0b29sdGlwLmFmdGVyQm9keSksIG1heExpbmVXaWR0aCk7XG5cbiAgLy8gQm9keSBsaW5lcyBtYXkgaW5jbHVkZSBzb21lIGV4dHJhIHdpZHRoIGR1ZSB0byB0aGUgY29sb3IgYm94XG4gIHdpZHRoUGFkZGluZyA9IG9wdGlvbnMuZGlzcGxheUNvbG9ycyA/IChib3hXaWR0aCArIDIgKyBvcHRpb25zLmJveFBhZGRpbmcpIDogMDtcbiAgZWFjaChib2R5LCAoYm9keUl0ZW0pID0+IHtcbiAgICBlYWNoKGJvZHlJdGVtLmJlZm9yZSwgbWF4TGluZVdpZHRoKTtcbiAgICBlYWNoKGJvZHlJdGVtLmxpbmVzLCBtYXhMaW5lV2lkdGgpO1xuICAgIGVhY2goYm9keUl0ZW0uYWZ0ZXIsIG1heExpbmVXaWR0aCk7XG4gIH0pO1xuXG4gIC8vIFJlc2V0IGJhY2sgdG8gMFxuICB3aWR0aFBhZGRpbmcgPSAwO1xuXG4gIC8vIEZvb3RlciB3aWR0aFxuICBjdHguZm9udCA9IGZvb3RlckZvbnQuc3RyaW5nO1xuICBlYWNoKHRvb2x0aXAuZm9vdGVyLCBtYXhMaW5lV2lkdGgpO1xuXG4gIGN0eC5yZXN0b3JlKCk7XG5cbiAgLy8gQWRkIHBhZGRpbmdcbiAgd2lkdGggKz0gcGFkZGluZy53aWR0aDtcblxuICByZXR1cm4ge3dpZHRoLCBoZWlnaHR9O1xufVxuXG5mdW5jdGlvbiBkZXRlcm1pbmVZQWxpZ24oY2hhcnQsIHNpemUpIHtcbiAgY29uc3Qge3ksIGhlaWdodH0gPSBzaXplO1xuXG4gIGlmICh5IDwgaGVpZ2h0IC8gMikge1xuICAgIHJldHVybiAndG9wJztcbiAgfSBlbHNlIGlmICh5ID4gKGNoYXJ0LmhlaWdodCAtIGhlaWdodCAvIDIpKSB7XG4gICAgcmV0dXJuICdib3R0b20nO1xuICB9XG4gIHJldHVybiAnY2VudGVyJztcbn1cblxuZnVuY3Rpb24gZG9lc05vdEZpdFdpdGhBbGlnbih4QWxpZ24sIGNoYXJ0LCBvcHRpb25zLCBzaXplKSB7XG4gIGNvbnN0IHt4LCB3aWR0aH0gPSBzaXplO1xuICBjb25zdCBjYXJldCA9IG9wdGlvbnMuY2FyZXRTaXplICsgb3B0aW9ucy5jYXJldFBhZGRpbmc7XG4gIGlmICh4QWxpZ24gPT09ICdsZWZ0JyAmJiB4ICsgd2lkdGggKyBjYXJldCA+IGNoYXJ0LndpZHRoKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBpZiAoeEFsaWduID09PSAncmlnaHQnICYmIHggLSB3aWR0aCAtIGNhcmV0IDwgMCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG59XG5cbmZ1bmN0aW9uIGRldGVybWluZVhBbGlnbihjaGFydCwgb3B0aW9ucywgc2l6ZSwgeUFsaWduKSB7XG4gIGNvbnN0IHt4LCB3aWR0aH0gPSBzaXplO1xuICBjb25zdCB7d2lkdGg6IGNoYXJ0V2lkdGgsIGNoYXJ0QXJlYToge2xlZnQsIHJpZ2h0fX0gPSBjaGFydDtcbiAgbGV0IHhBbGlnbiA9ICdjZW50ZXInO1xuXG4gIGlmICh5QWxpZ24gPT09ICdjZW50ZXInKSB7XG4gICAgeEFsaWduID0geCA8PSAobGVmdCArIHJpZ2h0KSAvIDIgPyAnbGVmdCcgOiAncmlnaHQnO1xuICB9IGVsc2UgaWYgKHggPD0gd2lkdGggLyAyKSB7XG4gICAgeEFsaWduID0gJ2xlZnQnO1xuICB9IGVsc2UgaWYgKHggPj0gY2hhcnRXaWR0aCAtIHdpZHRoIC8gMikge1xuICAgIHhBbGlnbiA9ICdyaWdodCc7XG4gIH1cblxuICBpZiAoZG9lc05vdEZpdFdpdGhBbGlnbih4QWxpZ24sIGNoYXJ0LCBvcHRpb25zLCBzaXplKSkge1xuICAgIHhBbGlnbiA9ICdjZW50ZXInO1xuICB9XG5cbiAgcmV0dXJuIHhBbGlnbjtcbn1cblxuLyoqXG4gKiBIZWxwZXIgdG8gZ2V0IHRoZSBhbGlnbm1lbnQgb2YgYSB0b29sdGlwIGdpdmVuIHRoZSBzaXplXG4gKi9cbmZ1bmN0aW9uIGRldGVybWluZUFsaWdubWVudChjaGFydCwgb3B0aW9ucywgc2l6ZSkge1xuICBjb25zdCB5QWxpZ24gPSBzaXplLnlBbGlnbiB8fCBvcHRpb25zLnlBbGlnbiB8fCBkZXRlcm1pbmVZQWxpZ24oY2hhcnQsIHNpemUpO1xuXG4gIHJldHVybiB7XG4gICAgeEFsaWduOiBzaXplLnhBbGlnbiB8fCBvcHRpb25zLnhBbGlnbiB8fCBkZXRlcm1pbmVYQWxpZ24oY2hhcnQsIG9wdGlvbnMsIHNpemUsIHlBbGlnbiksXG4gICAgeUFsaWduXG4gIH07XG59XG5cbmZ1bmN0aW9uIGFsaWduWChzaXplLCB4QWxpZ24pIHtcbiAgbGV0IHt4LCB3aWR0aH0gPSBzaXplO1xuICBpZiAoeEFsaWduID09PSAncmlnaHQnKSB7XG4gICAgeCAtPSB3aWR0aDtcbiAgfSBlbHNlIGlmICh4QWxpZ24gPT09ICdjZW50ZXInKSB7XG4gICAgeCAtPSAod2lkdGggLyAyKTtcbiAgfVxuICByZXR1cm4geDtcbn1cblxuZnVuY3Rpb24gYWxpZ25ZKHNpemUsIHlBbGlnbiwgcGFkZGluZ0FuZFNpemUpIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHByZWZlci1jb25zdFxuICBsZXQge3ksIGhlaWdodH0gPSBzaXplO1xuICBpZiAoeUFsaWduID09PSAndG9wJykge1xuICAgIHkgKz0gcGFkZGluZ0FuZFNpemU7XG4gIH0gZWxzZSBpZiAoeUFsaWduID09PSAnYm90dG9tJykge1xuICAgIHkgLT0gaGVpZ2h0ICsgcGFkZGluZ0FuZFNpemU7XG4gIH0gZWxzZSB7XG4gICAgeSAtPSAoaGVpZ2h0IC8gMik7XG4gIH1cbiAgcmV0dXJuIHk7XG59XG5cbi8qKlxuICogSGVscGVyIHRvIGdldCB0aGUgbG9jYXRpb24gYSB0b29sdGlwIG5lZWRzIHRvIGJlIHBsYWNlZCBhdCBnaXZlbiB0aGUgaW5pdGlhbCBwb3NpdGlvbiAodmlhIHRoZSB2bSkgYW5kIHRoZSBzaXplIGFuZCBhbGlnbm1lbnRcbiAqL1xuZnVuY3Rpb24gZ2V0QmFja2dyb3VuZFBvaW50KG9wdGlvbnMsIHNpemUsIGFsaWdubWVudCwgY2hhcnQpIHtcbiAgY29uc3Qge2NhcmV0U2l6ZSwgY2FyZXRQYWRkaW5nLCBjb3JuZXJSYWRpdXN9ID0gb3B0aW9ucztcbiAgY29uc3Qge3hBbGlnbiwgeUFsaWdufSA9IGFsaWdubWVudDtcbiAgY29uc3QgcGFkZGluZ0FuZFNpemUgPSBjYXJldFNpemUgKyBjYXJldFBhZGRpbmc7XG4gIGNvbnN0IHt0b3BMZWZ0LCB0b3BSaWdodCwgYm90dG9tTGVmdCwgYm90dG9tUmlnaHR9ID0gdG9UUkJMQ29ybmVycyhjb3JuZXJSYWRpdXMpO1xuXG4gIGxldCB4ID0gYWxpZ25YKHNpemUsIHhBbGlnbik7XG4gIGNvbnN0IHkgPSBhbGlnblkoc2l6ZSwgeUFsaWduLCBwYWRkaW5nQW5kU2l6ZSk7XG5cbiAgaWYgKHlBbGlnbiA9PT0gJ2NlbnRlcicpIHtcbiAgICBpZiAoeEFsaWduID09PSAnbGVmdCcpIHtcbiAgICAgIHggKz0gcGFkZGluZ0FuZFNpemU7XG4gICAgfSBlbHNlIGlmICh4QWxpZ24gPT09ICdyaWdodCcpIHtcbiAgICAgIHggLT0gcGFkZGluZ0FuZFNpemU7XG4gICAgfVxuICB9IGVsc2UgaWYgKHhBbGlnbiA9PT0gJ2xlZnQnKSB7XG4gICAgeCAtPSBNYXRoLm1heCh0b3BMZWZ0LCBib3R0b21MZWZ0KSArIGNhcmV0U2l6ZTtcbiAgfSBlbHNlIGlmICh4QWxpZ24gPT09ICdyaWdodCcpIHtcbiAgICB4ICs9IE1hdGgubWF4KHRvcFJpZ2h0LCBib3R0b21SaWdodCkgKyBjYXJldFNpemU7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHg6IF9saW1pdFZhbHVlKHgsIDAsIGNoYXJ0LndpZHRoIC0gc2l6ZS53aWR0aCksXG4gICAgeTogX2xpbWl0VmFsdWUoeSwgMCwgY2hhcnQuaGVpZ2h0IC0gc2l6ZS5oZWlnaHQpXG4gIH07XG59XG5cbmZ1bmN0aW9uIGdldEFsaWduZWRYKHRvb2x0aXAsIGFsaWduLCBvcHRpb25zKSB7XG4gIGNvbnN0IHBhZGRpbmcgPSB0b1BhZGRpbmcob3B0aW9ucy5wYWRkaW5nKTtcblxuICByZXR1cm4gYWxpZ24gPT09ICdjZW50ZXInXG4gICAgPyB0b29sdGlwLnggKyB0b29sdGlwLndpZHRoIC8gMlxuICAgIDogYWxpZ24gPT09ICdyaWdodCdcbiAgICAgID8gdG9vbHRpcC54ICsgdG9vbHRpcC53aWR0aCAtIHBhZGRpbmcucmlnaHRcbiAgICAgIDogdG9vbHRpcC54ICsgcGFkZGluZy5sZWZ0O1xufVxuXG4vKipcbiAqIEhlbHBlciB0byBidWlsZCBiZWZvcmUgYW5kIGFmdGVyIGJvZHkgbGluZXNcbiAqL1xuZnVuY3Rpb24gZ2V0QmVmb3JlQWZ0ZXJCb2R5TGluZXMoY2FsbGJhY2spIHtcbiAgcmV0dXJuIHB1c2hPckNvbmNhdChbXSwgc3BsaXROZXdsaW5lcyhjYWxsYmFjaykpO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVUb29sdGlwQ29udGV4dChwYXJlbnQsIHRvb2x0aXAsIHRvb2x0aXBJdGVtcykge1xuICByZXR1cm4gY3JlYXRlQ29udGV4dChwYXJlbnQsIHtcbiAgICB0b29sdGlwLFxuICAgIHRvb2x0aXBJdGVtcyxcbiAgICB0eXBlOiAndG9vbHRpcCdcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIG92ZXJyaWRlQ2FsbGJhY2tzKGNhbGxiYWNrcywgY29udGV4dCkge1xuICBjb25zdCBvdmVycmlkZSA9IGNvbnRleHQgJiYgY29udGV4dC5kYXRhc2V0ICYmIGNvbnRleHQuZGF0YXNldC50b29sdGlwICYmIGNvbnRleHQuZGF0YXNldC50b29sdGlwLmNhbGxiYWNrcztcbiAgcmV0dXJuIG92ZXJyaWRlID8gY2FsbGJhY2tzLm92ZXJyaWRlKG92ZXJyaWRlKSA6IGNhbGxiYWNrcztcbn1cblxuY29uc3QgZGVmYXVsdENhbGxiYWNrcyA9IHtcbiAgLy8gQXJncyBhcmU6ICh0b29sdGlwSXRlbXMsIGRhdGEpXG4gIGJlZm9yZVRpdGxlOiBub29wLFxuICB0aXRsZSh0b29sdGlwSXRlbXMpIHtcbiAgICBpZiAodG9vbHRpcEl0ZW1zLmxlbmd0aCA+IDApIHtcbiAgICAgIGNvbnN0IGl0ZW0gPSB0b29sdGlwSXRlbXNbMF07XG4gICAgICBjb25zdCBsYWJlbHMgPSBpdGVtLmNoYXJ0LmRhdGEubGFiZWxzO1xuICAgICAgY29uc3QgbGFiZWxDb3VudCA9IGxhYmVscyA/IGxhYmVscy5sZW5ndGggOiAwO1xuXG4gICAgICBpZiAodGhpcyAmJiB0aGlzLm9wdGlvbnMgJiYgdGhpcy5vcHRpb25zLm1vZGUgPT09ICdkYXRhc2V0Jykge1xuICAgICAgICByZXR1cm4gaXRlbS5kYXRhc2V0LmxhYmVsIHx8ICcnO1xuICAgICAgfSBlbHNlIGlmIChpdGVtLmxhYmVsKSB7XG4gICAgICAgIHJldHVybiBpdGVtLmxhYmVsO1xuICAgICAgfSBlbHNlIGlmIChsYWJlbENvdW50ID4gMCAmJiBpdGVtLmRhdGFJbmRleCA8IGxhYmVsQ291bnQpIHtcbiAgICAgICAgcmV0dXJuIGxhYmVsc1tpdGVtLmRhdGFJbmRleF07XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuICcnO1xuICB9LFxuICBhZnRlclRpdGxlOiBub29wLFxuXG4gIC8vIEFyZ3MgYXJlOiAodG9vbHRpcEl0ZW1zLCBkYXRhKVxuICBiZWZvcmVCb2R5OiBub29wLFxuXG4gIC8vIEFyZ3MgYXJlOiAodG9vbHRpcEl0ZW0sIGRhdGEpXG4gIGJlZm9yZUxhYmVsOiBub29wLFxuICBsYWJlbCh0b29sdGlwSXRlbSkge1xuICAgIGlmICh0aGlzICYmIHRoaXMub3B0aW9ucyAmJiB0aGlzLm9wdGlvbnMubW9kZSA9PT0gJ2RhdGFzZXQnKSB7XG4gICAgICByZXR1cm4gdG9vbHRpcEl0ZW0ubGFiZWwgKyAnOiAnICsgdG9vbHRpcEl0ZW0uZm9ybWF0dGVkVmFsdWUgfHwgdG9vbHRpcEl0ZW0uZm9ybWF0dGVkVmFsdWU7XG4gICAgfVxuXG4gICAgbGV0IGxhYmVsID0gdG9vbHRpcEl0ZW0uZGF0YXNldC5sYWJlbCB8fCAnJztcblxuICAgIGlmIChsYWJlbCkge1xuICAgICAgbGFiZWwgKz0gJzogJztcbiAgICB9XG4gICAgY29uc3QgdmFsdWUgPSB0b29sdGlwSXRlbS5mb3JtYXR0ZWRWYWx1ZTtcbiAgICBpZiAoIWlzTnVsbE9yVW5kZWYodmFsdWUpKSB7XG4gICAgICBsYWJlbCArPSB2YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGxhYmVsO1xuICB9LFxuICBsYWJlbENvbG9yKHRvb2x0aXBJdGVtKSB7XG4gICAgY29uc3QgbWV0YSA9IHRvb2x0aXBJdGVtLmNoYXJ0LmdldERhdGFzZXRNZXRhKHRvb2x0aXBJdGVtLmRhdGFzZXRJbmRleCk7XG4gICAgY29uc3Qgb3B0aW9ucyA9IG1ldGEuY29udHJvbGxlci5nZXRTdHlsZSh0b29sdGlwSXRlbS5kYXRhSW5kZXgpO1xuICAgIHJldHVybiB7XG4gICAgICBib3JkZXJDb2xvcjogb3B0aW9ucy5ib3JkZXJDb2xvcixcbiAgICAgIGJhY2tncm91bmRDb2xvcjogb3B0aW9ucy5iYWNrZ3JvdW5kQ29sb3IsXG4gICAgICBib3JkZXJXaWR0aDogb3B0aW9ucy5ib3JkZXJXaWR0aCxcbiAgICAgIGJvcmRlckRhc2g6IG9wdGlvbnMuYm9yZGVyRGFzaCxcbiAgICAgIGJvcmRlckRhc2hPZmZzZXQ6IG9wdGlvbnMuYm9yZGVyRGFzaE9mZnNldCxcbiAgICAgIGJvcmRlclJhZGl1czogMCxcbiAgICB9O1xuICB9LFxuICBsYWJlbFRleHRDb2xvcigpIHtcbiAgICByZXR1cm4gdGhpcy5vcHRpb25zLmJvZHlDb2xvcjtcbiAgfSxcbiAgbGFiZWxQb2ludFN0eWxlKHRvb2x0aXBJdGVtKSB7XG4gICAgY29uc3QgbWV0YSA9IHRvb2x0aXBJdGVtLmNoYXJ0LmdldERhdGFzZXRNZXRhKHRvb2x0aXBJdGVtLmRhdGFzZXRJbmRleCk7XG4gICAgY29uc3Qgb3B0aW9ucyA9IG1ldGEuY29udHJvbGxlci5nZXRTdHlsZSh0b29sdGlwSXRlbS5kYXRhSW5kZXgpO1xuICAgIHJldHVybiB7XG4gICAgICBwb2ludFN0eWxlOiBvcHRpb25zLnBvaW50U3R5bGUsXG4gICAgICByb3RhdGlvbjogb3B0aW9ucy5yb3RhdGlvbixcbiAgICB9O1xuICB9LFxuICBhZnRlckxhYmVsOiBub29wLFxuXG4gIC8vIEFyZ3MgYXJlOiAodG9vbHRpcEl0ZW1zLCBkYXRhKVxuICBhZnRlckJvZHk6IG5vb3AsXG5cbiAgLy8gQXJncyBhcmU6ICh0b29sdGlwSXRlbXMsIGRhdGEpXG4gIGJlZm9yZUZvb3Rlcjogbm9vcCxcbiAgZm9vdGVyOiBub29wLFxuICBhZnRlckZvb3Rlcjogbm9vcFxufTtcblxuLyoqXG4gKiBJbnZva2UgY2FsbGJhY2sgZnJvbSBvYmplY3Qgd2l0aCBjb250ZXh0IGFuZCBhcmd1bWVudHMuXG4gKiBJZiBjYWxsYmFjayByZXR1cm5zIGB1bmRlZmluZWRgLCB0aGVuIHdpbGwgYmUgaW52b2tlZCBkZWZhdWx0IGNhbGxiYWNrLlxuICogQHBhcmFtIHtSZWNvcmQ8a2V5b2YgdHlwZW9mIGRlZmF1bHRDYWxsYmFja3MsIEZ1bmN0aW9uPn0gY2FsbGJhY2tzXG4gKiBAcGFyYW0ge2tleW9mIHR5cGVvZiBkZWZhdWx0Q2FsbGJhY2tzfSBuYW1lXG4gKiBAcGFyYW0geyp9IGN0eFxuICogQHBhcmFtIHsqfSBhcmdcbiAqIEByZXR1cm5zIHthbnl9XG4gKi9cbmZ1bmN0aW9uIGludm9rZUNhbGxiYWNrV2l0aEZhbGxiYWNrKGNhbGxiYWNrcywgbmFtZSwgY3R4LCBhcmcpIHtcbiAgY29uc3QgcmVzdWx0ID0gY2FsbGJhY2tzW25hbWVdLmNhbGwoY3R4LCBhcmcpO1xuXG4gIGlmICh0eXBlb2YgcmVzdWx0ID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBkZWZhdWx0Q2FsbGJhY2tzW25hbWVdLmNhbGwoY3R4LCBhcmcpO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZXhwb3J0IGNsYXNzIFRvb2x0aXAgZXh0ZW5kcyBFbGVtZW50IHtcblxuICAvKipcbiAgICogQG5hbWVzcGFjZSBDaGFydC5Ub29sdGlwLnBvc2l0aW9uZXJzXG4gICAqL1xuICBzdGF0aWMgcG9zaXRpb25lcnMgPSBwb3NpdGlvbmVycztcblxuICBjb25zdHJ1Y3Rvcihjb25maWcpIHtcbiAgICBzdXBlcigpO1xuXG4gICAgdGhpcy5vcGFjaXR5ID0gMDtcbiAgICB0aGlzLl9hY3RpdmUgPSBbXTtcbiAgICB0aGlzLl9ldmVudFBvc2l0aW9uID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX3NpemUgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fY2FjaGVkQW5pbWF0aW9ucyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl90b29sdGlwSXRlbXMgPSBbXTtcbiAgICB0aGlzLiRhbmltYXRpb25zID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuJGNvbnRleHQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5jaGFydCA9IGNvbmZpZy5jaGFydDtcbiAgICB0aGlzLm9wdGlvbnMgPSBjb25maWcub3B0aW9ucztcbiAgICB0aGlzLmRhdGFQb2ludHMgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy50aXRsZSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmJlZm9yZUJvZHkgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5ib2R5ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuYWZ0ZXJCb2R5ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuZm9vdGVyID0gdW5kZWZpbmVkO1xuICAgIHRoaXMueEFsaWduID0gdW5kZWZpbmVkO1xuICAgIHRoaXMueUFsaWduID0gdW5kZWZpbmVkO1xuICAgIHRoaXMueCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnkgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5oZWlnaHQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy53aWR0aCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmNhcmV0WCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmNhcmV0WSA9IHVuZGVmaW5lZDtcbiAgICAvLyBUT0RPOiBWNCwgbWFrZSB0aGlzIHByaXZhdGUsIHJlbmFtZSB0byBgX2xhYmVsU3R5bGVzYCwgYW5kIGNvbWJpbmUgd2l0aCBgbGFiZWxQb2ludFN0eWxlc2BcbiAgICAvLyBhbmQgYGxhYmVsVGV4dENvbG9yc2AgdG8gY3JlYXRlIGEgc2luZ2xlIHZhcmlhYmxlXG4gICAgdGhpcy5sYWJlbENvbG9ycyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmxhYmVsUG9pbnRTdHlsZXMgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5sYWJlbFRleHRDb2xvcnMgPSB1bmRlZmluZWQ7XG4gIH1cblxuICBpbml0aWFsaXplKG9wdGlvbnMpIHtcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgIHRoaXMuX2NhY2hlZEFuaW1hdGlvbnMgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy4kY29udGV4dCA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgX3Jlc29sdmVBbmltYXRpb25zKCkge1xuICAgIGNvbnN0IGNhY2hlZCA9IHRoaXMuX2NhY2hlZEFuaW1hdGlvbnM7XG5cbiAgICBpZiAoY2FjaGVkKSB7XG4gICAgICByZXR1cm4gY2FjaGVkO1xuICAgIH1cblxuICAgIGNvbnN0IGNoYXJ0ID0gdGhpcy5jaGFydDtcbiAgICBjb25zdCBvcHRpb25zID0gdGhpcy5vcHRpb25zLnNldENvbnRleHQodGhpcy5nZXRDb250ZXh0KCkpO1xuICAgIGNvbnN0IG9wdHMgPSBvcHRpb25zLmVuYWJsZWQgJiYgY2hhcnQub3B0aW9ucy5hbmltYXRpb24gJiYgb3B0aW9ucy5hbmltYXRpb25zO1xuICAgIGNvbnN0IGFuaW1hdGlvbnMgPSBuZXcgQW5pbWF0aW9ucyh0aGlzLmNoYXJ0LCBvcHRzKTtcbiAgICBpZiAob3B0cy5fY2FjaGVhYmxlKSB7XG4gICAgICB0aGlzLl9jYWNoZWRBbmltYXRpb25zID0gT2JqZWN0LmZyZWV6ZShhbmltYXRpb25zKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYW5pbWF0aW9ucztcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuICBnZXRDb250ZXh0KCkge1xuICAgIHJldHVybiB0aGlzLiRjb250ZXh0IHx8XG5cdFx0XHQodGhpcy4kY29udGV4dCA9IGNyZWF0ZVRvb2x0aXBDb250ZXh0KHRoaXMuY2hhcnQuZ2V0Q29udGV4dCgpLCB0aGlzLCB0aGlzLl90b29sdGlwSXRlbXMpKTtcbiAgfVxuXG4gIGdldFRpdGxlKGNvbnRleHQsIG9wdGlvbnMpIHtcbiAgICBjb25zdCB7Y2FsbGJhY2tzfSA9IG9wdGlvbnM7XG5cbiAgICBjb25zdCBiZWZvcmVUaXRsZSA9IGludm9rZUNhbGxiYWNrV2l0aEZhbGxiYWNrKGNhbGxiYWNrcywgJ2JlZm9yZVRpdGxlJywgdGhpcywgY29udGV4dCk7XG4gICAgY29uc3QgdGl0bGUgPSBpbnZva2VDYWxsYmFja1dpdGhGYWxsYmFjayhjYWxsYmFja3MsICd0aXRsZScsIHRoaXMsIGNvbnRleHQpO1xuICAgIGNvbnN0IGFmdGVyVGl0bGUgPSBpbnZva2VDYWxsYmFja1dpdGhGYWxsYmFjayhjYWxsYmFja3MsICdhZnRlclRpdGxlJywgdGhpcywgY29udGV4dCk7XG5cbiAgICBsZXQgbGluZXMgPSBbXTtcbiAgICBsaW5lcyA9IHB1c2hPckNvbmNhdChsaW5lcywgc3BsaXROZXdsaW5lcyhiZWZvcmVUaXRsZSkpO1xuICAgIGxpbmVzID0gcHVzaE9yQ29uY2F0KGxpbmVzLCBzcGxpdE5ld2xpbmVzKHRpdGxlKSk7XG4gICAgbGluZXMgPSBwdXNoT3JDb25jYXQobGluZXMsIHNwbGl0TmV3bGluZXMoYWZ0ZXJUaXRsZSkpO1xuXG4gICAgcmV0dXJuIGxpbmVzO1xuICB9XG5cbiAgZ2V0QmVmb3JlQm9keSh0b29sdGlwSXRlbXMsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gZ2V0QmVmb3JlQWZ0ZXJCb2R5TGluZXMoXG4gICAgICBpbnZva2VDYWxsYmFja1dpdGhGYWxsYmFjayhvcHRpb25zLmNhbGxiYWNrcywgJ2JlZm9yZUJvZHknLCB0aGlzLCB0b29sdGlwSXRlbXMpXG4gICAgKTtcbiAgfVxuXG4gIGdldEJvZHkodG9vbHRpcEl0ZW1zLCBvcHRpb25zKSB7XG4gICAgY29uc3Qge2NhbGxiYWNrc30gPSBvcHRpb25zO1xuICAgIGNvbnN0IGJvZHlJdGVtcyA9IFtdO1xuXG4gICAgZWFjaCh0b29sdGlwSXRlbXMsIChjb250ZXh0KSA9PiB7XG4gICAgICBjb25zdCBib2R5SXRlbSA9IHtcbiAgICAgICAgYmVmb3JlOiBbXSxcbiAgICAgICAgbGluZXM6IFtdLFxuICAgICAgICBhZnRlcjogW11cbiAgICAgIH07XG4gICAgICBjb25zdCBzY29wZWQgPSBvdmVycmlkZUNhbGxiYWNrcyhjYWxsYmFja3MsIGNvbnRleHQpO1xuICAgICAgcHVzaE9yQ29uY2F0KGJvZHlJdGVtLmJlZm9yZSwgc3BsaXROZXdsaW5lcyhpbnZva2VDYWxsYmFja1dpdGhGYWxsYmFjayhzY29wZWQsICdiZWZvcmVMYWJlbCcsIHRoaXMsIGNvbnRleHQpKSk7XG4gICAgICBwdXNoT3JDb25jYXQoYm9keUl0ZW0ubGluZXMsIGludm9rZUNhbGxiYWNrV2l0aEZhbGxiYWNrKHNjb3BlZCwgJ2xhYmVsJywgdGhpcywgY29udGV4dCkpO1xuICAgICAgcHVzaE9yQ29uY2F0KGJvZHlJdGVtLmFmdGVyLCBzcGxpdE5ld2xpbmVzKGludm9rZUNhbGxiYWNrV2l0aEZhbGxiYWNrKHNjb3BlZCwgJ2FmdGVyTGFiZWwnLCB0aGlzLCBjb250ZXh0KSkpO1xuXG4gICAgICBib2R5SXRlbXMucHVzaChib2R5SXRlbSk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gYm9keUl0ZW1zO1xuICB9XG5cbiAgZ2V0QWZ0ZXJCb2R5KHRvb2x0aXBJdGVtcywgb3B0aW9ucykge1xuICAgIHJldHVybiBnZXRCZWZvcmVBZnRlckJvZHlMaW5lcyhcbiAgICAgIGludm9rZUNhbGxiYWNrV2l0aEZhbGxiYWNrKG9wdGlvbnMuY2FsbGJhY2tzLCAnYWZ0ZXJCb2R5JywgdGhpcywgdG9vbHRpcEl0ZW1zKVxuICAgICk7XG4gIH1cblxuICAvLyBHZXQgdGhlIGZvb3RlciBhbmQgYmVmb3JlRm9vdGVyIGFuZCBhZnRlckZvb3RlciBsaW5lc1xuICBnZXRGb290ZXIodG9vbHRpcEl0ZW1zLCBvcHRpb25zKSB7XG4gICAgY29uc3Qge2NhbGxiYWNrc30gPSBvcHRpb25zO1xuXG4gICAgY29uc3QgYmVmb3JlRm9vdGVyID0gaW52b2tlQ2FsbGJhY2tXaXRoRmFsbGJhY2soY2FsbGJhY2tzLCAnYmVmb3JlRm9vdGVyJywgdGhpcywgdG9vbHRpcEl0ZW1zKTtcbiAgICBjb25zdCBmb290ZXIgPSBpbnZva2VDYWxsYmFja1dpdGhGYWxsYmFjayhjYWxsYmFja3MsICdmb290ZXInLCB0aGlzLCB0b29sdGlwSXRlbXMpO1xuICAgIGNvbnN0IGFmdGVyRm9vdGVyID0gaW52b2tlQ2FsbGJhY2tXaXRoRmFsbGJhY2soY2FsbGJhY2tzLCAnYWZ0ZXJGb290ZXInLCB0aGlzLCB0b29sdGlwSXRlbXMpO1xuXG4gICAgbGV0IGxpbmVzID0gW107XG4gICAgbGluZXMgPSBwdXNoT3JDb25jYXQobGluZXMsIHNwbGl0TmV3bGluZXMoYmVmb3JlRm9vdGVyKSk7XG4gICAgbGluZXMgPSBwdXNoT3JDb25jYXQobGluZXMsIHNwbGl0TmV3bGluZXMoZm9vdGVyKSk7XG4gICAgbGluZXMgPSBwdXNoT3JDb25jYXQobGluZXMsIHNwbGl0TmV3bGluZXMoYWZ0ZXJGb290ZXIpKTtcblxuICAgIHJldHVybiBsaW5lcztcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgX2NyZWF0ZUl0ZW1zKG9wdGlvbnMpIHtcbiAgICBjb25zdCBhY3RpdmUgPSB0aGlzLl9hY3RpdmU7XG4gICAgY29uc3QgZGF0YSA9IHRoaXMuY2hhcnQuZGF0YTtcbiAgICBjb25zdCBsYWJlbENvbG9ycyA9IFtdO1xuICAgIGNvbnN0IGxhYmVsUG9pbnRTdHlsZXMgPSBbXTtcbiAgICBjb25zdCBsYWJlbFRleHRDb2xvcnMgPSBbXTtcbiAgICBsZXQgdG9vbHRpcEl0ZW1zID0gW107XG4gICAgbGV0IGksIGxlbjtcblxuICAgIGZvciAoaSA9IDAsIGxlbiA9IGFjdGl2ZS5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgICAgdG9vbHRpcEl0ZW1zLnB1c2goY3JlYXRlVG9vbHRpcEl0ZW0odGhpcy5jaGFydCwgYWN0aXZlW2ldKSk7XG4gICAgfVxuXG4gICAgLy8gSWYgdGhlIHVzZXIgcHJvdmlkZWQgYSBmaWx0ZXIgZnVuY3Rpb24sIHVzZSBpdCB0byBtb2RpZnkgdGhlIHRvb2x0aXAgaXRlbXNcbiAgICBpZiAob3B0aW9ucy5maWx0ZXIpIHtcbiAgICAgIHRvb2x0aXBJdGVtcyA9IHRvb2x0aXBJdGVtcy5maWx0ZXIoKGVsZW1lbnQsIGluZGV4LCBhcnJheSkgPT4gb3B0aW9ucy5maWx0ZXIoZWxlbWVudCwgaW5kZXgsIGFycmF5LCBkYXRhKSk7XG4gICAgfVxuXG4gICAgLy8gSWYgdGhlIHVzZXIgcHJvdmlkZWQgYSBzb3J0aW5nIGZ1bmN0aW9uLCB1c2UgaXQgdG8gbW9kaWZ5IHRoZSB0b29sdGlwIGl0ZW1zXG4gICAgaWYgKG9wdGlvbnMuaXRlbVNvcnQpIHtcbiAgICAgIHRvb2x0aXBJdGVtcyA9IHRvb2x0aXBJdGVtcy5zb3J0KChhLCBiKSA9PiBvcHRpb25zLml0ZW1Tb3J0KGEsIGIsIGRhdGEpKTtcbiAgICB9XG5cbiAgICAvLyBEZXRlcm1pbmUgY29sb3JzIGZvciBib3hlc1xuICAgIGVhY2godG9vbHRpcEl0ZW1zLCAoY29udGV4dCkgPT4ge1xuICAgICAgY29uc3Qgc2NvcGVkID0gb3ZlcnJpZGVDYWxsYmFja3Mob3B0aW9ucy5jYWxsYmFja3MsIGNvbnRleHQpO1xuICAgICAgbGFiZWxDb2xvcnMucHVzaChpbnZva2VDYWxsYmFja1dpdGhGYWxsYmFjayhzY29wZWQsICdsYWJlbENvbG9yJywgdGhpcywgY29udGV4dCkpO1xuICAgICAgbGFiZWxQb2ludFN0eWxlcy5wdXNoKGludm9rZUNhbGxiYWNrV2l0aEZhbGxiYWNrKHNjb3BlZCwgJ2xhYmVsUG9pbnRTdHlsZScsIHRoaXMsIGNvbnRleHQpKTtcbiAgICAgIGxhYmVsVGV4dENvbG9ycy5wdXNoKGludm9rZUNhbGxiYWNrV2l0aEZhbGxiYWNrKHNjb3BlZCwgJ2xhYmVsVGV4dENvbG9yJywgdGhpcywgY29udGV4dCkpO1xuICAgIH0pO1xuXG4gICAgdGhpcy5sYWJlbENvbG9ycyA9IGxhYmVsQ29sb3JzO1xuICAgIHRoaXMubGFiZWxQb2ludFN0eWxlcyA9IGxhYmVsUG9pbnRTdHlsZXM7XG4gICAgdGhpcy5sYWJlbFRleHRDb2xvcnMgPSBsYWJlbFRleHRDb2xvcnM7XG4gICAgdGhpcy5kYXRhUG9pbnRzID0gdG9vbHRpcEl0ZW1zO1xuICAgIHJldHVybiB0b29sdGlwSXRlbXM7XG4gIH1cblxuICB1cGRhdGUoY2hhbmdlZCwgcmVwbGF5KSB7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMub3B0aW9ucy5zZXRDb250ZXh0KHRoaXMuZ2V0Q29udGV4dCgpKTtcbiAgICBjb25zdCBhY3RpdmUgPSB0aGlzLl9hY3RpdmU7XG4gICAgbGV0IHByb3BlcnRpZXM7XG4gICAgbGV0IHRvb2x0aXBJdGVtcyA9IFtdO1xuXG4gICAgaWYgKCFhY3RpdmUubGVuZ3RoKSB7XG4gICAgICBpZiAodGhpcy5vcGFjaXR5ICE9PSAwKSB7XG4gICAgICAgIHByb3BlcnRpZXMgPSB7XG4gICAgICAgICAgb3BhY2l0eTogMFxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBwb3NpdGlvbiA9IHBvc2l0aW9uZXJzW29wdGlvbnMucG9zaXRpb25dLmNhbGwodGhpcywgYWN0aXZlLCB0aGlzLl9ldmVudFBvc2l0aW9uKTtcbiAgICAgIHRvb2x0aXBJdGVtcyA9IHRoaXMuX2NyZWF0ZUl0ZW1zKG9wdGlvbnMpO1xuXG4gICAgICB0aGlzLnRpdGxlID0gdGhpcy5nZXRUaXRsZSh0b29sdGlwSXRlbXMsIG9wdGlvbnMpO1xuICAgICAgdGhpcy5iZWZvcmVCb2R5ID0gdGhpcy5nZXRCZWZvcmVCb2R5KHRvb2x0aXBJdGVtcywgb3B0aW9ucyk7XG4gICAgICB0aGlzLmJvZHkgPSB0aGlzLmdldEJvZHkodG9vbHRpcEl0ZW1zLCBvcHRpb25zKTtcbiAgICAgIHRoaXMuYWZ0ZXJCb2R5ID0gdGhpcy5nZXRBZnRlckJvZHkodG9vbHRpcEl0ZW1zLCBvcHRpb25zKTtcbiAgICAgIHRoaXMuZm9vdGVyID0gdGhpcy5nZXRGb290ZXIodG9vbHRpcEl0ZW1zLCBvcHRpb25zKTtcblxuICAgICAgY29uc3Qgc2l6ZSA9IHRoaXMuX3NpemUgPSBnZXRUb29sdGlwU2l6ZSh0aGlzLCBvcHRpb25zKTtcbiAgICAgIGNvbnN0IHBvc2l0aW9uQW5kU2l6ZSA9IE9iamVjdC5hc3NpZ24oe30sIHBvc2l0aW9uLCBzaXplKTtcbiAgICAgIGNvbnN0IGFsaWdubWVudCA9IGRldGVybWluZUFsaWdubWVudCh0aGlzLmNoYXJ0LCBvcHRpb25zLCBwb3NpdGlvbkFuZFNpemUpO1xuICAgICAgY29uc3QgYmFja2dyb3VuZFBvaW50ID0gZ2V0QmFja2dyb3VuZFBvaW50KG9wdGlvbnMsIHBvc2l0aW9uQW5kU2l6ZSwgYWxpZ25tZW50LCB0aGlzLmNoYXJ0KTtcblxuICAgICAgdGhpcy54QWxpZ24gPSBhbGlnbm1lbnQueEFsaWduO1xuICAgICAgdGhpcy55QWxpZ24gPSBhbGlnbm1lbnQueUFsaWduO1xuXG4gICAgICBwcm9wZXJ0aWVzID0ge1xuICAgICAgICBvcGFjaXR5OiAxLFxuICAgICAgICB4OiBiYWNrZ3JvdW5kUG9pbnQueCxcbiAgICAgICAgeTogYmFja2dyb3VuZFBvaW50LnksXG4gICAgICAgIHdpZHRoOiBzaXplLndpZHRoLFxuICAgICAgICBoZWlnaHQ6IHNpemUuaGVpZ2h0LFxuICAgICAgICBjYXJldFg6IHBvc2l0aW9uLngsXG4gICAgICAgIGNhcmV0WTogcG9zaXRpb24ueVxuICAgICAgfTtcbiAgICB9XG5cbiAgICB0aGlzLl90b29sdGlwSXRlbXMgPSB0b29sdGlwSXRlbXM7XG4gICAgdGhpcy4kY29udGV4dCA9IHVuZGVmaW5lZDtcblxuICAgIGlmIChwcm9wZXJ0aWVzKSB7XG4gICAgICB0aGlzLl9yZXNvbHZlQW5pbWF0aW9ucygpLnVwZGF0ZSh0aGlzLCBwcm9wZXJ0aWVzKTtcbiAgICB9XG5cbiAgICBpZiAoY2hhbmdlZCAmJiBvcHRpb25zLmV4dGVybmFsKSB7XG4gICAgICBvcHRpb25zLmV4dGVybmFsLmNhbGwodGhpcywge2NoYXJ0OiB0aGlzLmNoYXJ0LCB0b29sdGlwOiB0aGlzLCByZXBsYXl9KTtcbiAgICB9XG4gIH1cblxuICBkcmF3Q2FyZXQodG9vbHRpcFBvaW50LCBjdHgsIHNpemUsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBjYXJldFBvc2l0aW9uID0gdGhpcy5nZXRDYXJldFBvc2l0aW9uKHRvb2x0aXBQb2ludCwgc2l6ZSwgb3B0aW9ucyk7XG5cbiAgICBjdHgubGluZVRvKGNhcmV0UG9zaXRpb24ueDEsIGNhcmV0UG9zaXRpb24ueTEpO1xuICAgIGN0eC5saW5lVG8oY2FyZXRQb3NpdGlvbi54MiwgY2FyZXRQb3NpdGlvbi55Mik7XG4gICAgY3R4LmxpbmVUbyhjYXJldFBvc2l0aW9uLngzLCBjYXJldFBvc2l0aW9uLnkzKTtcbiAgfVxuXG4gIGdldENhcmV0UG9zaXRpb24odG9vbHRpcFBvaW50LCBzaXplLCBvcHRpb25zKSB7XG4gICAgY29uc3Qge3hBbGlnbiwgeUFsaWdufSA9IHRoaXM7XG4gICAgY29uc3Qge2NhcmV0U2l6ZSwgY29ybmVyUmFkaXVzfSA9IG9wdGlvbnM7XG4gICAgY29uc3Qge3RvcExlZnQsIHRvcFJpZ2h0LCBib3R0b21MZWZ0LCBib3R0b21SaWdodH0gPSB0b1RSQkxDb3JuZXJzKGNvcm5lclJhZGl1cyk7XG4gICAgY29uc3Qge3g6IHB0WCwgeTogcHRZfSA9IHRvb2x0aXBQb2ludDtcbiAgICBjb25zdCB7d2lkdGgsIGhlaWdodH0gPSBzaXplO1xuICAgIGxldCB4MSwgeDIsIHgzLCB5MSwgeTIsIHkzO1xuXG4gICAgaWYgKHlBbGlnbiA9PT0gJ2NlbnRlcicpIHtcbiAgICAgIHkyID0gcHRZICsgKGhlaWdodCAvIDIpO1xuXG4gICAgICBpZiAoeEFsaWduID09PSAnbGVmdCcpIHtcbiAgICAgICAgeDEgPSBwdFg7XG4gICAgICAgIHgyID0geDEgLSBjYXJldFNpemU7XG5cbiAgICAgICAgLy8gTGVmdCBkcmF3cyBib3R0b20gLT4gdG9wLCB0aGlzIHkxIGlzIG9uIHRoZSBib3R0b21cbiAgICAgICAgeTEgPSB5MiArIGNhcmV0U2l6ZTtcbiAgICAgICAgeTMgPSB5MiAtIGNhcmV0U2l6ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHgxID0gcHRYICsgd2lkdGg7XG4gICAgICAgIHgyID0geDEgKyBjYXJldFNpemU7XG5cbiAgICAgICAgLy8gUmlnaHQgZHJhd3MgdG9wIC0+IGJvdHRvbSwgdGh1cyB5MSBpcyBvbiB0aGUgdG9wXG4gICAgICAgIHkxID0geTIgLSBjYXJldFNpemU7XG4gICAgICAgIHkzID0geTIgKyBjYXJldFNpemU7XG4gICAgICB9XG5cbiAgICAgIHgzID0geDE7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh4QWxpZ24gPT09ICdsZWZ0Jykge1xuICAgICAgICB4MiA9IHB0WCArIE1hdGgubWF4KHRvcExlZnQsIGJvdHRvbUxlZnQpICsgKGNhcmV0U2l6ZSk7XG4gICAgICB9IGVsc2UgaWYgKHhBbGlnbiA9PT0gJ3JpZ2h0Jykge1xuICAgICAgICB4MiA9IHB0WCArIHdpZHRoIC0gTWF0aC5tYXgodG9wUmlnaHQsIGJvdHRvbVJpZ2h0KSAtIGNhcmV0U2l6ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHgyID0gdGhpcy5jYXJldFg7XG4gICAgICB9XG5cbiAgICAgIGlmICh5QWxpZ24gPT09ICd0b3AnKSB7XG4gICAgICAgIHkxID0gcHRZO1xuICAgICAgICB5MiA9IHkxIC0gY2FyZXRTaXplO1xuXG4gICAgICAgIC8vIFRvcCBkcmF3cyBsZWZ0IC0+IHJpZ2h0LCB0aHVzIHgxIGlzIG9uIHRoZSBsZWZ0XG4gICAgICAgIHgxID0geDIgLSBjYXJldFNpemU7XG4gICAgICAgIHgzID0geDIgKyBjYXJldFNpemU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB5MSA9IHB0WSArIGhlaWdodDtcbiAgICAgICAgeTIgPSB5MSArIGNhcmV0U2l6ZTtcblxuICAgICAgICAvLyBCb3R0b20gZHJhd3MgcmlnaHQgLT4gbGVmdCwgdGh1cyB4MSBpcyBvbiB0aGUgcmlnaHRcbiAgICAgICAgeDEgPSB4MiArIGNhcmV0U2l6ZTtcbiAgICAgICAgeDMgPSB4MiAtIGNhcmV0U2l6ZTtcbiAgICAgIH1cbiAgICAgIHkzID0geTE7XG4gICAgfVxuICAgIHJldHVybiB7eDEsIHgyLCB4MywgeTEsIHkyLCB5M307XG4gIH1cblxuICBkcmF3VGl0bGUocHQsIGN0eCwgb3B0aW9ucykge1xuICAgIGNvbnN0IHRpdGxlID0gdGhpcy50aXRsZTtcbiAgICBjb25zdCBsZW5ndGggPSB0aXRsZS5sZW5ndGg7XG4gICAgbGV0IHRpdGxlRm9udCwgdGl0bGVTcGFjaW5nLCBpO1xuXG4gICAgaWYgKGxlbmd0aCkge1xuICAgICAgY29uc3QgcnRsSGVscGVyID0gZ2V0UnRsQWRhcHRlcihvcHRpb25zLnJ0bCwgdGhpcy54LCB0aGlzLndpZHRoKTtcblxuICAgICAgcHQueCA9IGdldEFsaWduZWRYKHRoaXMsIG9wdGlvbnMudGl0bGVBbGlnbiwgb3B0aW9ucyk7XG5cbiAgICAgIGN0eC50ZXh0QWxpZ24gPSBydGxIZWxwZXIudGV4dEFsaWduKG9wdGlvbnMudGl0bGVBbGlnbik7XG4gICAgICBjdHgudGV4dEJhc2VsaW5lID0gJ21pZGRsZSc7XG5cbiAgICAgIHRpdGxlRm9udCA9IHRvRm9udChvcHRpb25zLnRpdGxlRm9udCk7XG4gICAgICB0aXRsZVNwYWNpbmcgPSBvcHRpb25zLnRpdGxlU3BhY2luZztcblxuICAgICAgY3R4LmZpbGxTdHlsZSA9IG9wdGlvbnMudGl0bGVDb2xvcjtcbiAgICAgIGN0eC5mb250ID0gdGl0bGVGb250LnN0cmluZztcblxuICAgICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgICAgIGN0eC5maWxsVGV4dCh0aXRsZVtpXSwgcnRsSGVscGVyLngocHQueCksIHB0LnkgKyB0aXRsZUZvbnQubGluZUhlaWdodCAvIDIpO1xuICAgICAgICBwdC55ICs9IHRpdGxlRm9udC5saW5lSGVpZ2h0ICsgdGl0bGVTcGFjaW5nOyAvLyBMaW5lIEhlaWdodCBhbmQgc3BhY2luZ1xuXG4gICAgICAgIGlmIChpICsgMSA9PT0gbGVuZ3RoKSB7XG4gICAgICAgICAgcHQueSArPSBvcHRpb25zLnRpdGxlTWFyZ2luQm90dG9tIC0gdGl0bGVTcGFjaW5nOyAvLyBJZiBMYXN0LCBhZGQgbWFyZ2luLCByZW1vdmUgc3BhY2luZ1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfZHJhd0NvbG9yQm94KGN0eCwgcHQsIGksIHJ0bEhlbHBlciwgb3B0aW9ucykge1xuICAgIGNvbnN0IGxhYmVsQ29sb3IgPSB0aGlzLmxhYmVsQ29sb3JzW2ldO1xuICAgIGNvbnN0IGxhYmVsUG9pbnRTdHlsZSA9IHRoaXMubGFiZWxQb2ludFN0eWxlc1tpXTtcbiAgICBjb25zdCB7Ym94SGVpZ2h0LCBib3hXaWR0aH0gPSBvcHRpb25zO1xuICAgIGNvbnN0IGJvZHlGb250ID0gdG9Gb250KG9wdGlvbnMuYm9keUZvbnQpO1xuICAgIGNvbnN0IGNvbG9yWCA9IGdldEFsaWduZWRYKHRoaXMsICdsZWZ0Jywgb3B0aW9ucyk7XG4gICAgY29uc3QgcnRsQ29sb3JYID0gcnRsSGVscGVyLngoY29sb3JYKTtcbiAgICBjb25zdCB5T2ZmU2V0ID0gYm94SGVpZ2h0IDwgYm9keUZvbnQubGluZUhlaWdodCA/IChib2R5Rm9udC5saW5lSGVpZ2h0IC0gYm94SGVpZ2h0KSAvIDIgOiAwO1xuICAgIGNvbnN0IGNvbG9yWSA9IHB0LnkgKyB5T2ZmU2V0O1xuXG4gICAgaWYgKG9wdGlvbnMudXNlUG9pbnRTdHlsZSkge1xuICAgICAgY29uc3QgZHJhd09wdGlvbnMgPSB7XG4gICAgICAgIHJhZGl1czogTWF0aC5taW4oYm94V2lkdGgsIGJveEhlaWdodCkgLyAyLCAvLyBmaXQgdGhlIGNpcmNsZSBpbiB0aGUgYm94XG4gICAgICAgIHBvaW50U3R5bGU6IGxhYmVsUG9pbnRTdHlsZS5wb2ludFN0eWxlLFxuICAgICAgICByb3RhdGlvbjogbGFiZWxQb2ludFN0eWxlLnJvdGF0aW9uLFxuICAgICAgICBib3JkZXJXaWR0aDogMVxuICAgICAgfTtcbiAgICAgIC8vIFJlY2FsY3VsYXRlIHggYW5kIHkgZm9yIGRyYXdQb2ludCgpIGJlY2F1c2UgaXRzIGV4cGVjdGluZ1xuICAgICAgLy8geCBhbmQgeSB0byBiZSBjZW50ZXIgb2YgZmlndXJlIChpbnN0ZWFkIG9mIHRvcCBsZWZ0KVxuICAgICAgY29uc3QgY2VudGVyWCA9IHJ0bEhlbHBlci5sZWZ0Rm9yTHRyKHJ0bENvbG9yWCwgYm94V2lkdGgpICsgYm94V2lkdGggLyAyO1xuICAgICAgY29uc3QgY2VudGVyWSA9IGNvbG9yWSArIGJveEhlaWdodCAvIDI7XG5cbiAgICAgIC8vIEZpbGwgdGhlIHBvaW50IHdpdGggd2hpdGUgc28gdGhhdCBjb2xvdXJzIG1lcmdlIG5pY2VseSBpZiB0aGUgb3BhY2l0eSBpcyA8IDFcbiAgICAgIGN0eC5zdHJva2VTdHlsZSA9IG9wdGlvbnMubXVsdGlLZXlCYWNrZ3JvdW5kO1xuICAgICAgY3R4LmZpbGxTdHlsZSA9IG9wdGlvbnMubXVsdGlLZXlCYWNrZ3JvdW5kO1xuICAgICAgZHJhd1BvaW50KGN0eCwgZHJhd09wdGlvbnMsIGNlbnRlclgsIGNlbnRlclkpO1xuXG4gICAgICAvLyBEcmF3IHRoZSBwb2ludFxuICAgICAgY3R4LnN0cm9rZVN0eWxlID0gbGFiZWxDb2xvci5ib3JkZXJDb2xvcjtcbiAgICAgIGN0eC5maWxsU3R5bGUgPSBsYWJlbENvbG9yLmJhY2tncm91bmRDb2xvcjtcbiAgICAgIGRyYXdQb2ludChjdHgsIGRyYXdPcHRpb25zLCBjZW50ZXJYLCBjZW50ZXJZKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gQm9yZGVyXG4gICAgICBjdHgubGluZVdpZHRoID0gaXNPYmplY3QobGFiZWxDb2xvci5ib3JkZXJXaWR0aCkgPyBNYXRoLm1heCguLi5PYmplY3QudmFsdWVzKGxhYmVsQ29sb3IuYm9yZGVyV2lkdGgpKSA6IChsYWJlbENvbG9yLmJvcmRlcldpZHRoIHx8IDEpOyAvLyBUT0RPLCB2NCByZW1vdmUgZmFsbGJhY2tcbiAgICAgIGN0eC5zdHJva2VTdHlsZSA9IGxhYmVsQ29sb3IuYm9yZGVyQ29sb3I7XG4gICAgICBjdHguc2V0TGluZURhc2gobGFiZWxDb2xvci5ib3JkZXJEYXNoIHx8IFtdKTtcbiAgICAgIGN0eC5saW5lRGFzaE9mZnNldCA9IGxhYmVsQ29sb3IuYm9yZGVyRGFzaE9mZnNldCB8fCAwO1xuXG4gICAgICAvLyBGaWxsIGEgd2hpdGUgcmVjdCBzbyB0aGF0IGNvbG91cnMgbWVyZ2UgbmljZWx5IGlmIHRoZSBvcGFjaXR5IGlzIDwgMVxuICAgICAgY29uc3Qgb3V0ZXJYID0gcnRsSGVscGVyLmxlZnRGb3JMdHIocnRsQ29sb3JYLCBib3hXaWR0aCk7XG4gICAgICBjb25zdCBpbm5lclggPSBydGxIZWxwZXIubGVmdEZvckx0cihydGxIZWxwZXIueFBsdXMocnRsQ29sb3JYLCAxKSwgYm94V2lkdGggLSAyKTtcbiAgICAgIGNvbnN0IGJvcmRlclJhZGl1cyA9IHRvVFJCTENvcm5lcnMobGFiZWxDb2xvci5ib3JkZXJSYWRpdXMpO1xuXG4gICAgICBpZiAoT2JqZWN0LnZhbHVlcyhib3JkZXJSYWRpdXMpLnNvbWUodiA9PiB2ICE9PSAwKSkge1xuICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgIGN0eC5maWxsU3R5bGUgPSBvcHRpb25zLm11bHRpS2V5QmFja2dyb3VuZDtcbiAgICAgICAgYWRkUm91bmRlZFJlY3RQYXRoKGN0eCwge1xuICAgICAgICAgIHg6IG91dGVyWCxcbiAgICAgICAgICB5OiBjb2xvclksXG4gICAgICAgICAgdzogYm94V2lkdGgsXG4gICAgICAgICAgaDogYm94SGVpZ2h0LFxuICAgICAgICAgIHJhZGl1czogYm9yZGVyUmFkaXVzLFxuICAgICAgICB9KTtcbiAgICAgICAgY3R4LmZpbGwoKTtcbiAgICAgICAgY3R4LnN0cm9rZSgpO1xuXG4gICAgICAgIC8vIElubmVyIHNxdWFyZVxuICAgICAgICBjdHguZmlsbFN0eWxlID0gbGFiZWxDb2xvci5iYWNrZ3JvdW5kQ29sb3I7XG4gICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgYWRkUm91bmRlZFJlY3RQYXRoKGN0eCwge1xuICAgICAgICAgIHg6IGlubmVyWCxcbiAgICAgICAgICB5OiBjb2xvclkgKyAxLFxuICAgICAgICAgIHc6IGJveFdpZHRoIC0gMixcbiAgICAgICAgICBoOiBib3hIZWlnaHQgLSAyLFxuICAgICAgICAgIHJhZGl1czogYm9yZGVyUmFkaXVzLFxuICAgICAgICB9KTtcbiAgICAgICAgY3R4LmZpbGwoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIE5vcm1hbCByZWN0XG4gICAgICAgIGN0eC5maWxsU3R5bGUgPSBvcHRpb25zLm11bHRpS2V5QmFja2dyb3VuZDtcbiAgICAgICAgY3R4LmZpbGxSZWN0KG91dGVyWCwgY29sb3JZLCBib3hXaWR0aCwgYm94SGVpZ2h0KTtcbiAgICAgICAgY3R4LnN0cm9rZVJlY3Qob3V0ZXJYLCBjb2xvclksIGJveFdpZHRoLCBib3hIZWlnaHQpO1xuICAgICAgICAvLyBJbm5lciBzcXVhcmVcbiAgICAgICAgY3R4LmZpbGxTdHlsZSA9IGxhYmVsQ29sb3IuYmFja2dyb3VuZENvbG9yO1xuICAgICAgICBjdHguZmlsbFJlY3QoaW5uZXJYLCBjb2xvclkgKyAxLCBib3hXaWR0aCAtIDIsIGJveEhlaWdodCAtIDIpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIHJlc3RvcmUgZmlsbFN0eWxlXG4gICAgY3R4LmZpbGxTdHlsZSA9IHRoaXMubGFiZWxUZXh0Q29sb3JzW2ldO1xuICB9XG5cbiAgZHJhd0JvZHkocHQsIGN0eCwgb3B0aW9ucykge1xuICAgIGNvbnN0IHtib2R5fSA9IHRoaXM7XG4gICAgY29uc3Qge2JvZHlTcGFjaW5nLCBib2R5QWxpZ24sIGRpc3BsYXlDb2xvcnMsIGJveEhlaWdodCwgYm94V2lkdGgsIGJveFBhZGRpbmd9ID0gb3B0aW9ucztcbiAgICBjb25zdCBib2R5Rm9udCA9IHRvRm9udChvcHRpb25zLmJvZHlGb250KTtcbiAgICBsZXQgYm9keUxpbmVIZWlnaHQgPSBib2R5Rm9udC5saW5lSGVpZ2h0O1xuICAgIGxldCB4TGluZVBhZGRpbmcgPSAwO1xuXG4gICAgY29uc3QgcnRsSGVscGVyID0gZ2V0UnRsQWRhcHRlcihvcHRpb25zLnJ0bCwgdGhpcy54LCB0aGlzLndpZHRoKTtcblxuICAgIGNvbnN0IGZpbGxMaW5lT2ZUZXh0ID0gZnVuY3Rpb24obGluZSkge1xuICAgICAgY3R4LmZpbGxUZXh0KGxpbmUsIHJ0bEhlbHBlci54KHB0LnggKyB4TGluZVBhZGRpbmcpLCBwdC55ICsgYm9keUxpbmVIZWlnaHQgLyAyKTtcbiAgICAgIHB0LnkgKz0gYm9keUxpbmVIZWlnaHQgKyBib2R5U3BhY2luZztcbiAgICB9O1xuXG4gICAgY29uc3QgYm9keUFsaWduRm9yQ2FsY3VsYXRpb24gPSBydGxIZWxwZXIudGV4dEFsaWduKGJvZHlBbGlnbik7XG4gICAgbGV0IGJvZHlJdGVtLCB0ZXh0Q29sb3IsIGxpbmVzLCBpLCBqLCBpbGVuLCBqbGVuO1xuXG4gICAgY3R4LnRleHRBbGlnbiA9IGJvZHlBbGlnbjtcbiAgICBjdHgudGV4dEJhc2VsaW5lID0gJ21pZGRsZSc7XG4gICAgY3R4LmZvbnQgPSBib2R5Rm9udC5zdHJpbmc7XG5cbiAgICBwdC54ID0gZ2V0QWxpZ25lZFgodGhpcywgYm9keUFsaWduRm9yQ2FsY3VsYXRpb24sIG9wdGlvbnMpO1xuXG4gICAgLy8gQmVmb3JlIGJvZHkgbGluZXNcbiAgICBjdHguZmlsbFN0eWxlID0gb3B0aW9ucy5ib2R5Q29sb3I7XG4gICAgZWFjaCh0aGlzLmJlZm9yZUJvZHksIGZpbGxMaW5lT2ZUZXh0KTtcblxuICAgIHhMaW5lUGFkZGluZyA9IGRpc3BsYXlDb2xvcnMgJiYgYm9keUFsaWduRm9yQ2FsY3VsYXRpb24gIT09ICdyaWdodCdcbiAgICAgID8gYm9keUFsaWduID09PSAnY2VudGVyJyA/IChib3hXaWR0aCAvIDIgKyBib3hQYWRkaW5nKSA6IChib3hXaWR0aCArIDIgKyBib3hQYWRkaW5nKVxuICAgICAgOiAwO1xuXG4gICAgLy8gRHJhdyBib2R5IGxpbmVzIG5vd1xuICAgIGZvciAoaSA9IDAsIGlsZW4gPSBib2R5Lmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgICAgYm9keUl0ZW0gPSBib2R5W2ldO1xuICAgICAgdGV4dENvbG9yID0gdGhpcy5sYWJlbFRleHRDb2xvcnNbaV07XG5cbiAgICAgIGN0eC5maWxsU3R5bGUgPSB0ZXh0Q29sb3I7XG4gICAgICBlYWNoKGJvZHlJdGVtLmJlZm9yZSwgZmlsbExpbmVPZlRleHQpO1xuXG4gICAgICBsaW5lcyA9IGJvZHlJdGVtLmxpbmVzO1xuICAgICAgLy8gRHJhdyBMZWdlbmQtbGlrZSBib3hlcyBpZiBuZWVkZWRcbiAgICAgIGlmIChkaXNwbGF5Q29sb3JzICYmIGxpbmVzLmxlbmd0aCkge1xuICAgICAgICB0aGlzLl9kcmF3Q29sb3JCb3goY3R4LCBwdCwgaSwgcnRsSGVscGVyLCBvcHRpb25zKTtcbiAgICAgICAgYm9keUxpbmVIZWlnaHQgPSBNYXRoLm1heChib2R5Rm9udC5saW5lSGVpZ2h0LCBib3hIZWlnaHQpO1xuICAgICAgfVxuXG4gICAgICBmb3IgKGogPSAwLCBqbGVuID0gbGluZXMubGVuZ3RoOyBqIDwgamxlbjsgKytqKSB7XG4gICAgICAgIGZpbGxMaW5lT2ZUZXh0KGxpbmVzW2pdKTtcbiAgICAgICAgLy8gUmVzZXQgZm9yIGFueSBsaW5lcyB0aGF0IGRvbid0IGluY2x1ZGUgY29sb3Jib3hcbiAgICAgICAgYm9keUxpbmVIZWlnaHQgPSBib2R5Rm9udC5saW5lSGVpZ2h0O1xuICAgICAgfVxuXG4gICAgICBlYWNoKGJvZHlJdGVtLmFmdGVyLCBmaWxsTGluZU9mVGV4dCk7XG4gICAgfVxuXG4gICAgLy8gUmVzZXQgYmFjayB0byAwIGZvciBhZnRlciBib2R5XG4gICAgeExpbmVQYWRkaW5nID0gMDtcbiAgICBib2R5TGluZUhlaWdodCA9IGJvZHlGb250LmxpbmVIZWlnaHQ7XG5cbiAgICAvLyBBZnRlciBib2R5IGxpbmVzXG4gICAgZWFjaCh0aGlzLmFmdGVyQm9keSwgZmlsbExpbmVPZlRleHQpO1xuICAgIHB0LnkgLT0gYm9keVNwYWNpbmc7IC8vIFJlbW92ZSBsYXN0IGJvZHkgc3BhY2luZ1xuICB9XG5cbiAgZHJhd0Zvb3RlcihwdCwgY3R4LCBvcHRpb25zKSB7XG4gICAgY29uc3QgZm9vdGVyID0gdGhpcy5mb290ZXI7XG4gICAgY29uc3QgbGVuZ3RoID0gZm9vdGVyLmxlbmd0aDtcbiAgICBsZXQgZm9vdGVyRm9udCwgaTtcblxuICAgIGlmIChsZW5ndGgpIHtcbiAgICAgIGNvbnN0IHJ0bEhlbHBlciA9IGdldFJ0bEFkYXB0ZXIob3B0aW9ucy5ydGwsIHRoaXMueCwgdGhpcy53aWR0aCk7XG5cbiAgICAgIHB0LnggPSBnZXRBbGlnbmVkWCh0aGlzLCBvcHRpb25zLmZvb3RlckFsaWduLCBvcHRpb25zKTtcbiAgICAgIHB0LnkgKz0gb3B0aW9ucy5mb290ZXJNYXJnaW5Ub3A7XG5cbiAgICAgIGN0eC50ZXh0QWxpZ24gPSBydGxIZWxwZXIudGV4dEFsaWduKG9wdGlvbnMuZm9vdGVyQWxpZ24pO1xuICAgICAgY3R4LnRleHRCYXNlbGluZSA9ICdtaWRkbGUnO1xuXG4gICAgICBmb290ZXJGb250ID0gdG9Gb250KG9wdGlvbnMuZm9vdGVyRm9udCk7XG5cbiAgICAgIGN0eC5maWxsU3R5bGUgPSBvcHRpb25zLmZvb3RlckNvbG9yO1xuICAgICAgY3R4LmZvbnQgPSBmb290ZXJGb250LnN0cmluZztcblxuICAgICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgICAgIGN0eC5maWxsVGV4dChmb290ZXJbaV0sIHJ0bEhlbHBlci54KHB0LngpLCBwdC55ICsgZm9vdGVyRm9udC5saW5lSGVpZ2h0IC8gMik7XG4gICAgICAgIHB0LnkgKz0gZm9vdGVyRm9udC5saW5lSGVpZ2h0ICsgb3B0aW9ucy5mb290ZXJTcGFjaW5nO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGRyYXdCYWNrZ3JvdW5kKHB0LCBjdHgsIHRvb2x0aXBTaXplLCBvcHRpb25zKSB7XG4gICAgY29uc3Qge3hBbGlnbiwgeUFsaWdufSA9IHRoaXM7XG4gICAgY29uc3Qge3gsIHl9ID0gcHQ7XG4gICAgY29uc3Qge3dpZHRoLCBoZWlnaHR9ID0gdG9vbHRpcFNpemU7XG4gICAgY29uc3Qge3RvcExlZnQsIHRvcFJpZ2h0LCBib3R0b21MZWZ0LCBib3R0b21SaWdodH0gPSB0b1RSQkxDb3JuZXJzKG9wdGlvbnMuY29ybmVyUmFkaXVzKTtcblxuICAgIGN0eC5maWxsU3R5bGUgPSBvcHRpb25zLmJhY2tncm91bmRDb2xvcjtcbiAgICBjdHguc3Ryb2tlU3R5bGUgPSBvcHRpb25zLmJvcmRlckNvbG9yO1xuICAgIGN0eC5saW5lV2lkdGggPSBvcHRpb25zLmJvcmRlcldpZHRoO1xuXG4gICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgIGN0eC5tb3ZlVG8oeCArIHRvcExlZnQsIHkpO1xuICAgIGlmICh5QWxpZ24gPT09ICd0b3AnKSB7XG4gICAgICB0aGlzLmRyYXdDYXJldChwdCwgY3R4LCB0b29sdGlwU2l6ZSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGN0eC5saW5lVG8oeCArIHdpZHRoIC0gdG9wUmlnaHQsIHkpO1xuICAgIGN0eC5xdWFkcmF0aWNDdXJ2ZVRvKHggKyB3aWR0aCwgeSwgeCArIHdpZHRoLCB5ICsgdG9wUmlnaHQpO1xuICAgIGlmICh5QWxpZ24gPT09ICdjZW50ZXInICYmIHhBbGlnbiA9PT0gJ3JpZ2h0Jykge1xuICAgICAgdGhpcy5kcmF3Q2FyZXQocHQsIGN0eCwgdG9vbHRpcFNpemUsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBjdHgubGluZVRvKHggKyB3aWR0aCwgeSArIGhlaWdodCAtIGJvdHRvbVJpZ2h0KTtcbiAgICBjdHgucXVhZHJhdGljQ3VydmVUbyh4ICsgd2lkdGgsIHkgKyBoZWlnaHQsIHggKyB3aWR0aCAtIGJvdHRvbVJpZ2h0LCB5ICsgaGVpZ2h0KTtcbiAgICBpZiAoeUFsaWduID09PSAnYm90dG9tJykge1xuICAgICAgdGhpcy5kcmF3Q2FyZXQocHQsIGN0eCwgdG9vbHRpcFNpemUsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBjdHgubGluZVRvKHggKyBib3R0b21MZWZ0LCB5ICsgaGVpZ2h0KTtcbiAgICBjdHgucXVhZHJhdGljQ3VydmVUbyh4LCB5ICsgaGVpZ2h0LCB4LCB5ICsgaGVpZ2h0IC0gYm90dG9tTGVmdCk7XG4gICAgaWYgKHlBbGlnbiA9PT0gJ2NlbnRlcicgJiYgeEFsaWduID09PSAnbGVmdCcpIHtcbiAgICAgIHRoaXMuZHJhd0NhcmV0KHB0LCBjdHgsIHRvb2x0aXBTaXplLCBvcHRpb25zKTtcbiAgICB9XG4gICAgY3R4LmxpbmVUbyh4LCB5ICsgdG9wTGVmdCk7XG4gICAgY3R4LnF1YWRyYXRpY0N1cnZlVG8oeCwgeSwgeCArIHRvcExlZnQsIHkpO1xuICAgIGN0eC5jbG9zZVBhdGgoKTtcblxuICAgIGN0eC5maWxsKCk7XG5cbiAgICBpZiAob3B0aW9ucy5ib3JkZXJXaWR0aCA+IDApIHtcbiAgICAgIGN0eC5zdHJva2UoKTtcbiAgICB9XG4gIH1cblxuICAvKipcblx0ICogVXBkYXRlIHgveSBhbmltYXRpb24gdGFyZ2V0cyB3aGVuIF9hY3RpdmUgZWxlbWVudHMgYXJlIGFuaW1hdGluZyB0b29cblx0ICogQHByaXZhdGVcblx0ICovXG4gIF91cGRhdGVBbmltYXRpb25UYXJnZXQob3B0aW9ucykge1xuICAgIGNvbnN0IGNoYXJ0ID0gdGhpcy5jaGFydDtcbiAgICBjb25zdCBhbmltcyA9IHRoaXMuJGFuaW1hdGlvbnM7XG4gICAgY29uc3QgYW5pbVggPSBhbmltcyAmJiBhbmltcy54O1xuICAgIGNvbnN0IGFuaW1ZID0gYW5pbXMgJiYgYW5pbXMueTtcbiAgICBpZiAoYW5pbVggfHwgYW5pbVkpIHtcbiAgICAgIGNvbnN0IHBvc2l0aW9uID0gcG9zaXRpb25lcnNbb3B0aW9ucy5wb3NpdGlvbl0uY2FsbCh0aGlzLCB0aGlzLl9hY3RpdmUsIHRoaXMuX2V2ZW50UG9zaXRpb24pO1xuICAgICAgaWYgKCFwb3NpdGlvbikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBzaXplID0gdGhpcy5fc2l6ZSA9IGdldFRvb2x0aXBTaXplKHRoaXMsIG9wdGlvbnMpO1xuICAgICAgY29uc3QgcG9zaXRpb25BbmRTaXplID0gT2JqZWN0LmFzc2lnbih7fSwgcG9zaXRpb24sIHRoaXMuX3NpemUpO1xuICAgICAgY29uc3QgYWxpZ25tZW50ID0gZGV0ZXJtaW5lQWxpZ25tZW50KGNoYXJ0LCBvcHRpb25zLCBwb3NpdGlvbkFuZFNpemUpO1xuICAgICAgY29uc3QgcG9pbnQgPSBnZXRCYWNrZ3JvdW5kUG9pbnQob3B0aW9ucywgcG9zaXRpb25BbmRTaXplLCBhbGlnbm1lbnQsIGNoYXJ0KTtcbiAgICAgIGlmIChhbmltWC5fdG8gIT09IHBvaW50LnggfHwgYW5pbVkuX3RvICE9PSBwb2ludC55KSB7XG4gICAgICAgIHRoaXMueEFsaWduID0gYWxpZ25tZW50LnhBbGlnbjtcbiAgICAgICAgdGhpcy55QWxpZ24gPSBhbGlnbm1lbnQueUFsaWduO1xuICAgICAgICB0aGlzLndpZHRoID0gc2l6ZS53aWR0aDtcbiAgICAgICAgdGhpcy5oZWlnaHQgPSBzaXplLmhlaWdodDtcbiAgICAgICAgdGhpcy5jYXJldFggPSBwb3NpdGlvbi54O1xuICAgICAgICB0aGlzLmNhcmV0WSA9IHBvc2l0aW9uLnk7XG4gICAgICAgIHRoaXMuX3Jlc29sdmVBbmltYXRpb25zKCkudXBkYXRlKHRoaXMsIHBvaW50KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRGV0ZXJtaW5lIGlmIHRoZSB0b29sdGlwIHdpbGwgZHJhdyBhbnl0aGluZ1xuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgdG9vbHRpcCB3aWxsIHJlbmRlclxuICAgKi9cbiAgX3dpbGxSZW5kZXIoKSB7XG4gICAgcmV0dXJuICEhdGhpcy5vcGFjaXR5O1xuICB9XG5cbiAgZHJhdyhjdHgpIHtcbiAgICBjb25zdCBvcHRpb25zID0gdGhpcy5vcHRpb25zLnNldENvbnRleHQodGhpcy5nZXRDb250ZXh0KCkpO1xuICAgIGxldCBvcGFjaXR5ID0gdGhpcy5vcGFjaXR5O1xuXG4gICAgaWYgKCFvcGFjaXR5KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5fdXBkYXRlQW5pbWF0aW9uVGFyZ2V0KG9wdGlvbnMpO1xuXG4gICAgY29uc3QgdG9vbHRpcFNpemUgPSB7XG4gICAgICB3aWR0aDogdGhpcy53aWR0aCxcbiAgICAgIGhlaWdodDogdGhpcy5oZWlnaHRcbiAgICB9O1xuICAgIGNvbnN0IHB0ID0ge1xuICAgICAgeDogdGhpcy54LFxuICAgICAgeTogdGhpcy55XG4gICAgfTtcblxuICAgIC8vIElFMTEvRWRnZSBkb2VzIG5vdCBsaWtlIHZlcnkgc21hbGwgb3BhY2l0aWVzLCBzbyBzbmFwIHRvIDBcbiAgICBvcGFjaXR5ID0gTWF0aC5hYnMob3BhY2l0eSkgPCAxZS0zID8gMCA6IG9wYWNpdHk7XG5cbiAgICBjb25zdCBwYWRkaW5nID0gdG9QYWRkaW5nKG9wdGlvbnMucGFkZGluZyk7XG5cbiAgICAvLyBUcnV0aHkvZmFsc2V5IHZhbHVlIGZvciBlbXB0eSB0b29sdGlwXG4gICAgY29uc3QgaGFzVG9vbHRpcENvbnRlbnQgPSB0aGlzLnRpdGxlLmxlbmd0aCB8fCB0aGlzLmJlZm9yZUJvZHkubGVuZ3RoIHx8IHRoaXMuYm9keS5sZW5ndGggfHwgdGhpcy5hZnRlckJvZHkubGVuZ3RoIHx8IHRoaXMuZm9vdGVyLmxlbmd0aDtcblxuICAgIGlmIChvcHRpb25zLmVuYWJsZWQgJiYgaGFzVG9vbHRpcENvbnRlbnQpIHtcbiAgICAgIGN0eC5zYXZlKCk7XG4gICAgICBjdHguZ2xvYmFsQWxwaGEgPSBvcGFjaXR5O1xuXG4gICAgICAvLyBEcmF3IEJhY2tncm91bmRcbiAgICAgIHRoaXMuZHJhd0JhY2tncm91bmQocHQsIGN0eCwgdG9vbHRpcFNpemUsIG9wdGlvbnMpO1xuXG4gICAgICBvdmVycmlkZVRleHREaXJlY3Rpb24oY3R4LCBvcHRpb25zLnRleHREaXJlY3Rpb24pO1xuXG4gICAgICBwdC55ICs9IHBhZGRpbmcudG9wO1xuXG4gICAgICAvLyBUaXRsZXNcbiAgICAgIHRoaXMuZHJhd1RpdGxlKHB0LCBjdHgsIG9wdGlvbnMpO1xuXG4gICAgICAvLyBCb2R5XG4gICAgICB0aGlzLmRyYXdCb2R5KHB0LCBjdHgsIG9wdGlvbnMpO1xuXG4gICAgICAvLyBGb290ZXJcbiAgICAgIHRoaXMuZHJhd0Zvb3RlcihwdCwgY3R4LCBvcHRpb25zKTtcblxuICAgICAgcmVzdG9yZVRleHREaXJlY3Rpb24oY3R4LCBvcHRpb25zLnRleHREaXJlY3Rpb24pO1xuXG4gICAgICBjdHgucmVzdG9yZSgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuXHQgKiBHZXQgYWN0aXZlIGVsZW1lbnRzIGluIHRoZSB0b29sdGlwXG5cdCAqIEByZXR1cm5zIHtBcnJheX0gQXJyYXkgb2YgZWxlbWVudHMgdGhhdCBhcmUgYWN0aXZlIGluIHRoZSB0b29sdGlwXG5cdCAqL1xuICBnZXRBY3RpdmVFbGVtZW50cygpIHtcbiAgICByZXR1cm4gdGhpcy5fYWN0aXZlIHx8IFtdO1xuICB9XG5cbiAgLyoqXG5cdCAqIFNldCBhY3RpdmUgZWxlbWVudHMgaW4gdGhlIHRvb2x0aXBcblx0ICogQHBhcmFtIHthcnJheX0gYWN0aXZlRWxlbWVudHMgQXJyYXkgb2YgYWN0aXZlIGRhdGFzZXRJbmRleC9pbmRleCBwYWlycy5cblx0ICogQHBhcmFtIHtvYmplY3R9IGV2ZW50UG9zaXRpb24gU3ludGhldGljIGV2ZW50IHBvc2l0aW9uIHVzZWQgaW4gcG9zaXRpb25pbmdcblx0ICovXG4gIHNldEFjdGl2ZUVsZW1lbnRzKGFjdGl2ZUVsZW1lbnRzLCBldmVudFBvc2l0aW9uKSB7XG4gICAgY29uc3QgbGFzdEFjdGl2ZSA9IHRoaXMuX2FjdGl2ZTtcbiAgICBjb25zdCBhY3RpdmUgPSBhY3RpdmVFbGVtZW50cy5tYXAoKHtkYXRhc2V0SW5kZXgsIGluZGV4fSkgPT4ge1xuICAgICAgY29uc3QgbWV0YSA9IHRoaXMuY2hhcnQuZ2V0RGF0YXNldE1ldGEoZGF0YXNldEluZGV4KTtcblxuICAgICAgaWYgKCFtZXRhKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGZpbmQgYSBkYXRhc2V0IGF0IGluZGV4ICcgKyBkYXRhc2V0SW5kZXgpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBkYXRhc2V0SW5kZXgsXG4gICAgICAgIGVsZW1lbnQ6IG1ldGEuZGF0YVtpbmRleF0sXG4gICAgICAgIGluZGV4LFxuICAgICAgfTtcbiAgICB9KTtcbiAgICBjb25zdCBjaGFuZ2VkID0gIV9lbGVtZW50c0VxdWFsKGxhc3RBY3RpdmUsIGFjdGl2ZSk7XG4gICAgY29uc3QgcG9zaXRpb25DaGFuZ2VkID0gdGhpcy5fcG9zaXRpb25DaGFuZ2VkKGFjdGl2ZSwgZXZlbnRQb3NpdGlvbik7XG5cbiAgICBpZiAoY2hhbmdlZCB8fCBwb3NpdGlvbkNoYW5nZWQpIHtcbiAgICAgIHRoaXMuX2FjdGl2ZSA9IGFjdGl2ZTtcbiAgICAgIHRoaXMuX2V2ZW50UG9zaXRpb24gPSBldmVudFBvc2l0aW9uO1xuICAgICAgdGhpcy5faWdub3JlUmVwbGF5RXZlbnRzID0gdHJ1ZTtcbiAgICAgIHRoaXMudXBkYXRlKHRydWUpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuXHQgKiBIYW5kbGUgYW4gZXZlbnRcblx0ICogQHBhcmFtIHtDaGFydEV2ZW50fSBlIC0gVGhlIGV2ZW50IHRvIGhhbmRsZVxuXHQgKiBAcGFyYW0ge2Jvb2xlYW59IFtyZXBsYXldIC0gVGhpcyBpcyBhIHJlcGxheWVkIGV2ZW50IChmcm9tIHVwZGF0ZSlcblx0ICogQHBhcmFtIHtib29sZWFufSBbaW5DaGFydEFyZWFdIC0gVGhlIGV2ZW50IGlzIGluc2lkZSBjaGFydEFyZWFcblx0ICogQHJldHVybnMge2Jvb2xlYW59IHRydWUgaWYgdGhlIHRvb2x0aXAgY2hhbmdlZFxuXHQgKi9cbiAgaGFuZGxlRXZlbnQoZSwgcmVwbGF5LCBpbkNoYXJ0QXJlYSA9IHRydWUpIHtcbiAgICBpZiAocmVwbGF5ICYmIHRoaXMuX2lnbm9yZVJlcGxheUV2ZW50cykge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB0aGlzLl9pZ25vcmVSZXBsYXlFdmVudHMgPSBmYWxzZTtcblxuICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgY29uc3QgbGFzdEFjdGl2ZSA9IHRoaXMuX2FjdGl2ZSB8fCBbXTtcbiAgICBjb25zdCBhY3RpdmUgPSB0aGlzLl9nZXRBY3RpdmVFbGVtZW50cyhlLCBsYXN0QWN0aXZlLCByZXBsYXksIGluQ2hhcnRBcmVhKTtcblxuICAgIC8vIFdoZW4gdGhlcmUgYXJlIG11bHRpcGxlIGl0ZW1zIHNob3duLCBidXQgdGhlIHRvb2x0aXAgcG9zaXRpb24gaXMgbmVhcmVzdCBtb2RlXG4gICAgLy8gYW4gdXBkYXRlIG1heSBuZWVkIHRvIGJlIG1hZGUgYmVjYXVzZSBvdXIgcG9zaXRpb24gbWF5IGhhdmUgY2hhbmdlZCBldmVuIHRob3VnaFxuICAgIC8vIHRoZSBpdGVtcyBhcmUgdGhlIHNhbWUgYXMgYmVmb3JlLlxuICAgIGNvbnN0IHBvc2l0aW9uQ2hhbmdlZCA9IHRoaXMuX3Bvc2l0aW9uQ2hhbmdlZChhY3RpdmUsIGUpO1xuXG4gICAgLy8gUmVtZW1iZXIgTGFzdCBBY3RpdmVzXG4gICAgY29uc3QgY2hhbmdlZCA9IHJlcGxheSB8fCAhX2VsZW1lbnRzRXF1YWwoYWN0aXZlLCBsYXN0QWN0aXZlKSB8fCBwb3NpdGlvbkNoYW5nZWQ7XG5cbiAgICAvLyBPbmx5IGhhbmRsZSB0YXJnZXQgZXZlbnQgb24gdG9vbHRpcCBjaGFuZ2VcbiAgICBpZiAoY2hhbmdlZCkge1xuICAgICAgdGhpcy5fYWN0aXZlID0gYWN0aXZlO1xuXG4gICAgICBpZiAob3B0aW9ucy5lbmFibGVkIHx8IG9wdGlvbnMuZXh0ZXJuYWwpIHtcbiAgICAgICAgdGhpcy5fZXZlbnRQb3NpdGlvbiA9IHtcbiAgICAgICAgICB4OiBlLngsXG4gICAgICAgICAgeTogZS55XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy51cGRhdGUodHJ1ZSwgcmVwbGF5KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gY2hhbmdlZDtcbiAgfVxuXG4gIC8qKlxuXHQgKiBIZWxwZXIgZm9yIGRldGVybWluaW5nIHRoZSBhY3RpdmUgZWxlbWVudHMgZm9yIGV2ZW50XG5cdCAqIEBwYXJhbSB7Q2hhcnRFdmVudH0gZSAtIFRoZSBldmVudCB0byBoYW5kbGVcblx0ICogQHBhcmFtIHtJbnRlcmFjdGlvbkl0ZW1bXX0gbGFzdEFjdGl2ZSAtIFByZXZpb3VzbHkgYWN0aXZlIGVsZW1lbnRzXG5cdCAqIEBwYXJhbSB7Ym9vbGVhbn0gW3JlcGxheV0gLSBUaGlzIGlzIGEgcmVwbGF5ZWQgZXZlbnQgKGZyb20gdXBkYXRlKVxuXHQgKiBAcGFyYW0ge2Jvb2xlYW59IFtpbkNoYXJ0QXJlYV0gLSBUaGUgZXZlbnQgaXMgaW5zaWRlIGNoYXJ0QXJlYVxuXHQgKiBAcmV0dXJucyB7SW50ZXJhY3Rpb25JdGVtW119IC0gQWN0aXZlIGVsZW1lbnRzXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfZ2V0QWN0aXZlRWxlbWVudHMoZSwgbGFzdEFjdGl2ZSwgcmVwbGF5LCBpbkNoYXJ0QXJlYSkge1xuICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG5cbiAgICBpZiAoZS50eXBlID09PSAnbW91c2VvdXQnKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuXG4gICAgaWYgKCFpbkNoYXJ0QXJlYSkge1xuICAgICAgLy8gTGV0IHVzZXIgY29udHJvbCB0aGUgYWN0aXZlIGVsZW1lbnRzIG91dHNpZGUgY2hhcnRBcmVhLiBFZy4gdXNpbmcgTGVnZW5kLlxuICAgICAgLy8gQnV0IG1ha2Ugc3VyZSB0aGF0IGFjdGl2ZSBlbGVtZW50cyBhcmUgc3RpbGwgdmFsaWQuXG4gICAgICByZXR1cm4gbGFzdEFjdGl2ZS5maWx0ZXIoaSA9PlxuICAgICAgICB0aGlzLmNoYXJ0LmRhdGEuZGF0YXNldHNbaS5kYXRhc2V0SW5kZXhdICYmXG4gICAgICAgIHRoaXMuY2hhcnQuZ2V0RGF0YXNldE1ldGEoaS5kYXRhc2V0SW5kZXgpLmNvbnRyb2xsZXIuZ2V0UGFyc2VkKGkuaW5kZXgpICE9PSB1bmRlZmluZWRcbiAgICAgICk7XG4gICAgfVxuXG4gICAgLy8gRmluZCBBY3RpdmUgRWxlbWVudHMgZm9yIHRvb2x0aXBzXG4gICAgY29uc3QgYWN0aXZlID0gdGhpcy5jaGFydC5nZXRFbGVtZW50c0F0RXZlbnRGb3JNb2RlKGUsIG9wdGlvbnMubW9kZSwgb3B0aW9ucywgcmVwbGF5KTtcblxuICAgIGlmIChvcHRpb25zLnJldmVyc2UpIHtcbiAgICAgIGFjdGl2ZS5yZXZlcnNlKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGFjdGl2ZTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBEZXRlcm1pbmUgaWYgdGhlIGFjdGl2ZSBlbGVtZW50cyArIGV2ZW50IGNvbWJpbmF0aW9uIGNoYW5nZXMgdGhlXG5cdCAqIHRvb2x0aXAgcG9zaXRpb25cblx0ICogQHBhcmFtIHthcnJheX0gYWN0aXZlIC0gQWN0aXZlIGVsZW1lbnRzXG5cdCAqIEBwYXJhbSB7Q2hhcnRFdmVudH0gZSAtIEV2ZW50IHRoYXQgdHJpZ2dlcmVkIHRoZSBwb3NpdGlvbiBjaGFuZ2Vcblx0ICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdGhlIHBvc2l0aW9uIGhhcyBjaGFuZ2VkXG5cdCAqL1xuICBfcG9zaXRpb25DaGFuZ2VkKGFjdGl2ZSwgZSkge1xuICAgIGNvbnN0IHtjYXJldFgsIGNhcmV0WSwgb3B0aW9uc30gPSB0aGlzO1xuICAgIGNvbnN0IHBvc2l0aW9uID0gcG9zaXRpb25lcnNbb3B0aW9ucy5wb3NpdGlvbl0uY2FsbCh0aGlzLCBhY3RpdmUsIGUpO1xuICAgIHJldHVybiBwb3NpdGlvbiAhPT0gZmFsc2UgJiYgKGNhcmV0WCAhPT0gcG9zaXRpb24ueCB8fCBjYXJldFkgIT09IHBvc2l0aW9uLnkpO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgaWQ6ICd0b29sdGlwJyxcbiAgX2VsZW1lbnQ6IFRvb2x0aXAsXG4gIHBvc2l0aW9uZXJzLFxuXG4gIGFmdGVySW5pdChjaGFydCwgX2FyZ3MsIG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucykge1xuICAgICAgY2hhcnQudG9vbHRpcCA9IG5ldyBUb29sdGlwKHtjaGFydCwgb3B0aW9uc30pO1xuICAgIH1cbiAgfSxcblxuICBiZWZvcmVVcGRhdGUoY2hhcnQsIF9hcmdzLCBvcHRpb25zKSB7XG4gICAgaWYgKGNoYXJ0LnRvb2x0aXApIHtcbiAgICAgIGNoYXJ0LnRvb2x0aXAuaW5pdGlhbGl6ZShvcHRpb25zKTtcbiAgICB9XG4gIH0sXG5cbiAgcmVzZXQoY2hhcnQsIF9hcmdzLCBvcHRpb25zKSB7XG4gICAgaWYgKGNoYXJ0LnRvb2x0aXApIHtcbiAgICAgIGNoYXJ0LnRvb2x0aXAuaW5pdGlhbGl6ZShvcHRpb25zKTtcbiAgICB9XG4gIH0sXG5cbiAgYWZ0ZXJEcmF3KGNoYXJ0KSB7XG4gICAgY29uc3QgdG9vbHRpcCA9IGNoYXJ0LnRvb2x0aXA7XG5cbiAgICBpZiAodG9vbHRpcCAmJiB0b29sdGlwLl93aWxsUmVuZGVyKCkpIHtcbiAgICAgIGNvbnN0IGFyZ3MgPSB7XG4gICAgICAgIHRvb2x0aXBcbiAgICAgIH07XG5cbiAgICAgIGlmIChjaGFydC5ub3RpZnlQbHVnaW5zKCdiZWZvcmVUb29sdGlwRHJhdycsIHsuLi5hcmdzLCBjYW5jZWxhYmxlOiB0cnVlfSkgPT09IGZhbHNlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdG9vbHRpcC5kcmF3KGNoYXJ0LmN0eCk7XG5cbiAgICAgIGNoYXJ0Lm5vdGlmeVBsdWdpbnMoJ2FmdGVyVG9vbHRpcERyYXcnLCBhcmdzKTtcbiAgICB9XG4gIH0sXG5cbiAgYWZ0ZXJFdmVudChjaGFydCwgYXJncykge1xuICAgIGlmIChjaGFydC50b29sdGlwKSB7XG4gICAgICAvLyBJZiB0aGUgZXZlbnQgaXMgcmVwbGF5ZWQgZnJvbSBgdXBkYXRlYCwgd2Ugc2hvdWxkIGV2YWx1YXRlIHdpdGggdGhlIGZpbmFsIHBvc2l0aW9ucy5cbiAgICAgIGNvbnN0IHVzZUZpbmFsUG9zaXRpb24gPSBhcmdzLnJlcGxheTtcbiAgICAgIGlmIChjaGFydC50b29sdGlwLmhhbmRsZUV2ZW50KGFyZ3MuZXZlbnQsIHVzZUZpbmFsUG9zaXRpb24sIGFyZ3MuaW5DaGFydEFyZWEpKSB7XG4gICAgICAgIC8vIG5vdGlmeSBjaGFydCBhYm91dCB0aGUgY2hhbmdlLCBzbyBpdCB3aWxsIHJlbmRlclxuICAgICAgICBhcmdzLmNoYW5nZWQgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICBkZWZhdWx0czoge1xuICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgZXh0ZXJuYWw6IG51bGwsXG4gICAgcG9zaXRpb246ICdhdmVyYWdlJyxcbiAgICBiYWNrZ3JvdW5kQ29sb3I6ICdyZ2JhKDAsMCwwLDAuOCknLFxuICAgIHRpdGxlQ29sb3I6ICcjZmZmJyxcbiAgICB0aXRsZUZvbnQ6IHtcbiAgICAgIHdlaWdodDogJ2JvbGQnLFxuICAgIH0sXG4gICAgdGl0bGVTcGFjaW5nOiAyLFxuICAgIHRpdGxlTWFyZ2luQm90dG9tOiA2LFxuICAgIHRpdGxlQWxpZ246ICdsZWZ0JyxcbiAgICBib2R5Q29sb3I6ICcjZmZmJyxcbiAgICBib2R5U3BhY2luZzogMixcbiAgICBib2R5Rm9udDoge1xuICAgIH0sXG4gICAgYm9keUFsaWduOiAnbGVmdCcsXG4gICAgZm9vdGVyQ29sb3I6ICcjZmZmJyxcbiAgICBmb290ZXJTcGFjaW5nOiAyLFxuICAgIGZvb3Rlck1hcmdpblRvcDogNixcbiAgICBmb290ZXJGb250OiB7XG4gICAgICB3ZWlnaHQ6ICdib2xkJyxcbiAgICB9LFxuICAgIGZvb3RlckFsaWduOiAnbGVmdCcsXG4gICAgcGFkZGluZzogNixcbiAgICBjYXJldFBhZGRpbmc6IDIsXG4gICAgY2FyZXRTaXplOiA1LFxuICAgIGNvcm5lclJhZGl1czogNixcbiAgICBib3hIZWlnaHQ6IChjdHgsIG9wdHMpID0+IG9wdHMuYm9keUZvbnQuc2l6ZSxcbiAgICBib3hXaWR0aDogKGN0eCwgb3B0cykgPT4gb3B0cy5ib2R5Rm9udC5zaXplLFxuICAgIG11bHRpS2V5QmFja2dyb3VuZDogJyNmZmYnLFxuICAgIGRpc3BsYXlDb2xvcnM6IHRydWUsXG4gICAgYm94UGFkZGluZzogMCxcbiAgICBib3JkZXJDb2xvcjogJ3JnYmEoMCwwLDAsMCknLFxuICAgIGJvcmRlcldpZHRoOiAwLFxuICAgIGFuaW1hdGlvbjoge1xuICAgICAgZHVyYXRpb246IDQwMCxcbiAgICAgIGVhc2luZzogJ2Vhc2VPdXRRdWFydCcsXG4gICAgfSxcbiAgICBhbmltYXRpb25zOiB7XG4gICAgICBudW1iZXJzOiB7XG4gICAgICAgIHR5cGU6ICdudW1iZXInLFxuICAgICAgICBwcm9wZXJ0aWVzOiBbJ3gnLCAneScsICd3aWR0aCcsICdoZWlnaHQnLCAnY2FyZXRYJywgJ2NhcmV0WSddLFxuICAgICAgfSxcbiAgICAgIG9wYWNpdHk6IHtcbiAgICAgICAgZWFzaW5nOiAnbGluZWFyJyxcbiAgICAgICAgZHVyYXRpb246IDIwMFxuICAgICAgfVxuICAgIH0sXG4gICAgY2FsbGJhY2tzOiBkZWZhdWx0Q2FsbGJhY2tzXG4gIH0sXG5cbiAgZGVmYXVsdFJvdXRlczoge1xuICAgIGJvZHlGb250OiAnZm9udCcsXG4gICAgZm9vdGVyRm9udDogJ2ZvbnQnLFxuICAgIHRpdGxlRm9udDogJ2ZvbnQnXG4gIH0sXG5cbiAgZGVzY3JpcHRvcnM6IHtcbiAgICBfc2NyaXB0YWJsZTogKG5hbWUpID0+IG5hbWUgIT09ICdmaWx0ZXInICYmIG5hbWUgIT09ICdpdGVtU29ydCcgJiYgbmFtZSAhPT0gJ2V4dGVybmFsJyxcbiAgICBfaW5kZXhhYmxlOiBmYWxzZSxcbiAgICBjYWxsYmFja3M6IHtcbiAgICAgIF9zY3JpcHRhYmxlOiBmYWxzZSxcbiAgICAgIF9pbmRleGFibGU6IGZhbHNlLFxuICAgIH0sXG4gICAgYW5pbWF0aW9uOiB7XG4gICAgICBfZmFsbGJhY2s6IGZhbHNlXG4gICAgfSxcbiAgICBhbmltYXRpb25zOiB7XG4gICAgICBfZmFsbGJhY2s6ICdhbmltYXRpb24nXG4gICAgfVxuICB9LFxuXG4gIC8vIFJlc29sdmUgYWRkaXRpb25hbGx5IGZyb20gYGludGVyYWN0aW9uYCBvcHRpb25zIGFuZCBkZWZhdWx0cy5cbiAgYWRkaXRpb25hbE9wdGlvblNjb3BlczogWydpbnRlcmFjdGlvbiddXG59O1xuIiwgImltcG9ydCBTY2FsZSBmcm9tICcuLi9jb3JlL2NvcmUuc2NhbGUuanMnO1xuaW1wb3J0IHtpc051bGxPclVuZGVmLCB2YWx1ZU9yRGVmYXVsdCwgX2xpbWl0VmFsdWV9IGZyb20gJy4uL2hlbHBlcnMvaW5kZXguanMnO1xuXG5jb25zdCBhZGRJZlN0cmluZyA9IChsYWJlbHMsIHJhdywgaW5kZXgsIGFkZGVkTGFiZWxzKSA9PiB7XG4gIGlmICh0eXBlb2YgcmF3ID09PSAnc3RyaW5nJykge1xuICAgIGluZGV4ID0gbGFiZWxzLnB1c2gocmF3KSAtIDE7XG4gICAgYWRkZWRMYWJlbHMudW5zaGlmdCh7aW5kZXgsIGxhYmVsOiByYXd9KTtcbiAgfSBlbHNlIGlmIChpc05hTihyYXcpKSB7XG4gICAgaW5kZXggPSBudWxsO1xuICB9XG4gIHJldHVybiBpbmRleDtcbn07XG5cbmZ1bmN0aW9uIGZpbmRPckFkZExhYmVsKGxhYmVscywgcmF3LCBpbmRleCwgYWRkZWRMYWJlbHMpIHtcbiAgY29uc3QgZmlyc3QgPSBsYWJlbHMuaW5kZXhPZihyYXcpO1xuICBpZiAoZmlyc3QgPT09IC0xKSB7XG4gICAgcmV0dXJuIGFkZElmU3RyaW5nKGxhYmVscywgcmF3LCBpbmRleCwgYWRkZWRMYWJlbHMpO1xuICB9XG4gIGNvbnN0IGxhc3QgPSBsYWJlbHMubGFzdEluZGV4T2YocmF3KTtcbiAgcmV0dXJuIGZpcnN0ICE9PSBsYXN0ID8gaW5kZXggOiBmaXJzdDtcbn1cblxuY29uc3QgdmFsaWRJbmRleCA9IChpbmRleCwgbWF4KSA9PiBpbmRleCA9PT0gbnVsbCA/IG51bGwgOiBfbGltaXRWYWx1ZShNYXRoLnJvdW5kKGluZGV4KSwgMCwgbWF4KTtcblxuZnVuY3Rpb24gX2dldExhYmVsRm9yVmFsdWUodmFsdWUpIHtcbiAgY29uc3QgbGFiZWxzID0gdGhpcy5nZXRMYWJlbHMoKTtcblxuICBpZiAodmFsdWUgPj0gMCAmJiB2YWx1ZSA8IGxhYmVscy5sZW5ndGgpIHtcbiAgICByZXR1cm4gbGFiZWxzW3ZhbHVlXTtcbiAgfVxuICByZXR1cm4gdmFsdWU7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIENhdGVnb3J5U2NhbGUgZXh0ZW5kcyBTY2FsZSB7XG5cbiAgc3RhdGljIGlkID0gJ2NhdGVnb3J5JztcblxuICAvKipcbiAgICogQHR5cGUge2FueX1cbiAgICovXG4gIHN0YXRpYyBkZWZhdWx0cyA9IHtcbiAgICB0aWNrczoge1xuICAgICAgY2FsbGJhY2s6IF9nZXRMYWJlbEZvclZhbHVlXG4gICAgfVxuICB9O1xuXG4gIGNvbnN0cnVjdG9yKGNmZykge1xuICAgIHN1cGVyKGNmZyk7XG5cbiAgICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgICB0aGlzLl9zdGFydFZhbHVlID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX3ZhbHVlUmFuZ2UgPSAwO1xuICAgIHRoaXMuX2FkZGVkTGFiZWxzID0gW107XG4gIH1cblxuICBpbml0KHNjYWxlT3B0aW9ucykge1xuICAgIGNvbnN0IGFkZGVkID0gdGhpcy5fYWRkZWRMYWJlbHM7XG4gICAgaWYgKGFkZGVkLmxlbmd0aCkge1xuICAgICAgY29uc3QgbGFiZWxzID0gdGhpcy5nZXRMYWJlbHMoKTtcbiAgICAgIGZvciAoY29uc3Qge2luZGV4LCBsYWJlbH0gb2YgYWRkZWQpIHtcbiAgICAgICAgaWYgKGxhYmVsc1tpbmRleF0gPT09IGxhYmVsKSB7XG4gICAgICAgICAgbGFiZWxzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMuX2FkZGVkTGFiZWxzID0gW107XG4gICAgfVxuICAgIHN1cGVyLmluaXQoc2NhbGVPcHRpb25zKTtcbiAgfVxuXG4gIHBhcnNlKHJhdywgaW5kZXgpIHtcbiAgICBpZiAoaXNOdWxsT3JVbmRlZihyYXcpKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3QgbGFiZWxzID0gdGhpcy5nZXRMYWJlbHMoKTtcbiAgICBpbmRleCA9IGlzRmluaXRlKGluZGV4KSAmJiBsYWJlbHNbaW5kZXhdID09PSByYXcgPyBpbmRleFxuICAgICAgOiBmaW5kT3JBZGRMYWJlbChsYWJlbHMsIHJhdywgdmFsdWVPckRlZmF1bHQoaW5kZXgsIHJhdyksIHRoaXMuX2FkZGVkTGFiZWxzKTtcbiAgICByZXR1cm4gdmFsaWRJbmRleChpbmRleCwgbGFiZWxzLmxlbmd0aCAtIDEpO1xuICB9XG5cbiAgZGV0ZXJtaW5lRGF0YUxpbWl0cygpIHtcbiAgICBjb25zdCB7bWluRGVmaW5lZCwgbWF4RGVmaW5lZH0gPSB0aGlzLmdldFVzZXJCb3VuZHMoKTtcbiAgICBsZXQge21pbiwgbWF4fSA9IHRoaXMuZ2V0TWluTWF4KHRydWUpO1xuXG4gICAgaWYgKHRoaXMub3B0aW9ucy5ib3VuZHMgPT09ICd0aWNrcycpIHtcbiAgICAgIGlmICghbWluRGVmaW5lZCkge1xuICAgICAgICBtaW4gPSAwO1xuICAgICAgfVxuICAgICAgaWYgKCFtYXhEZWZpbmVkKSB7XG4gICAgICAgIG1heCA9IHRoaXMuZ2V0TGFiZWxzKCkubGVuZ3RoIC0gMTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLm1pbiA9IG1pbjtcbiAgICB0aGlzLm1heCA9IG1heDtcbiAgfVxuXG4gIGJ1aWxkVGlja3MoKSB7XG4gICAgY29uc3QgbWluID0gdGhpcy5taW47XG4gICAgY29uc3QgbWF4ID0gdGhpcy5tYXg7XG4gICAgY29uc3Qgb2Zmc2V0ID0gdGhpcy5vcHRpb25zLm9mZnNldDtcbiAgICBjb25zdCB0aWNrcyA9IFtdO1xuICAgIGxldCBsYWJlbHMgPSB0aGlzLmdldExhYmVscygpO1xuXG4gICAgLy8gSWYgd2UgYXJlIHZpZXdpbmcgc29tZSBzdWJzZXQgb2YgbGFiZWxzLCBzbGljZSB0aGUgb3JpZ2luYWwgYXJyYXlcbiAgICBsYWJlbHMgPSAobWluID09PSAwICYmIG1heCA9PT0gbGFiZWxzLmxlbmd0aCAtIDEpID8gbGFiZWxzIDogbGFiZWxzLnNsaWNlKG1pbiwgbWF4ICsgMSk7XG5cbiAgICB0aGlzLl92YWx1ZVJhbmdlID0gTWF0aC5tYXgobGFiZWxzLmxlbmd0aCAtIChvZmZzZXQgPyAwIDogMSksIDEpO1xuICAgIHRoaXMuX3N0YXJ0VmFsdWUgPSB0aGlzLm1pbiAtIChvZmZzZXQgPyAwLjUgOiAwKTtcblxuICAgIGZvciAobGV0IHZhbHVlID0gbWluOyB2YWx1ZSA8PSBtYXg7IHZhbHVlKyspIHtcbiAgICAgIHRpY2tzLnB1c2goe3ZhbHVlfSk7XG4gICAgfVxuICAgIHJldHVybiB0aWNrcztcbiAgfVxuXG4gIGdldExhYmVsRm9yVmFsdWUodmFsdWUpIHtcbiAgICByZXR1cm4gX2dldExhYmVsRm9yVmFsdWUuY2FsbCh0aGlzLCB2YWx1ZSk7XG4gIH1cblxuICAvKipcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cbiAgY29uZmlndXJlKCkge1xuICAgIHN1cGVyLmNvbmZpZ3VyZSgpO1xuXG4gICAgaWYgKCF0aGlzLmlzSG9yaXpvbnRhbCgpKSB7XG4gICAgICAvLyBGb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eSwgdmVydGljYWwgY2F0ZWdvcnkgc2NhbGUgcmV2ZXJzZSBpcyBpbnZlcnRlZC5cbiAgICAgIHRoaXMuX3JldmVyc2VQaXhlbHMgPSAhdGhpcy5fcmV2ZXJzZVBpeGVscztcbiAgICB9XG4gIH1cblxuICAvLyBVc2VkIHRvIGdldCBkYXRhIHZhbHVlIGxvY2F0aW9ucy4gVmFsdWUgY2FuIGVpdGhlciBiZSBhbiBpbmRleCBvciBhIG51bWVyaWNhbCB2YWx1ZVxuICBnZXRQaXhlbEZvclZhbHVlKHZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ251bWJlcicpIHtcbiAgICAgIHZhbHVlID0gdGhpcy5wYXJzZSh2YWx1ZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHZhbHVlID09PSBudWxsID8gTmFOIDogdGhpcy5nZXRQaXhlbEZvckRlY2ltYWwoKHZhbHVlIC0gdGhpcy5fc3RhcnRWYWx1ZSkgLyB0aGlzLl92YWx1ZVJhbmdlKTtcbiAgfVxuXG4gIC8vIE11c3Qgb3ZlcnJpZGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBiZWNhdXNlIGl0IGNhbGxzIGdldFBpeGVsRm9yVmFsdWVcbiAgLy8gYW5kIGNhdGVnb3J5IHNjYWxlIGNhbiBoYXZlIGR1cGxpY2F0ZSB2YWx1ZXNcbiAgZ2V0UGl4ZWxGb3JUaWNrKGluZGV4KSB7XG4gICAgY29uc3QgdGlja3MgPSB0aGlzLnRpY2tzO1xuICAgIGlmIChpbmRleCA8IDAgfHwgaW5kZXggPiB0aWNrcy5sZW5ndGggLSAxKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZ2V0UGl4ZWxGb3JWYWx1ZSh0aWNrc1tpbmRleF0udmFsdWUpO1xuICB9XG5cbiAgZ2V0VmFsdWVGb3JQaXhlbChwaXhlbCkge1xuICAgIHJldHVybiBNYXRoLnJvdW5kKHRoaXMuX3N0YXJ0VmFsdWUgKyB0aGlzLmdldERlY2ltYWxGb3JQaXhlbChwaXhlbCkgKiB0aGlzLl92YWx1ZVJhbmdlKTtcbiAgfVxuXG4gIGdldEJhc2VQaXhlbCgpIHtcbiAgICByZXR1cm4gdGhpcy5ib3R0b207XG4gIH1cbn1cbiIsICJpbXBvcnQge2lzTnVsbE9yVW5kZWZ9IGZyb20gJy4uL2hlbHBlcnMvaGVscGVycy5jb3JlLmpzJztcbmltcG9ydCB7YWxtb3N0RXF1YWxzLCBhbG1vc3RXaG9sZSwgbmljZU51bSwgX2RlY2ltYWxQbGFjZXMsIF9zZXRNaW5BbmRNYXhCeUtleSwgc2lnbiwgdG9SYWRpYW5zfSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMubWF0aC5qcyc7XG5pbXBvcnQgU2NhbGUgZnJvbSAnLi4vY29yZS9jb3JlLnNjYWxlLmpzJztcbmltcG9ydCB7Zm9ybWF0TnVtYmVyfSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMuaW50bC5qcyc7XG5cbi8qKlxuICogR2VuZXJhdGUgYSBzZXQgb2YgbGluZWFyIHRpY2tzIGZvciBhbiBheGlzXG4gKiAxLiBJZiBnZW5lcmF0aW9uT3B0aW9ucy5taW4sIGdlbmVyYXRpb25PcHRpb25zLm1heCwgYW5kIGdlbmVyYXRpb25PcHRpb25zLnN0ZXAgYXJlIGRlZmluZWQ6XG4gKiAgICBpZiAobWF4IC0gbWluKSAvIHN0ZXAgaXMgYW4gaW50ZWdlciwgdGlja3MgYXJlIGdlbmVyYXRlZCBhcyBbbWluLCBtaW4gKyBzdGVwLCAuLi4sIG1heF1cbiAqICAgIE5vdGUgdGhhdCB0aGUgZ2VuZXJhdGlvbk9wdGlvbnMubWF4Q291bnQgc2V0dGluZyBpcyByZXNwZWN0ZWQgaW4gdGhpcyBzY2VuYXJpb1xuICpcbiAqIDIuIElmIGdlbmVyYXRpb25PcHRpb25zLm1pbiwgZ2VuZXJhdGlvbk9wdGlvbnMubWF4LCBhbmQgZ2VuZXJhdGlvbk9wdGlvbnMuY291bnQgaXMgZGVmaW5lZFxuICogICAgc3BhY2luZyA9IChtYXggLSBtaW4pIC8gY291bnRcbiAqICAgIFRpY2tzIGFyZSBnZW5lcmF0ZWQgYXMgW21pbiwgbWluICsgc3BhY2luZywgLi4uLCBtYXhdXG4gKlxuICogMy4gSWYgZ2VuZXJhdGlvbk9wdGlvbnMuY291bnQgaXMgZGVmaW5lZFxuICogICAgc3BhY2luZyA9IChuaWNlTWF4IC0gbmljZU1pbikgLyBjb3VudFxuICpcbiAqIDQuIENvbXB1dGUgb3B0aW1hbCBzcGFjaW5nIG9mIHRpY2tzIHVzaW5nIG5pY2VOdW0gYWxnb3JpdGhtXG4gKlxuICogQHBhcmFtIGdlbmVyYXRpb25PcHRpb25zIHRoZSBvcHRpb25zIHVzZWQgdG8gZ2VuZXJhdGUgdGhlIHRpY2tzXG4gKiBAcGFyYW0gZGF0YVJhbmdlIHRoZSByYW5nZSBvZiB0aGUgZGF0YVxuICogQHJldHVybnMge29iamVjdFtdfSBhcnJheSBvZiB0aWNrIG9iamVjdHNcbiAqL1xuZnVuY3Rpb24gZ2VuZXJhdGVUaWNrcyhnZW5lcmF0aW9uT3B0aW9ucywgZGF0YVJhbmdlKSB7XG4gIGNvbnN0IHRpY2tzID0gW107XG4gIC8vIFRvIGdldCBhIFwibmljZVwiIHZhbHVlIGZvciB0aGUgdGljayBzcGFjaW5nLCB3ZSB3aWxsIHVzZSB0aGUgYXBwcm9wcmlhdGVseSBuYW1lZFxuICAvLyBcIm5pY2UgbnVtYmVyXCIgYWxnb3JpdGhtLiBTZWUgaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvODUwNjg4MS9uaWNlLWxhYmVsLWFsZ29yaXRobS1mb3ItY2hhcnRzLXdpdGgtbWluaW11bS10aWNrc1xuICAvLyBmb3IgZGV0YWlscy5cblxuICBjb25zdCBNSU5fU1BBQ0lORyA9IDFlLTE0O1xuICBjb25zdCB7Ym91bmRzLCBzdGVwLCBtaW4sIG1heCwgcHJlY2lzaW9uLCBjb3VudCwgbWF4VGlja3MsIG1heERpZ2l0cywgaW5jbHVkZUJvdW5kc30gPSBnZW5lcmF0aW9uT3B0aW9ucztcbiAgY29uc3QgdW5pdCA9IHN0ZXAgfHwgMTtcbiAgY29uc3QgbWF4U3BhY2VzID0gbWF4VGlja3MgLSAxO1xuICBjb25zdCB7bWluOiBybWluLCBtYXg6IHJtYXh9ID0gZGF0YVJhbmdlO1xuICBjb25zdCBtaW5EZWZpbmVkID0gIWlzTnVsbE9yVW5kZWYobWluKTtcbiAgY29uc3QgbWF4RGVmaW5lZCA9ICFpc051bGxPclVuZGVmKG1heCk7XG4gIGNvbnN0IGNvdW50RGVmaW5lZCA9ICFpc051bGxPclVuZGVmKGNvdW50KTtcbiAgY29uc3QgbWluU3BhY2luZyA9IChybWF4IC0gcm1pbikgLyAobWF4RGlnaXRzICsgMSk7XG4gIGxldCBzcGFjaW5nID0gbmljZU51bSgocm1heCAtIHJtaW4pIC8gbWF4U3BhY2VzIC8gdW5pdCkgKiB1bml0O1xuICBsZXQgZmFjdG9yLCBuaWNlTWluLCBuaWNlTWF4LCBudW1TcGFjZXM7XG5cbiAgLy8gQmV5b25kIE1JTl9TUEFDSU5HIGZsb2F0aW5nIHBvaW50IG51bWJlcnMgYmVpbmcgdG8gbG9zZSBwcmVjaXNpb25cbiAgLy8gc3VjaCB0aGF0IHdlIGNhbid0IGRvIHRoZSBtYXRoIG5lY2Vzc2FyeSB0byBnZW5lcmF0ZSB0aWNrc1xuICBpZiAoc3BhY2luZyA8IE1JTl9TUEFDSU5HICYmICFtaW5EZWZpbmVkICYmICFtYXhEZWZpbmVkKSB7XG4gICAgcmV0dXJuIFt7dmFsdWU6IHJtaW59LCB7dmFsdWU6IHJtYXh9XTtcbiAgfVxuXG4gIG51bVNwYWNlcyA9IE1hdGguY2VpbChybWF4IC8gc3BhY2luZykgLSBNYXRoLmZsb29yKHJtaW4gLyBzcGFjaW5nKTtcbiAgaWYgKG51bVNwYWNlcyA+IG1heFNwYWNlcykge1xuICAgIC8vIElmIHRoZSBjYWxjdWxhdGVkIG51bSBvZiBzcGFjZXMgZXhjZWVkcyBtYXhOdW1TcGFjZXMsIHJlY2FsY3VsYXRlIGl0XG4gICAgc3BhY2luZyA9IG5pY2VOdW0obnVtU3BhY2VzICogc3BhY2luZyAvIG1heFNwYWNlcyAvIHVuaXQpICogdW5pdDtcbiAgfVxuXG4gIGlmICghaXNOdWxsT3JVbmRlZihwcmVjaXNpb24pKSB7XG4gICAgLy8gSWYgdGhlIHVzZXIgc3BlY2lmaWVkIGEgcHJlY2lzaW9uLCByb3VuZCB0byB0aGF0IG51bWJlciBvZiBkZWNpbWFsIHBsYWNlc1xuICAgIGZhY3RvciA9IE1hdGgucG93KDEwLCBwcmVjaXNpb24pO1xuICAgIHNwYWNpbmcgPSBNYXRoLmNlaWwoc3BhY2luZyAqIGZhY3RvcikgLyBmYWN0b3I7XG4gIH1cblxuICBpZiAoYm91bmRzID09PSAndGlja3MnKSB7XG4gICAgbmljZU1pbiA9IE1hdGguZmxvb3Iocm1pbiAvIHNwYWNpbmcpICogc3BhY2luZztcbiAgICBuaWNlTWF4ID0gTWF0aC5jZWlsKHJtYXggLyBzcGFjaW5nKSAqIHNwYWNpbmc7XG4gIH0gZWxzZSB7XG4gICAgbmljZU1pbiA9IHJtaW47XG4gICAgbmljZU1heCA9IHJtYXg7XG4gIH1cblxuICBpZiAobWluRGVmaW5lZCAmJiBtYXhEZWZpbmVkICYmIHN0ZXAgJiYgYWxtb3N0V2hvbGUoKG1heCAtIG1pbikgLyBzdGVwLCBzcGFjaW5nIC8gMTAwMCkpIHtcbiAgICAvLyBDYXNlIDE6IElmIG1pbiwgbWF4IGFuZCBzdGVwU2l6ZSBhcmUgc2V0IGFuZCB0aGV5IG1ha2UgYW4gZXZlbmx5IHNwYWNlZCBzY2FsZSB1c2UgaXQuXG4gICAgLy8gc3BhY2luZyA9IHN0ZXA7XG4gICAgLy8gbnVtU3BhY2VzID0gKG1heCAtIG1pbikgLyBzcGFjaW5nO1xuICAgIC8vIE5vdGUgdGhhdCB3ZSByb3VuZCBoZXJlIHRvIGhhbmRsZSB0aGUgY2FzZSB3aGVyZSBhbG1vc3RXaG9sZSB0cmFuc2xhdGVkIGFuIEZQIGVycm9yXG4gICAgbnVtU3BhY2VzID0gTWF0aC5yb3VuZChNYXRoLm1pbigobWF4IC0gbWluKSAvIHNwYWNpbmcsIG1heFRpY2tzKSk7XG4gICAgc3BhY2luZyA9IChtYXggLSBtaW4pIC8gbnVtU3BhY2VzO1xuICAgIG5pY2VNaW4gPSBtaW47XG4gICAgbmljZU1heCA9IG1heDtcbiAgfSBlbHNlIGlmIChjb3VudERlZmluZWQpIHtcbiAgICAvLyBDYXNlcyAyICYgMywgd2UgaGF2ZSBhIGNvdW50IHNwZWNpZmllZC4gSGFuZGxlIG9wdGlvbmFsIHVzZXIgZGVmaW5lZCBlZGdlcyB0byB0aGUgcmFuZ2UuXG4gICAgLy8gU29tZXRpbWVzIHRoZXNlIGFyZSBuby1vcHMsIGJ1dCBpdCBtYWtlcyB0aGUgY29kZSBhIGxvdCBjbGVhcmVyXG4gICAgLy8gYW5kIHdoZW4gYSB1c2VyIGRlZmluZWQgcmFuZ2UgaXMgc3BlY2lmaWVkLCB3ZSB3YW50IHRoZSBjb3JyZWN0IHRpY2tzXG4gICAgbmljZU1pbiA9IG1pbkRlZmluZWQgPyBtaW4gOiBuaWNlTWluO1xuICAgIG5pY2VNYXggPSBtYXhEZWZpbmVkID8gbWF4IDogbmljZU1heDtcbiAgICBudW1TcGFjZXMgPSBjb3VudCAtIDE7XG4gICAgc3BhY2luZyA9IChuaWNlTWF4IC0gbmljZU1pbikgLyBudW1TcGFjZXM7XG4gIH0gZWxzZSB7XG4gICAgLy8gQ2FzZSA0XG4gICAgbnVtU3BhY2VzID0gKG5pY2VNYXggLSBuaWNlTWluKSAvIHNwYWNpbmc7XG5cbiAgICAvLyBJZiB2ZXJ5IGNsb3NlIHRvIG91ciByb3VuZGVkIHZhbHVlLCB1c2UgaXQuXG4gICAgaWYgKGFsbW9zdEVxdWFscyhudW1TcGFjZXMsIE1hdGgucm91bmQobnVtU3BhY2VzKSwgc3BhY2luZyAvIDEwMDApKSB7XG4gICAgICBudW1TcGFjZXMgPSBNYXRoLnJvdW5kKG51bVNwYWNlcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG51bVNwYWNlcyA9IE1hdGguY2VpbChudW1TcGFjZXMpO1xuICAgIH1cbiAgfVxuXG4gIC8vIFRoZSBzcGFjaW5nIHdpbGwgaGF2ZSBjaGFuZ2VkIGluIGNhc2VzIDEsIDIsIGFuZCAzIHNvIHRoZSBmYWN0b3IgY2Fubm90IGJlIGNvbXB1dGVkXG4gIC8vIHVudGlsIHRoaXMgcG9pbnRcbiAgY29uc3QgZGVjaW1hbFBsYWNlcyA9IE1hdGgubWF4KFxuICAgIF9kZWNpbWFsUGxhY2VzKHNwYWNpbmcpLFxuICAgIF9kZWNpbWFsUGxhY2VzKG5pY2VNaW4pXG4gICk7XG4gIGZhY3RvciA9IE1hdGgucG93KDEwLCBpc051bGxPclVuZGVmKHByZWNpc2lvbikgPyBkZWNpbWFsUGxhY2VzIDogcHJlY2lzaW9uKTtcbiAgbmljZU1pbiA9IE1hdGgucm91bmQobmljZU1pbiAqIGZhY3RvcikgLyBmYWN0b3I7XG4gIG5pY2VNYXggPSBNYXRoLnJvdW5kKG5pY2VNYXggKiBmYWN0b3IpIC8gZmFjdG9yO1xuXG4gIGxldCBqID0gMDtcbiAgaWYgKG1pbkRlZmluZWQpIHtcbiAgICBpZiAoaW5jbHVkZUJvdW5kcyAmJiBuaWNlTWluICE9PSBtaW4pIHtcbiAgICAgIHRpY2tzLnB1c2goe3ZhbHVlOiBtaW59KTtcblxuICAgICAgaWYgKG5pY2VNaW4gPCBtaW4pIHtcbiAgICAgICAgaisrOyAvLyBTa2lwIG5pY2VNaW5cbiAgICAgIH1cbiAgICAgIC8vIElmIHRoZSBuZXh0IG5pY2UgdGljayBpcyBjbG9zZSB0byBtaW4sIHNraXAgaXRcbiAgICAgIGlmIChhbG1vc3RFcXVhbHMoTWF0aC5yb3VuZCgobmljZU1pbiArIGogKiBzcGFjaW5nKSAqIGZhY3RvcikgLyBmYWN0b3IsIG1pbiwgcmVsYXRpdmVMYWJlbFNpemUobWluLCBtaW5TcGFjaW5nLCBnZW5lcmF0aW9uT3B0aW9ucykpKSB7XG4gICAgICAgIGorKztcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG5pY2VNaW4gPCBtaW4pIHtcbiAgICAgIGorKztcbiAgICB9XG4gIH1cblxuICBmb3IgKDsgaiA8IG51bVNwYWNlczsgKytqKSB7XG4gICAgY29uc3QgdGlja1ZhbHVlID0gTWF0aC5yb3VuZCgobmljZU1pbiArIGogKiBzcGFjaW5nKSAqIGZhY3RvcikgLyBmYWN0b3I7XG4gICAgaWYgKG1heERlZmluZWQgJiYgdGlja1ZhbHVlID4gbWF4KSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgdGlja3MucHVzaCh7dmFsdWU6IHRpY2tWYWx1ZX0pO1xuICB9XG5cbiAgaWYgKG1heERlZmluZWQgJiYgaW5jbHVkZUJvdW5kcyAmJiBuaWNlTWF4ICE9PSBtYXgpIHtcbiAgICAvLyBJZiB0aGUgcHJldmlvdXMgdGljayBpcyB0b28gY2xvc2UgdG8gbWF4LCByZXBsYWNlIGl0IHdpdGggbWF4LCBlbHNlIGFkZCBtYXhcbiAgICBpZiAodGlja3MubGVuZ3RoICYmIGFsbW9zdEVxdWFscyh0aWNrc1t0aWNrcy5sZW5ndGggLSAxXS52YWx1ZSwgbWF4LCByZWxhdGl2ZUxhYmVsU2l6ZShtYXgsIG1pblNwYWNpbmcsIGdlbmVyYXRpb25PcHRpb25zKSkpIHtcbiAgICAgIHRpY2tzW3RpY2tzLmxlbmd0aCAtIDFdLnZhbHVlID0gbWF4O1xuICAgIH0gZWxzZSB7XG4gICAgICB0aWNrcy5wdXNoKHt2YWx1ZTogbWF4fSk7XG4gICAgfVxuICB9IGVsc2UgaWYgKCFtYXhEZWZpbmVkIHx8IG5pY2VNYXggPT09IG1heCkge1xuICAgIHRpY2tzLnB1c2goe3ZhbHVlOiBuaWNlTWF4fSk7XG4gIH1cblxuICByZXR1cm4gdGlja3M7XG59XG5cbmZ1bmN0aW9uIHJlbGF0aXZlTGFiZWxTaXplKHZhbHVlLCBtaW5TcGFjaW5nLCB7aG9yaXpvbnRhbCwgbWluUm90YXRpb259KSB7XG4gIGNvbnN0IHJhZCA9IHRvUmFkaWFucyhtaW5Sb3RhdGlvbik7XG4gIGNvbnN0IHJhdGlvID0gKGhvcml6b250YWwgPyBNYXRoLnNpbihyYWQpIDogTWF0aC5jb3MocmFkKSkgfHwgMC4wMDE7XG4gIGNvbnN0IGxlbmd0aCA9IDAuNzUgKiBtaW5TcGFjaW5nICogKCcnICsgdmFsdWUpLmxlbmd0aDtcbiAgcmV0dXJuIE1hdGgubWluKG1pblNwYWNpbmcgLyByYXRpbywgbGVuZ3RoKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTGluZWFyU2NhbGVCYXNlIGV4dGVuZHMgU2NhbGUge1xuXG4gIGNvbnN0cnVjdG9yKGNmZykge1xuICAgIHN1cGVyKGNmZyk7XG5cbiAgICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgICB0aGlzLnN0YXJ0ID0gdW5kZWZpbmVkO1xuICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgIHRoaXMuZW5kID0gdW5kZWZpbmVkO1xuICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgIHRoaXMuX3N0YXJ0VmFsdWUgPSB1bmRlZmluZWQ7XG4gICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgdGhpcy5fZW5kVmFsdWUgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fdmFsdWVSYW5nZSA9IDA7XG4gIH1cblxuICBwYXJzZShyYXcsIGluZGV4KSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgICBpZiAoaXNOdWxsT3JVbmRlZihyYXcpKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgaWYgKCh0eXBlb2YgcmF3ID09PSAnbnVtYmVyJyB8fCByYXcgaW5zdGFuY2VvZiBOdW1iZXIpICYmICFpc0Zpbml0ZSgrcmF3KSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuICtyYXc7XG4gIH1cblxuICBoYW5kbGVUaWNrUmFuZ2VPcHRpb25zKCkge1xuICAgIGNvbnN0IHtiZWdpbkF0WmVyb30gPSB0aGlzLm9wdGlvbnM7XG4gICAgY29uc3Qge21pbkRlZmluZWQsIG1heERlZmluZWR9ID0gdGhpcy5nZXRVc2VyQm91bmRzKCk7XG4gICAgbGV0IHttaW4sIG1heH0gPSB0aGlzO1xuXG4gICAgY29uc3Qgc2V0TWluID0gdiA9PiAobWluID0gbWluRGVmaW5lZCA/IG1pbiA6IHYpO1xuICAgIGNvbnN0IHNldE1heCA9IHYgPT4gKG1heCA9IG1heERlZmluZWQgPyBtYXggOiB2KTtcblxuICAgIGlmIChiZWdpbkF0WmVybykge1xuICAgICAgY29uc3QgbWluU2lnbiA9IHNpZ24obWluKTtcbiAgICAgIGNvbnN0IG1heFNpZ24gPSBzaWduKG1heCk7XG5cbiAgICAgIGlmIChtaW5TaWduIDwgMCAmJiBtYXhTaWduIDwgMCkge1xuICAgICAgICBzZXRNYXgoMCk7XG4gICAgICB9IGVsc2UgaWYgKG1pblNpZ24gPiAwICYmIG1heFNpZ24gPiAwKSB7XG4gICAgICAgIHNldE1pbigwKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAobWluID09PSBtYXgpIHtcbiAgICAgIGxldCBvZmZzZXQgPSBtYXggPT09IDAgPyAxIDogTWF0aC5hYnMobWF4ICogMC4wNSk7XG5cbiAgICAgIHNldE1heChtYXggKyBvZmZzZXQpO1xuXG4gICAgICBpZiAoIWJlZ2luQXRaZXJvKSB7XG4gICAgICAgIHNldE1pbihtaW4gLSBvZmZzZXQpO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLm1pbiA9IG1pbjtcbiAgICB0aGlzLm1heCA9IG1heDtcbiAgfVxuXG4gIGdldFRpY2tMaW1pdCgpIHtcbiAgICBjb25zdCB0aWNrT3B0cyA9IHRoaXMub3B0aW9ucy50aWNrcztcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcHJlZmVyLWNvbnN0XG4gICAgbGV0IHttYXhUaWNrc0xpbWl0LCBzdGVwU2l6ZX0gPSB0aWNrT3B0cztcbiAgICBsZXQgbWF4VGlja3M7XG5cbiAgICBpZiAoc3RlcFNpemUpIHtcbiAgICAgIG1heFRpY2tzID0gTWF0aC5jZWlsKHRoaXMubWF4IC8gc3RlcFNpemUpIC0gTWF0aC5mbG9vcih0aGlzLm1pbiAvIHN0ZXBTaXplKSArIDE7XG4gICAgICBpZiAobWF4VGlja3MgPiAxMDAwKSB7XG4gICAgICAgIGNvbnNvbGUud2Fybihgc2NhbGVzLiR7dGhpcy5pZH0udGlja3Muc3RlcFNpemU6ICR7c3RlcFNpemV9IHdvdWxkIHJlc3VsdCBnZW5lcmF0aW5nIHVwIHRvICR7bWF4VGlja3N9IHRpY2tzLiBMaW1pdGluZyB0byAxMDAwLmApO1xuICAgICAgICBtYXhUaWNrcyA9IDEwMDA7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIG1heFRpY2tzID0gdGhpcy5jb21wdXRlVGlja0xpbWl0KCk7XG4gICAgICBtYXhUaWNrc0xpbWl0ID0gbWF4VGlja3NMaW1pdCB8fCAxMTtcbiAgICB9XG5cbiAgICBpZiAobWF4VGlja3NMaW1pdCkge1xuICAgICAgbWF4VGlja3MgPSBNYXRoLm1pbihtYXhUaWNrc0xpbWl0LCBtYXhUaWNrcyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG1heFRpY2tzO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG4gIGNvbXB1dGVUaWNrTGltaXQoKSB7XG4gICAgcmV0dXJuIE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcbiAgfVxuXG4gIGJ1aWxkVGlja3MoKSB7XG4gICAgY29uc3Qgb3B0cyA9IHRoaXMub3B0aW9ucztcbiAgICBjb25zdCB0aWNrT3B0cyA9IG9wdHMudGlja3M7XG5cbiAgICAvLyBGaWd1cmUgb3V0IHdoYXQgdGhlIG1heCBudW1iZXIgb2YgdGlja3Mgd2UgY2FuIHN1cHBvcnQgaXQgaXMgYmFzZWQgb24gdGhlIHNpemUgb2ZcbiAgICAvLyB0aGUgYXhpcyBhcmVhLiBGb3Igbm93LCB3ZSBzYXkgdGhhdCB0aGUgbWluaW11bSB0aWNrIHNwYWNpbmcgaW4gcGl4ZWxzIG11c3QgYmUgNDBcbiAgICAvLyBXZSBhbHNvIGxpbWl0IHRoZSBtYXhpbXVtIG51bWJlciBvZiB0aWNrcyB0byAxMSB3aGljaCBnaXZlcyBhIG5pY2UgMTAgc3F1YXJlcyBvblxuICAgIC8vIHRoZSBncmFwaC4gTWFrZSBzdXJlIHdlIGFsd2F5cyBoYXZlIGF0IGxlYXN0IDIgdGlja3NcbiAgICBsZXQgbWF4VGlja3MgPSB0aGlzLmdldFRpY2tMaW1pdCgpO1xuICAgIG1heFRpY2tzID0gTWF0aC5tYXgoMiwgbWF4VGlja3MpO1xuXG4gICAgY29uc3QgbnVtZXJpY0dlbmVyYXRvck9wdGlvbnMgPSB7XG4gICAgICBtYXhUaWNrcyxcbiAgICAgIGJvdW5kczogb3B0cy5ib3VuZHMsXG4gICAgICBtaW46IG9wdHMubWluLFxuICAgICAgbWF4OiBvcHRzLm1heCxcbiAgICAgIHByZWNpc2lvbjogdGlja09wdHMucHJlY2lzaW9uLFxuICAgICAgc3RlcDogdGlja09wdHMuc3RlcFNpemUsXG4gICAgICBjb3VudDogdGlja09wdHMuY291bnQsXG4gICAgICBtYXhEaWdpdHM6IHRoaXMuX21heERpZ2l0cygpLFxuICAgICAgaG9yaXpvbnRhbDogdGhpcy5pc0hvcml6b250YWwoKSxcbiAgICAgIG1pblJvdGF0aW9uOiB0aWNrT3B0cy5taW5Sb3RhdGlvbiB8fCAwLFxuICAgICAgaW5jbHVkZUJvdW5kczogdGlja09wdHMuaW5jbHVkZUJvdW5kcyAhPT0gZmFsc2VcbiAgICB9O1xuICAgIGNvbnN0IGRhdGFSYW5nZSA9IHRoaXMuX3JhbmdlIHx8IHRoaXM7XG4gICAgY29uc3QgdGlja3MgPSBnZW5lcmF0ZVRpY2tzKG51bWVyaWNHZW5lcmF0b3JPcHRpb25zLCBkYXRhUmFuZ2UpO1xuXG4gICAgLy8gQXQgdGhpcyBwb2ludCwgd2UgbmVlZCB0byB1cGRhdGUgb3VyIG1heCBhbmQgbWluIGdpdmVuIHRoZSB0aWNrIHZhbHVlcyxcbiAgICAvLyBzaW5jZSB3ZSBwcm9iYWJseSBoYXZlIGV4cGFuZGVkIHRoZSByYW5nZSBvZiB0aGUgc2NhbGVcbiAgICBpZiAob3B0cy5ib3VuZHMgPT09ICd0aWNrcycpIHtcbiAgICAgIF9zZXRNaW5BbmRNYXhCeUtleSh0aWNrcywgdGhpcywgJ3ZhbHVlJyk7XG4gICAgfVxuXG4gICAgaWYgKG9wdHMucmV2ZXJzZSkge1xuICAgICAgdGlja3MucmV2ZXJzZSgpO1xuXG4gICAgICB0aGlzLnN0YXJ0ID0gdGhpcy5tYXg7XG4gICAgICB0aGlzLmVuZCA9IHRoaXMubWluO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnN0YXJ0ID0gdGhpcy5taW47XG4gICAgICB0aGlzLmVuZCA9IHRoaXMubWF4O1xuICAgIH1cblxuICAgIHJldHVybiB0aWNrcztcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuICBjb25maWd1cmUoKSB7XG4gICAgY29uc3QgdGlja3MgPSB0aGlzLnRpY2tzO1xuICAgIGxldCBzdGFydCA9IHRoaXMubWluO1xuICAgIGxldCBlbmQgPSB0aGlzLm1heDtcblxuICAgIHN1cGVyLmNvbmZpZ3VyZSgpO1xuXG4gICAgaWYgKHRoaXMub3B0aW9ucy5vZmZzZXQgJiYgdGlja3MubGVuZ3RoKSB7XG4gICAgICBjb25zdCBvZmZzZXQgPSAoZW5kIC0gc3RhcnQpIC8gTWF0aC5tYXgodGlja3MubGVuZ3RoIC0gMSwgMSkgLyAyO1xuICAgICAgc3RhcnQgLT0gb2Zmc2V0O1xuICAgICAgZW5kICs9IG9mZnNldDtcbiAgICB9XG4gICAgdGhpcy5fc3RhcnRWYWx1ZSA9IHN0YXJ0O1xuICAgIHRoaXMuX2VuZFZhbHVlID0gZW5kO1xuICAgIHRoaXMuX3ZhbHVlUmFuZ2UgPSBlbmQgLSBzdGFydDtcbiAgfVxuXG4gIGdldExhYmVsRm9yVmFsdWUodmFsdWUpIHtcbiAgICByZXR1cm4gZm9ybWF0TnVtYmVyKHZhbHVlLCB0aGlzLmNoYXJ0Lm9wdGlvbnMubG9jYWxlLCB0aGlzLm9wdGlvbnMudGlja3MuZm9ybWF0KTtcbiAgfVxufVxuIiwgImltcG9ydCB7aXNGaW5pdGV9IGZyb20gJy4uL2hlbHBlcnMvaGVscGVycy5jb3JlLmpzJztcbmltcG9ydCBMaW5lYXJTY2FsZUJhc2UgZnJvbSAnLi9zY2FsZS5saW5lYXJiYXNlLmpzJztcbmltcG9ydCBUaWNrcyBmcm9tICcuLi9jb3JlL2NvcmUudGlja3MuanMnO1xuaW1wb3J0IHt0b1JhZGlhbnN9IGZyb20gJy4uL2hlbHBlcnMvaW5kZXguanMnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBMaW5lYXJTY2FsZSBleHRlbmRzIExpbmVhclNjYWxlQmFzZSB7XG5cbiAgc3RhdGljIGlkID0gJ2xpbmVhcic7XG5cbiAgLyoqXG4gICAqIEB0eXBlIHthbnl9XG4gICAqL1xuICBzdGF0aWMgZGVmYXVsdHMgPSB7XG4gICAgdGlja3M6IHtcbiAgICAgIGNhbGxiYWNrOiBUaWNrcy5mb3JtYXR0ZXJzLm51bWVyaWNcbiAgICB9XG4gIH07XG5cblxuICBkZXRlcm1pbmVEYXRhTGltaXRzKCkge1xuICAgIGNvbnN0IHttaW4sIG1heH0gPSB0aGlzLmdldE1pbk1heCh0cnVlKTtcblxuICAgIHRoaXMubWluID0gaXNGaW5pdGUobWluKSA/IG1pbiA6IDA7XG4gICAgdGhpcy5tYXggPSBpc0Zpbml0ZShtYXgpID8gbWF4IDogMTtcblxuICAgIC8vIENvbW1vbiBiYXNlIGltcGxlbWVudGF0aW9uIHRvIGhhbmRsZSBtaW4sIG1heCwgYmVnaW5BdFplcm9cbiAgICB0aGlzLmhhbmRsZVRpY2tSYW5nZU9wdGlvbnMoKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBSZXR1cm5zIHRoZSBtYXhpbXVtIG51bWJlciBvZiB0aWNrcyBiYXNlZCBvbiB0aGUgc2NhbGUgZGltZW5zaW9uXG5cdCAqIEBwcm90ZWN0ZWRcbiBcdCAqL1xuICBjb21wdXRlVGlja0xpbWl0KCkge1xuICAgIGNvbnN0IGhvcml6b250YWwgPSB0aGlzLmlzSG9yaXpvbnRhbCgpO1xuICAgIGNvbnN0IGxlbmd0aCA9IGhvcml6b250YWwgPyB0aGlzLndpZHRoIDogdGhpcy5oZWlnaHQ7XG4gICAgY29uc3QgbWluUm90YXRpb24gPSB0b1JhZGlhbnModGhpcy5vcHRpb25zLnRpY2tzLm1pblJvdGF0aW9uKTtcbiAgICBjb25zdCByYXRpbyA9IChob3Jpem9udGFsID8gTWF0aC5zaW4obWluUm90YXRpb24pIDogTWF0aC5jb3MobWluUm90YXRpb24pKSB8fCAwLjAwMTtcbiAgICBjb25zdCB0aWNrRm9udCA9IHRoaXMuX3Jlc29sdmVUaWNrRm9udE9wdGlvbnMoMCk7XG4gICAgcmV0dXJuIE1hdGguY2VpbChsZW5ndGggLyBNYXRoLm1pbig0MCwgdGlja0ZvbnQubGluZUhlaWdodCAvIHJhdGlvKSk7XG4gIH1cblxuICAvLyBVdGlsc1xuICBnZXRQaXhlbEZvclZhbHVlKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlID09PSBudWxsID8gTmFOIDogdGhpcy5nZXRQaXhlbEZvckRlY2ltYWwoKHZhbHVlIC0gdGhpcy5fc3RhcnRWYWx1ZSkgLyB0aGlzLl92YWx1ZVJhbmdlKTtcbiAgfVxuXG4gIGdldFZhbHVlRm9yUGl4ZWwocGl4ZWwpIHtcbiAgICByZXR1cm4gdGhpcy5fc3RhcnRWYWx1ZSArIHRoaXMuZ2V0RGVjaW1hbEZvclBpeGVsKHBpeGVsKSAqIHRoaXMuX3ZhbHVlUmFuZ2U7XG4gIH1cbn1cbiIsICJpbXBvcnQge2Zpbml0ZU9yRGVmYXVsdCwgaXNGaW5pdGV9IGZyb20gJy4uL2hlbHBlcnMvaGVscGVycy5jb3JlLmpzJztcbmltcG9ydCB7Zm9ybWF0TnVtYmVyfSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMuaW50bC5qcyc7XG5pbXBvcnQge19zZXRNaW5BbmRNYXhCeUtleSwgbG9nMTB9IGZyb20gJy4uL2hlbHBlcnMvaGVscGVycy5tYXRoLmpzJztcbmltcG9ydCBTY2FsZSBmcm9tICcuLi9jb3JlL2NvcmUuc2NhbGUuanMnO1xuaW1wb3J0IExpbmVhclNjYWxlQmFzZSBmcm9tICcuL3NjYWxlLmxpbmVhcmJhc2UuanMnO1xuaW1wb3J0IFRpY2tzIGZyb20gJy4uL2NvcmUvY29yZS50aWNrcy5qcyc7XG5cbmNvbnN0IGxvZzEwRmxvb3IgPSB2ID0+IE1hdGguZmxvb3IobG9nMTAodikpO1xuY29uc3QgY2hhbmdlRXhwb25lbnQgPSAodiwgbSkgPT4gTWF0aC5wb3coMTAsIGxvZzEwRmxvb3IodikgKyBtKTtcblxuZnVuY3Rpb24gaXNNYWpvcih0aWNrVmFsKSB7XG4gIGNvbnN0IHJlbWFpbiA9IHRpY2tWYWwgLyAoTWF0aC5wb3coMTAsIGxvZzEwRmxvb3IodGlja1ZhbCkpKTtcbiAgcmV0dXJuIHJlbWFpbiA9PT0gMTtcbn1cblxuZnVuY3Rpb24gc3RlcHMobWluLCBtYXgsIHJhbmdlRXhwKSB7XG4gIGNvbnN0IHJhbmdlU3RlcCA9IE1hdGgucG93KDEwLCByYW5nZUV4cCk7XG4gIGNvbnN0IHN0YXJ0ID0gTWF0aC5mbG9vcihtaW4gLyByYW5nZVN0ZXApO1xuICBjb25zdCBlbmQgPSBNYXRoLmNlaWwobWF4IC8gcmFuZ2VTdGVwKTtcbiAgcmV0dXJuIGVuZCAtIHN0YXJ0O1xufVxuXG5mdW5jdGlvbiBzdGFydEV4cChtaW4sIG1heCkge1xuICBjb25zdCByYW5nZSA9IG1heCAtIG1pbjtcbiAgbGV0IHJhbmdlRXhwID0gbG9nMTBGbG9vcihyYW5nZSk7XG4gIHdoaWxlIChzdGVwcyhtaW4sIG1heCwgcmFuZ2VFeHApID4gMTApIHtcbiAgICByYW5nZUV4cCsrO1xuICB9XG4gIHdoaWxlIChzdGVwcyhtaW4sIG1heCwgcmFuZ2VFeHApIDwgMTApIHtcbiAgICByYW5nZUV4cC0tO1xuICB9XG4gIHJldHVybiBNYXRoLm1pbihyYW5nZUV4cCwgbG9nMTBGbG9vcihtaW4pKTtcbn1cblxuXG4vKipcbiAqIEdlbmVyYXRlIGEgc2V0IG9mIGxvZ2FyaXRobWljIHRpY2tzXG4gKiBAcGFyYW0gZ2VuZXJhdGlvbk9wdGlvbnMgdGhlIG9wdGlvbnMgdXNlZCB0byBnZW5lcmF0ZSB0aGUgdGlja3NcbiAqIEBwYXJhbSBkYXRhUmFuZ2UgdGhlIHJhbmdlIG9mIHRoZSBkYXRhXG4gKiBAcmV0dXJucyB7b2JqZWN0W119IGFycmF5IG9mIHRpY2sgb2JqZWN0c1xuICovXG5mdW5jdGlvbiBnZW5lcmF0ZVRpY2tzKGdlbmVyYXRpb25PcHRpb25zLCB7bWluLCBtYXh9KSB7XG4gIG1pbiA9IGZpbml0ZU9yRGVmYXVsdChnZW5lcmF0aW9uT3B0aW9ucy5taW4sIG1pbik7XG4gIGNvbnN0IHRpY2tzID0gW107XG4gIGNvbnN0IG1pbkV4cCA9IGxvZzEwRmxvb3IobWluKTtcbiAgbGV0IGV4cCA9IHN0YXJ0RXhwKG1pbiwgbWF4KTtcbiAgbGV0IHByZWNpc2lvbiA9IGV4cCA8IDAgPyBNYXRoLnBvdygxMCwgTWF0aC5hYnMoZXhwKSkgOiAxO1xuICBjb25zdCBzdGVwU2l6ZSA9IE1hdGgucG93KDEwLCBleHApO1xuICBjb25zdCBiYXNlID0gbWluRXhwID4gZXhwID8gTWF0aC5wb3coMTAsIG1pbkV4cCkgOiAwO1xuICBjb25zdCBzdGFydCA9IE1hdGgucm91bmQoKG1pbiAtIGJhc2UpICogcHJlY2lzaW9uKSAvIHByZWNpc2lvbjtcbiAgY29uc3Qgb2Zmc2V0ID0gTWF0aC5mbG9vcigobWluIC0gYmFzZSkgLyBzdGVwU2l6ZSAvIDEwKSAqIHN0ZXBTaXplICogMTA7XG4gIGxldCBzaWduaWZpY2FuZCA9IE1hdGguZmxvb3IoKHN0YXJ0IC0gb2Zmc2V0KSAvIE1hdGgucG93KDEwLCBleHApKTtcbiAgbGV0IHZhbHVlID0gZmluaXRlT3JEZWZhdWx0KGdlbmVyYXRpb25PcHRpb25zLm1pbiwgTWF0aC5yb3VuZCgoYmFzZSArIG9mZnNldCArIHNpZ25pZmljYW5kICogTWF0aC5wb3coMTAsIGV4cCkpICogcHJlY2lzaW9uKSAvIHByZWNpc2lvbik7XG4gIHdoaWxlICh2YWx1ZSA8IG1heCkge1xuICAgIHRpY2tzLnB1c2goe3ZhbHVlLCBtYWpvcjogaXNNYWpvcih2YWx1ZSksIHNpZ25pZmljYW5kfSk7XG4gICAgaWYgKHNpZ25pZmljYW5kID49IDEwKSB7XG4gICAgICBzaWduaWZpY2FuZCA9IHNpZ25pZmljYW5kIDwgMTUgPyAxNSA6IDIwO1xuICAgIH0gZWxzZSB7XG4gICAgICBzaWduaWZpY2FuZCsrO1xuICAgIH1cbiAgICBpZiAoc2lnbmlmaWNhbmQgPj0gMjApIHtcbiAgICAgIGV4cCsrO1xuICAgICAgc2lnbmlmaWNhbmQgPSAyO1xuICAgICAgcHJlY2lzaW9uID0gZXhwID49IDAgPyAxIDogcHJlY2lzaW9uO1xuICAgIH1cbiAgICB2YWx1ZSA9IE1hdGgucm91bmQoKGJhc2UgKyBvZmZzZXQgKyBzaWduaWZpY2FuZCAqIE1hdGgucG93KDEwLCBleHApKSAqIHByZWNpc2lvbikgLyBwcmVjaXNpb247XG4gIH1cbiAgY29uc3QgbGFzdFRpY2sgPSBmaW5pdGVPckRlZmF1bHQoZ2VuZXJhdGlvbk9wdGlvbnMubWF4LCB2YWx1ZSk7XG4gIHRpY2tzLnB1c2goe3ZhbHVlOiBsYXN0VGljaywgbWFqb3I6IGlzTWFqb3IobGFzdFRpY2spLCBzaWduaWZpY2FuZH0pO1xuXG4gIHJldHVybiB0aWNrcztcbn1cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTG9nYXJpdGhtaWNTY2FsZSBleHRlbmRzIFNjYWxlIHtcblxuICBzdGF0aWMgaWQgPSAnbG9nYXJpdGhtaWMnO1xuXG4gIC8qKlxuICAgKiBAdHlwZSB7YW55fVxuICAgKi9cbiAgc3RhdGljIGRlZmF1bHRzID0ge1xuICAgIHRpY2tzOiB7XG4gICAgICBjYWxsYmFjazogVGlja3MuZm9ybWF0dGVycy5sb2dhcml0aG1pYyxcbiAgICAgIG1ham9yOiB7XG4gICAgICAgIGVuYWJsZWQ6IHRydWVcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cblxuICBjb25zdHJ1Y3RvcihjZmcpIHtcbiAgICBzdXBlcihjZmcpO1xuXG4gICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgdGhpcy5zdGFydCA9IHVuZGVmaW5lZDtcbiAgICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgICB0aGlzLmVuZCA9IHVuZGVmaW5lZDtcbiAgICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgICB0aGlzLl9zdGFydFZhbHVlID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX3ZhbHVlUmFuZ2UgPSAwO1xuICB9XG5cbiAgcGFyc2UocmF3LCBpbmRleCkge1xuICAgIGNvbnN0IHZhbHVlID0gTGluZWFyU2NhbGVCYXNlLnByb3RvdHlwZS5wYXJzZS5hcHBseSh0aGlzLCBbcmF3LCBpbmRleF0pO1xuICAgIGlmICh2YWx1ZSA9PT0gMCkge1xuICAgICAgdGhpcy5femVybyA9IHRydWU7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICByZXR1cm4gaXNGaW5pdGUodmFsdWUpICYmIHZhbHVlID4gMCA/IHZhbHVlIDogbnVsbDtcbiAgfVxuXG4gIGRldGVybWluZURhdGFMaW1pdHMoKSB7XG4gICAgY29uc3Qge21pbiwgbWF4fSA9IHRoaXMuZ2V0TWluTWF4KHRydWUpO1xuXG4gICAgdGhpcy5taW4gPSBpc0Zpbml0ZShtaW4pID8gTWF0aC5tYXgoMCwgbWluKSA6IG51bGw7XG4gICAgdGhpcy5tYXggPSBpc0Zpbml0ZShtYXgpID8gTWF0aC5tYXgoMCwgbWF4KSA6IG51bGw7XG5cbiAgICBpZiAodGhpcy5vcHRpb25zLmJlZ2luQXRaZXJvKSB7XG4gICAgICB0aGlzLl96ZXJvID0gdHJ1ZTtcbiAgICB9XG5cbiAgICAvLyBpZiBkYXRhIGhhcyBgMGAgaW4gaXQgb3IgYGJlZ2luQXRaZXJvYCBpcyB0cnVlLCBtaW4gKG5vbiB6ZXJvKSB2YWx1ZSBpcyBhdCBib3R0b21cbiAgICAvLyBvZiBzY2FsZSwgYW5kIGl0IGRvZXMgbm90IGVxdWFsIHN1Z2dlc3RlZE1pbiwgbG93ZXIgdGhlIG1pbiBib3VuZCBieSBvbmUgZXhwLlxuICAgIGlmICh0aGlzLl96ZXJvICYmIHRoaXMubWluICE9PSB0aGlzLl9zdWdnZXN0ZWRNaW4gJiYgIWlzRmluaXRlKHRoaXMuX3VzZXJNaW4pKSB7XG4gICAgICB0aGlzLm1pbiA9IG1pbiA9PT0gY2hhbmdlRXhwb25lbnQodGhpcy5taW4sIDApID8gY2hhbmdlRXhwb25lbnQodGhpcy5taW4sIC0xKSA6IGNoYW5nZUV4cG9uZW50KHRoaXMubWluLCAwKTtcbiAgICB9XG5cbiAgICB0aGlzLmhhbmRsZVRpY2tSYW5nZU9wdGlvbnMoKTtcbiAgfVxuXG4gIGhhbmRsZVRpY2tSYW5nZU9wdGlvbnMoKSB7XG4gICAgY29uc3Qge21pbkRlZmluZWQsIG1heERlZmluZWR9ID0gdGhpcy5nZXRVc2VyQm91bmRzKCk7XG4gICAgbGV0IG1pbiA9IHRoaXMubWluO1xuICAgIGxldCBtYXggPSB0aGlzLm1heDtcblxuICAgIGNvbnN0IHNldE1pbiA9IHYgPT4gKG1pbiA9IG1pbkRlZmluZWQgPyBtaW4gOiB2KTtcbiAgICBjb25zdCBzZXRNYXggPSB2ID0+IChtYXggPSBtYXhEZWZpbmVkID8gbWF4IDogdik7XG5cbiAgICBpZiAobWluID09PSBtYXgpIHtcbiAgICAgIGlmIChtaW4gPD0gMCkgeyAvLyBpbmNsdWRlcyBudWxsXG4gICAgICAgIHNldE1pbigxKTtcbiAgICAgICAgc2V0TWF4KDEwKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNldE1pbihjaGFuZ2VFeHBvbmVudChtaW4sIC0xKSk7XG4gICAgICAgIHNldE1heChjaGFuZ2VFeHBvbmVudChtYXgsICsxKSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChtaW4gPD0gMCkge1xuICAgICAgc2V0TWluKGNoYW5nZUV4cG9uZW50KG1heCwgLTEpKTtcbiAgICB9XG4gICAgaWYgKG1heCA8PSAwKSB7XG5cbiAgICAgIHNldE1heChjaGFuZ2VFeHBvbmVudChtaW4sICsxKSk7XG4gICAgfVxuXG4gICAgdGhpcy5taW4gPSBtaW47XG4gICAgdGhpcy5tYXggPSBtYXg7XG4gIH1cblxuICBidWlsZFRpY2tzKCkge1xuICAgIGNvbnN0IG9wdHMgPSB0aGlzLm9wdGlvbnM7XG5cbiAgICBjb25zdCBnZW5lcmF0aW9uT3B0aW9ucyA9IHtcbiAgICAgIG1pbjogdGhpcy5fdXNlck1pbixcbiAgICAgIG1heDogdGhpcy5fdXNlck1heFxuICAgIH07XG4gICAgY29uc3QgdGlja3MgPSBnZW5lcmF0ZVRpY2tzKGdlbmVyYXRpb25PcHRpb25zLCB0aGlzKTtcblxuICAgIC8vIEF0IHRoaXMgcG9pbnQsIHdlIG5lZWQgdG8gdXBkYXRlIG91ciBtYXggYW5kIG1pbiBnaXZlbiB0aGUgdGljayB2YWx1ZXMsXG4gICAgLy8gc2luY2Ugd2UgcHJvYmFibHkgaGF2ZSBleHBhbmRlZCB0aGUgcmFuZ2Ugb2YgdGhlIHNjYWxlXG4gICAgaWYgKG9wdHMuYm91bmRzID09PSAndGlja3MnKSB7XG4gICAgICBfc2V0TWluQW5kTWF4QnlLZXkodGlja3MsIHRoaXMsICd2YWx1ZScpO1xuICAgIH1cblxuICAgIGlmIChvcHRzLnJldmVyc2UpIHtcbiAgICAgIHRpY2tzLnJldmVyc2UoKTtcblxuICAgICAgdGhpcy5zdGFydCA9IHRoaXMubWF4O1xuICAgICAgdGhpcy5lbmQgPSB0aGlzLm1pbjtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zdGFydCA9IHRoaXMubWluO1xuICAgICAgdGhpcy5lbmQgPSB0aGlzLm1heDtcbiAgICB9XG5cbiAgICByZXR1cm4gdGlja3M7XG4gIH1cblxuICAvKipcblx0ICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlXG5cdCAqIEByZXR1cm4ge3N0cmluZ31cblx0ICovXG4gIGdldExhYmVsRm9yVmFsdWUodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgPT09IHVuZGVmaW5lZFxuICAgICAgPyAnMCdcbiAgICAgIDogZm9ybWF0TnVtYmVyKHZhbHVlLCB0aGlzLmNoYXJ0Lm9wdGlvbnMubG9jYWxlLCB0aGlzLm9wdGlvbnMudGlja3MuZm9ybWF0KTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuICBjb25maWd1cmUoKSB7XG4gICAgY29uc3Qgc3RhcnQgPSB0aGlzLm1pbjtcblxuICAgIHN1cGVyLmNvbmZpZ3VyZSgpO1xuXG4gICAgdGhpcy5fc3RhcnRWYWx1ZSA9IGxvZzEwKHN0YXJ0KTtcbiAgICB0aGlzLl92YWx1ZVJhbmdlID0gbG9nMTAodGhpcy5tYXgpIC0gbG9nMTAoc3RhcnQpO1xuICB9XG5cbiAgZ2V0UGl4ZWxGb3JWYWx1ZSh2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8IHZhbHVlID09PSAwKSB7XG4gICAgICB2YWx1ZSA9IHRoaXMubWluO1xuICAgIH1cbiAgICBpZiAodmFsdWUgPT09IG51bGwgfHwgaXNOYU4odmFsdWUpKSB7XG4gICAgICByZXR1cm4gTmFOO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5nZXRQaXhlbEZvckRlY2ltYWwodmFsdWUgPT09IHRoaXMubWluXG4gICAgICA/IDBcbiAgICAgIDogKGxvZzEwKHZhbHVlKSAtIHRoaXMuX3N0YXJ0VmFsdWUpIC8gdGhpcy5fdmFsdWVSYW5nZSk7XG4gIH1cblxuICBnZXRWYWx1ZUZvclBpeGVsKHBpeGVsKSB7XG4gICAgY29uc3QgZGVjaW1hbCA9IHRoaXMuZ2V0RGVjaW1hbEZvclBpeGVsKHBpeGVsKTtcbiAgICByZXR1cm4gTWF0aC5wb3coMTAsIHRoaXMuX3N0YXJ0VmFsdWUgKyBkZWNpbWFsICogdGhpcy5fdmFsdWVSYW5nZSk7XG4gIH1cbn1cbiIsICJpbXBvcnQgZGVmYXVsdHMgZnJvbSAnLi4vY29yZS9jb3JlLmRlZmF1bHRzLmpzJztcbmltcG9ydCB7X2xvbmdlc3RUZXh0LCBhZGRSb3VuZGVkUmVjdFBhdGgsIHJlbmRlclRleHQsIF9pc1BvaW50SW5BcmVhfSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMuY2FudmFzLmpzJztcbmltcG9ydCB7SEFMRl9QSSwgVEFVLCB0b0RlZ3JlZXMsIHRvUmFkaWFucywgX25vcm1hbGl6ZUFuZ2xlLCBQSX0gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLm1hdGguanMnO1xuaW1wb3J0IExpbmVhclNjYWxlQmFzZSBmcm9tICcuL3NjYWxlLmxpbmVhcmJhc2UuanMnO1xuaW1wb3J0IFRpY2tzIGZyb20gJy4uL2NvcmUvY29yZS50aWNrcy5qcyc7XG5pbXBvcnQge3ZhbHVlT3JEZWZhdWx0LCBpc0FycmF5LCBpc0Zpbml0ZSwgY2FsbGJhY2sgYXMgY2FsbENhbGxiYWNrLCBpc051bGxPclVuZGVmfSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMuY29yZS5qcyc7XG5pbXBvcnQge2NyZWF0ZUNvbnRleHQsIHRvRm9udCwgdG9QYWRkaW5nLCB0b1RSQkxDb3JuZXJzfSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMub3B0aW9ucy5qcyc7XG5cbmZ1bmN0aW9uIGdldFRpY2tCYWNrZHJvcEhlaWdodChvcHRzKSB7XG4gIGNvbnN0IHRpY2tPcHRzID0gb3B0cy50aWNrcztcblxuICBpZiAodGlja09wdHMuZGlzcGxheSAmJiBvcHRzLmRpc3BsYXkpIHtcbiAgICBjb25zdCBwYWRkaW5nID0gdG9QYWRkaW5nKHRpY2tPcHRzLmJhY2tkcm9wUGFkZGluZyk7XG4gICAgcmV0dXJuIHZhbHVlT3JEZWZhdWx0KHRpY2tPcHRzLmZvbnQgJiYgdGlja09wdHMuZm9udC5zaXplLCBkZWZhdWx0cy5mb250LnNpemUpICsgcGFkZGluZy5oZWlnaHQ7XG4gIH1cbiAgcmV0dXJuIDA7XG59XG5cbmZ1bmN0aW9uIG1lYXN1cmVMYWJlbFNpemUoY3R4LCBmb250LCBsYWJlbCkge1xuICBsYWJlbCA9IGlzQXJyYXkobGFiZWwpID8gbGFiZWwgOiBbbGFiZWxdO1xuICByZXR1cm4ge1xuICAgIHc6IF9sb25nZXN0VGV4dChjdHgsIGZvbnQuc3RyaW5nLCBsYWJlbCksXG4gICAgaDogbGFiZWwubGVuZ3RoICogZm9udC5saW5lSGVpZ2h0XG4gIH07XG59XG5cbmZ1bmN0aW9uIGRldGVybWluZUxpbWl0cyhhbmdsZSwgcG9zLCBzaXplLCBtaW4sIG1heCkge1xuICBpZiAoYW5nbGUgPT09IG1pbiB8fCBhbmdsZSA9PT0gbWF4KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHN0YXJ0OiBwb3MgLSAoc2l6ZSAvIDIpLFxuICAgICAgZW5kOiBwb3MgKyAoc2l6ZSAvIDIpXG4gICAgfTtcbiAgfSBlbHNlIGlmIChhbmdsZSA8IG1pbiB8fCBhbmdsZSA+IG1heCkge1xuICAgIHJldHVybiB7XG4gICAgICBzdGFydDogcG9zIC0gc2l6ZSxcbiAgICAgIGVuZDogcG9zXG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgc3RhcnQ6IHBvcyxcbiAgICBlbmQ6IHBvcyArIHNpemVcbiAgfTtcbn1cblxuLyoqXG4gKiBIZWxwZXIgZnVuY3Rpb24gdG8gZml0IGEgcmFkaWFsIGxpbmVhciBzY2FsZSB3aXRoIHBvaW50IGxhYmVsc1xuICovXG5mdW5jdGlvbiBmaXRXaXRoUG9pbnRMYWJlbHMoc2NhbGUpIHtcblxuICAvLyBSaWdodCwgdGhpcyBpcyByZWFsbHkgY29uZnVzaW5nIGFuZCB0aGVyZSBpcyBhIGxvdCBvZiBtYXRocyBnb2luZyBvbiBoZXJlXG4gIC8vIFRoZSBnaXN0IG9mIHRoZSBwcm9ibGVtIGlzIGhlcmU6IGh0dHBzOi8vZ2lzdC5naXRodWIuY29tL25ubmljay82OTZjYzljNTVmNGIwYmViOGZlOVxuICAvL1xuICAvLyBSZWFjdGlvbjogaHR0cHM6Ly9kbC5kcm9wYm94dXNlcmNvbnRlbnQuY29tL3UvMzQ2MDEzNjMvdG9vbXVjaHNjaWVuY2UuZ2lmXG4gIC8vXG4gIC8vIFNvbHV0aW9uOlxuICAvL1xuICAvLyBXZSBhc3N1bWUgdGhlIHJhZGl1cyBvZiB0aGUgcG9seWdvbiBpcyBoYWxmIHRoZSBzaXplIG9mIHRoZSBjYW52YXMgYXQgZmlyc3RcbiAgLy8gYXQgZWFjaCBpbmRleCB3ZSBjaGVjayBpZiB0aGUgdGV4dCBvdmVybGFwcy5cbiAgLy9cbiAgLy8gV2hlcmUgaXQgZG9lcywgd2Ugc3RvcmUgdGhhdCBhbmdsZSBhbmQgdGhhdCBpbmRleC5cbiAgLy9cbiAgLy8gQWZ0ZXIgZmluZGluZyB0aGUgbGFyZ2VzdCBpbmRleCBhbmQgYW5nbGUgd2UgY2FsY3VsYXRlIGhvdyBtdWNoIHdlIG5lZWQgdG8gcmVtb3ZlXG4gIC8vIGZyb20gdGhlIHNoYXBlIHJhZGl1cyB0byBtb3ZlIHRoZSBwb2ludCBpbndhcmRzIGJ5IHRoYXQgeC5cbiAgLy9cbiAgLy8gV2UgYXZlcmFnZSB0aGUgbGVmdCBhbmQgcmlnaHQgZGlzdGFuY2VzIHRvIGdldCB0aGUgbWF4aW11bSBzaGFwZSByYWRpdXMgdGhhdCBjYW4gZml0IGluIHRoZSBib3hcbiAgLy8gYWxvbmcgd2l0aCBsYWJlbHMuXG4gIC8vXG4gIC8vIE9uY2Ugd2UgaGF2ZSB0aGF0LCB3ZSBjYW4gZmluZCB0aGUgY2VudHJlIHBvaW50IGZvciB0aGUgY2hhcnQsIGJ5IHRha2luZyB0aGUgeCB0ZXh0IHByb3RydXNpb25cbiAgLy8gb24gZWFjaCBzaWRlLCByZW1vdmluZyB0aGF0IGZyb20gdGhlIHNpemUsIGhhbHZpbmcgaXQgYW5kIGFkZGluZyB0aGUgbGVmdCB4IHByb3RydXNpb24gd2lkdGguXG4gIC8vXG4gIC8vIFRoaXMgd2lsbCBtZWFuIHdlIGhhdmUgYSBzaGFwZSBmaXR0ZWQgdG8gdGhlIGNhbnZhcywgYXMgbGFyZ2UgYXMgaXQgY2FuIGJlIHdpdGggdGhlIGxhYmVsc1xuICAvLyBhbmQgcG9zaXRpb24gaXQgaW4gdGhlIG1vc3Qgc3BhY2UgZWZmaWNpZW50IG1hbm5lclxuICAvL1xuICAvLyBodHRwczovL2RsLmRyb3Bib3h1c2VyY29udGVudC5jb20vdS8zNDYwMTM2My95ZWFoc2NpZW5jZS5naWZcblxuICAvLyBHZXQgbWF4aW11bSByYWRpdXMgb2YgdGhlIHBvbHlnb24uIEVpdGhlciBoYWxmIHRoZSBoZWlnaHQgKG1pbnVzIHRoZSB0ZXh0IHdpZHRoKSBvciBoYWxmIHRoZSB3aWR0aC5cbiAgLy8gVXNlIHRoaXMgdG8gY2FsY3VsYXRlIHRoZSBvZmZzZXQgKyBjaGFuZ2UuIC0gTWFrZSBzdXJlIEwvUiBwcm90cnVzaW9uIGlzIGF0IGxlYXN0IDAgdG8gc3RvcCBpc3N1ZXMgd2l0aCBjZW50cmUgcG9pbnRzXG4gIGNvbnN0IG9yaWcgPSB7XG4gICAgbDogc2NhbGUubGVmdCArIHNjYWxlLl9wYWRkaW5nLmxlZnQsXG4gICAgcjogc2NhbGUucmlnaHQgLSBzY2FsZS5fcGFkZGluZy5yaWdodCxcbiAgICB0OiBzY2FsZS50b3AgKyBzY2FsZS5fcGFkZGluZy50b3AsXG4gICAgYjogc2NhbGUuYm90dG9tIC0gc2NhbGUuX3BhZGRpbmcuYm90dG9tXG4gIH07XG4gIGNvbnN0IGxpbWl0cyA9IE9iamVjdC5hc3NpZ24oe30sIG9yaWcpO1xuICBjb25zdCBsYWJlbFNpemVzID0gW107XG4gIGNvbnN0IHBhZGRpbmcgPSBbXTtcbiAgY29uc3QgdmFsdWVDb3VudCA9IHNjYWxlLl9wb2ludExhYmVscy5sZW5ndGg7XG4gIGNvbnN0IHBvaW50TGFiZWxPcHRzID0gc2NhbGUub3B0aW9ucy5wb2ludExhYmVscztcbiAgY29uc3QgYWRkaXRpb25hbEFuZ2xlID0gcG9pbnRMYWJlbE9wdHMuY2VudGVyUG9pbnRMYWJlbHMgPyBQSSAvIHZhbHVlQ291bnQgOiAwO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsdWVDb3VudDsgaSsrKSB7XG4gICAgY29uc3Qgb3B0cyA9IHBvaW50TGFiZWxPcHRzLnNldENvbnRleHQoc2NhbGUuZ2V0UG9pbnRMYWJlbENvbnRleHQoaSkpO1xuICAgIHBhZGRpbmdbaV0gPSBvcHRzLnBhZGRpbmc7XG4gICAgY29uc3QgcG9pbnRQb3NpdGlvbiA9IHNjYWxlLmdldFBvaW50UG9zaXRpb24oaSwgc2NhbGUuZHJhd2luZ0FyZWEgKyBwYWRkaW5nW2ldLCBhZGRpdGlvbmFsQW5nbGUpO1xuICAgIGNvbnN0IHBsRm9udCA9IHRvRm9udChvcHRzLmZvbnQpO1xuICAgIGNvbnN0IHRleHRTaXplID0gbWVhc3VyZUxhYmVsU2l6ZShzY2FsZS5jdHgsIHBsRm9udCwgc2NhbGUuX3BvaW50TGFiZWxzW2ldKTtcbiAgICBsYWJlbFNpemVzW2ldID0gdGV4dFNpemU7XG5cbiAgICBjb25zdCBhbmdsZVJhZGlhbnMgPSBfbm9ybWFsaXplQW5nbGUoc2NhbGUuZ2V0SW5kZXhBbmdsZShpKSArIGFkZGl0aW9uYWxBbmdsZSk7XG4gICAgY29uc3QgYW5nbGUgPSBNYXRoLnJvdW5kKHRvRGVncmVlcyhhbmdsZVJhZGlhbnMpKTtcbiAgICBjb25zdCBoTGltaXRzID0gZGV0ZXJtaW5lTGltaXRzKGFuZ2xlLCBwb2ludFBvc2l0aW9uLngsIHRleHRTaXplLncsIDAsIDE4MCk7XG4gICAgY29uc3QgdkxpbWl0cyA9IGRldGVybWluZUxpbWl0cyhhbmdsZSwgcG9pbnRQb3NpdGlvbi55LCB0ZXh0U2l6ZS5oLCA5MCwgMjcwKTtcbiAgICB1cGRhdGVMaW1pdHMobGltaXRzLCBvcmlnLCBhbmdsZVJhZGlhbnMsIGhMaW1pdHMsIHZMaW1pdHMpO1xuICB9XG5cbiAgc2NhbGUuc2V0Q2VudGVyUG9pbnQoXG4gICAgb3JpZy5sIC0gbGltaXRzLmwsXG4gICAgbGltaXRzLnIgLSBvcmlnLnIsXG4gICAgb3JpZy50IC0gbGltaXRzLnQsXG4gICAgbGltaXRzLmIgLSBvcmlnLmJcbiAgKTtcblxuICAvLyBOb3cgdGhhdCB0ZXh0IHNpemUgaXMgZGV0ZXJtaW5lZCwgY29tcHV0ZSB0aGUgZnVsbCBwb3NpdGlvbnNcbiAgc2NhbGUuX3BvaW50TGFiZWxJdGVtcyA9IGJ1aWxkUG9pbnRMYWJlbEl0ZW1zKHNjYWxlLCBsYWJlbFNpemVzLCBwYWRkaW5nKTtcbn1cblxuZnVuY3Rpb24gdXBkYXRlTGltaXRzKGxpbWl0cywgb3JpZywgYW5nbGUsIGhMaW1pdHMsIHZMaW1pdHMpIHtcbiAgY29uc3Qgc2luID0gTWF0aC5hYnMoTWF0aC5zaW4oYW5nbGUpKTtcbiAgY29uc3QgY29zID0gTWF0aC5hYnMoTWF0aC5jb3MoYW5nbGUpKTtcbiAgbGV0IHggPSAwO1xuICBsZXQgeSA9IDA7XG4gIGlmIChoTGltaXRzLnN0YXJ0IDwgb3JpZy5sKSB7XG4gICAgeCA9IChvcmlnLmwgLSBoTGltaXRzLnN0YXJ0KSAvIHNpbjtcbiAgICBsaW1pdHMubCA9IE1hdGgubWluKGxpbWl0cy5sLCBvcmlnLmwgLSB4KTtcbiAgfSBlbHNlIGlmIChoTGltaXRzLmVuZCA+IG9yaWcucikge1xuICAgIHggPSAoaExpbWl0cy5lbmQgLSBvcmlnLnIpIC8gc2luO1xuICAgIGxpbWl0cy5yID0gTWF0aC5tYXgobGltaXRzLnIsIG9yaWcuciArIHgpO1xuICB9XG4gIGlmICh2TGltaXRzLnN0YXJ0IDwgb3JpZy50KSB7XG4gICAgeSA9IChvcmlnLnQgLSB2TGltaXRzLnN0YXJ0KSAvIGNvcztcbiAgICBsaW1pdHMudCA9IE1hdGgubWluKGxpbWl0cy50LCBvcmlnLnQgLSB5KTtcbiAgfSBlbHNlIGlmICh2TGltaXRzLmVuZCA+IG9yaWcuYikge1xuICAgIHkgPSAodkxpbWl0cy5lbmQgLSBvcmlnLmIpIC8gY29zO1xuICAgIGxpbWl0cy5iID0gTWF0aC5tYXgobGltaXRzLmIsIG9yaWcuYiArIHkpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVBvaW50TGFiZWxJdGVtKHNjYWxlLCBpbmRleCwgaXRlbU9wdHMpIHtcbiAgY29uc3Qgb3V0ZXJEaXN0YW5jZSA9IHNjYWxlLmRyYXdpbmdBcmVhO1xuICBjb25zdCB7ZXh0cmEsIGFkZGl0aW9uYWxBbmdsZSwgcGFkZGluZywgc2l6ZX0gPSBpdGVtT3B0cztcbiAgY29uc3QgcG9pbnRMYWJlbFBvc2l0aW9uID0gc2NhbGUuZ2V0UG9pbnRQb3NpdGlvbihpbmRleCwgb3V0ZXJEaXN0YW5jZSArIGV4dHJhICsgcGFkZGluZywgYWRkaXRpb25hbEFuZ2xlKTtcbiAgY29uc3QgYW5nbGUgPSBNYXRoLnJvdW5kKHRvRGVncmVlcyhfbm9ybWFsaXplQW5nbGUocG9pbnRMYWJlbFBvc2l0aW9uLmFuZ2xlICsgSEFMRl9QSSkpKTtcbiAgY29uc3QgeSA9IHlGb3JBbmdsZShwb2ludExhYmVsUG9zaXRpb24ueSwgc2l6ZS5oLCBhbmdsZSk7XG4gIGNvbnN0IHRleHRBbGlnbiA9IGdldFRleHRBbGlnbkZvckFuZ2xlKGFuZ2xlKTtcbiAgY29uc3QgbGVmdCA9IGxlZnRGb3JUZXh0QWxpZ24ocG9pbnRMYWJlbFBvc2l0aW9uLngsIHNpemUudywgdGV4dEFsaWduKTtcbiAgcmV0dXJuIHtcbiAgICAvLyBpZiB0byBkcmF3IG9yIG92ZXJsYXBwZWRcbiAgICB2aXNpYmxlOiB0cnVlLFxuXG4gICAgLy8gVGV4dCBwb3NpdGlvblxuICAgIHg6IHBvaW50TGFiZWxQb3NpdGlvbi54LFxuICAgIHksXG5cbiAgICAvLyBUZXh0IHJlbmRlcmluZyBkYXRhXG4gICAgdGV4dEFsaWduLFxuXG4gICAgLy8gQm91bmRpbmcgYm94XG4gICAgbGVmdCxcbiAgICB0b3A6IHksXG4gICAgcmlnaHQ6IGxlZnQgKyBzaXplLncsXG4gICAgYm90dG9tOiB5ICsgc2l6ZS5oXG4gIH07XG59XG5cbmZ1bmN0aW9uIGlzTm90T3ZlcmxhcHBlZChpdGVtLCBhcmVhKSB7XG4gIGlmICghYXJlYSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGNvbnN0IHtsZWZ0LCB0b3AsIHJpZ2h0LCBib3R0b219ID0gaXRlbTtcbiAgY29uc3QgYXBleGVzSW5BcmVhID0gX2lzUG9pbnRJbkFyZWEoe3g6IGxlZnQsIHk6IHRvcH0sIGFyZWEpIHx8IF9pc1BvaW50SW5BcmVhKHt4OiBsZWZ0LCB5OiBib3R0b219LCBhcmVhKSB8fFxuICAgIF9pc1BvaW50SW5BcmVhKHt4OiByaWdodCwgeTogdG9wfSwgYXJlYSkgfHwgX2lzUG9pbnRJbkFyZWEoe3g6IHJpZ2h0LCB5OiBib3R0b219LCBhcmVhKTtcbiAgcmV0dXJuICFhcGV4ZXNJbkFyZWE7XG59XG5cbmZ1bmN0aW9uIGJ1aWxkUG9pbnRMYWJlbEl0ZW1zKHNjYWxlLCBsYWJlbFNpemVzLCBwYWRkaW5nKSB7XG4gIGNvbnN0IGl0ZW1zID0gW107XG4gIGNvbnN0IHZhbHVlQ291bnQgPSBzY2FsZS5fcG9pbnRMYWJlbHMubGVuZ3RoO1xuICBjb25zdCBvcHRzID0gc2NhbGUub3B0aW9ucztcbiAgY29uc3Qge2NlbnRlclBvaW50TGFiZWxzLCBkaXNwbGF5fSA9IG9wdHMucG9pbnRMYWJlbHM7XG4gIGNvbnN0IGl0ZW1PcHRzID0ge1xuICAgIGV4dHJhOiBnZXRUaWNrQmFja2Ryb3BIZWlnaHQob3B0cykgLyAyLFxuICAgIGFkZGl0aW9uYWxBbmdsZTogY2VudGVyUG9pbnRMYWJlbHMgPyBQSSAvIHZhbHVlQ291bnQgOiAwXG4gIH07XG4gIGxldCBhcmVhO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsdWVDb3VudDsgaSsrKSB7XG4gICAgaXRlbU9wdHMucGFkZGluZyA9IHBhZGRpbmdbaV07XG4gICAgaXRlbU9wdHMuc2l6ZSA9IGxhYmVsU2l6ZXNbaV07XG5cbiAgICBjb25zdCBpdGVtID0gY3JlYXRlUG9pbnRMYWJlbEl0ZW0oc2NhbGUsIGksIGl0ZW1PcHRzKTtcbiAgICBpdGVtcy5wdXNoKGl0ZW0pO1xuICAgIGlmIChkaXNwbGF5ID09PSAnYXV0bycpIHtcbiAgICAgIGl0ZW0udmlzaWJsZSA9IGlzTm90T3ZlcmxhcHBlZChpdGVtLCBhcmVhKTtcbiAgICAgIGlmIChpdGVtLnZpc2libGUpIHtcbiAgICAgICAgYXJlYSA9IGl0ZW07XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBpdGVtcztcbn1cblxuZnVuY3Rpb24gZ2V0VGV4dEFsaWduRm9yQW5nbGUoYW5nbGUpIHtcbiAgaWYgKGFuZ2xlID09PSAwIHx8IGFuZ2xlID09PSAxODApIHtcbiAgICByZXR1cm4gJ2NlbnRlcic7XG4gIH0gZWxzZSBpZiAoYW5nbGUgPCAxODApIHtcbiAgICByZXR1cm4gJ2xlZnQnO1xuICB9XG5cbiAgcmV0dXJuICdyaWdodCc7XG59XG5cbmZ1bmN0aW9uIGxlZnRGb3JUZXh0QWxpZ24oeCwgdywgYWxpZ24pIHtcbiAgaWYgKGFsaWduID09PSAncmlnaHQnKSB7XG4gICAgeCAtPSB3O1xuICB9IGVsc2UgaWYgKGFsaWduID09PSAnY2VudGVyJykge1xuICAgIHggLT0gKHcgLyAyKTtcbiAgfVxuICByZXR1cm4geDtcbn1cblxuZnVuY3Rpb24geUZvckFuZ2xlKHksIGgsIGFuZ2xlKSB7XG4gIGlmIChhbmdsZSA9PT0gOTAgfHwgYW5nbGUgPT09IDI3MCkge1xuICAgIHkgLT0gKGggLyAyKTtcbiAgfSBlbHNlIGlmIChhbmdsZSA+IDI3MCB8fCBhbmdsZSA8IDkwKSB7XG4gICAgeSAtPSBoO1xuICB9XG4gIHJldHVybiB5O1xufVxuXG5mdW5jdGlvbiBkcmF3UG9pbnRMYWJlbEJveChjdHgsIG9wdHMsIGl0ZW0pIHtcbiAgY29uc3Qge2xlZnQsIHRvcCwgcmlnaHQsIGJvdHRvbX0gPSBpdGVtO1xuICBjb25zdCB7YmFja2Ryb3BDb2xvcn0gPSBvcHRzO1xuXG4gIGlmICghaXNOdWxsT3JVbmRlZihiYWNrZHJvcENvbG9yKSkge1xuICAgIGNvbnN0IGJvcmRlclJhZGl1cyA9IHRvVFJCTENvcm5lcnMob3B0cy5ib3JkZXJSYWRpdXMpO1xuICAgIGNvbnN0IHBhZGRpbmcgPSB0b1BhZGRpbmcob3B0cy5iYWNrZHJvcFBhZGRpbmcpO1xuICAgIGN0eC5maWxsU3R5bGUgPSBiYWNrZHJvcENvbG9yO1xuXG4gICAgY29uc3QgYmFja2Ryb3BMZWZ0ID0gbGVmdCAtIHBhZGRpbmcubGVmdDtcbiAgICBjb25zdCBiYWNrZHJvcFRvcCA9IHRvcCAtIHBhZGRpbmcudG9wO1xuICAgIGNvbnN0IGJhY2tkcm9wV2lkdGggPSByaWdodCAtIGxlZnQgKyBwYWRkaW5nLndpZHRoO1xuICAgIGNvbnN0IGJhY2tkcm9wSGVpZ2h0ID0gYm90dG9tIC0gdG9wICsgcGFkZGluZy5oZWlnaHQ7XG5cbiAgICBpZiAoT2JqZWN0LnZhbHVlcyhib3JkZXJSYWRpdXMpLnNvbWUodiA9PiB2ICE9PSAwKSkge1xuICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgYWRkUm91bmRlZFJlY3RQYXRoKGN0eCwge1xuICAgICAgICB4OiBiYWNrZHJvcExlZnQsXG4gICAgICAgIHk6IGJhY2tkcm9wVG9wLFxuICAgICAgICB3OiBiYWNrZHJvcFdpZHRoLFxuICAgICAgICBoOiBiYWNrZHJvcEhlaWdodCxcbiAgICAgICAgcmFkaXVzOiBib3JkZXJSYWRpdXMsXG4gICAgICB9KTtcbiAgICAgIGN0eC5maWxsKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGN0eC5maWxsUmVjdChiYWNrZHJvcExlZnQsIGJhY2tkcm9wVG9wLCBiYWNrZHJvcFdpZHRoLCBiYWNrZHJvcEhlaWdodCk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGRyYXdQb2ludExhYmVscyhzY2FsZSwgbGFiZWxDb3VudCkge1xuICBjb25zdCB7Y3R4LCBvcHRpb25zOiB7cG9pbnRMYWJlbHN9fSA9IHNjYWxlO1xuXG4gIGZvciAobGV0IGkgPSBsYWJlbENvdW50IC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICBjb25zdCBpdGVtID0gc2NhbGUuX3BvaW50TGFiZWxJdGVtc1tpXTtcbiAgICBpZiAoIWl0ZW0udmlzaWJsZSkge1xuICAgICAgLy8gb3ZlcmxhcHBpbmdcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBjb25zdCBvcHRzQXRJbmRleCA9IHBvaW50TGFiZWxzLnNldENvbnRleHQoc2NhbGUuZ2V0UG9pbnRMYWJlbENvbnRleHQoaSkpO1xuICAgIGRyYXdQb2ludExhYmVsQm94KGN0eCwgb3B0c0F0SW5kZXgsIGl0ZW0pO1xuICAgIGNvbnN0IHBsRm9udCA9IHRvRm9udChvcHRzQXRJbmRleC5mb250KTtcbiAgICBjb25zdCB7eCwgeSwgdGV4dEFsaWdufSA9IGl0ZW07XG5cbiAgICByZW5kZXJUZXh0KFxuICAgICAgY3R4LFxuICAgICAgc2NhbGUuX3BvaW50TGFiZWxzW2ldLFxuICAgICAgeCxcbiAgICAgIHkgKyAocGxGb250LmxpbmVIZWlnaHQgLyAyKSxcbiAgICAgIHBsRm9udCxcbiAgICAgIHtcbiAgICAgICAgY29sb3I6IG9wdHNBdEluZGV4LmNvbG9yLFxuICAgICAgICB0ZXh0QWxpZ246IHRleHRBbGlnbixcbiAgICAgICAgdGV4dEJhc2VsaW5lOiAnbWlkZGxlJ1xuICAgICAgfVxuICAgICk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcGF0aFJhZGl1c0xpbmUoc2NhbGUsIHJhZGl1cywgY2lyY3VsYXIsIGxhYmVsQ291bnQpIHtcbiAgY29uc3Qge2N0eH0gPSBzY2FsZTtcbiAgaWYgKGNpcmN1bGFyKSB7XG4gICAgLy8gRHJhdyBjaXJjdWxhciBhcmNzIGJldHdlZW4gdGhlIHBvaW50c1xuICAgIGN0eC5hcmMoc2NhbGUueENlbnRlciwgc2NhbGUueUNlbnRlciwgcmFkaXVzLCAwLCBUQVUpO1xuICB9IGVsc2Uge1xuICAgIC8vIERyYXcgc3RyYWlnaHQgbGluZXMgY29ubmVjdGluZyBlYWNoIGluZGV4XG4gICAgbGV0IHBvaW50UG9zaXRpb24gPSBzY2FsZS5nZXRQb2ludFBvc2l0aW9uKDAsIHJhZGl1cyk7XG4gICAgY3R4Lm1vdmVUbyhwb2ludFBvc2l0aW9uLngsIHBvaW50UG9zaXRpb24ueSk7XG5cbiAgICBmb3IgKGxldCBpID0gMTsgaSA8IGxhYmVsQ291bnQ7IGkrKykge1xuICAgICAgcG9pbnRQb3NpdGlvbiA9IHNjYWxlLmdldFBvaW50UG9zaXRpb24oaSwgcmFkaXVzKTtcbiAgICAgIGN0eC5saW5lVG8ocG9pbnRQb3NpdGlvbi54LCBwb2ludFBvc2l0aW9uLnkpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBkcmF3UmFkaXVzTGluZShzY2FsZSwgZ3JpZExpbmVPcHRzLCByYWRpdXMsIGxhYmVsQ291bnQsIGJvcmRlck9wdHMpIHtcbiAgY29uc3QgY3R4ID0gc2NhbGUuY3R4O1xuICBjb25zdCBjaXJjdWxhciA9IGdyaWRMaW5lT3B0cy5jaXJjdWxhcjtcblxuICBjb25zdCB7Y29sb3IsIGxpbmVXaWR0aH0gPSBncmlkTGluZU9wdHM7XG5cbiAgaWYgKCghY2lyY3VsYXIgJiYgIWxhYmVsQ291bnQpIHx8ICFjb2xvciB8fCAhbGluZVdpZHRoIHx8IHJhZGl1cyA8IDApIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBjdHguc2F2ZSgpO1xuICBjdHguc3Ryb2tlU3R5bGUgPSBjb2xvcjtcbiAgY3R4LmxpbmVXaWR0aCA9IGxpbmVXaWR0aDtcbiAgY3R4LnNldExpbmVEYXNoKGJvcmRlck9wdHMuZGFzaCk7XG4gIGN0eC5saW5lRGFzaE9mZnNldCA9IGJvcmRlck9wdHMuZGFzaE9mZnNldDtcblxuICBjdHguYmVnaW5QYXRoKCk7XG4gIHBhdGhSYWRpdXNMaW5lKHNjYWxlLCByYWRpdXMsIGNpcmN1bGFyLCBsYWJlbENvdW50KTtcbiAgY3R4LmNsb3NlUGF0aCgpO1xuICBjdHguc3Ryb2tlKCk7XG4gIGN0eC5yZXN0b3JlKCk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVBvaW50TGFiZWxDb250ZXh0KHBhcmVudCwgaW5kZXgsIGxhYmVsKSB7XG4gIHJldHVybiBjcmVhdGVDb250ZXh0KHBhcmVudCwge1xuICAgIGxhYmVsLFxuICAgIGluZGV4LFxuICAgIHR5cGU6ICdwb2ludExhYmVsJ1xuICB9KTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUmFkaWFsTGluZWFyU2NhbGUgZXh0ZW5kcyBMaW5lYXJTY2FsZUJhc2Uge1xuXG4gIHN0YXRpYyBpZCA9ICdyYWRpYWxMaW5lYXInO1xuXG4gIC8qKlxuICAgKiBAdHlwZSB7YW55fVxuICAgKi9cbiAgc3RhdGljIGRlZmF1bHRzID0ge1xuICAgIGRpc3BsYXk6IHRydWUsXG5cbiAgICAvLyBCb29sZWFuIC0gV2hldGhlciB0byBhbmltYXRlIHNjYWxpbmcgdGhlIGNoYXJ0IGZyb20gdGhlIGNlbnRyZVxuICAgIGFuaW1hdGU6IHRydWUsXG4gICAgcG9zaXRpb246ICdjaGFydEFyZWEnLFxuXG4gICAgYW5nbGVMaW5lczoge1xuICAgICAgZGlzcGxheTogdHJ1ZSxcbiAgICAgIGxpbmVXaWR0aDogMSxcbiAgICAgIGJvcmRlckRhc2g6IFtdLFxuICAgICAgYm9yZGVyRGFzaE9mZnNldDogMC4wXG4gICAgfSxcblxuICAgIGdyaWQ6IHtcbiAgICAgIGNpcmN1bGFyOiBmYWxzZVxuICAgIH0sXG5cbiAgICBzdGFydEFuZ2xlOiAwLFxuXG4gICAgLy8gbGFiZWwgc2V0dGluZ3NcbiAgICB0aWNrczoge1xuICAgICAgLy8gQm9vbGVhbiAtIFNob3cgYSBiYWNrZHJvcCB0byB0aGUgc2NhbGUgbGFiZWxcbiAgICAgIHNob3dMYWJlbEJhY2tkcm9wOiB0cnVlLFxuXG4gICAgICBjYWxsYmFjazogVGlja3MuZm9ybWF0dGVycy5udW1lcmljXG4gICAgfSxcblxuICAgIHBvaW50TGFiZWxzOiB7XG4gICAgICBiYWNrZHJvcENvbG9yOiB1bmRlZmluZWQsXG5cbiAgICAgIC8vIE51bWJlciAtIFRoZSBiYWNrZHJvcCBwYWRkaW5nIGFib3ZlICYgYmVsb3cgdGhlIGxhYmVsIGluIHBpeGVsc1xuICAgICAgYmFja2Ryb3BQYWRkaW5nOiAyLFxuXG4gICAgICAvLyBCb29sZWFuIC0gaWYgdHJ1ZSwgc2hvdyBwb2ludCBsYWJlbHNcbiAgICAgIGRpc3BsYXk6IHRydWUsXG5cbiAgICAgIC8vIE51bWJlciAtIFBvaW50IGxhYmVsIGZvbnQgc2l6ZSBpbiBwaXhlbHNcbiAgICAgIGZvbnQ6IHtcbiAgICAgICAgc2l6ZTogMTBcbiAgICAgIH0sXG5cbiAgICAgIC8vIEZ1bmN0aW9uIC0gVXNlZCB0byBjb252ZXJ0IHBvaW50IGxhYmVsc1xuICAgICAgY2FsbGJhY2sobGFiZWwpIHtcbiAgICAgICAgcmV0dXJuIGxhYmVsO1xuICAgICAgfSxcblxuICAgICAgLy8gTnVtYmVyIC0gQWRkaXRpb25sIHBhZGRpbmcgYmV0d2VlbiBzY2FsZSBhbmQgcG9pbnRMYWJlbFxuICAgICAgcGFkZGluZzogNSxcblxuICAgICAgLy8gQm9vbGVhbiAtIGlmIHRydWUsIGNlbnRlciBwb2ludCBsYWJlbHMgdG8gc2xpY2VzIGluIHBvbGFyIGNoYXJ0XG4gICAgICBjZW50ZXJQb2ludExhYmVsczogZmFsc2VcbiAgICB9XG4gIH07XG5cbiAgc3RhdGljIGRlZmF1bHRSb3V0ZXMgPSB7XG4gICAgJ2FuZ2xlTGluZXMuY29sb3InOiAnYm9yZGVyQ29sb3InLFxuICAgICdwb2ludExhYmVscy5jb2xvcic6ICdjb2xvcicsXG4gICAgJ3RpY2tzLmNvbG9yJzogJ2NvbG9yJ1xuICB9O1xuXG4gIHN0YXRpYyBkZXNjcmlwdG9ycyA9IHtcbiAgICBhbmdsZUxpbmVzOiB7XG4gICAgICBfZmFsbGJhY2s6ICdncmlkJ1xuICAgIH1cbiAgfTtcblxuICBjb25zdHJ1Y3RvcihjZmcpIHtcbiAgICBzdXBlcihjZmcpO1xuXG4gICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgdGhpcy54Q2VudGVyID0gdW5kZWZpbmVkO1xuICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgIHRoaXMueUNlbnRlciA9IHVuZGVmaW5lZDtcbiAgICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgICB0aGlzLmRyYXdpbmdBcmVhID0gdW5kZWZpbmVkO1xuICAgIC8qKiBAdHlwZSB7c3RyaW5nW119ICovXG4gICAgdGhpcy5fcG9pbnRMYWJlbHMgPSBbXTtcbiAgICB0aGlzLl9wb2ludExhYmVsSXRlbXMgPSBbXTtcbiAgfVxuXG4gIHNldERpbWVuc2lvbnMoKSB7XG4gICAgLy8gU2V0IHRoZSB1bmNvbnN0cmFpbmVkIGRpbWVuc2lvbiBiZWZvcmUgbGFiZWwgcm90YXRpb25cbiAgICBjb25zdCBwYWRkaW5nID0gdGhpcy5fcGFkZGluZyA9IHRvUGFkZGluZyhnZXRUaWNrQmFja2Ryb3BIZWlnaHQodGhpcy5vcHRpb25zKSAvIDIpO1xuICAgIGNvbnN0IHcgPSB0aGlzLndpZHRoID0gdGhpcy5tYXhXaWR0aCAtIHBhZGRpbmcud2lkdGg7XG4gICAgY29uc3QgaCA9IHRoaXMuaGVpZ2h0ID0gdGhpcy5tYXhIZWlnaHQgLSBwYWRkaW5nLmhlaWdodDtcbiAgICB0aGlzLnhDZW50ZXIgPSBNYXRoLmZsb29yKHRoaXMubGVmdCArIHcgLyAyICsgcGFkZGluZy5sZWZ0KTtcbiAgICB0aGlzLnlDZW50ZXIgPSBNYXRoLmZsb29yKHRoaXMudG9wICsgaCAvIDIgKyBwYWRkaW5nLnRvcCk7XG4gICAgdGhpcy5kcmF3aW5nQXJlYSA9IE1hdGguZmxvb3IoTWF0aC5taW4odywgaCkgLyAyKTtcbiAgfVxuXG4gIGRldGVybWluZURhdGFMaW1pdHMoKSB7XG4gICAgY29uc3Qge21pbiwgbWF4fSA9IHRoaXMuZ2V0TWluTWF4KGZhbHNlKTtcblxuICAgIHRoaXMubWluID0gaXNGaW5pdGUobWluKSAmJiAhaXNOYU4obWluKSA/IG1pbiA6IDA7XG4gICAgdGhpcy5tYXggPSBpc0Zpbml0ZShtYXgpICYmICFpc05hTihtYXgpID8gbWF4IDogMDtcblxuICAgIC8vIENvbW1vbiBiYXNlIGltcGxlbWVudGF0aW9uIHRvIGhhbmRsZSBtaW4sIG1heCwgYmVnaW5BdFplcm9cbiAgICB0aGlzLmhhbmRsZVRpY2tSYW5nZU9wdGlvbnMoKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBSZXR1cm5zIHRoZSBtYXhpbXVtIG51bWJlciBvZiB0aWNrcyBiYXNlZCBvbiB0aGUgc2NhbGUgZGltZW5zaW9uXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG4gIGNvbXB1dGVUaWNrTGltaXQoKSB7XG4gICAgcmV0dXJuIE1hdGguY2VpbCh0aGlzLmRyYXdpbmdBcmVhIC8gZ2V0VGlja0JhY2tkcm9wSGVpZ2h0KHRoaXMub3B0aW9ucykpO1xuICB9XG5cbiAgZ2VuZXJhdGVUaWNrTGFiZWxzKHRpY2tzKSB7XG4gICAgTGluZWFyU2NhbGVCYXNlLnByb3RvdHlwZS5nZW5lcmF0ZVRpY2tMYWJlbHMuY2FsbCh0aGlzLCB0aWNrcyk7XG5cbiAgICAvLyBQb2ludCBsYWJlbHNcbiAgICB0aGlzLl9wb2ludExhYmVscyA9IHRoaXMuZ2V0TGFiZWxzKClcbiAgICAgIC5tYXAoKHZhbHVlLCBpbmRleCkgPT4ge1xuICAgICAgICBjb25zdCBsYWJlbCA9IGNhbGxDYWxsYmFjayh0aGlzLm9wdGlvbnMucG9pbnRMYWJlbHMuY2FsbGJhY2ssIFt2YWx1ZSwgaW5kZXhdLCB0aGlzKTtcbiAgICAgICAgcmV0dXJuIGxhYmVsIHx8IGxhYmVsID09PSAwID8gbGFiZWwgOiAnJztcbiAgICAgIH0pXG4gICAgICAuZmlsdGVyKCh2LCBpKSA9PiB0aGlzLmNoYXJ0LmdldERhdGFWaXNpYmlsaXR5KGkpKTtcbiAgfVxuXG4gIGZpdCgpIHtcbiAgICBjb25zdCBvcHRzID0gdGhpcy5vcHRpb25zO1xuXG4gICAgaWYgKG9wdHMuZGlzcGxheSAmJiBvcHRzLnBvaW50TGFiZWxzLmRpc3BsYXkpIHtcbiAgICAgIGZpdFdpdGhQb2ludExhYmVscyh0aGlzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zZXRDZW50ZXJQb2ludCgwLCAwLCAwLCAwKTtcbiAgICB9XG4gIH1cblxuICBzZXRDZW50ZXJQb2ludChsZWZ0TW92ZW1lbnQsIHJpZ2h0TW92ZW1lbnQsIHRvcE1vdmVtZW50LCBib3R0b21Nb3ZlbWVudCkge1xuICAgIHRoaXMueENlbnRlciArPSBNYXRoLmZsb29yKChsZWZ0TW92ZW1lbnQgLSByaWdodE1vdmVtZW50KSAvIDIpO1xuICAgIHRoaXMueUNlbnRlciArPSBNYXRoLmZsb29yKCh0b3BNb3ZlbWVudCAtIGJvdHRvbU1vdmVtZW50KSAvIDIpO1xuICAgIHRoaXMuZHJhd2luZ0FyZWEgLT0gTWF0aC5taW4odGhpcy5kcmF3aW5nQXJlYSAvIDIsIE1hdGgubWF4KGxlZnRNb3ZlbWVudCwgcmlnaHRNb3ZlbWVudCwgdG9wTW92ZW1lbnQsIGJvdHRvbU1vdmVtZW50KSk7XG4gIH1cblxuICBnZXRJbmRleEFuZ2xlKGluZGV4KSB7XG4gICAgY29uc3QgYW5nbGVNdWx0aXBsaWVyID0gVEFVIC8gKHRoaXMuX3BvaW50TGFiZWxzLmxlbmd0aCB8fCAxKTtcbiAgICBjb25zdCBzdGFydEFuZ2xlID0gdGhpcy5vcHRpb25zLnN0YXJ0QW5nbGUgfHwgMDtcblxuICAgIHJldHVybiBfbm9ybWFsaXplQW5nbGUoaW5kZXggKiBhbmdsZU11bHRpcGxpZXIgKyB0b1JhZGlhbnMoc3RhcnRBbmdsZSkpO1xuICB9XG5cbiAgZ2V0RGlzdGFuY2VGcm9tQ2VudGVyRm9yVmFsdWUodmFsdWUpIHtcbiAgICBpZiAoaXNOdWxsT3JVbmRlZih2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBOYU47XG4gICAgfVxuXG4gICAgLy8gVGFrZSBpbnRvIGFjY291bnQgaGFsZiBmb250IHNpemUgKyB0aGUgeVBhZGRpbmcgb2YgdGhlIHRvcCB2YWx1ZVxuICAgIGNvbnN0IHNjYWxpbmdGYWN0b3IgPSB0aGlzLmRyYXdpbmdBcmVhIC8gKHRoaXMubWF4IC0gdGhpcy5taW4pO1xuICAgIGlmICh0aGlzLm9wdGlvbnMucmV2ZXJzZSkge1xuICAgICAgcmV0dXJuICh0aGlzLm1heCAtIHZhbHVlKSAqIHNjYWxpbmdGYWN0b3I7XG4gICAgfVxuICAgIHJldHVybiAodmFsdWUgLSB0aGlzLm1pbikgKiBzY2FsaW5nRmFjdG9yO1xuICB9XG5cbiAgZ2V0VmFsdWVGb3JEaXN0YW5jZUZyb21DZW50ZXIoZGlzdGFuY2UpIHtcbiAgICBpZiAoaXNOdWxsT3JVbmRlZihkaXN0YW5jZSkpIHtcbiAgICAgIHJldHVybiBOYU47XG4gICAgfVxuXG4gICAgY29uc3Qgc2NhbGVkRGlzdGFuY2UgPSBkaXN0YW5jZSAvICh0aGlzLmRyYXdpbmdBcmVhIC8gKHRoaXMubWF4IC0gdGhpcy5taW4pKTtcbiAgICByZXR1cm4gdGhpcy5vcHRpb25zLnJldmVyc2UgPyB0aGlzLm1heCAtIHNjYWxlZERpc3RhbmNlIDogdGhpcy5taW4gKyBzY2FsZWREaXN0YW5jZTtcbiAgfVxuXG4gIGdldFBvaW50TGFiZWxDb250ZXh0KGluZGV4KSB7XG4gICAgY29uc3QgcG9pbnRMYWJlbHMgPSB0aGlzLl9wb2ludExhYmVscyB8fCBbXTtcblxuICAgIGlmIChpbmRleCA+PSAwICYmIGluZGV4IDwgcG9pbnRMYWJlbHMubGVuZ3RoKSB7XG4gICAgICBjb25zdCBwb2ludExhYmVsID0gcG9pbnRMYWJlbHNbaW5kZXhdO1xuICAgICAgcmV0dXJuIGNyZWF0ZVBvaW50TGFiZWxDb250ZXh0KHRoaXMuZ2V0Q29udGV4dCgpLCBpbmRleCwgcG9pbnRMYWJlbCk7XG4gICAgfVxuICB9XG5cbiAgZ2V0UG9pbnRQb3NpdGlvbihpbmRleCwgZGlzdGFuY2VGcm9tQ2VudGVyLCBhZGRpdGlvbmFsQW5nbGUgPSAwKSB7XG4gICAgY29uc3QgYW5nbGUgPSB0aGlzLmdldEluZGV4QW5nbGUoaW5kZXgpIC0gSEFMRl9QSSArIGFkZGl0aW9uYWxBbmdsZTtcbiAgICByZXR1cm4ge1xuICAgICAgeDogTWF0aC5jb3MoYW5nbGUpICogZGlzdGFuY2VGcm9tQ2VudGVyICsgdGhpcy54Q2VudGVyLFxuICAgICAgeTogTWF0aC5zaW4oYW5nbGUpICogZGlzdGFuY2VGcm9tQ2VudGVyICsgdGhpcy55Q2VudGVyLFxuICAgICAgYW5nbGVcbiAgICB9O1xuICB9XG5cbiAgZ2V0UG9pbnRQb3NpdGlvbkZvclZhbHVlKGluZGV4LCB2YWx1ZSkge1xuICAgIHJldHVybiB0aGlzLmdldFBvaW50UG9zaXRpb24oaW5kZXgsIHRoaXMuZ2V0RGlzdGFuY2VGcm9tQ2VudGVyRm9yVmFsdWUodmFsdWUpKTtcbiAgfVxuXG4gIGdldEJhc2VQb3NpdGlvbihpbmRleCkge1xuICAgIHJldHVybiB0aGlzLmdldFBvaW50UG9zaXRpb25Gb3JWYWx1ZShpbmRleCB8fCAwLCB0aGlzLmdldEJhc2VWYWx1ZSgpKTtcbiAgfVxuXG4gIGdldFBvaW50TGFiZWxQb3NpdGlvbihpbmRleCkge1xuICAgIGNvbnN0IHtsZWZ0LCB0b3AsIHJpZ2h0LCBib3R0b219ID0gdGhpcy5fcG9pbnRMYWJlbEl0ZW1zW2luZGV4XTtcbiAgICByZXR1cm4ge1xuICAgICAgbGVmdCxcbiAgICAgIHRvcCxcbiAgICAgIHJpZ2h0LFxuICAgICAgYm90dG9tLFxuICAgIH07XG4gIH1cblxuICAvKipcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cbiAgZHJhd0JhY2tncm91bmQoKSB7XG4gICAgY29uc3Qge2JhY2tncm91bmRDb2xvciwgZ3JpZDoge2NpcmN1bGFyfX0gPSB0aGlzLm9wdGlvbnM7XG4gICAgaWYgKGJhY2tncm91bmRDb2xvcikge1xuICAgICAgY29uc3QgY3R4ID0gdGhpcy5jdHg7XG4gICAgICBjdHguc2F2ZSgpO1xuICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgcGF0aFJhZGl1c0xpbmUodGhpcywgdGhpcy5nZXREaXN0YW5jZUZyb21DZW50ZXJGb3JWYWx1ZSh0aGlzLl9lbmRWYWx1ZSksIGNpcmN1bGFyLCB0aGlzLl9wb2ludExhYmVscy5sZW5ndGgpO1xuICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgICAgY3R4LmZpbGxTdHlsZSA9IGJhY2tncm91bmRDb2xvcjtcbiAgICAgIGN0eC5maWxsKCk7XG4gICAgICBjdHgucmVzdG9yZSgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuICBkcmF3R3JpZCgpIHtcbiAgICBjb25zdCBjdHggPSB0aGlzLmN0eDtcbiAgICBjb25zdCBvcHRzID0gdGhpcy5vcHRpb25zO1xuICAgIGNvbnN0IHthbmdsZUxpbmVzLCBncmlkLCBib3JkZXJ9ID0gb3B0cztcbiAgICBjb25zdCBsYWJlbENvdW50ID0gdGhpcy5fcG9pbnRMYWJlbHMubGVuZ3RoO1xuXG4gICAgbGV0IGksIG9mZnNldCwgcG9zaXRpb247XG5cbiAgICBpZiAob3B0cy5wb2ludExhYmVscy5kaXNwbGF5KSB7XG4gICAgICBkcmF3UG9pbnRMYWJlbHModGhpcywgbGFiZWxDb3VudCk7XG4gICAgfVxuXG4gICAgaWYgKGdyaWQuZGlzcGxheSkge1xuICAgICAgdGhpcy50aWNrcy5mb3JFYWNoKCh0aWNrLCBpbmRleCkgPT4ge1xuICAgICAgICBpZiAoaW5kZXggIT09IDAgfHwgKGluZGV4ID09PSAwICYmIHRoaXMubWluIDwgMCkpIHtcbiAgICAgICAgICBvZmZzZXQgPSB0aGlzLmdldERpc3RhbmNlRnJvbUNlbnRlckZvclZhbHVlKHRpY2sudmFsdWUpO1xuICAgICAgICAgIGNvbnN0IGNvbnRleHQgPSB0aGlzLmdldENvbnRleHQoaW5kZXgpO1xuICAgICAgICAgIGNvbnN0IG9wdHNBdEluZGV4ID0gZ3JpZC5zZXRDb250ZXh0KGNvbnRleHQpO1xuICAgICAgICAgIGNvbnN0IG9wdHNBdEluZGV4Qm9yZGVyID0gYm9yZGVyLnNldENvbnRleHQoY29udGV4dCk7XG5cbiAgICAgICAgICBkcmF3UmFkaXVzTGluZSh0aGlzLCBvcHRzQXRJbmRleCwgb2Zmc2V0LCBsYWJlbENvdW50LCBvcHRzQXRJbmRleEJvcmRlcik7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmIChhbmdsZUxpbmVzLmRpc3BsYXkpIHtcbiAgICAgIGN0eC5zYXZlKCk7XG5cbiAgICAgIGZvciAoaSA9IGxhYmVsQ291bnQgLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICBjb25zdCBvcHRzQXRJbmRleCA9IGFuZ2xlTGluZXMuc2V0Q29udGV4dCh0aGlzLmdldFBvaW50TGFiZWxDb250ZXh0KGkpKTtcbiAgICAgICAgY29uc3Qge2NvbG9yLCBsaW5lV2lkdGh9ID0gb3B0c0F0SW5kZXg7XG5cbiAgICAgICAgaWYgKCFsaW5lV2lkdGggfHwgIWNvbG9yKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBjdHgubGluZVdpZHRoID0gbGluZVdpZHRoO1xuICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSBjb2xvcjtcblxuICAgICAgICBjdHguc2V0TGluZURhc2gob3B0c0F0SW5kZXguYm9yZGVyRGFzaCk7XG4gICAgICAgIGN0eC5saW5lRGFzaE9mZnNldCA9IG9wdHNBdEluZGV4LmJvcmRlckRhc2hPZmZzZXQ7XG5cbiAgICAgICAgb2Zmc2V0ID0gdGhpcy5nZXREaXN0YW5jZUZyb21DZW50ZXJGb3JWYWx1ZShvcHRzLnJldmVyc2UgPyB0aGlzLm1pbiA6IHRoaXMubWF4KTtcbiAgICAgICAgcG9zaXRpb24gPSB0aGlzLmdldFBvaW50UG9zaXRpb24oaSwgb2Zmc2V0KTtcbiAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICBjdHgubW92ZVRvKHRoaXMueENlbnRlciwgdGhpcy55Q2VudGVyKTtcbiAgICAgICAgY3R4LmxpbmVUbyhwb3NpdGlvbi54LCBwb3NpdGlvbi55KTtcbiAgICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgfVxuXG4gICAgICBjdHgucmVzdG9yZSgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuICBkcmF3Qm9yZGVyKCkge31cblxuICAvKipcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cbiAgZHJhd0xhYmVscygpIHtcbiAgICBjb25zdCBjdHggPSB0aGlzLmN0eDtcbiAgICBjb25zdCBvcHRzID0gdGhpcy5vcHRpb25zO1xuICAgIGNvbnN0IHRpY2tPcHRzID0gb3B0cy50aWNrcztcblxuICAgIGlmICghdGlja09wdHMuZGlzcGxheSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IHN0YXJ0QW5nbGUgPSB0aGlzLmdldEluZGV4QW5nbGUoMCk7XG4gICAgbGV0IG9mZnNldCwgd2lkdGg7XG5cbiAgICBjdHguc2F2ZSgpO1xuICAgIGN0eC50cmFuc2xhdGUodGhpcy54Q2VudGVyLCB0aGlzLnlDZW50ZXIpO1xuICAgIGN0eC5yb3RhdGUoc3RhcnRBbmdsZSk7XG4gICAgY3R4LnRleHRBbGlnbiA9ICdjZW50ZXInO1xuICAgIGN0eC50ZXh0QmFzZWxpbmUgPSAnbWlkZGxlJztcblxuICAgIHRoaXMudGlja3MuZm9yRWFjaCgodGljaywgaW5kZXgpID0+IHtcbiAgICAgIGlmICgoaW5kZXggPT09IDAgJiYgdGhpcy5taW4gPj0gMCkgJiYgIW9wdHMucmV2ZXJzZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IG9wdHNBdEluZGV4ID0gdGlja09wdHMuc2V0Q29udGV4dCh0aGlzLmdldENvbnRleHQoaW5kZXgpKTtcbiAgICAgIGNvbnN0IHRpY2tGb250ID0gdG9Gb250KG9wdHNBdEluZGV4LmZvbnQpO1xuICAgICAgb2Zmc2V0ID0gdGhpcy5nZXREaXN0YW5jZUZyb21DZW50ZXJGb3JWYWx1ZSh0aGlzLnRpY2tzW2luZGV4XS52YWx1ZSk7XG5cbiAgICAgIGlmIChvcHRzQXRJbmRleC5zaG93TGFiZWxCYWNrZHJvcCkge1xuICAgICAgICBjdHguZm9udCA9IHRpY2tGb250LnN0cmluZztcbiAgICAgICAgd2lkdGggPSBjdHgubWVhc3VyZVRleHQodGljay5sYWJlbCkud2lkdGg7XG4gICAgICAgIGN0eC5maWxsU3R5bGUgPSBvcHRzQXRJbmRleC5iYWNrZHJvcENvbG9yO1xuXG4gICAgICAgIGNvbnN0IHBhZGRpbmcgPSB0b1BhZGRpbmcob3B0c0F0SW5kZXguYmFja2Ryb3BQYWRkaW5nKTtcbiAgICAgICAgY3R4LmZpbGxSZWN0KFxuICAgICAgICAgIC13aWR0aCAvIDIgLSBwYWRkaW5nLmxlZnQsXG4gICAgICAgICAgLW9mZnNldCAtIHRpY2tGb250LnNpemUgLyAyIC0gcGFkZGluZy50b3AsXG4gICAgICAgICAgd2lkdGggKyBwYWRkaW5nLndpZHRoLFxuICAgICAgICAgIHRpY2tGb250LnNpemUgKyBwYWRkaW5nLmhlaWdodFxuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICByZW5kZXJUZXh0KGN0eCwgdGljay5sYWJlbCwgMCwgLW9mZnNldCwgdGlja0ZvbnQsIHtcbiAgICAgICAgY29sb3I6IG9wdHNBdEluZGV4LmNvbG9yLFxuICAgICAgICBzdHJva2VDb2xvcjogb3B0c0F0SW5kZXgudGV4dFN0cm9rZUNvbG9yLFxuICAgICAgICBzdHJva2VXaWR0aDogb3B0c0F0SW5kZXgudGV4dFN0cm9rZVdpZHRoLFxuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBjdHgucmVzdG9yZSgpO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG4gIGRyYXdUaXRsZSgpIHt9XG59XG4iLCAiaW1wb3J0IGFkYXB0ZXJzIGZyb20gJy4uL2NvcmUvY29yZS5hZGFwdGVycy5qcyc7XG5pbXBvcnQge2NhbGxiYWNrIGFzIGNhbGwsIGlzRmluaXRlLCBpc051bGxPclVuZGVmLCBtZXJnZUlmLCB2YWx1ZU9yRGVmYXVsdH0gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLmNvcmUuanMnO1xuaW1wb3J0IHt0b1JhZGlhbnMsIGlzTnVtYmVyLCBfbGltaXRWYWx1ZX0gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLm1hdGguanMnO1xuaW1wb3J0IFNjYWxlIGZyb20gJy4uL2NvcmUvY29yZS5zY2FsZS5qcyc7XG5pbXBvcnQge19hcnJheVVuaXF1ZSwgX2ZpbHRlckJldHdlZW4sIF9sb29rdXB9IGZyb20gJy4uL2hlbHBlcnMvaGVscGVycy5jb2xsZWN0aW9uLmpzJztcblxuLyoqXG4gKiBAdHlwZWRlZiB7IGltcG9ydCgnLi4vY29yZS9jb3JlLmFkYXB0ZXJzLmpzJykuVGltZVVuaXQgfSBVbml0XG4gKiBAdHlwZWRlZiB7e2NvbW1vbjogYm9vbGVhbiwgc2l6ZTogbnVtYmVyLCBzdGVwcz86IG51bWJlcn19IEludGVydmFsXG4gKiBAdHlwZWRlZiB7IGltcG9ydCgnLi4vY29yZS9jb3JlLmFkYXB0ZXJzLmpzJykuRGF0ZUFkYXB0ZXIgfSBEYXRlQWRhcHRlclxuICovXG5cbi8qKlxuICogQHR5cGUge09iamVjdDxVbml0LCBJbnRlcnZhbD59XG4gKi9cbmNvbnN0IElOVEVSVkFMUyA9IHtcbiAgbWlsbGlzZWNvbmQ6IHtjb21tb246IHRydWUsIHNpemU6IDEsIHN0ZXBzOiAxMDAwfSxcbiAgc2Vjb25kOiB7Y29tbW9uOiB0cnVlLCBzaXplOiAxMDAwLCBzdGVwczogNjB9LFxuICBtaW51dGU6IHtjb21tb246IHRydWUsIHNpemU6IDYwMDAwLCBzdGVwczogNjB9LFxuICBob3VyOiB7Y29tbW9uOiB0cnVlLCBzaXplOiAzNjAwMDAwLCBzdGVwczogMjR9LFxuICBkYXk6IHtjb21tb246IHRydWUsIHNpemU6IDg2NDAwMDAwLCBzdGVwczogMzB9LFxuICB3ZWVrOiB7Y29tbW9uOiBmYWxzZSwgc2l6ZTogNjA0ODAwMDAwLCBzdGVwczogNH0sXG4gIG1vbnRoOiB7Y29tbW9uOiB0cnVlLCBzaXplOiAyLjYyOGU5LCBzdGVwczogMTJ9LFxuICBxdWFydGVyOiB7Y29tbW9uOiBmYWxzZSwgc2l6ZTogNy44ODRlOSwgc3RlcHM6IDR9LFxuICB5ZWFyOiB7Y29tbW9uOiB0cnVlLCBzaXplOiAzLjE1NGUxMH1cbn07XG5cbi8qKlxuICogQHR5cGUge1VuaXRbXX1cbiAqL1xuY29uc3QgVU5JVFMgPSAvKiogQHR5cGUgVW5pdFtdICovIC8qICNfX1BVUkVfXyAqLyAoT2JqZWN0LmtleXMoSU5URVJWQUxTKSk7XG5cbi8qKlxuICogQHBhcmFtIHtudW1iZXJ9IGFcbiAqIEBwYXJhbSB7bnVtYmVyfSBiXG4gKi9cbmZ1bmN0aW9uIHNvcnRlcihhLCBiKSB7XG4gIHJldHVybiBhIC0gYjtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge1RpbWVTY2FsZX0gc2NhbGVcbiAqIEBwYXJhbSB7Kn0gaW5wdXRcbiAqIEByZXR1cm4ge251bWJlcn1cbiAqL1xuZnVuY3Rpb24gcGFyc2Uoc2NhbGUsIGlucHV0KSB7XG4gIGlmIChpc051bGxPclVuZGVmKGlucHV0KSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgY29uc3QgYWRhcHRlciA9IHNjYWxlLl9hZGFwdGVyO1xuICBjb25zdCB7cGFyc2VyLCByb3VuZCwgaXNvV2Vla2RheX0gPSBzY2FsZS5fcGFyc2VPcHRzO1xuICBsZXQgdmFsdWUgPSBpbnB1dDtcblxuICBpZiAodHlwZW9mIHBhcnNlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHZhbHVlID0gcGFyc2VyKHZhbHVlKTtcbiAgfVxuXG4gIC8vIE9ubHkgcGFyc2UgaWYgaXQncyBub3QgYSB0aW1lc3RhbXAgYWxyZWFkeVxuICBpZiAoIWlzRmluaXRlKHZhbHVlKSkge1xuICAgIHZhbHVlID0gdHlwZW9mIHBhcnNlciA9PT0gJ3N0cmluZydcbiAgICAgID8gYWRhcHRlci5wYXJzZSh2YWx1ZSwgLyoqIEB0eXBlIHtVbml0fSAqLyAocGFyc2VyKSlcbiAgICAgIDogYWRhcHRlci5wYXJzZSh2YWx1ZSk7XG4gIH1cblxuICBpZiAodmFsdWUgPT09IG51bGwpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGlmIChyb3VuZCkge1xuICAgIHZhbHVlID0gcm91bmQgPT09ICd3ZWVrJyAmJiAoaXNOdW1iZXIoaXNvV2Vla2RheSkgfHwgaXNvV2Vla2RheSA9PT0gdHJ1ZSlcbiAgICAgID8gYWRhcHRlci5zdGFydE9mKHZhbHVlLCAnaXNvV2VlaycsIGlzb1dlZWtkYXkpXG4gICAgICA6IGFkYXB0ZXIuc3RhcnRPZih2YWx1ZSwgcm91bmQpO1xuICB9XG5cbiAgcmV0dXJuICt2YWx1ZTtcbn1cblxuLyoqXG4gKiBGaWd1cmVzIG91dCB3aGF0IHVuaXQgcmVzdWx0cyBpbiBhbiBhcHByb3ByaWF0ZSBudW1iZXIgb2YgYXV0by1nZW5lcmF0ZWQgdGlja3NcbiAqIEBwYXJhbSB7VW5pdH0gbWluVW5pdFxuICogQHBhcmFtIHtudW1iZXJ9IG1pblxuICogQHBhcmFtIHtudW1iZXJ9IG1heFxuICogQHBhcmFtIHtudW1iZXJ9IGNhcGFjaXR5XG4gKiBAcmV0dXJuIHtvYmplY3R9XG4gKi9cbmZ1bmN0aW9uIGRldGVybWluZVVuaXRGb3JBdXRvVGlja3MobWluVW5pdCwgbWluLCBtYXgsIGNhcGFjaXR5KSB7XG4gIGNvbnN0IGlsZW4gPSBVTklUUy5sZW5ndGg7XG5cbiAgZm9yIChsZXQgaSA9IFVOSVRTLmluZGV4T2YobWluVW5pdCk7IGkgPCBpbGVuIC0gMTsgKytpKSB7XG4gICAgY29uc3QgaW50ZXJ2YWwgPSBJTlRFUlZBTFNbVU5JVFNbaV1dO1xuICAgIGNvbnN0IGZhY3RvciA9IGludGVydmFsLnN0ZXBzID8gaW50ZXJ2YWwuc3RlcHMgOiBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUjtcblxuICAgIGlmIChpbnRlcnZhbC5jb21tb24gJiYgTWF0aC5jZWlsKChtYXggLSBtaW4pIC8gKGZhY3RvciAqIGludGVydmFsLnNpemUpKSA8PSBjYXBhY2l0eSkge1xuICAgICAgcmV0dXJuIFVOSVRTW2ldO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBVTklUU1tpbGVuIC0gMV07XG59XG5cbi8qKlxuICogRmlndXJlcyBvdXQgd2hhdCB1bml0IHRvIGZvcm1hdCBhIHNldCBvZiB0aWNrcyB3aXRoXG4gKiBAcGFyYW0ge1RpbWVTY2FsZX0gc2NhbGVcbiAqIEBwYXJhbSB7bnVtYmVyfSBudW1UaWNrc1xuICogQHBhcmFtIHtVbml0fSBtaW5Vbml0XG4gKiBAcGFyYW0ge251bWJlcn0gbWluXG4gKiBAcGFyYW0ge251bWJlcn0gbWF4XG4gKiBAcmV0dXJuIHtVbml0fVxuICovXG5mdW5jdGlvbiBkZXRlcm1pbmVVbml0Rm9yRm9ybWF0dGluZyhzY2FsZSwgbnVtVGlja3MsIG1pblVuaXQsIG1pbiwgbWF4KSB7XG4gIGZvciAobGV0IGkgPSBVTklUUy5sZW5ndGggLSAxOyBpID49IFVOSVRTLmluZGV4T2YobWluVW5pdCk7IGktLSkge1xuICAgIGNvbnN0IHVuaXQgPSBVTklUU1tpXTtcbiAgICBpZiAoSU5URVJWQUxTW3VuaXRdLmNvbW1vbiAmJiBzY2FsZS5fYWRhcHRlci5kaWZmKG1heCwgbWluLCB1bml0KSA+PSBudW1UaWNrcyAtIDEpIHtcbiAgICAgIHJldHVybiB1bml0O1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBVTklUU1ttaW5Vbml0ID8gVU5JVFMuaW5kZXhPZihtaW5Vbml0KSA6IDBdO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7VW5pdH0gdW5pdFxuICogQHJldHVybiB7b2JqZWN0fVxuICovXG5mdW5jdGlvbiBkZXRlcm1pbmVNYWpvclVuaXQodW5pdCkge1xuICBmb3IgKGxldCBpID0gVU5JVFMuaW5kZXhPZih1bml0KSArIDEsIGlsZW4gPSBVTklUUy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICBpZiAoSU5URVJWQUxTW1VOSVRTW2ldXS5jb21tb24pIHtcbiAgICAgIHJldHVybiBVTklUU1tpXTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge29iamVjdH0gdGlja3NcbiAqIEBwYXJhbSB7bnVtYmVyfSB0aW1lXG4gKiBAcGFyYW0ge251bWJlcltdfSBbdGltZXN0YW1wc10gLSBpZiBkZWZpbmVkLCBzbmFwIHRvIHRoZXNlIHRpbWVzdGFtcHNcbiAqL1xuZnVuY3Rpb24gYWRkVGljayh0aWNrcywgdGltZSwgdGltZXN0YW1wcykge1xuICBpZiAoIXRpbWVzdGFtcHMpIHtcbiAgICB0aWNrc1t0aW1lXSA9IHRydWU7XG4gIH0gZWxzZSBpZiAodGltZXN0YW1wcy5sZW5ndGgpIHtcbiAgICBjb25zdCB7bG8sIGhpfSA9IF9sb29rdXAodGltZXN0YW1wcywgdGltZSk7XG4gICAgY29uc3QgdGltZXN0YW1wID0gdGltZXN0YW1wc1tsb10gPj0gdGltZSA/IHRpbWVzdGFtcHNbbG9dIDogdGltZXN0YW1wc1toaV07XG4gICAgdGlja3NbdGltZXN0YW1wXSA9IHRydWU7XG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge1RpbWVTY2FsZX0gc2NhbGVcbiAqIEBwYXJhbSB7b2JqZWN0W119IHRpY2tzXG4gKiBAcGFyYW0ge29iamVjdH0gbWFwXG4gKiBAcGFyYW0ge1VuaXR9IG1ham9yVW5pdFxuICogQHJldHVybiB7b2JqZWN0W119XG4gKi9cbmZ1bmN0aW9uIHNldE1ham9yVGlja3Moc2NhbGUsIHRpY2tzLCBtYXAsIG1ham9yVW5pdCkge1xuICBjb25zdCBhZGFwdGVyID0gc2NhbGUuX2FkYXB0ZXI7XG4gIGNvbnN0IGZpcnN0ID0gK2FkYXB0ZXIuc3RhcnRPZih0aWNrc1swXS52YWx1ZSwgbWFqb3JVbml0KTtcbiAgY29uc3QgbGFzdCA9IHRpY2tzW3RpY2tzLmxlbmd0aCAtIDFdLnZhbHVlO1xuICBsZXQgbWFqb3IsIGluZGV4O1xuXG4gIGZvciAobWFqb3IgPSBmaXJzdDsgbWFqb3IgPD0gbGFzdDsgbWFqb3IgPSArYWRhcHRlci5hZGQobWFqb3IsIDEsIG1ham9yVW5pdCkpIHtcbiAgICBpbmRleCA9IG1hcFttYWpvcl07XG4gICAgaWYgKGluZGV4ID49IDApIHtcbiAgICAgIHRpY2tzW2luZGV4XS5tYWpvciA9IHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiB0aWNrcztcbn1cblxuLyoqXG4gKiBAcGFyYW0ge1RpbWVTY2FsZX0gc2NhbGVcbiAqIEBwYXJhbSB7bnVtYmVyW119IHZhbHVlc1xuICogQHBhcmFtIHtVbml0fHVuZGVmaW5lZH0gW21ham9yVW5pdF1cbiAqIEByZXR1cm4ge29iamVjdFtdfVxuICovXG5mdW5jdGlvbiB0aWNrc0Zyb21UaW1lc3RhbXBzKHNjYWxlLCB2YWx1ZXMsIG1ham9yVW5pdCkge1xuICBjb25zdCB0aWNrcyA9IFtdO1xuICAvKiogQHR5cGUge09iamVjdDxudW1iZXIsb2JqZWN0Pn0gKi9cbiAgY29uc3QgbWFwID0ge307XG4gIGNvbnN0IGlsZW4gPSB2YWx1ZXMubGVuZ3RoO1xuICBsZXQgaSwgdmFsdWU7XG5cbiAgZm9yIChpID0gMDsgaSA8IGlsZW47ICsraSkge1xuICAgIHZhbHVlID0gdmFsdWVzW2ldO1xuICAgIG1hcFt2YWx1ZV0gPSBpO1xuXG4gICAgdGlja3MucHVzaCh7XG4gICAgICB2YWx1ZSxcbiAgICAgIG1ham9yOiBmYWxzZVxuICAgIH0pO1xuICB9XG5cbiAgLy8gV2Ugc2V0IHRoZSBtYWpvciB0aWNrcyBzZXBhcmF0ZWx5IGZyb20gdGhlIGFib3ZlIGxvb3AgYmVjYXVzZSBjYWxsaW5nIHN0YXJ0T2YgZm9yIGV2ZXJ5IHRpY2tcbiAgLy8gaXMgZXhwZW5zaXZlIHdoZW4gdGhlcmUgaXMgYSBsYXJnZSBudW1iZXIgb2YgdGlja3NcbiAgcmV0dXJuIChpbGVuID09PSAwIHx8ICFtYWpvclVuaXQpID8gdGlja3MgOiBzZXRNYWpvclRpY2tzKHNjYWxlLCB0aWNrcywgbWFwLCBtYWpvclVuaXQpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBUaW1lU2NhbGUgZXh0ZW5kcyBTY2FsZSB7XG5cbiAgc3RhdGljIGlkID0gJ3RpbWUnO1xuXG4gIC8qKlxuICAgKiBAdHlwZSB7YW55fVxuICAgKi9cbiAgc3RhdGljIGRlZmF1bHRzID0ge1xuICAgIC8qKlxuICAgICAqIFNjYWxlIGJvdW5kYXJ5IHN0cmF0ZWd5IChieXBhc3NlZCBieSBtaW4vbWF4IHRpbWUgb3B0aW9ucylcbiAgICAgKiAtIGBkYXRhYDogbWFrZSBzdXJlIGRhdGEgYXJlIGZ1bGx5IHZpc2libGUsIHRpY2tzIG91dHNpZGUgYXJlIHJlbW92ZWRcbiAgICAgKiAtIGB0aWNrc2A6IG1ha2Ugc3VyZSB0aWNrcyBhcmUgZnVsbHkgdmlzaWJsZSwgZGF0YSBvdXRzaWRlIGFyZSB0cnVuY2F0ZWRcbiAgICAgKiBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9jaGFydGpzL0NoYXJ0LmpzL3B1bGwvNDU1NlxuICAgICAqIEBzaW5jZSAyLjcuMFxuICAgICAqL1xuICAgIGJvdW5kczogJ2RhdGEnLFxuXG4gICAgYWRhcHRlcnM6IHt9LFxuICAgIHRpbWU6IHtcbiAgICAgIHBhcnNlcjogZmFsc2UsIC8vIGZhbHNlID09IGEgcGF0dGVybiBzdHJpbmcgZnJvbSBvciBhIGN1c3RvbSBjYWxsYmFjayB0aGF0IGNvbnZlcnRzIGl0cyBhcmd1bWVudCB0byBhIHRpbWVzdGFtcFxuICAgICAgdW5pdDogZmFsc2UsIC8vIGZhbHNlID09IGF1dG9tYXRpYyBvciBvdmVycmlkZSB3aXRoIHdlZWssIG1vbnRoLCB5ZWFyLCBldGMuXG4gICAgICByb3VuZDogZmFsc2UsIC8vIG5vbmUsIG9yIG92ZXJyaWRlIHdpdGggd2VlaywgbW9udGgsIHllYXIsIGV0Yy5cbiAgICAgIGlzb1dlZWtkYXk6IGZhbHNlLCAvLyBvdmVycmlkZSB3ZWVrIHN0YXJ0IGRheVxuICAgICAgbWluVW5pdDogJ21pbGxpc2Vjb25kJyxcbiAgICAgIGRpc3BsYXlGb3JtYXRzOiB7fVxuICAgIH0sXG4gICAgdGlja3M6IHtcbiAgICAgIC8qKlxuICAgICAgICogVGlja3MgZ2VuZXJhdGlvbiBpbnB1dCB2YWx1ZXM6XG4gICAgICAgKiAtICdhdXRvJzogZ2VuZXJhdGVzIFwib3B0aW1hbFwiIHRpY2tzIGJhc2VkIG9uIHNjYWxlIHNpemUgYW5kIHRpbWUgb3B0aW9ucy5cbiAgICAgICAqIC0gJ2RhdGEnOiBnZW5lcmF0ZXMgdGlja3MgZnJvbSBkYXRhIChpbmNsdWRpbmcgbGFiZWxzIGZyb20gZGF0YSB7dHx4fHl9IG9iamVjdHMpLlxuICAgICAgICogLSAnbGFiZWxzJzogZ2VuZXJhdGVzIHRpY2tzIGZyb20gdXNlciBnaXZlbiBgZGF0YS5sYWJlbHNgIHZhbHVlcyBPTkxZLlxuICAgICAgICogQHNlZSBodHRwczovL2dpdGh1Yi5jb20vY2hhcnRqcy9DaGFydC5qcy9wdWxsLzQ1MDdcbiAgICAgICAqIEBzaW5jZSAyLjcuMFxuICAgICAgICovXG4gICAgICBzb3VyY2U6ICdhdXRvJyxcblxuICAgICAgY2FsbGJhY2s6IGZhbHNlLFxuXG4gICAgICBtYWpvcjoge1xuICAgICAgICBlbmFibGVkOiBmYWxzZVxuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvKipcblx0ICogQHBhcmFtIHtvYmplY3R9IHByb3BzXG5cdCAqL1xuICBjb25zdHJ1Y3Rvcihwcm9wcykge1xuICAgIHN1cGVyKHByb3BzKTtcblxuICAgIC8qKiBAdHlwZSB7e2RhdGE6IG51bWJlcltdLCBsYWJlbHM6IG51bWJlcltdLCBhbGw6IG51bWJlcltdfX0gKi9cbiAgICB0aGlzLl9jYWNoZSA9IHtcbiAgICAgIGRhdGE6IFtdLFxuICAgICAgbGFiZWxzOiBbXSxcbiAgICAgIGFsbDogW11cbiAgICB9O1xuXG4gICAgLyoqIEB0eXBlIHtVbml0fSAqL1xuICAgIHRoaXMuX3VuaXQgPSAnZGF5JztcbiAgICAvKiogQHR5cGUge1VuaXQ9fSAqL1xuICAgIHRoaXMuX21ham9yVW5pdCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9vZmZzZXRzID0ge307XG4gICAgdGhpcy5fbm9ybWFsaXplZCA9IGZhbHNlO1xuICAgIHRoaXMuX3BhcnNlT3B0cyA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIGluaXQoc2NhbGVPcHRzLCBvcHRzID0ge30pIHtcbiAgICBjb25zdCB0aW1lID0gc2NhbGVPcHRzLnRpbWUgfHwgKHNjYWxlT3B0cy50aW1lID0ge30pO1xuICAgIC8qKiBAdHlwZSB7RGF0ZUFkYXB0ZXJ9ICovXG4gICAgY29uc3QgYWRhcHRlciA9IHRoaXMuX2FkYXB0ZXIgPSBuZXcgYWRhcHRlcnMuX2RhdGUoc2NhbGVPcHRzLmFkYXB0ZXJzLmRhdGUpO1xuXG4gICAgYWRhcHRlci5pbml0KG9wdHMpO1xuXG4gICAgLy8gQmFja3dhcmQgY29tcGF0aWJpbGl0eTogYmVmb3JlIGludHJvZHVjaW5nIGFkYXB0ZXIsIGBkaXNwbGF5Rm9ybWF0c2Agd2FzXG4gICAgLy8gc3VwcG9zZWQgdG8gY29udGFpbiAqYWxsKiB1bml0L3N0cmluZyBwYWlycyBidXQgdGhpcyBjYW4ndCBiZSByZXNvbHZlZFxuICAgIC8vIHdoZW4gbG9hZGluZyB0aGUgc2NhbGUgKGFkYXB0ZXJzIGFyZSBsb2FkZWQgYWZ0ZXJ3YXJkKSwgc28gbGV0J3MgcG9wdWxhdGVcbiAgICAvLyBtaXNzaW5nIGZvcm1hdHMgb24gdXBkYXRlXG4gICAgbWVyZ2VJZih0aW1lLmRpc3BsYXlGb3JtYXRzLCBhZGFwdGVyLmZvcm1hdHMoKSk7XG5cbiAgICB0aGlzLl9wYXJzZU9wdHMgPSB7XG4gICAgICBwYXJzZXI6IHRpbWUucGFyc2VyLFxuICAgICAgcm91bmQ6IHRpbWUucm91bmQsXG4gICAgICBpc29XZWVrZGF5OiB0aW1lLmlzb1dlZWtkYXlcbiAgICB9O1xuXG4gICAgc3VwZXIuaW5pdChzY2FsZU9wdHMpO1xuXG4gICAgdGhpcy5fbm9ybWFsaXplZCA9IG9wdHMubm9ybWFsaXplZDtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcGFyYW0geyp9IHJhd1xuXHQgKiBAcGFyYW0ge251bWJlcj99IFtpbmRleF1cblx0ICogQHJldHVybiB7bnVtYmVyfVxuXHQgKi9cbiAgcGFyc2UocmF3LCBpbmRleCkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gICAgaWYgKHJhdyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIHBhcnNlKHRoaXMsIHJhdyk7XG4gIH1cblxuICBiZWZvcmVMYXlvdXQoKSB7XG4gICAgc3VwZXIuYmVmb3JlTGF5b3V0KCk7XG4gICAgdGhpcy5fY2FjaGUgPSB7XG4gICAgICBkYXRhOiBbXSxcbiAgICAgIGxhYmVsczogW10sXG4gICAgICBhbGw6IFtdXG4gICAgfTtcbiAgfVxuXG4gIGRldGVybWluZURhdGFMaW1pdHMoKSB7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICBjb25zdCBhZGFwdGVyID0gdGhpcy5fYWRhcHRlcjtcbiAgICBjb25zdCB1bml0ID0gb3B0aW9ucy50aW1lLnVuaXQgfHwgJ2RheSc7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHByZWZlci1jb25zdFxuICAgIGxldCB7bWluLCBtYXgsIG1pbkRlZmluZWQsIG1heERlZmluZWR9ID0gdGhpcy5nZXRVc2VyQm91bmRzKCk7XG5cbiAgICAvKipcblx0XHQgKiBAcGFyYW0ge29iamVjdH0gYm91bmRzXG5cdFx0ICovXG4gICAgZnVuY3Rpb24gX2FwcGx5Qm91bmRzKGJvdW5kcykge1xuICAgICAgaWYgKCFtaW5EZWZpbmVkICYmICFpc05hTihib3VuZHMubWluKSkge1xuICAgICAgICBtaW4gPSBNYXRoLm1pbihtaW4sIGJvdW5kcy5taW4pO1xuICAgICAgfVxuICAgICAgaWYgKCFtYXhEZWZpbmVkICYmICFpc05hTihib3VuZHMubWF4KSkge1xuICAgICAgICBtYXggPSBNYXRoLm1heChtYXgsIGJvdW5kcy5tYXgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIElmIHdlIGhhdmUgdXNlciBwcm92aWRlZCBgbWluYCBhbmQgYG1heGAgbGFiZWxzIC8gZGF0YSBib3VuZHMgY2FuIGJlIGlnbm9yZWRcbiAgICBpZiAoIW1pbkRlZmluZWQgfHwgIW1heERlZmluZWQpIHtcbiAgICAgIC8vIExhYmVscyBhcmUgYWx3YXlzIGNvbnNpZGVyZWQsIHdoZW4gdXNlciBkaWQgbm90IGZvcmNlIGJvdW5kc1xuICAgICAgX2FwcGx5Qm91bmRzKHRoaXMuX2dldExhYmVsQm91bmRzKCkpO1xuXG4gICAgICAvLyBJZiBgYm91bmRzYCBpcyBgJ3RpY2tzJ2AgYW5kIGB0aWNrcy5zb3VyY2VgIGlzIGAnbGFiZWxzJ2AsXG4gICAgICAvLyBkYXRhIGJvdW5kcyBhcmUgaWdub3JlZCAoYW5kIGRvbid0IG5lZWQgdG8gYmUgZGV0ZXJtaW5lZClcbiAgICAgIGlmIChvcHRpb25zLmJvdW5kcyAhPT0gJ3RpY2tzJyB8fCBvcHRpb25zLnRpY2tzLnNvdXJjZSAhPT0gJ2xhYmVscycpIHtcbiAgICAgICAgX2FwcGx5Qm91bmRzKHRoaXMuZ2V0TWluTWF4KGZhbHNlKSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgbWluID0gaXNGaW5pdGUobWluKSAmJiAhaXNOYU4obWluKSA/IG1pbiA6ICthZGFwdGVyLnN0YXJ0T2YoRGF0ZS5ub3coKSwgdW5pdCk7XG4gICAgbWF4ID0gaXNGaW5pdGUobWF4KSAmJiAhaXNOYU4obWF4KSA/IG1heCA6ICthZGFwdGVyLmVuZE9mKERhdGUubm93KCksIHVuaXQpICsgMTtcblxuICAgIC8vIE1ha2Ugc3VyZSB0aGF0IG1heCBpcyBzdHJpY3RseSBoaWdoZXIgdGhhbiBtaW4gKHJlcXVpcmVkIGJ5IHRoZSB0aW1lc2VyaWVzIGxvb2t1cCB0YWJsZSlcbiAgICB0aGlzLm1pbiA9IE1hdGgubWluKG1pbiwgbWF4IC0gMSk7XG4gICAgdGhpcy5tYXggPSBNYXRoLm1heChtaW4gKyAxLCBtYXgpO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfZ2V0TGFiZWxCb3VuZHMoKSB7XG4gICAgY29uc3QgYXJyID0gdGhpcy5nZXRMYWJlbFRpbWVzdGFtcHMoKTtcbiAgICBsZXQgbWluID0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZO1xuICAgIGxldCBtYXggPSBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFk7XG5cbiAgICBpZiAoYXJyLmxlbmd0aCkge1xuICAgICAgbWluID0gYXJyWzBdO1xuICAgICAgbWF4ID0gYXJyW2Fyci5sZW5ndGggLSAxXTtcbiAgICB9XG4gICAgcmV0dXJuIHttaW4sIG1heH07XG4gIH1cblxuICAvKipcblx0ICogQHJldHVybiB7b2JqZWN0W119XG5cdCAqL1xuICBidWlsZFRpY2tzKCkge1xuICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgY29uc3QgdGltZU9wdHMgPSBvcHRpb25zLnRpbWU7XG4gICAgY29uc3QgdGlja09wdHMgPSBvcHRpb25zLnRpY2tzO1xuICAgIGNvbnN0IHRpbWVzdGFtcHMgPSB0aWNrT3B0cy5zb3VyY2UgPT09ICdsYWJlbHMnID8gdGhpcy5nZXRMYWJlbFRpbWVzdGFtcHMoKSA6IHRoaXMuX2dlbmVyYXRlKCk7XG5cbiAgICBpZiAob3B0aW9ucy5ib3VuZHMgPT09ICd0aWNrcycgJiYgdGltZXN0YW1wcy5sZW5ndGgpIHtcbiAgICAgIHRoaXMubWluID0gdGhpcy5fdXNlck1pbiB8fCB0aW1lc3RhbXBzWzBdO1xuICAgICAgdGhpcy5tYXggPSB0aGlzLl91c2VyTWF4IHx8IHRpbWVzdGFtcHNbdGltZXN0YW1wcy5sZW5ndGggLSAxXTtcbiAgICB9XG5cbiAgICBjb25zdCBtaW4gPSB0aGlzLm1pbjtcbiAgICBjb25zdCBtYXggPSB0aGlzLm1heDtcblxuICAgIGNvbnN0IHRpY2tzID0gX2ZpbHRlckJldHdlZW4odGltZXN0YW1wcywgbWluLCBtYXgpO1xuXG4gICAgLy8gUFJJVkFURVxuICAgIC8vIGRldGVybWluZVVuaXRGb3JGb3JtYXR0aW5nIHJlbGllcyBvbiB0aGUgbnVtYmVyIG9mIHRpY2tzIHNvIHdlIGRvbid0IHVzZSBpdCB3aGVuXG4gICAgLy8gYXV0b1NraXAgaXMgZW5hYmxlZCBiZWNhdXNlIHdlIGRvbid0IHlldCBrbm93IHdoYXQgdGhlIGZpbmFsIG51bWJlciBvZiB0aWNrcyB3aWxsIGJlXG4gICAgdGhpcy5fdW5pdCA9IHRpbWVPcHRzLnVuaXQgfHwgKHRpY2tPcHRzLmF1dG9Ta2lwXG4gICAgICA/IGRldGVybWluZVVuaXRGb3JBdXRvVGlja3ModGltZU9wdHMubWluVW5pdCwgdGhpcy5taW4sIHRoaXMubWF4LCB0aGlzLl9nZXRMYWJlbENhcGFjaXR5KG1pbikpXG4gICAgICA6IGRldGVybWluZVVuaXRGb3JGb3JtYXR0aW5nKHRoaXMsIHRpY2tzLmxlbmd0aCwgdGltZU9wdHMubWluVW5pdCwgdGhpcy5taW4sIHRoaXMubWF4KSk7XG4gICAgdGhpcy5fbWFqb3JVbml0ID0gIXRpY2tPcHRzLm1ham9yLmVuYWJsZWQgfHwgdGhpcy5fdW5pdCA9PT0gJ3llYXInID8gdW5kZWZpbmVkXG4gICAgICA6IGRldGVybWluZU1ham9yVW5pdCh0aGlzLl91bml0KTtcbiAgICB0aGlzLmluaXRPZmZzZXRzKHRpbWVzdGFtcHMpO1xuXG4gICAgaWYgKG9wdGlvbnMucmV2ZXJzZSkge1xuICAgICAgdGlja3MucmV2ZXJzZSgpO1xuICAgIH1cblxuICAgIHJldHVybiB0aWNrc0Zyb21UaW1lc3RhbXBzKHRoaXMsIHRpY2tzLCB0aGlzLl9tYWpvclVuaXQpO1xuICB9XG5cbiAgYWZ0ZXJBdXRvU2tpcCgpIHtcbiAgICAvLyBPZmZzZXRzIGZvciBiYXIgY2hhcnRzIG5lZWQgdG8gYmUgaGFuZGxlZCB3aXRoIHRoZSBhdXRvIHNraXBwZWRcbiAgICAvLyB0aWNrcy4gT25jZSB0aWNrcyBoYXZlIGJlZW4gc2tpcHBlZCwgd2UgcmUtY29tcHV0ZSB0aGUgb2Zmc2V0cy5cbiAgICBpZiAodGhpcy5vcHRpb25zLm9mZnNldEFmdGVyQXV0b3NraXApIHtcbiAgICAgIHRoaXMuaW5pdE9mZnNldHModGhpcy50aWNrcy5tYXAodGljayA9PiArdGljay52YWx1ZSkpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuXHQgKiBSZXR1cm5zIHRoZSBzdGFydCBhbmQgZW5kIG9mZnNldHMgZnJvbSBlZGdlcyBpbiB0aGUgZm9ybSBvZiB7c3RhcnQsIGVuZH1cblx0ICogd2hlcmUgZWFjaCB2YWx1ZSBpcyBhIHJlbGF0aXZlIHdpZHRoIHRvIHRoZSBzY2FsZSBhbmQgcmFuZ2VzIGJldHdlZW4gMCBhbmQgMS5cblx0ICogVGhleSBhZGQgZXh0cmEgbWFyZ2lucyBvbiB0aGUgYm90aCBzaWRlcyBieSBzY2FsaW5nIGRvd24gdGhlIG9yaWdpbmFsIHNjYWxlLlxuXHQgKiBPZmZzZXRzIGFyZSBhZGRlZCB3aGVuIHRoZSBgb2Zmc2V0YCBvcHRpb24gaXMgdHJ1ZS5cblx0ICogQHBhcmFtIHtudW1iZXJbXX0gdGltZXN0YW1wc1xuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuICBpbml0T2Zmc2V0cyh0aW1lc3RhbXBzID0gW10pIHtcbiAgICBsZXQgc3RhcnQgPSAwO1xuICAgIGxldCBlbmQgPSAwO1xuICAgIGxldCBmaXJzdCwgbGFzdDtcblxuICAgIGlmICh0aGlzLm9wdGlvbnMub2Zmc2V0ICYmIHRpbWVzdGFtcHMubGVuZ3RoKSB7XG4gICAgICBmaXJzdCA9IHRoaXMuZ2V0RGVjaW1hbEZvclZhbHVlKHRpbWVzdGFtcHNbMF0pO1xuICAgICAgaWYgKHRpbWVzdGFtcHMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIHN0YXJ0ID0gMSAtIGZpcnN0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RhcnQgPSAodGhpcy5nZXREZWNpbWFsRm9yVmFsdWUodGltZXN0YW1wc1sxXSkgLSBmaXJzdCkgLyAyO1xuICAgICAgfVxuICAgICAgbGFzdCA9IHRoaXMuZ2V0RGVjaW1hbEZvclZhbHVlKHRpbWVzdGFtcHNbdGltZXN0YW1wcy5sZW5ndGggLSAxXSk7XG4gICAgICBpZiAodGltZXN0YW1wcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgZW5kID0gbGFzdDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVuZCA9IChsYXN0IC0gdGhpcy5nZXREZWNpbWFsRm9yVmFsdWUodGltZXN0YW1wc1t0aW1lc3RhbXBzLmxlbmd0aCAtIDJdKSkgLyAyO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBsaW1pdCA9IHRpbWVzdGFtcHMubGVuZ3RoIDwgMyA/IDAuNSA6IDAuMjU7XG4gICAgc3RhcnQgPSBfbGltaXRWYWx1ZShzdGFydCwgMCwgbGltaXQpO1xuICAgIGVuZCA9IF9saW1pdFZhbHVlKGVuZCwgMCwgbGltaXQpO1xuXG4gICAgdGhpcy5fb2Zmc2V0cyA9IHtzdGFydCwgZW5kLCBmYWN0b3I6IDEgLyAoc3RhcnQgKyAxICsgZW5kKX07XG4gIH1cblxuICAvKipcblx0ICogR2VuZXJhdGVzIGEgbWF4aW11bSBvZiBgY2FwYWNpdHlgIHRpbWVzdGFtcHMgYmV0d2VlbiBtaW4gYW5kIG1heCwgcm91bmRlZCB0byB0aGVcblx0ICogYG1pbm9yYCB1bml0IHVzaW5nIHRoZSBnaXZlbiBzY2FsZSB0aW1lIGBvcHRpb25zYC5cblx0ICogSW1wb3J0YW50OiB0aGlzIG1ldGhvZCBjYW4gcmV0dXJuIHRpY2tzIG91dHNpZGUgdGhlIG1pbiBhbmQgbWF4IHJhbmdlLCBpdCdzIHRoZVxuXHQgKiByZXNwb25zaWJpbGl0eSBvZiB0aGUgY2FsbGluZyBjb2RlIHRvIGNsYW1wIHZhbHVlcyBpZiBuZWVkZWQuXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG4gIF9nZW5lcmF0ZSgpIHtcbiAgICBjb25zdCBhZGFwdGVyID0gdGhpcy5fYWRhcHRlcjtcbiAgICBjb25zdCBtaW4gPSB0aGlzLm1pbjtcbiAgICBjb25zdCBtYXggPSB0aGlzLm1heDtcbiAgICBjb25zdCBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgIGNvbnN0IHRpbWVPcHRzID0gb3B0aW9ucy50aW1lO1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBjb25zdCBtaW5vciA9IHRpbWVPcHRzLnVuaXQgfHwgZGV0ZXJtaW5lVW5pdEZvckF1dG9UaWNrcyh0aW1lT3B0cy5taW5Vbml0LCBtaW4sIG1heCwgdGhpcy5fZ2V0TGFiZWxDYXBhY2l0eShtaW4pKTtcbiAgICBjb25zdCBzdGVwU2l6ZSA9IHZhbHVlT3JEZWZhdWx0KG9wdGlvbnMudGlja3Muc3RlcFNpemUsIDEpO1xuICAgIGNvbnN0IHdlZWtkYXkgPSBtaW5vciA9PT0gJ3dlZWsnID8gdGltZU9wdHMuaXNvV2Vla2RheSA6IGZhbHNlO1xuICAgIGNvbnN0IGhhc1dlZWtkYXkgPSBpc051bWJlcih3ZWVrZGF5KSB8fCB3ZWVrZGF5ID09PSB0cnVlO1xuICAgIGNvbnN0IHRpY2tzID0ge307XG4gICAgbGV0IGZpcnN0ID0gbWluO1xuICAgIGxldCB0aW1lLCBjb3VudDtcblxuICAgIC8vIEZvciAnd2VlaycgdW5pdCwgaGFuZGxlIHRoZSBmaXJzdCBkYXkgb2Ygd2VlayBvcHRpb25cbiAgICBpZiAoaGFzV2Vla2RheSkge1xuICAgICAgZmlyc3QgPSArYWRhcHRlci5zdGFydE9mKGZpcnN0LCAnaXNvV2VlaycsIHdlZWtkYXkpO1xuICAgIH1cblxuICAgIC8vIEFsaWduIGZpcnN0IHRpY2tzIG9uIHVuaXRcbiAgICBmaXJzdCA9ICthZGFwdGVyLnN0YXJ0T2YoZmlyc3QsIGhhc1dlZWtkYXkgPyAnZGF5JyA6IG1pbm9yKTtcblxuICAgIC8vIFByZXZlbnQgYnJvd3NlciBmcm9tIGZyZWV6aW5nIGluIGNhc2UgdXNlciBvcHRpb25zIHJlcXVlc3QgbWlsbGlvbnMgb2YgbWlsbGlzZWNvbmRzXG4gICAgaWYgKGFkYXB0ZXIuZGlmZihtYXgsIG1pbiwgbWlub3IpID4gMTAwMDAwICogc3RlcFNpemUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihtaW4gKyAnIGFuZCAnICsgbWF4ICsgJyBhcmUgdG9vIGZhciBhcGFydCB3aXRoIHN0ZXBTaXplIG9mICcgKyBzdGVwU2l6ZSArICcgJyArIG1pbm9yKTtcbiAgICB9XG5cbiAgICBjb25zdCB0aW1lc3RhbXBzID0gb3B0aW9ucy50aWNrcy5zb3VyY2UgPT09ICdkYXRhJyAmJiB0aGlzLmdldERhdGFUaW1lc3RhbXBzKCk7XG4gICAgZm9yICh0aW1lID0gZmlyc3QsIGNvdW50ID0gMDsgdGltZSA8IG1heDsgdGltZSA9ICthZGFwdGVyLmFkZCh0aW1lLCBzdGVwU2l6ZSwgbWlub3IpLCBjb3VudCsrKSB7XG4gICAgICBhZGRUaWNrKHRpY2tzLCB0aW1lLCB0aW1lc3RhbXBzKTtcbiAgICB9XG5cbiAgICBpZiAodGltZSA9PT0gbWF4IHx8IG9wdGlvbnMuYm91bmRzID09PSAndGlja3MnIHx8IGNvdW50ID09PSAxKSB7XG4gICAgICBhZGRUaWNrKHRpY2tzLCB0aW1lLCB0aW1lc3RhbXBzKTtcbiAgICB9XG5cbiAgICAvLyBAdHMtaWdub3JlXG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKHRpY2tzKS5zb3J0KHNvcnRlcikubWFwKHggPT4gK3gpO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZVxuXHQgKiBAcmV0dXJuIHtzdHJpbmd9XG5cdCAqL1xuICBnZXRMYWJlbEZvclZhbHVlKHZhbHVlKSB7XG4gICAgY29uc3QgYWRhcHRlciA9IHRoaXMuX2FkYXB0ZXI7XG4gICAgY29uc3QgdGltZU9wdHMgPSB0aGlzLm9wdGlvbnMudGltZTtcblxuICAgIGlmICh0aW1lT3B0cy50b29sdGlwRm9ybWF0KSB7XG4gICAgICByZXR1cm4gYWRhcHRlci5mb3JtYXQodmFsdWUsIHRpbWVPcHRzLnRvb2x0aXBGb3JtYXQpO1xuICAgIH1cbiAgICByZXR1cm4gYWRhcHRlci5mb3JtYXQodmFsdWUsIHRpbWVPcHRzLmRpc3BsYXlGb3JtYXRzLmRhdGV0aW1lKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcGFyYW0ge251bWJlcn0gdmFsdWVcblx0ICogQHBhcmFtIHtzdHJpbmd8dW5kZWZpbmVkfSBmb3JtYXRcblx0ICogQHJldHVybiB7c3RyaW5nfVxuXHQgKi9cbiAgZm9ybWF0KHZhbHVlLCBmb3JtYXQpIHtcbiAgICBjb25zdCBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgIGNvbnN0IGZvcm1hdHMgPSBvcHRpb25zLnRpbWUuZGlzcGxheUZvcm1hdHM7XG4gICAgY29uc3QgdW5pdCA9IHRoaXMuX3VuaXQ7XG4gICAgY29uc3QgZm10ID0gZm9ybWF0IHx8IGZvcm1hdHNbdW5pdF07XG4gICAgcmV0dXJuIHRoaXMuX2FkYXB0ZXIuZm9ybWF0KHZhbHVlLCBmbXQpO1xuICB9XG5cbiAgLyoqXG5cdCAqIEZ1bmN0aW9uIHRvIGZvcm1hdCBhbiBpbmRpdmlkdWFsIHRpY2sgbWFya1xuXHQgKiBAcGFyYW0ge251bWJlcn0gdGltZVxuXHQgKiBAcGFyYW0ge251bWJlcn0gaW5kZXhcblx0ICogQHBhcmFtIHtvYmplY3RbXX0gdGlja3Ncblx0ICogQHBhcmFtIHtzdHJpbmd8dW5kZWZpbmVkfSBbZm9ybWF0XVxuXHQgKiBAcmV0dXJuIHtzdHJpbmd9XG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfdGlja0Zvcm1hdEZ1bmN0aW9uKHRpbWUsIGluZGV4LCB0aWNrcywgZm9ybWF0KSB7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICBjb25zdCBmb3JtYXR0ZXIgPSBvcHRpb25zLnRpY2tzLmNhbGxiYWNrO1xuXG4gICAgaWYgKGZvcm1hdHRlcikge1xuICAgICAgcmV0dXJuIGNhbGwoZm9ybWF0dGVyLCBbdGltZSwgaW5kZXgsIHRpY2tzXSwgdGhpcyk7XG4gICAgfVxuXG4gICAgY29uc3QgZm9ybWF0cyA9IG9wdGlvbnMudGltZS5kaXNwbGF5Rm9ybWF0cztcbiAgICBjb25zdCB1bml0ID0gdGhpcy5fdW5pdDtcbiAgICBjb25zdCBtYWpvclVuaXQgPSB0aGlzLl9tYWpvclVuaXQ7XG4gICAgY29uc3QgbWlub3JGb3JtYXQgPSB1bml0ICYmIGZvcm1hdHNbdW5pdF07XG4gICAgY29uc3QgbWFqb3JGb3JtYXQgPSBtYWpvclVuaXQgJiYgZm9ybWF0c1ttYWpvclVuaXRdO1xuICAgIGNvbnN0IHRpY2sgPSB0aWNrc1tpbmRleF07XG4gICAgY29uc3QgbWFqb3IgPSBtYWpvclVuaXQgJiYgbWFqb3JGb3JtYXQgJiYgdGljayAmJiB0aWNrLm1ham9yO1xuXG4gICAgcmV0dXJuIHRoaXMuX2FkYXB0ZXIuZm9ybWF0KHRpbWUsIGZvcm1hdCB8fCAobWFqb3IgPyBtYWpvckZvcm1hdCA6IG1pbm9yRm9ybWF0KSk7XG4gIH1cblxuICAvKipcblx0ICogQHBhcmFtIHtvYmplY3RbXX0gdGlja3Ncblx0ICovXG4gIGdlbmVyYXRlVGlja0xhYmVscyh0aWNrcykge1xuICAgIGxldCBpLCBpbGVuLCB0aWNrO1xuXG4gICAgZm9yIChpID0gMCwgaWxlbiA9IHRpY2tzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgICAgdGljayA9IHRpY2tzW2ldO1xuICAgICAgdGljay5sYWJlbCA9IHRoaXMuX3RpY2tGb3JtYXRGdW5jdGlvbih0aWNrLnZhbHVlLCBpLCB0aWNrcyk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSAtIE1pbGxpc2Vjb25kcyBzaW5jZSBlcG9jaCAoMSBKYW51YXJ5IDE5NzAgMDA6MDA6MDAgVVRDKVxuXHQgKiBAcmV0dXJuIHtudW1iZXJ9XG5cdCAqL1xuICBnZXREZWNpbWFsRm9yVmFsdWUodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgPT09IG51bGwgPyBOYU4gOiAodmFsdWUgLSB0aGlzLm1pbikgLyAodGhpcy5tYXggLSB0aGlzLm1pbik7XG4gIH1cblxuICAvKipcblx0ICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIC0gTWlsbGlzZWNvbmRzIHNpbmNlIGVwb2NoICgxIEphbnVhcnkgMTk3MCAwMDowMDowMCBVVEMpXG5cdCAqIEByZXR1cm4ge251bWJlcn1cblx0ICovXG4gIGdldFBpeGVsRm9yVmFsdWUodmFsdWUpIHtcbiAgICBjb25zdCBvZmZzZXRzID0gdGhpcy5fb2Zmc2V0cztcbiAgICBjb25zdCBwb3MgPSB0aGlzLmdldERlY2ltYWxGb3JWYWx1ZSh2YWx1ZSk7XG4gICAgcmV0dXJuIHRoaXMuZ2V0UGl4ZWxGb3JEZWNpbWFsKChvZmZzZXRzLnN0YXJ0ICsgcG9zKSAqIG9mZnNldHMuZmFjdG9yKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcGFyYW0ge251bWJlcn0gcGl4ZWxcblx0ICogQHJldHVybiB7bnVtYmVyfVxuXHQgKi9cbiAgZ2V0VmFsdWVGb3JQaXhlbChwaXhlbCkge1xuICAgIGNvbnN0IG9mZnNldHMgPSB0aGlzLl9vZmZzZXRzO1xuICAgIGNvbnN0IHBvcyA9IHRoaXMuZ2V0RGVjaW1hbEZvclBpeGVsKHBpeGVsKSAvIG9mZnNldHMuZmFjdG9yIC0gb2Zmc2V0cy5lbmQ7XG4gICAgcmV0dXJuIHRoaXMubWluICsgcG9zICogKHRoaXMubWF4IC0gdGhpcy5taW4pO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBsYWJlbFxuXHQgKiBAcmV0dXJuIHt7dzpudW1iZXIsIGg6bnVtYmVyfX1cblx0ICogQHByaXZhdGVcblx0ICovXG4gIF9nZXRMYWJlbFNpemUobGFiZWwpIHtcbiAgICBjb25zdCB0aWNrc09wdHMgPSB0aGlzLm9wdGlvbnMudGlja3M7XG4gICAgY29uc3QgdGlja0xhYmVsV2lkdGggPSB0aGlzLmN0eC5tZWFzdXJlVGV4dChsYWJlbCkud2lkdGg7XG4gICAgY29uc3QgYW5nbGUgPSB0b1JhZGlhbnModGhpcy5pc0hvcml6b250YWwoKSA/IHRpY2tzT3B0cy5tYXhSb3RhdGlvbiA6IHRpY2tzT3B0cy5taW5Sb3RhdGlvbik7XG4gICAgY29uc3QgY29zUm90YXRpb24gPSBNYXRoLmNvcyhhbmdsZSk7XG4gICAgY29uc3Qgc2luUm90YXRpb24gPSBNYXRoLnNpbihhbmdsZSk7XG4gICAgY29uc3QgdGlja0ZvbnRTaXplID0gdGhpcy5fcmVzb2x2ZVRpY2tGb250T3B0aW9ucygwKS5zaXplO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIHc6ICh0aWNrTGFiZWxXaWR0aCAqIGNvc1JvdGF0aW9uKSArICh0aWNrRm9udFNpemUgKiBzaW5Sb3RhdGlvbiksXG4gICAgICBoOiAodGlja0xhYmVsV2lkdGggKiBzaW5Sb3RhdGlvbikgKyAodGlja0ZvbnRTaXplICogY29zUm90YXRpb24pXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcGFyYW0ge251bWJlcn0gZXhhbXBsZVRpbWVcblx0ICogQHJldHVybiB7bnVtYmVyfVxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgX2dldExhYmVsQ2FwYWNpdHkoZXhhbXBsZVRpbWUpIHtcbiAgICBjb25zdCB0aW1lT3B0cyA9IHRoaXMub3B0aW9ucy50aW1lO1xuICAgIGNvbnN0IGRpc3BsYXlGb3JtYXRzID0gdGltZU9wdHMuZGlzcGxheUZvcm1hdHM7XG5cbiAgICAvLyBwaWNrIHRoZSBsb25nZXN0IGZvcm1hdCAobWlsbGlzZWNvbmRzKSBmb3IgZ3Vlc3N0aW1hdGlvblxuICAgIGNvbnN0IGZvcm1hdCA9IGRpc3BsYXlGb3JtYXRzW3RpbWVPcHRzLnVuaXRdIHx8IGRpc3BsYXlGb3JtYXRzLm1pbGxpc2Vjb25kO1xuICAgIGNvbnN0IGV4YW1wbGVMYWJlbCA9IHRoaXMuX3RpY2tGb3JtYXRGdW5jdGlvbihleGFtcGxlVGltZSwgMCwgdGlja3NGcm9tVGltZXN0YW1wcyh0aGlzLCBbZXhhbXBsZVRpbWVdLCB0aGlzLl9tYWpvclVuaXQpLCBmb3JtYXQpO1xuICAgIGNvbnN0IHNpemUgPSB0aGlzLl9nZXRMYWJlbFNpemUoZXhhbXBsZUxhYmVsKTtcbiAgICAvLyBzdWJ0cmFjdCAxIC0gaWYgb2Zmc2V0IHRoZW4gdGhlcmUncyBvbmUgbGVzcyBsYWJlbCB0aGFuIHRpY2tcbiAgICAvLyBpZiBub3Qgb2Zmc2V0IHRoZW4gb25lIGhhbGYgbGFiZWwgcGFkZGluZyBpcyBhZGRlZCB0byBlYWNoIGVuZCBsZWF2aW5nIHJvb20gZm9yIG9uZSBsZXNzIGxhYmVsXG4gICAgY29uc3QgY2FwYWNpdHkgPSBNYXRoLmZsb29yKHRoaXMuaXNIb3Jpem9udGFsKCkgPyB0aGlzLndpZHRoIC8gc2l6ZS53IDogdGhpcy5oZWlnaHQgLyBzaXplLmgpIC0gMTtcbiAgICByZXR1cm4gY2FwYWNpdHkgPiAwID8gY2FwYWNpdHkgOiAxO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG4gIGdldERhdGFUaW1lc3RhbXBzKCkge1xuICAgIGxldCB0aW1lc3RhbXBzID0gdGhpcy5fY2FjaGUuZGF0YSB8fCBbXTtcbiAgICBsZXQgaSwgaWxlbjtcblxuICAgIGlmICh0aW1lc3RhbXBzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIHRpbWVzdGFtcHM7XG4gICAgfVxuXG4gICAgY29uc3QgbWV0YXMgPSB0aGlzLmdldE1hdGNoaW5nVmlzaWJsZU1ldGFzKCk7XG5cbiAgICBpZiAodGhpcy5fbm9ybWFsaXplZCAmJiBtZXRhcy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiAodGhpcy5fY2FjaGUuZGF0YSA9IG1ldGFzWzBdLmNvbnRyb2xsZXIuZ2V0QWxsUGFyc2VkVmFsdWVzKHRoaXMpKTtcbiAgICB9XG5cbiAgICBmb3IgKGkgPSAwLCBpbGVuID0gbWV0YXMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgICB0aW1lc3RhbXBzID0gdGltZXN0YW1wcy5jb25jYXQobWV0YXNbaV0uY29udHJvbGxlci5nZXRBbGxQYXJzZWRWYWx1ZXModGhpcykpO1xuICAgIH1cblxuICAgIHJldHVybiAodGhpcy5fY2FjaGUuZGF0YSA9IHRoaXMubm9ybWFsaXplKHRpbWVzdGFtcHMpKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuICBnZXRMYWJlbFRpbWVzdGFtcHMoKSB7XG4gICAgY29uc3QgdGltZXN0YW1wcyA9IHRoaXMuX2NhY2hlLmxhYmVscyB8fCBbXTtcbiAgICBsZXQgaSwgaWxlbjtcblxuICAgIGlmICh0aW1lc3RhbXBzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIHRpbWVzdGFtcHM7XG4gICAgfVxuXG4gICAgY29uc3QgbGFiZWxzID0gdGhpcy5nZXRMYWJlbHMoKTtcbiAgICBmb3IgKGkgPSAwLCBpbGVuID0gbGFiZWxzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgICAgdGltZXN0YW1wcy5wdXNoKHBhcnNlKHRoaXMsIGxhYmVsc1tpXSkpO1xuICAgIH1cblxuICAgIHJldHVybiAodGhpcy5fY2FjaGUubGFiZWxzID0gdGhpcy5fbm9ybWFsaXplZCA/IHRpbWVzdGFtcHMgOiB0aGlzLm5vcm1hbGl6ZSh0aW1lc3RhbXBzKSk7XG4gIH1cblxuICAvKipcblx0ICogQHBhcmFtIHtudW1iZXJbXX0gdmFsdWVzXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG4gIG5vcm1hbGl6ZSh2YWx1ZXMpIHtcbiAgICAvLyBJdCBzZWVtcyB0byBiZSBzb21ld2hhdCBmYXN0ZXIgdG8gZG8gc29ydGluZyBmaXJzdFxuICAgIHJldHVybiBfYXJyYXlVbmlxdWUodmFsdWVzLnNvcnQoc29ydGVyKSk7XG4gIH1cbn1cbiIsICJpbXBvcnQgVGltZVNjYWxlIGZyb20gJy4vc2NhbGUudGltZS5qcyc7XG5pbXBvcnQge19sb29rdXBCeUtleX0gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLmNvbGxlY3Rpb24uanMnO1xuXG4vKipcbiAqIExpbmVhcmx5IGludGVycG9sYXRlcyB0aGUgZ2l2ZW4gc291cmNlIGB2YWxgIHVzaW5nIHRoZSB0YWJsZS4gSWYgdmFsdWUgaXMgb3V0IG9mIGJvdW5kcywgdmFsdWVzXG4gKiBhdCBlZGdlcyBhcmUgdXNlZCBmb3IgdGhlIGludGVycG9sYXRpb24uXG4gKiBAcGFyYW0ge29iamVjdH0gdGFibGVcbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWxcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW3JldmVyc2VdIGxvb2t1cCB0aW1lIGJhc2VkIG9uIHBvc2l0aW9uIGluc3RlYWQgb2YgdmljZSB2ZXJzYVxuICogQHJldHVybiB7b2JqZWN0fVxuICovXG5mdW5jdGlvbiBpbnRlcnBvbGF0ZSh0YWJsZSwgdmFsLCByZXZlcnNlKSB7XG4gIGxldCBsbyA9IDA7XG4gIGxldCBoaSA9IHRhYmxlLmxlbmd0aCAtIDE7XG4gIGxldCBwcmV2U291cmNlLCBuZXh0U291cmNlLCBwcmV2VGFyZ2V0LCBuZXh0VGFyZ2V0O1xuICBpZiAocmV2ZXJzZSkge1xuICAgIGlmICh2YWwgPj0gdGFibGVbbG9dLnBvcyAmJiB2YWwgPD0gdGFibGVbaGldLnBvcykge1xuICAgICAgKHtsbywgaGl9ID0gX2xvb2t1cEJ5S2V5KHRhYmxlLCAncG9zJywgdmFsKSk7XG4gICAgfVxuICAgICh7cG9zOiBwcmV2U291cmNlLCB0aW1lOiBwcmV2VGFyZ2V0fSA9IHRhYmxlW2xvXSk7XG4gICAgKHtwb3M6IG5leHRTb3VyY2UsIHRpbWU6IG5leHRUYXJnZXR9ID0gdGFibGVbaGldKTtcbiAgfSBlbHNlIHtcbiAgICBpZiAodmFsID49IHRhYmxlW2xvXS50aW1lICYmIHZhbCA8PSB0YWJsZVtoaV0udGltZSkge1xuICAgICAgKHtsbywgaGl9ID0gX2xvb2t1cEJ5S2V5KHRhYmxlLCAndGltZScsIHZhbCkpO1xuICAgIH1cbiAgICAoe3RpbWU6IHByZXZTb3VyY2UsIHBvczogcHJldlRhcmdldH0gPSB0YWJsZVtsb10pO1xuICAgICh7dGltZTogbmV4dFNvdXJjZSwgcG9zOiBuZXh0VGFyZ2V0fSA9IHRhYmxlW2hpXSk7XG4gIH1cblxuICBjb25zdCBzcGFuID0gbmV4dFNvdXJjZSAtIHByZXZTb3VyY2U7XG4gIHJldHVybiBzcGFuID8gcHJldlRhcmdldCArIChuZXh0VGFyZ2V0IC0gcHJldlRhcmdldCkgKiAodmFsIC0gcHJldlNvdXJjZSkgLyBzcGFuIDogcHJldlRhcmdldDtcbn1cblxuY2xhc3MgVGltZVNlcmllc1NjYWxlIGV4dGVuZHMgVGltZVNjYWxlIHtcblxuICBzdGF0aWMgaWQgPSAndGltZXNlcmllcyc7XG5cbiAgLyoqXG4gICAqIEB0eXBlIHthbnl9XG4gICAqL1xuICBzdGF0aWMgZGVmYXVsdHMgPSBUaW1lU2NhbGUuZGVmYXVsdHM7XG5cbiAgLyoqXG5cdCAqIEBwYXJhbSB7b2JqZWN0fSBwcm9wc1xuXHQgKi9cbiAgY29uc3RydWN0b3IocHJvcHMpIHtcbiAgICBzdXBlcihwcm9wcyk7XG5cbiAgICAvKiogQHR5cGUge29iamVjdFtdfSAqL1xuICAgIHRoaXMuX3RhYmxlID0gW107XG4gICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgdGhpcy5fbWluUG9zID0gdW5kZWZpbmVkO1xuICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgIHRoaXMuX3RhYmxlUmFuZ2UgPSB1bmRlZmluZWQ7XG4gIH1cblxuICAvKipcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cbiAgaW5pdE9mZnNldHMoKSB7XG4gICAgY29uc3QgdGltZXN0YW1wcyA9IHRoaXMuX2dldFRpbWVzdGFtcHNGb3JUYWJsZSgpO1xuICAgIGNvbnN0IHRhYmxlID0gdGhpcy5fdGFibGUgPSB0aGlzLmJ1aWxkTG9va3VwVGFibGUodGltZXN0YW1wcyk7XG4gICAgdGhpcy5fbWluUG9zID0gaW50ZXJwb2xhdGUodGFibGUsIHRoaXMubWluKTtcbiAgICB0aGlzLl90YWJsZVJhbmdlID0gaW50ZXJwb2xhdGUodGFibGUsIHRoaXMubWF4KSAtIHRoaXMuX21pblBvcztcbiAgICBzdXBlci5pbml0T2Zmc2V0cyh0aW1lc3RhbXBzKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBSZXR1cm5zIGFuIGFycmF5IG9mIHt0aW1lLCBwb3N9IG9iamVjdHMgdXNlZCB0byBpbnRlcnBvbGF0ZSBhIHNwZWNpZmljIGB0aW1lYCBvciBwb3NpdGlvblxuXHQgKiAoYHBvc2ApIG9uIHRoZSBzY2FsZSwgYnkgc2VhcmNoaW5nIGVudHJpZXMgYmVmb3JlIGFuZCBhZnRlciB0aGUgcmVxdWVzdGVkIHZhbHVlLiBgcG9zYCBpc1xuXHQgKiBhIGRlY2ltYWwgYmV0d2VlbiAwIGFuZCAxOiAwIGJlaW5nIHRoZSBzdGFydCBvZiB0aGUgc2NhbGUgKGxlZnQgb3IgdG9wKSBhbmQgMSB0aGUgb3RoZXJcblx0ICogZXh0cmVtaXR5IChsZWZ0ICsgd2lkdGggb3IgdG9wICsgaGVpZ2h0KS4gTm90ZSB0aGF0IGl0IHdvdWxkIGJlIG1vcmUgb3B0aW1pemVkIHRvIGRpcmVjdGx5XG5cdCAqIHN0b3JlIHByZS1jb21wdXRlZCBwaXhlbHMsIGJ1dCB0aGUgc2NhbGUgZGltZW5zaW9ucyBhcmUgbm90IGd1YXJhbnRlZWQgYXQgdGhlIHRpbWUgd2UgbmVlZFxuXHQgKiB0byBjcmVhdGUgdGhlIGxvb2t1cCB0YWJsZS4gVGhlIHRhYmxlIEFMV0FZUyBjb250YWlucyBhdCBsZWFzdCB0d28gaXRlbXM6IG1pbiBhbmQgbWF4LlxuXHQgKiBAcGFyYW0ge251bWJlcltdfSB0aW1lc3RhbXBzXG5cdCAqIEByZXR1cm4ge29iamVjdFtdfVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuICBidWlsZExvb2t1cFRhYmxlKHRpbWVzdGFtcHMpIHtcbiAgICBjb25zdCB7bWluLCBtYXh9ID0gdGhpcztcbiAgICBjb25zdCBpdGVtcyA9IFtdO1xuICAgIGNvbnN0IHRhYmxlID0gW107XG4gICAgbGV0IGksIGlsZW4sIHByZXYsIGN1cnIsIG5leHQ7XG5cbiAgICBmb3IgKGkgPSAwLCBpbGVuID0gdGltZXN0YW1wcy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICAgIGN1cnIgPSB0aW1lc3RhbXBzW2ldO1xuICAgICAgaWYgKGN1cnIgPj0gbWluICYmIGN1cnIgPD0gbWF4KSB7XG4gICAgICAgIGl0ZW1zLnB1c2goY3Vycik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGl0ZW1zLmxlbmd0aCA8IDIpIHtcbiAgICAgIC8vIEluIGNhc2UgdGhlcmUgaXMgbGVzcyB0aGF0IDIgdGltZXN0YW1wcyBiZXR3ZWVuIG1pbiBhbmQgbWF4LCB0aGUgc2NhbGUgaXMgZGVmaW5lZCBieSBtaW4gYW5kIG1heFxuICAgICAgcmV0dXJuIFtcbiAgICAgICAge3RpbWU6IG1pbiwgcG9zOiAwfSxcbiAgICAgICAge3RpbWU6IG1heCwgcG9zOiAxfVxuICAgICAgXTtcbiAgICB9XG5cbiAgICBmb3IgKGkgPSAwLCBpbGVuID0gaXRlbXMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgICBuZXh0ID0gaXRlbXNbaSArIDFdO1xuICAgICAgcHJldiA9IGl0ZW1zW2kgLSAxXTtcbiAgICAgIGN1cnIgPSBpdGVtc1tpXTtcblxuICAgICAgLy8gb25seSBhZGQgcG9pbnRzIHRoYXQgYnJlYWtzIHRoZSBzY2FsZSBsaW5lYXJpdHlcbiAgICAgIGlmIChNYXRoLnJvdW5kKChuZXh0ICsgcHJldikgLyAyKSAhPT0gY3Vycikge1xuICAgICAgICB0YWJsZS5wdXNoKHt0aW1lOiBjdXJyLCBwb3M6IGkgLyAoaWxlbiAtIDEpfSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0YWJsZTtcbiAgfVxuXG4gIC8qKlxuICAgICogR2VuZXJhdGVzIGFsbCB0aW1lc3RhbXBzIGRlZmluZWQgaW4gdGhlIGRhdGEuXG4gICAgKiBJbXBvcnRhbnQ6IHRoaXMgbWV0aG9kIGNhbiByZXR1cm4gdGlja3Mgb3V0c2lkZSB0aGUgbWluIGFuZCBtYXggcmFuZ2UsIGl0J3MgdGhlXG4gICAgKiByZXNwb25zaWJpbGl0eSBvZiB0aGUgY2FsbGluZyBjb2RlIHRvIGNsYW1wIHZhbHVlcyBpZiBuZWVkZWQuXG4gICAgKiBAcHJvdGVjdGVkXG4gICAgKi9cbiAgX2dlbmVyYXRlKCkge1xuICAgIGNvbnN0IG1pbiA9IHRoaXMubWluO1xuICAgIGNvbnN0IG1heCA9IHRoaXMubWF4O1xuICAgIGxldCB0aW1lc3RhbXBzID0gc3VwZXIuZ2V0RGF0YVRpbWVzdGFtcHMoKTtcbiAgICBpZiAoIXRpbWVzdGFtcHMuaW5jbHVkZXMobWluKSB8fCAhdGltZXN0YW1wcy5sZW5ndGgpIHtcbiAgICAgIHRpbWVzdGFtcHMuc3BsaWNlKDAsIDAsIG1pbik7XG4gICAgfVxuICAgIGlmICghdGltZXN0YW1wcy5pbmNsdWRlcyhtYXgpIHx8IHRpbWVzdGFtcHMubGVuZ3RoID09PSAxKSB7XG4gICAgICB0aW1lc3RhbXBzLnB1c2gobWF4KTtcbiAgICB9XG4gICAgcmV0dXJuIHRpbWVzdGFtcHMuc29ydCgoYSwgYikgPT4gYSAtIGIpO1xuICB9XG5cbiAgLyoqXG5cdCAqIFJldHVybnMgYWxsIHRpbWVzdGFtcHNcblx0ICogQHJldHVybiB7bnVtYmVyW119XG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfZ2V0VGltZXN0YW1wc0ZvclRhYmxlKCkge1xuICAgIGxldCB0aW1lc3RhbXBzID0gdGhpcy5fY2FjaGUuYWxsIHx8IFtdO1xuXG4gICAgaWYgKHRpbWVzdGFtcHMubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gdGltZXN0YW1wcztcbiAgICB9XG5cbiAgICBjb25zdCBkYXRhID0gdGhpcy5nZXREYXRhVGltZXN0YW1wcygpO1xuICAgIGNvbnN0IGxhYmVsID0gdGhpcy5nZXRMYWJlbFRpbWVzdGFtcHMoKTtcbiAgICBpZiAoZGF0YS5sZW5ndGggJiYgbGFiZWwubGVuZ3RoKSB7XG4gICAgICAvLyBJZiBjb21iaW5pbmcgbGFiZWxzIGFuZCBkYXRhIChkYXRhIG1pZ2h0IG5vdCBjb250YWluIGFsbCBsYWJlbHMpLFxuICAgICAgLy8gd2UgbmVlZCB0byByZWNoZWNrIHVuaXF1ZW5lc3MgYW5kIHNvcnRcbiAgICAgIHRpbWVzdGFtcHMgPSB0aGlzLm5vcm1hbGl6ZShkYXRhLmNvbmNhdChsYWJlbCkpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aW1lc3RhbXBzID0gZGF0YS5sZW5ndGggPyBkYXRhIDogbGFiZWw7XG4gICAgfVxuICAgIHRpbWVzdGFtcHMgPSB0aGlzLl9jYWNoZS5hbGwgPSB0aW1lc3RhbXBzO1xuXG4gICAgcmV0dXJuIHRpbWVzdGFtcHM7XG4gIH1cblxuICAvKipcblx0ICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIC0gTWlsbGlzZWNvbmRzIHNpbmNlIGVwb2NoICgxIEphbnVhcnkgMTk3MCAwMDowMDowMCBVVEMpXG5cdCAqIEByZXR1cm4ge251bWJlcn1cblx0ICovXG4gIGdldERlY2ltYWxGb3JWYWx1ZSh2YWx1ZSkge1xuICAgIHJldHVybiAoaW50ZXJwb2xhdGUodGhpcy5fdGFibGUsIHZhbHVlKSAtIHRoaXMuX21pblBvcykgLyB0aGlzLl90YWJsZVJhbmdlO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBwaXhlbFxuXHQgKiBAcmV0dXJuIHtudW1iZXJ9XG5cdCAqL1xuICBnZXRWYWx1ZUZvclBpeGVsKHBpeGVsKSB7XG4gICAgY29uc3Qgb2Zmc2V0cyA9IHRoaXMuX29mZnNldHM7XG4gICAgY29uc3QgZGVjaW1hbCA9IHRoaXMuZ2V0RGVjaW1hbEZvclBpeGVsKHBpeGVsKSAvIG9mZnNldHMuZmFjdG9yIC0gb2Zmc2V0cy5lbmQ7XG4gICAgcmV0dXJuIGludGVycG9sYXRlKHRoaXMuX3RhYmxlLCBkZWNpbWFsICogdGhpcy5fdGFibGVSYW5nZSArIHRoaXMuX21pblBvcywgdHJ1ZSk7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgVGltZVNlcmllc1NjYWxlO1xuIiwgImV4cG9ydCAqIGZyb20gJy4vY29udHJvbGxlcnMvaW5kZXguanMnO1xuZXhwb3J0ICogZnJvbSAnLi9jb3JlL2luZGV4LmpzJztcbmV4cG9ydCAqIGZyb20gJy4vZWxlbWVudHMvaW5kZXguanMnO1xuZXhwb3J0ICogZnJvbSAnLi9wbGF0Zm9ybS9pbmRleC5qcyc7XG5leHBvcnQgKiBmcm9tICcuL3BsdWdpbnMvaW5kZXguanMnO1xuZXhwb3J0ICogZnJvbSAnLi9zY2FsZXMvaW5kZXguanMnO1xuXG5pbXBvcnQgKiBhcyBjb250cm9sbGVycyBmcm9tICcuL2NvbnRyb2xsZXJzL2luZGV4LmpzJztcbmltcG9ydCAqIGFzIGVsZW1lbnRzIGZyb20gJy4vZWxlbWVudHMvaW5kZXguanMnO1xuaW1wb3J0ICogYXMgcGx1Z2lucyBmcm9tICcuL3BsdWdpbnMvaW5kZXguanMnO1xuaW1wb3J0ICogYXMgc2NhbGVzIGZyb20gJy4vc2NhbGVzL2luZGV4LmpzJztcblxuZXhwb3J0IHtcbiAgY29udHJvbGxlcnMsXG4gIGVsZW1lbnRzLFxuICBwbHVnaW5zLFxuICBzY2FsZXMsXG59O1xuXG5leHBvcnQgY29uc3QgcmVnaXN0ZXJhYmxlcyA9IFtcbiAgY29udHJvbGxlcnMsXG4gIGVsZW1lbnRzLFxuICBwbHVnaW5zLFxuICBzY2FsZXMsXG5dO1xuIiwgIi8qIVxuKiBjaGFydGpzLXBsdWdpbi16b29tIHYyLjAuMVxuKiB1bmRlZmluZWRcbiAqIChjKSAyMDE2LTIwMjMgY2hhcnRqcy1wbHVnaW4tem9vbSBDb250cmlidXRvcnNcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZVxuICovXG5pbXBvcnQgSGFtbWVyIGZyb20gJ2hhbW1lcmpzJztcbmltcG9ydCB7IGVhY2gsIHZhbHVlT3JEZWZhdWx0LCBjYWxsYmFjaywgc2lnbiwgZ2V0UmVsYXRpdmVQb3NpdGlvbiB9IGZyb20gJ2NoYXJ0LmpzL2hlbHBlcnMnO1xuXG5jb25zdCBnZXRNb2RpZmllcktleSA9IG9wdHMgPT4gb3B0cyAmJiBvcHRzLmVuYWJsZWQgJiYgb3B0cy5tb2RpZmllcktleTtcbmNvbnN0IGtleVByZXNzZWQgPSAoa2V5LCBldmVudCkgPT4ga2V5ICYmIGV2ZW50W2tleSArICdLZXknXTtcbmNvbnN0IGtleU5vdFByZXNzZWQgPSAoa2V5LCBldmVudCkgPT4ga2V5ICYmICFldmVudFtrZXkgKyAnS2V5J107XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd8ZnVuY3Rpb259IG1vZGUgY2FuIGJlICd4JywgJ3knIG9yICd4eSdcbiAqIEBwYXJhbSB7c3RyaW5nfSBkaXIgY2FuIGJlICd4JyBvciAneSdcbiAqIEBwYXJhbSB7aW1wb3J0KCdjaGFydC5qcycpLkNoYXJ0fSBjaGFydCBpbnN0YW5jZSBvZiB0aGUgY2hhcnQgaW4gcXVlc3Rpb25cbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBkaXJlY3Rpb25FbmFibGVkKG1vZGUsIGRpciwgY2hhcnQpIHtcbiAgaWYgKG1vZGUgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBtb2RlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBtb2RlLmluZGV4T2YoZGlyKSAhPT0gLTE7XG4gIH0gZWxzZSBpZiAodHlwZW9mIG1vZGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gbW9kZSh7Y2hhcnR9KS5pbmRleE9mKGRpcikgIT09IC0xO1xuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBkaXJlY3Rpb25zRW5hYmxlZChtb2RlLCBjaGFydCkge1xuICBpZiAodHlwZW9mIG1vZGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICBtb2RlID0gbW9kZSh7Y2hhcnR9KTtcbiAgfVxuICBpZiAodHlwZW9mIG1vZGUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHt4OiBtb2RlLmluZGV4T2YoJ3gnKSAhPT0gLTEsIHk6IG1vZGUuaW5kZXhPZigneScpICE9PSAtMX07XG4gIH1cblxuICByZXR1cm4ge3g6IGZhbHNlLCB5OiBmYWxzZX07XG59XG5cbi8qKlxuICogRGVib3VuY2VzIGNhbGxpbmcgYGZuYCBmb3IgYGRlbGF5YCBtc1xuICogQHBhcmFtIHtmdW5jdGlvbn0gZm4gLSBGdW5jdGlvbiB0byBjYWxsLiBObyBhcmd1bWVudHMgYXJlIHBhc3NlZC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBkZWxheSAtIERlbGF5IGluIG1zLiAwID0gaW1tZWRpYXRlIGludm9jYXRpb24uXG4gKiBAcmV0dXJucyB7ZnVuY3Rpb259XG4gKi9cbmZ1bmN0aW9uIGRlYm91bmNlKGZuLCBkZWxheSkge1xuICBsZXQgdGltZW91dDtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICB0aW1lb3V0ID0gc2V0VGltZW91dChmbiwgZGVsYXkpO1xuICAgIHJldHVybiBkZWxheTtcbiAgfTtcbn1cblxuLyoqXG4gKiBDaGVja3Mgd2hpY2ggYXhpcyBpcyB1bmRlciB0aGUgbW91c2UgY3Vyc29yLlxuICogQHBhcmFtIHt7eDogbnVtYmVyLCB5OiBudW1iZXJ9fSBwb2ludCAtIHRoZSBtb3VzZSBsb2NhdGlvblxuICogQHBhcmFtIHtpbXBvcnQoJ2NoYXJ0LmpzJykuQ2hhcnR9IFtjaGFydF0gaW5zdGFuY2Ugb2YgdGhlIGNoYXJ0IGluIHF1ZXN0aW9uXG4gKiBAcmV0dXJuIHtpbXBvcnQoJ2NoYXJ0LmpzJykuU2NhbGV9XG4gKi9cbmZ1bmN0aW9uIGdldFNjYWxlVW5kZXJQb2ludCh7eCwgeX0sIGNoYXJ0KSB7XG4gIGNvbnN0IHNjYWxlcyA9IGNoYXJ0LnNjYWxlcztcbiAgY29uc3Qgc2NhbGVJZHMgPSBPYmplY3Qua2V5cyhzY2FsZXMpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHNjYWxlSWRzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3Qgc2NhbGUgPSBzY2FsZXNbc2NhbGVJZHNbaV1dO1xuICAgIGlmICh5ID49IHNjYWxlLnRvcCAmJiB5IDw9IHNjYWxlLmJvdHRvbSAmJiB4ID49IHNjYWxlLmxlZnQgJiYgeCA8PSBzY2FsZS5yaWdodCkge1xuICAgICAgcmV0dXJuIHNjYWxlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cblxuLyoqXG4gKiBFdmFsdWF0ZSB0aGUgY2hhcnQncyBtb2RlLCBzY2FsZU1vZGUsIGFuZCBvdmVyU2NhbGVNb2RlIHByb3BlcnRpZXMgdG9cbiAqIGRldGVybWluZSB3aGljaCBheGVzIGFyZSBlbGlnaWJsZSBmb3Igc2NhbGluZy5cbiAqIG9wdGlvbnMub3ZlclNjYWxlTW9kZSBjYW4gYmUgYSBmdW5jdGlvbiBpZiB1c2VyIHdhbnQgem9vbSBvbmx5IG9uZSBzY2FsZSBvZiBtYW55IGZvciBleGFtcGxlLlxuICogQHBhcmFtIG9wdGlvbnMgLSBab29tIG9yIHBhbiBvcHRpb25zXG4gKiBAcGFyYW0ge3t4OiBudW1iZXIsIHk6IG51bWJlcn19IHBvaW50IC0gdGhlIG1vdXNlIGxvY2F0aW9uXG4gKiBAcGFyYW0ge2ltcG9ydCgnY2hhcnQuanMnKS5DaGFydH0gW2NoYXJ0XSBpbnN0YW5jZSBvZiB0aGUgY2hhcnQgaW4gcXVlc3Rpb25cbiAqIEByZXR1cm4ge2ltcG9ydCgnY2hhcnQuanMnKS5TY2FsZVtdfVxuICovXG5mdW5jdGlvbiBnZXRFbmFibGVkU2NhbGVzQnlQb2ludChvcHRpb25zLCBwb2ludCwgY2hhcnQpIHtcbiAgY29uc3Qge21vZGUgPSAneHknLCBzY2FsZU1vZGUsIG92ZXJTY2FsZU1vZGV9ID0gb3B0aW9ucyB8fCB7fTtcbiAgY29uc3Qgc2NhbGUgPSBnZXRTY2FsZVVuZGVyUG9pbnQocG9pbnQsIGNoYXJ0KTtcblxuICBjb25zdCBlbmFibGVkID0gZGlyZWN0aW9uc0VuYWJsZWQobW9kZSwgY2hhcnQpO1xuICBjb25zdCBzY2FsZUVuYWJsZWQgPSBkaXJlY3Rpb25zRW5hYmxlZChzY2FsZU1vZGUsIGNoYXJ0KTtcblxuICAvLyBDb252ZXJ0IGRlcHJlY2F0ZWQgb3ZlclNjYWxlRW5hYmxlZCB0byBuZXcgc2NhbGVFbmFibGVkLlxuICBpZiAob3ZlclNjYWxlTW9kZSkge1xuICAgIGNvbnN0IG92ZXJTY2FsZUVuYWJsZWQgPSBkaXJlY3Rpb25zRW5hYmxlZChvdmVyU2NhbGVNb2RlLCBjaGFydCk7XG4gICAgZm9yIChjb25zdCBheGlzIG9mIFsneCcsICd5J10pIHtcbiAgICAgIGlmIChvdmVyU2NhbGVFbmFibGVkW2F4aXNdKSB7XG4gICAgICAgIHNjYWxlRW5hYmxlZFtheGlzXSA9IGVuYWJsZWRbYXhpc107XG4gICAgICAgIGVuYWJsZWRbYXhpc10gPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAoc2NhbGUgJiYgc2NhbGVFbmFibGVkW3NjYWxlLmF4aXNdKSB7XG4gICAgcmV0dXJuIFtzY2FsZV07XG4gIH1cblxuICBjb25zdCBlbmFibGVkU2NhbGVzID0gW107XG4gIGVhY2goY2hhcnQuc2NhbGVzLCBmdW5jdGlvbihzY2FsZUl0ZW0pIHtcbiAgICBpZiAoZW5hYmxlZFtzY2FsZUl0ZW0uYXhpc10pIHtcbiAgICAgIGVuYWJsZWRTY2FsZXMucHVzaChzY2FsZUl0ZW0pO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBlbmFibGVkU2NhbGVzO1xufVxuXG5jb25zdCBjaGFydFN0YXRlcyA9IG5ldyBXZWFrTWFwKCk7XG5cbmZ1bmN0aW9uIGdldFN0YXRlKGNoYXJ0KSB7XG4gIGxldCBzdGF0ZSA9IGNoYXJ0U3RhdGVzLmdldChjaGFydCk7XG4gIGlmICghc3RhdGUpIHtcbiAgICBzdGF0ZSA9IHtcbiAgICAgIG9yaWdpbmFsU2NhbGVMaW1pdHM6IHt9LFxuICAgICAgdXBkYXRlZFNjYWxlTGltaXRzOiB7fSxcbiAgICAgIGhhbmRsZXJzOiB7fSxcbiAgICAgIHBhbkRlbHRhOiB7fVxuICAgIH07XG4gICAgY2hhcnRTdGF0ZXMuc2V0KGNoYXJ0LCBzdGF0ZSk7XG4gIH1cbiAgcmV0dXJuIHN0YXRlO1xufVxuXG5mdW5jdGlvbiByZW1vdmVTdGF0ZShjaGFydCkge1xuICBjaGFydFN0YXRlcy5kZWxldGUoY2hhcnQpO1xufVxuXG5mdW5jdGlvbiB6b29tRGVsdGEoc2NhbGUsIHpvb20sIGNlbnRlcikge1xuICBjb25zdCByYW5nZSA9IHNjYWxlLm1heCAtIHNjYWxlLm1pbjtcbiAgY29uc3QgbmV3UmFuZ2UgPSByYW5nZSAqICh6b29tIC0gMSk7XG5cbiAgY29uc3QgY2VudGVyUG9pbnQgPSBzY2FsZS5pc0hvcml6b250YWwoKSA/IGNlbnRlci54IDogY2VudGVyLnk7XG4gIC8vIGBzY2FsZS5nZXRWYWx1ZUZvclBpeGVsKClgIGNhbiByZXR1cm4gYSB2YWx1ZSBsZXNzIHRoYW4gdGhlIGBzY2FsZS5taW5gIG9yXG4gIC8vIGdyZWF0ZXIgdGhhbiBgc2NhbGUubWF4YCB3aGVuIGBjZW50ZXJQb2ludGAgaXMgb3V0c2lkZSBjaGFydEFyZWEuXG4gIGNvbnN0IG1pblBlcmNlbnQgPSBNYXRoLm1heCgwLCBNYXRoLm1pbigxLFxuICAgIChzY2FsZS5nZXRWYWx1ZUZvclBpeGVsKGNlbnRlclBvaW50KSAtIHNjYWxlLm1pbikgLyByYW5nZSB8fCAwXG4gICkpO1xuXG4gIGNvbnN0IG1heFBlcmNlbnQgPSAxIC0gbWluUGVyY2VudDtcblxuICByZXR1cm4ge1xuICAgIG1pbjogbmV3UmFuZ2UgKiBtaW5QZXJjZW50LFxuICAgIG1heDogbmV3UmFuZ2UgKiBtYXhQZXJjZW50XG4gIH07XG59XG5cbmZ1bmN0aW9uIGdldExpbWl0KHN0YXRlLCBzY2FsZSwgc2NhbGVMaW1pdHMsIHByb3AsIGZhbGxiYWNrKSB7XG4gIGxldCBsaW1pdCA9IHNjYWxlTGltaXRzW3Byb3BdO1xuICBpZiAobGltaXQgPT09ICdvcmlnaW5hbCcpIHtcbiAgICBjb25zdCBvcmlnaW5hbCA9IHN0YXRlLm9yaWdpbmFsU2NhbGVMaW1pdHNbc2NhbGUuaWRdW3Byb3BdO1xuICAgIGxpbWl0ID0gdmFsdWVPckRlZmF1bHQob3JpZ2luYWwub3B0aW9ucywgb3JpZ2luYWwuc2NhbGUpO1xuICB9XG4gIHJldHVybiB2YWx1ZU9yRGVmYXVsdChsaW1pdCwgZmFsbGJhY2spO1xufVxuXG5mdW5jdGlvbiBnZXRSYW5nZShzY2FsZSwgcGl4ZWwwLCBwaXhlbDEpIHtcbiAgY29uc3QgdjAgPSBzY2FsZS5nZXRWYWx1ZUZvclBpeGVsKHBpeGVsMCk7XG4gIGNvbnN0IHYxID0gc2NhbGUuZ2V0VmFsdWVGb3JQaXhlbChwaXhlbDEpO1xuICByZXR1cm4ge1xuICAgIG1pbjogTWF0aC5taW4odjAsIHYxKSxcbiAgICBtYXg6IE1hdGgubWF4KHYwLCB2MSlcbiAgfTtcbn1cblxuZnVuY3Rpb24gdXBkYXRlUmFuZ2Uoc2NhbGUsIHttaW4sIG1heH0sIGxpbWl0cywgem9vbSA9IGZhbHNlKSB7XG4gIGNvbnN0IHN0YXRlID0gZ2V0U3RhdGUoc2NhbGUuY2hhcnQpO1xuICBjb25zdCB7aWQsIGF4aXMsIG9wdGlvbnM6IHNjYWxlT3B0c30gPSBzY2FsZTtcblxuICBjb25zdCBzY2FsZUxpbWl0cyA9IGxpbWl0cyAmJiAobGltaXRzW2lkXSB8fCBsaW1pdHNbYXhpc10pIHx8IHt9O1xuICBjb25zdCB7bWluUmFuZ2UgPSAwfSA9IHNjYWxlTGltaXRzO1xuICBjb25zdCBtaW5MaW1pdCA9IGdldExpbWl0KHN0YXRlLCBzY2FsZSwgc2NhbGVMaW1pdHMsICdtaW4nLCAtSW5maW5pdHkpO1xuICBjb25zdCBtYXhMaW1pdCA9IGdldExpbWl0KHN0YXRlLCBzY2FsZSwgc2NhbGVMaW1pdHMsICdtYXgnLCBJbmZpbml0eSk7XG5cbiAgY29uc3QgcmFuZ2UgPSB6b29tID8gTWF0aC5tYXgobWF4IC0gbWluLCBtaW5SYW5nZSkgOiBzY2FsZS5tYXggLSBzY2FsZS5taW47XG4gIGNvbnN0IG9mZnNldCA9IChyYW5nZSAtIG1heCArIG1pbikgLyAyO1xuICBtaW4gLT0gb2Zmc2V0O1xuICBtYXggKz0gb2Zmc2V0O1xuXG4gIGlmIChtaW4gPCBtaW5MaW1pdCkge1xuICAgIG1pbiA9IG1pbkxpbWl0O1xuICAgIG1heCA9IE1hdGgubWluKG1pbkxpbWl0ICsgcmFuZ2UsIG1heExpbWl0KTtcbiAgfSBlbHNlIGlmIChtYXggPiBtYXhMaW1pdCkge1xuICAgIG1heCA9IG1heExpbWl0O1xuICAgIG1pbiA9IE1hdGgubWF4KG1heExpbWl0IC0gcmFuZ2UsIG1pbkxpbWl0KTtcbiAgfVxuICBzY2FsZU9wdHMubWluID0gbWluO1xuICBzY2FsZU9wdHMubWF4ID0gbWF4O1xuXG4gIHN0YXRlLnVwZGF0ZWRTY2FsZUxpbWl0c1tzY2FsZS5pZF0gPSB7bWluLCBtYXh9O1xuXG4gIC8vIHJldHVybiB0cnVlIGlmIHRoZSBzY2FsZSByYW5nZSBpcyBjaGFuZ2VkXG4gIHJldHVybiBzY2FsZS5wYXJzZShtaW4pICE9PSBzY2FsZS5taW4gfHwgc2NhbGUucGFyc2UobWF4KSAhPT0gc2NhbGUubWF4O1xufVxuXG5mdW5jdGlvbiB6b29tTnVtZXJpY2FsU2NhbGUoc2NhbGUsIHpvb20sIGNlbnRlciwgbGltaXRzKSB7XG4gIGNvbnN0IGRlbHRhID0gem9vbURlbHRhKHNjYWxlLCB6b29tLCBjZW50ZXIpO1xuICBjb25zdCBuZXdSYW5nZSA9IHttaW46IHNjYWxlLm1pbiArIGRlbHRhLm1pbiwgbWF4OiBzY2FsZS5tYXggLSBkZWx0YS5tYXh9O1xuICByZXR1cm4gdXBkYXRlUmFuZ2Uoc2NhbGUsIG5ld1JhbmdlLCBsaW1pdHMsIHRydWUpO1xufVxuXG5mdW5jdGlvbiB6b29tUmVjdE51bWVyaWNhbFNjYWxlKHNjYWxlLCBmcm9tLCB0bywgbGltaXRzKSB7XG4gIHVwZGF0ZVJhbmdlKHNjYWxlLCBnZXRSYW5nZShzY2FsZSwgZnJvbSwgdG8pLCBsaW1pdHMsIHRydWUpO1xufVxuXG5jb25zdCBpbnRlZ2VyQ2hhbmdlID0gKHYpID0+IHYgPT09IDAgfHwgaXNOYU4odikgPyAwIDogdiA8IDAgPyBNYXRoLm1pbihNYXRoLnJvdW5kKHYpLCAtMSkgOiBNYXRoLm1heChNYXRoLnJvdW5kKHYpLCAxKTtcblxuZnVuY3Rpb24gZXhpc3RDYXRlZ29yeUZyb21NYXhab29tKHNjYWxlKSB7XG4gIGNvbnN0IGxhYmVscyA9IHNjYWxlLmdldExhYmVscygpO1xuICBjb25zdCBtYXhJbmRleCA9IGxhYmVscy5sZW5ndGggLSAxO1xuXG4gIGlmIChzY2FsZS5taW4gPiAwKSB7XG4gICAgc2NhbGUubWluIC09IDE7XG4gIH1cbiAgaWYgKHNjYWxlLm1heCA8IG1heEluZGV4KSB7XG4gICAgc2NhbGUubWF4ICs9IDE7XG4gIH1cbn1cblxuZnVuY3Rpb24gem9vbUNhdGVnb3J5U2NhbGUoc2NhbGUsIHpvb20sIGNlbnRlciwgbGltaXRzKSB7XG4gIGNvbnN0IGRlbHRhID0gem9vbURlbHRhKHNjYWxlLCB6b29tLCBjZW50ZXIpO1xuICBpZiAoc2NhbGUubWluID09PSBzY2FsZS5tYXggJiYgem9vbSA8IDEpIHtcbiAgICBleGlzdENhdGVnb3J5RnJvbU1heFpvb20oc2NhbGUpO1xuICB9XG4gIGNvbnN0IG5ld1JhbmdlID0ge21pbjogc2NhbGUubWluICsgaW50ZWdlckNoYW5nZShkZWx0YS5taW4pLCBtYXg6IHNjYWxlLm1heCAtIGludGVnZXJDaGFuZ2UoZGVsdGEubWF4KX07XG4gIHJldHVybiB1cGRhdGVSYW5nZShzY2FsZSwgbmV3UmFuZ2UsIGxpbWl0cywgdHJ1ZSk7XG59XG5cbmZ1bmN0aW9uIHNjYWxlTGVuZ3RoKHNjYWxlKSB7XG4gIHJldHVybiBzY2FsZS5pc0hvcml6b250YWwoKSA/IHNjYWxlLndpZHRoIDogc2NhbGUuaGVpZ2h0O1xufVxuXG5mdW5jdGlvbiBwYW5DYXRlZ29yeVNjYWxlKHNjYWxlLCBkZWx0YSwgbGltaXRzKSB7XG4gIGNvbnN0IGxhYmVscyA9IHNjYWxlLmdldExhYmVscygpO1xuICBjb25zdCBsYXN0TGFiZWxJbmRleCA9IGxhYmVscy5sZW5ndGggLSAxO1xuICBsZXQge21pbiwgbWF4fSA9IHNjYWxlO1xuICAvLyBUaGUgdmlzaWJsZSByYW5nZS4gVGlja3MgY2FuIGJlIHNraXBwZWQsIGFuZCB0aHVzIG5vdCByZWxpYWJsZS5cbiAgY29uc3QgcmFuZ2UgPSBNYXRoLm1heChtYXggLSBtaW4sIDEpO1xuICAvLyBIb3cgbWFueSBwaXhlbHMgb2YgZGVsdGEgaXMgcmVxdWlyZWQgYmVmb3JlIG1ha2luZyBhIHN0ZXAuIHN0ZXBTaXplLCBidXQgbGltaXRlZCB0byBtYXggMS8xMCBvZiB0aGUgc2NhbGUgbGVuZ3RoLlxuICBjb25zdCBzdGVwRGVsdGEgPSBNYXRoLnJvdW5kKHNjYWxlTGVuZ3RoKHNjYWxlKSAvIE1hdGgubWF4KHJhbmdlLCAxMCkpO1xuICBjb25zdCBzdGVwU2l6ZSA9IE1hdGgucm91bmQoTWF0aC5hYnMoZGVsdGEgLyBzdGVwRGVsdGEpKTtcbiAgbGV0IGFwcGxpZWQ7XG4gIGlmIChkZWx0YSA8IC1zdGVwRGVsdGEpIHtcbiAgICBtYXggPSBNYXRoLm1pbihtYXggKyBzdGVwU2l6ZSwgbGFzdExhYmVsSW5kZXgpO1xuICAgIG1pbiA9IHJhbmdlID09PSAxID8gbWF4IDogbWF4IC0gcmFuZ2U7XG4gICAgYXBwbGllZCA9IG1heCA9PT0gbGFzdExhYmVsSW5kZXg7XG4gIH0gZWxzZSBpZiAoZGVsdGEgPiBzdGVwRGVsdGEpIHtcbiAgICBtaW4gPSBNYXRoLm1heCgwLCBtaW4gLSBzdGVwU2l6ZSk7XG4gICAgbWF4ID0gcmFuZ2UgPT09IDEgPyBtaW4gOiBtaW4gKyByYW5nZTtcbiAgICBhcHBsaWVkID0gbWluID09PSAwO1xuICB9XG5cbiAgcmV0dXJuIHVwZGF0ZVJhbmdlKHNjYWxlLCB7bWluLCBtYXh9LCBsaW1pdHMpIHx8IGFwcGxpZWQ7XG59XG5cbmNvbnN0IE9GRlNFVFMgPSB7XG4gIHNlY29uZDogNTAwLCAvLyA1MDAgbXNcbiAgbWludXRlOiAzMCAqIDEwMDAsIC8vIDMwIHNcbiAgaG91cjogMzAgKiA2MCAqIDEwMDAsIC8vIDMwIG1cbiAgZGF5OiAxMiAqIDYwICogNjAgKiAxMDAwLCAvLyAxMiBoXG4gIHdlZWs6IDMuNSAqIDI0ICogNjAgKiA2MCAqIDEwMDAsIC8vIDMuNSBkXG4gIG1vbnRoOiAxNSAqIDI0ICogNjAgKiA2MCAqIDEwMDAsIC8vIDE1IGRcbiAgcXVhcnRlcjogNjAgKiAyNCAqIDYwICogNjAgKiAxMDAwLCAvLyA2MCBkXG4gIHllYXI6IDE4MiAqIDI0ICogNjAgKiA2MCAqIDEwMDAgLy8gMTgyIGRcbn07XG5cbmZ1bmN0aW9uIHBhbk51bWVyaWNhbFNjYWxlKHNjYWxlLCBkZWx0YSwgbGltaXRzLCBjYW5ab29tID0gZmFsc2UpIHtcbiAgY29uc3Qge21pbjogcHJldlN0YXJ0LCBtYXg6IHByZXZFbmQsIG9wdGlvbnN9ID0gc2NhbGU7XG4gIGNvbnN0IHJvdW5kID0gb3B0aW9ucy50aW1lICYmIG9wdGlvbnMudGltZS5yb3VuZDtcbiAgY29uc3Qgb2Zmc2V0ID0gT0ZGU0VUU1tyb3VuZF0gfHwgMDtcbiAgY29uc3QgbmV3TWluID0gc2NhbGUuZ2V0VmFsdWVGb3JQaXhlbChzY2FsZS5nZXRQaXhlbEZvclZhbHVlKHByZXZTdGFydCArIG9mZnNldCkgLSBkZWx0YSk7XG4gIGNvbnN0IG5ld01heCA9IHNjYWxlLmdldFZhbHVlRm9yUGl4ZWwoc2NhbGUuZ2V0UGl4ZWxGb3JWYWx1ZShwcmV2RW5kICsgb2Zmc2V0KSAtIGRlbHRhKTtcbiAgY29uc3Qge21pbjogbWluTGltaXQgPSAtSW5maW5pdHksIG1heDogbWF4TGltaXQgPSBJbmZpbml0eX0gPSBjYW5ab29tICYmIGxpbWl0cyAmJiBsaW1pdHNbc2NhbGUuYXhpc10gfHwge307XG4gIGlmIChpc05hTihuZXdNaW4pIHx8IGlzTmFOKG5ld01heCkgfHwgbmV3TWluIDwgbWluTGltaXQgfHwgbmV3TWF4ID4gbWF4TGltaXQpIHtcbiAgICAvLyBBdCBsaW1pdDogTm8gY2hhbmdlIGJ1dCByZXR1cm4gdHJ1ZSB0byBpbmRpY2F0ZSBubyBuZWVkIHRvIHN0b3JlIHRoZSBkZWx0YS5cbiAgICAvLyBOYU4gY2FuIGhhcHBlbiBmb3IgMC1kaW1lbnNpb24gc2NhbGVzIChlaXRoZXIgYmVjYXVzZSB0aGV5IHdlcmUgY29uZmlndXJlZFxuICAgIC8vIHdpdGggbWluID09PSBtYXggb3IgYmVjYXVzZSB0aGUgY2hhcnQgaGFzIDAgcGxvdHRhYmxlIGFyZWEpLlxuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiB1cGRhdGVSYW5nZShzY2FsZSwge21pbjogbmV3TWluLCBtYXg6IG5ld01heH0sIGxpbWl0cywgY2FuWm9vbSk7XG59XG5cbmZ1bmN0aW9uIHBhbk5vbkxpbmVhclNjYWxlKHNjYWxlLCBkZWx0YSwgbGltaXRzKSB7XG4gIHJldHVybiBwYW5OdW1lcmljYWxTY2FsZShzY2FsZSwgZGVsdGEsIGxpbWl0cywgdHJ1ZSk7XG59XG5cbmNvbnN0IHpvb21GdW5jdGlvbnMgPSB7XG4gIGNhdGVnb3J5OiB6b29tQ2F0ZWdvcnlTY2FsZSxcbiAgZGVmYXVsdDogem9vbU51bWVyaWNhbFNjYWxlLFxufTtcblxuY29uc3Qgem9vbVJlY3RGdW5jdGlvbnMgPSB7XG4gIGRlZmF1bHQ6IHpvb21SZWN0TnVtZXJpY2FsU2NhbGUsXG59O1xuXG5jb25zdCBwYW5GdW5jdGlvbnMgPSB7XG4gIGNhdGVnb3J5OiBwYW5DYXRlZ29yeVNjYWxlLFxuICBkZWZhdWx0OiBwYW5OdW1lcmljYWxTY2FsZSxcbiAgbG9nYXJpdGhtaWM6IHBhbk5vbkxpbmVhclNjYWxlLFxuICB0aW1lc2VyaWVzOiBwYW5Ob25MaW5lYXJTY2FsZSxcbn07XG5cbmZ1bmN0aW9uIHNob3VsZFVwZGF0ZVNjYWxlTGltaXRzKHNjYWxlLCBvcmlnaW5hbFNjYWxlTGltaXRzLCB1cGRhdGVkU2NhbGVMaW1pdHMpIHtcbiAgY29uc3Qge2lkLCBvcHRpb25zOiB7bWluLCBtYXh9fSA9IHNjYWxlO1xuICBpZiAoIW9yaWdpbmFsU2NhbGVMaW1pdHNbaWRdIHx8ICF1cGRhdGVkU2NhbGVMaW1pdHNbaWRdKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgY29uc3QgcHJldmlvdXMgPSB1cGRhdGVkU2NhbGVMaW1pdHNbaWRdO1xuICByZXR1cm4gcHJldmlvdXMubWluICE9PSBtaW4gfHwgcHJldmlvdXMubWF4ICE9PSBtYXg7XG59XG5cbmZ1bmN0aW9uIHJlbW92ZU1pc3NpbmdTY2FsZXMobGltaXRzLCBzY2FsZXMpIHtcbiAgZWFjaChsaW1pdHMsIChvcHQsIGtleSkgPT4ge1xuICAgIGlmICghc2NhbGVzW2tleV0pIHtcbiAgICAgIGRlbGV0ZSBsaW1pdHNba2V5XTtcbiAgICB9XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBzdG9yZU9yaWdpbmFsU2NhbGVMaW1pdHMoY2hhcnQsIHN0YXRlKSB7XG4gIGNvbnN0IHtzY2FsZXN9ID0gY2hhcnQ7XG4gIGNvbnN0IHtvcmlnaW5hbFNjYWxlTGltaXRzLCB1cGRhdGVkU2NhbGVMaW1pdHN9ID0gc3RhdGU7XG5cbiAgZWFjaChzY2FsZXMsIGZ1bmN0aW9uKHNjYWxlKSB7XG4gICAgaWYgKHNob3VsZFVwZGF0ZVNjYWxlTGltaXRzKHNjYWxlLCBvcmlnaW5hbFNjYWxlTGltaXRzLCB1cGRhdGVkU2NhbGVMaW1pdHMpKSB7XG4gICAgICBvcmlnaW5hbFNjYWxlTGltaXRzW3NjYWxlLmlkXSA9IHtcbiAgICAgICAgbWluOiB7c2NhbGU6IHNjYWxlLm1pbiwgb3B0aW9uczogc2NhbGUub3B0aW9ucy5taW59LFxuICAgICAgICBtYXg6IHtzY2FsZTogc2NhbGUubWF4LCBvcHRpb25zOiBzY2FsZS5vcHRpb25zLm1heH0sXG4gICAgICB9O1xuICAgIH1cbiAgfSk7XG5cbiAgcmVtb3ZlTWlzc2luZ1NjYWxlcyhvcmlnaW5hbFNjYWxlTGltaXRzLCBzY2FsZXMpO1xuICByZW1vdmVNaXNzaW5nU2NhbGVzKHVwZGF0ZWRTY2FsZUxpbWl0cywgc2NhbGVzKTtcbiAgcmV0dXJuIG9yaWdpbmFsU2NhbGVMaW1pdHM7XG59XG5cbmZ1bmN0aW9uIGRvWm9vbShzY2FsZSwgYW1vdW50LCBjZW50ZXIsIGxpbWl0cykge1xuICBjb25zdCBmbiA9IHpvb21GdW5jdGlvbnNbc2NhbGUudHlwZV0gfHwgem9vbUZ1bmN0aW9ucy5kZWZhdWx0O1xuICBjYWxsYmFjayhmbiwgW3NjYWxlLCBhbW91bnQsIGNlbnRlciwgbGltaXRzXSk7XG59XG5cbmZ1bmN0aW9uIGRvWm9vbVJlY3Qoc2NhbGUsIGFtb3VudCwgZnJvbSwgdG8sIGxpbWl0cykge1xuICBjb25zdCBmbiA9IHpvb21SZWN0RnVuY3Rpb25zW3NjYWxlLnR5cGVdIHx8IHpvb21SZWN0RnVuY3Rpb25zLmRlZmF1bHQ7XG4gIGNhbGxiYWNrKGZuLCBbc2NhbGUsIGFtb3VudCwgZnJvbSwgdG8sIGxpbWl0c10pO1xufVxuXG5mdW5jdGlvbiBnZXRDZW50ZXIoY2hhcnQpIHtcbiAgY29uc3QgY2EgPSBjaGFydC5jaGFydEFyZWE7XG4gIHJldHVybiB7XG4gICAgeDogKGNhLmxlZnQgKyBjYS5yaWdodCkgLyAyLFxuICAgIHk6IChjYS50b3AgKyBjYS5ib3R0b20pIC8gMixcbiAgfTtcbn1cblxuLyoqXG4gKiBAcGFyYW0gY2hhcnQgVGhlIGNoYXJ0IGluc3RhbmNlXG4gKiBAcGFyYW0ge251bWJlciB8IHt4PzogbnVtYmVyLCB5PzogbnVtYmVyLCBmb2NhbFBvaW50Pzoge3g6IG51bWJlciwgeTogbnVtYmVyfX19IGFtb3VudCBUaGUgem9vbSBwZXJjZW50YWdlIG9yIHBlcmNlbnRhZ2VzIGFuZCBmb2NhbCBwb2ludFxuICogQHBhcmFtIHtzdHJpbmd9IFt0cmFuc2l0aW9uXSBXaGljaCB0cmFuc2l0aW9uIG1vZGUgdG8gdXNlLiBEZWZhdWx0cyB0byAnbm9uZSdcbiAqL1xuZnVuY3Rpb24gem9vbShjaGFydCwgYW1vdW50LCB0cmFuc2l0aW9uID0gJ25vbmUnKSB7XG4gIGNvbnN0IHt4ID0gMSwgeSA9IDEsIGZvY2FsUG9pbnQgPSBnZXRDZW50ZXIoY2hhcnQpfSA9IHR5cGVvZiBhbW91bnQgPT09ICdudW1iZXInID8ge3g6IGFtb3VudCwgeTogYW1vdW50fSA6IGFtb3VudDtcbiAgY29uc3Qgc3RhdGUgPSBnZXRTdGF0ZShjaGFydCk7XG4gIGNvbnN0IHtvcHRpb25zOiB7bGltaXRzLCB6b29tOiB6b29tT3B0aW9uc319ID0gc3RhdGU7XG5cbiAgc3RvcmVPcmlnaW5hbFNjYWxlTGltaXRzKGNoYXJ0LCBzdGF0ZSk7XG5cbiAgY29uc3QgeEVuYWJsZWQgPSB4ICE9PSAxO1xuICBjb25zdCB5RW5hYmxlZCA9IHkgIT09IDE7XG4gIGNvbnN0IGVuYWJsZWRTY2FsZXMgPSBnZXRFbmFibGVkU2NhbGVzQnlQb2ludCh6b29tT3B0aW9ucywgZm9jYWxQb2ludCwgY2hhcnQpO1xuXG4gIGVhY2goZW5hYmxlZFNjYWxlcyB8fCBjaGFydC5zY2FsZXMsIGZ1bmN0aW9uKHNjYWxlKSB7XG4gICAgaWYgKHNjYWxlLmlzSG9yaXpvbnRhbCgpICYmIHhFbmFibGVkKSB7XG4gICAgICBkb1pvb20oc2NhbGUsIHgsIGZvY2FsUG9pbnQsIGxpbWl0cyk7XG4gICAgfSBlbHNlIGlmICghc2NhbGUuaXNIb3Jpem9udGFsKCkgJiYgeUVuYWJsZWQpIHtcbiAgICAgIGRvWm9vbShzY2FsZSwgeSwgZm9jYWxQb2ludCwgbGltaXRzKTtcbiAgICB9XG4gIH0pO1xuXG4gIGNoYXJ0LnVwZGF0ZSh0cmFuc2l0aW9uKTtcblxuICBjYWxsYmFjayh6b29tT3B0aW9ucy5vblpvb20sIFt7Y2hhcnR9XSk7XG59XG5cbmZ1bmN0aW9uIHpvb21SZWN0KGNoYXJ0LCBwMCwgcDEsIHRyYW5zaXRpb24gPSAnbm9uZScpIHtcbiAgY29uc3Qgc3RhdGUgPSBnZXRTdGF0ZShjaGFydCk7XG4gIGNvbnN0IHtvcHRpb25zOiB7bGltaXRzLCB6b29tOiB6b29tT3B0aW9uc319ID0gc3RhdGU7XG4gIGNvbnN0IHttb2RlID0gJ3h5J30gPSB6b29tT3B0aW9ucztcblxuICBzdG9yZU9yaWdpbmFsU2NhbGVMaW1pdHMoY2hhcnQsIHN0YXRlKTtcbiAgY29uc3QgeEVuYWJsZWQgPSBkaXJlY3Rpb25FbmFibGVkKG1vZGUsICd4JywgY2hhcnQpO1xuICBjb25zdCB5RW5hYmxlZCA9IGRpcmVjdGlvbkVuYWJsZWQobW9kZSwgJ3knLCBjaGFydCk7XG5cbiAgZWFjaChjaGFydC5zY2FsZXMsIGZ1bmN0aW9uKHNjYWxlKSB7XG4gICAgaWYgKHNjYWxlLmlzSG9yaXpvbnRhbCgpICYmIHhFbmFibGVkKSB7XG4gICAgICBkb1pvb21SZWN0KHNjYWxlLCBwMC54LCBwMS54LCBsaW1pdHMpO1xuICAgIH0gZWxzZSBpZiAoIXNjYWxlLmlzSG9yaXpvbnRhbCgpICYmIHlFbmFibGVkKSB7XG4gICAgICBkb1pvb21SZWN0KHNjYWxlLCBwMC55LCBwMS55LCBsaW1pdHMpO1xuICAgIH1cbiAgfSk7XG5cbiAgY2hhcnQudXBkYXRlKHRyYW5zaXRpb24pO1xuXG4gIGNhbGxiYWNrKHpvb21PcHRpb25zLm9uWm9vbSwgW3tjaGFydH1dKTtcbn1cblxuZnVuY3Rpb24gem9vbVNjYWxlKGNoYXJ0LCBzY2FsZUlkLCByYW5nZSwgdHJhbnNpdGlvbiA9ICdub25lJykge1xuICBzdG9yZU9yaWdpbmFsU2NhbGVMaW1pdHMoY2hhcnQsIGdldFN0YXRlKGNoYXJ0KSk7XG4gIGNvbnN0IHNjYWxlID0gY2hhcnQuc2NhbGVzW3NjYWxlSWRdO1xuICB1cGRhdGVSYW5nZShzY2FsZSwgcmFuZ2UsIHVuZGVmaW5lZCwgdHJ1ZSk7XG4gIGNoYXJ0LnVwZGF0ZSh0cmFuc2l0aW9uKTtcbn1cblxuZnVuY3Rpb24gcmVzZXRab29tKGNoYXJ0LCB0cmFuc2l0aW9uID0gJ2RlZmF1bHQnKSB7XG4gIGNvbnN0IHN0YXRlID0gZ2V0U3RhdGUoY2hhcnQpO1xuICBjb25zdCBvcmlnaW5hbFNjYWxlTGltaXRzID0gc3RvcmVPcmlnaW5hbFNjYWxlTGltaXRzKGNoYXJ0LCBzdGF0ZSk7XG5cbiAgZWFjaChjaGFydC5zY2FsZXMsIGZ1bmN0aW9uKHNjYWxlKSB7XG4gICAgY29uc3Qgc2NhbGVPcHRpb25zID0gc2NhbGUub3B0aW9ucztcbiAgICBpZiAob3JpZ2luYWxTY2FsZUxpbWl0c1tzY2FsZS5pZF0pIHtcbiAgICAgIHNjYWxlT3B0aW9ucy5taW4gPSBvcmlnaW5hbFNjYWxlTGltaXRzW3NjYWxlLmlkXS5taW4ub3B0aW9ucztcbiAgICAgIHNjYWxlT3B0aW9ucy5tYXggPSBvcmlnaW5hbFNjYWxlTGltaXRzW3NjYWxlLmlkXS5tYXgub3B0aW9ucztcbiAgICB9IGVsc2Uge1xuICAgICAgZGVsZXRlIHNjYWxlT3B0aW9ucy5taW47XG4gICAgICBkZWxldGUgc2NhbGVPcHRpb25zLm1heDtcbiAgICB9XG4gIH0pO1xuICBjaGFydC51cGRhdGUodHJhbnNpdGlvbik7XG4gIGNhbGxiYWNrKHN0YXRlLm9wdGlvbnMuem9vbS5vblpvb21Db21wbGV0ZSwgW3tjaGFydH1dKTtcbn1cblxuZnVuY3Rpb24gZ2V0T3JpZ2luYWxSYW5nZShzdGF0ZSwgc2NhbGVJZCkge1xuICBjb25zdCBvcmlnaW5hbCA9IHN0YXRlLm9yaWdpbmFsU2NhbGVMaW1pdHNbc2NhbGVJZF07XG4gIGlmICghb3JpZ2luYWwpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3Qge21pbiwgbWF4fSA9IG9yaWdpbmFsO1xuICByZXR1cm4gdmFsdWVPckRlZmF1bHQobWF4Lm9wdGlvbnMsIG1heC5zY2FsZSkgLSB2YWx1ZU9yRGVmYXVsdChtaW4ub3B0aW9ucywgbWluLnNjYWxlKTtcbn1cblxuZnVuY3Rpb24gZ2V0Wm9vbUxldmVsKGNoYXJ0KSB7XG4gIGNvbnN0IHN0YXRlID0gZ2V0U3RhdGUoY2hhcnQpO1xuICBsZXQgbWluID0gMTtcbiAgbGV0IG1heCA9IDE7XG4gIGVhY2goY2hhcnQuc2NhbGVzLCBmdW5jdGlvbihzY2FsZSkge1xuICAgIGNvbnN0IG9yaWdSYW5nZSA9IGdldE9yaWdpbmFsUmFuZ2Uoc3RhdGUsIHNjYWxlLmlkKTtcbiAgICBpZiAob3JpZ1JhbmdlKSB7XG4gICAgICBjb25zdCBsZXZlbCA9IE1hdGgucm91bmQob3JpZ1JhbmdlIC8gKHNjYWxlLm1heCAtIHNjYWxlLm1pbikgKiAxMDApIC8gMTAwO1xuICAgICAgbWluID0gTWF0aC5taW4obWluLCBsZXZlbCk7XG4gICAgICBtYXggPSBNYXRoLm1heChtYXgsIGxldmVsKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gbWluIDwgMSA/IG1pbiA6IG1heDtcbn1cblxuZnVuY3Rpb24gcGFuU2NhbGUoc2NhbGUsIGRlbHRhLCBsaW1pdHMsIHN0YXRlKSB7XG4gIGNvbnN0IHtwYW5EZWx0YX0gPSBzdGF0ZTtcbiAgLy8gQWRkIHBvc3NpYmxlIGN1bXVsYXRpdmUgZGVsdGEgZnJvbSBwcmV2aW91cyBwYW4gYXR0ZW1wdHMgd2hlcmUgc2NhbGUgZGlkIG5vdCBjaGFuZ2VcbiAgY29uc3Qgc3RvcmVkRGVsdGEgPSBwYW5EZWx0YVtzY2FsZS5pZF0gfHwgMDtcbiAgaWYgKHNpZ24oc3RvcmVkRGVsdGEpID09PSBzaWduKGRlbHRhKSkge1xuICAgIGRlbHRhICs9IHN0b3JlZERlbHRhO1xuICB9XG4gIGNvbnN0IGZuID0gcGFuRnVuY3Rpb25zW3NjYWxlLnR5cGVdIHx8IHBhbkZ1bmN0aW9ucy5kZWZhdWx0O1xuICBpZiAoY2FsbGJhY2soZm4sIFtzY2FsZSwgZGVsdGEsIGxpbWl0c10pKSB7XG4gICAgLy8gVGhlIHNjYWxlIGNoYW5nZWQsIHJlc2V0IGN1bXVsYXRpdmUgZGVsdGFcbiAgICBwYW5EZWx0YVtzY2FsZS5pZF0gPSAwO1xuICB9IGVsc2Uge1xuICAgIC8vIFRoZSBzY2FsZSBkaWQgbm90IGNoYW5nZSwgc3RvcmUgY3VtdWxhdGl2ZSBkZWx0YVxuICAgIHBhbkRlbHRhW3NjYWxlLmlkXSA9IGRlbHRhO1xuICB9XG59XG5cbmZ1bmN0aW9uIHBhbihjaGFydCwgZGVsdGEsIGVuYWJsZWRTY2FsZXMsIHRyYW5zaXRpb24gPSAnbm9uZScpIHtcbiAgY29uc3Qge3ggPSAwLCB5ID0gMH0gPSB0eXBlb2YgZGVsdGEgPT09ICdudW1iZXInID8ge3g6IGRlbHRhLCB5OiBkZWx0YX0gOiBkZWx0YTtcbiAgY29uc3Qgc3RhdGUgPSBnZXRTdGF0ZShjaGFydCk7XG4gIGNvbnN0IHtvcHRpb25zOiB7cGFuOiBwYW5PcHRpb25zLCBsaW1pdHN9fSA9IHN0YXRlO1xuICBjb25zdCB7b25QYW59ID0gcGFuT3B0aW9ucyB8fCB7fTtcblxuICBzdG9yZU9yaWdpbmFsU2NhbGVMaW1pdHMoY2hhcnQsIHN0YXRlKTtcblxuICBjb25zdCB4RW5hYmxlZCA9IHggIT09IDA7XG4gIGNvbnN0IHlFbmFibGVkID0geSAhPT0gMDtcblxuICBlYWNoKGVuYWJsZWRTY2FsZXMgfHwgY2hhcnQuc2NhbGVzLCBmdW5jdGlvbihzY2FsZSkge1xuICAgIGlmIChzY2FsZS5pc0hvcml6b250YWwoKSAmJiB4RW5hYmxlZCkge1xuICAgICAgcGFuU2NhbGUoc2NhbGUsIHgsIGxpbWl0cywgc3RhdGUpO1xuICAgIH0gZWxzZSBpZiAoIXNjYWxlLmlzSG9yaXpvbnRhbCgpICYmIHlFbmFibGVkKSB7XG4gICAgICBwYW5TY2FsZShzY2FsZSwgeSwgbGltaXRzLCBzdGF0ZSk7XG4gICAgfVxuICB9KTtcblxuICBjaGFydC51cGRhdGUodHJhbnNpdGlvbik7XG5cbiAgY2FsbGJhY2sob25QYW4sIFt7Y2hhcnR9XSk7XG59XG5cbmZ1bmN0aW9uIGdldEluaXRpYWxTY2FsZUJvdW5kcyhjaGFydCkge1xuICBjb25zdCBzdGF0ZSA9IGdldFN0YXRlKGNoYXJ0KTtcbiAgc3RvcmVPcmlnaW5hbFNjYWxlTGltaXRzKGNoYXJ0LCBzdGF0ZSk7XG4gIGNvbnN0IHNjYWxlQm91bmRzID0ge307XG4gIGZvciAoY29uc3Qgc2NhbGVJZCBvZiBPYmplY3Qua2V5cyhjaGFydC5zY2FsZXMpKSB7XG4gICAgY29uc3Qge21pbiwgbWF4fSA9IHN0YXRlLm9yaWdpbmFsU2NhbGVMaW1pdHNbc2NhbGVJZF0gfHwge21pbjoge30sIG1heDoge319O1xuICAgIHNjYWxlQm91bmRzW3NjYWxlSWRdID0ge21pbjogbWluLnNjYWxlLCBtYXg6IG1heC5zY2FsZX07XG4gIH1cblxuICByZXR1cm4gc2NhbGVCb3VuZHM7XG59XG5cbmZ1bmN0aW9uIGlzWm9vbWVkT3JQYW5uZWQoY2hhcnQpIHtcbiAgY29uc3Qgc2NhbGVCb3VuZHMgPSBnZXRJbml0aWFsU2NhbGVCb3VuZHMoY2hhcnQpO1xuICBmb3IgKGNvbnN0IHNjYWxlSWQgb2YgT2JqZWN0LmtleXMoY2hhcnQuc2NhbGVzKSkge1xuICAgIGNvbnN0IHttaW46IG9yaWdpbmFsTWluLCBtYXg6IG9yaWdpbmFsTWF4fSA9IHNjYWxlQm91bmRzW3NjYWxlSWRdO1xuXG4gICAgaWYgKG9yaWdpbmFsTWluICE9PSB1bmRlZmluZWQgJiYgY2hhcnQuc2NhbGVzW3NjYWxlSWRdLm1pbiAhPT0gb3JpZ2luYWxNaW4pIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGlmIChvcmlnaW5hbE1heCAhPT0gdW5kZWZpbmVkICYmIGNoYXJ0LnNjYWxlc1tzY2FsZUlkXS5tYXggIT09IG9yaWdpbmFsTWF4KSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIHJlbW92ZUhhbmRsZXIoY2hhcnQsIHR5cGUpIHtcbiAgY29uc3Qge2hhbmRsZXJzfSA9IGdldFN0YXRlKGNoYXJ0KTtcbiAgY29uc3QgaGFuZGxlciA9IGhhbmRsZXJzW3R5cGVdO1xuICBpZiAoaGFuZGxlciAmJiBoYW5kbGVyLnRhcmdldCkge1xuICAgIGhhbmRsZXIudGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSwgaGFuZGxlcik7XG4gICAgZGVsZXRlIGhhbmRsZXJzW3R5cGVdO1xuICB9XG59XG5cbmZ1bmN0aW9uIGFkZEhhbmRsZXIoY2hhcnQsIHRhcmdldCwgdHlwZSwgaGFuZGxlcikge1xuICBjb25zdCB7aGFuZGxlcnMsIG9wdGlvbnN9ID0gZ2V0U3RhdGUoY2hhcnQpO1xuICBjb25zdCBvbGRIYW5kbGVyID0gaGFuZGxlcnNbdHlwZV07XG4gIGlmIChvbGRIYW5kbGVyICYmIG9sZEhhbmRsZXIudGFyZ2V0ID09PSB0YXJnZXQpIHtcbiAgICAvLyBhbHJlYWR5IGF0dGFjaGVkXG4gICAgcmV0dXJuO1xuICB9XG4gIHJlbW92ZUhhbmRsZXIoY2hhcnQsIHR5cGUpO1xuICBoYW5kbGVyc1t0eXBlXSA9IChldmVudCkgPT4gaGFuZGxlcihjaGFydCwgZXZlbnQsIG9wdGlvbnMpO1xuICBoYW5kbGVyc1t0eXBlXS50YXJnZXQgPSB0YXJnZXQ7XG4gIHRhcmdldC5hZGRFdmVudExpc3RlbmVyKHR5cGUsIGhhbmRsZXJzW3R5cGVdKTtcbn1cblxuZnVuY3Rpb24gbW91c2VNb3ZlKGNoYXJ0LCBldmVudCkge1xuICBjb25zdCBzdGF0ZSA9IGdldFN0YXRlKGNoYXJ0KTtcbiAgaWYgKHN0YXRlLmRyYWdTdGFydCkge1xuICAgIHN0YXRlLmRyYWdnaW5nID0gdHJ1ZTtcbiAgICBzdGF0ZS5kcmFnRW5kID0gZXZlbnQ7XG4gICAgY2hhcnQudXBkYXRlKCdub25lJyk7XG4gIH1cbn1cblxuZnVuY3Rpb24ga2V5RG93bihjaGFydCwgZXZlbnQpIHtcbiAgY29uc3Qgc3RhdGUgPSBnZXRTdGF0ZShjaGFydCk7XG4gIGlmICghc3RhdGUuZHJhZ1N0YXJ0IHx8IGV2ZW50LmtleSAhPT0gJ0VzY2FwZScpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICByZW1vdmVIYW5kbGVyKGNoYXJ0LCAna2V5ZG93bicpO1xuICBzdGF0ZS5kcmFnZ2luZyA9IGZhbHNlO1xuICBzdGF0ZS5kcmFnU3RhcnQgPSBzdGF0ZS5kcmFnRW5kID0gbnVsbDtcbiAgY2hhcnQudXBkYXRlKCdub25lJyk7XG59XG5cbmZ1bmN0aW9uIHpvb21TdGFydChjaGFydCwgZXZlbnQsIHpvb21PcHRpb25zKSB7XG4gIGNvbnN0IHtvblpvb21TdGFydCwgb25ab29tUmVqZWN0ZWR9ID0gem9vbU9wdGlvbnM7XG4gIGlmIChvblpvb21TdGFydCkge1xuICAgIGNvbnN0IHBvaW50ID0gZ2V0UmVsYXRpdmVQb3NpdGlvbihldmVudCwgY2hhcnQpO1xuICAgIGlmIChjYWxsYmFjayhvblpvb21TdGFydCwgW3tjaGFydCwgZXZlbnQsIHBvaW50fV0pID09PSBmYWxzZSkge1xuICAgICAgY2FsbGJhY2sob25ab29tUmVqZWN0ZWQsIFt7Y2hhcnQsIGV2ZW50fV0pO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBtb3VzZURvd24oY2hhcnQsIGV2ZW50KSB7XG4gIGNvbnN0IHN0YXRlID0gZ2V0U3RhdGUoY2hhcnQpO1xuICBjb25zdCB7cGFuOiBwYW5PcHRpb25zLCB6b29tOiB6b29tT3B0aW9ucyA9IHt9fSA9IHN0YXRlLm9wdGlvbnM7XG4gIGlmIChcbiAgICBldmVudC5idXR0b24gIT09IDAgfHxcbiAgICBrZXlQcmVzc2VkKGdldE1vZGlmaWVyS2V5KHBhbk9wdGlvbnMpLCBldmVudCkgfHxcbiAgICBrZXlOb3RQcmVzc2VkKGdldE1vZGlmaWVyS2V5KHpvb21PcHRpb25zLmRyYWcpLCBldmVudClcbiAgKSB7XG4gICAgcmV0dXJuIGNhbGxiYWNrKHpvb21PcHRpb25zLm9uWm9vbVJlamVjdGVkLCBbe2NoYXJ0LCBldmVudH1dKTtcbiAgfVxuXG4gIGlmICh6b29tU3RhcnQoY2hhcnQsIGV2ZW50LCB6b29tT3B0aW9ucykgPT09IGZhbHNlKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHN0YXRlLmRyYWdTdGFydCA9IGV2ZW50O1xuXG4gIGFkZEhhbmRsZXIoY2hhcnQsIGNoYXJ0LmNhbnZhcywgJ21vdXNlbW92ZScsIG1vdXNlTW92ZSk7XG4gIGFkZEhhbmRsZXIoY2hhcnQsIHdpbmRvdy5kb2N1bWVudCwgJ2tleWRvd24nLCBrZXlEb3duKTtcbn1cblxuZnVuY3Rpb24gY29tcHV0ZURyYWdSZWN0KGNoYXJ0LCBtb2RlLCBiZWdpblBvaW50RXZlbnQsIGVuZFBvaW50RXZlbnQpIHtcbiAgY29uc3QgeEVuYWJsZWQgPSBkaXJlY3Rpb25FbmFibGVkKG1vZGUsICd4JywgY2hhcnQpO1xuICBjb25zdCB5RW5hYmxlZCA9IGRpcmVjdGlvbkVuYWJsZWQobW9kZSwgJ3knLCBjaGFydCk7XG4gIGxldCB7dG9wLCBsZWZ0LCByaWdodCwgYm90dG9tLCB3aWR0aDogY2hhcnRXaWR0aCwgaGVpZ2h0OiBjaGFydEhlaWdodH0gPSBjaGFydC5jaGFydEFyZWE7XG5cbiAgY29uc3QgYmVnaW5Qb2ludCA9IGdldFJlbGF0aXZlUG9zaXRpb24oYmVnaW5Qb2ludEV2ZW50LCBjaGFydCk7XG4gIGNvbnN0IGVuZFBvaW50ID0gZ2V0UmVsYXRpdmVQb3NpdGlvbihlbmRQb2ludEV2ZW50LCBjaGFydCk7XG5cbiAgaWYgKHhFbmFibGVkKSB7XG4gICAgbGVmdCA9IE1hdGgubWluKGJlZ2luUG9pbnQueCwgZW5kUG9pbnQueCk7XG4gICAgcmlnaHQgPSBNYXRoLm1heChiZWdpblBvaW50LngsIGVuZFBvaW50LngpO1xuICB9XG5cbiAgaWYgKHlFbmFibGVkKSB7XG4gICAgdG9wID0gTWF0aC5taW4oYmVnaW5Qb2ludC55LCBlbmRQb2ludC55KTtcbiAgICBib3R0b20gPSBNYXRoLm1heChiZWdpblBvaW50LnksIGVuZFBvaW50LnkpO1xuICB9XG4gIGNvbnN0IHdpZHRoID0gcmlnaHQgLSBsZWZ0O1xuICBjb25zdCBoZWlnaHQgPSBib3R0b20gLSB0b3A7XG5cbiAgcmV0dXJuIHtcbiAgICBsZWZ0LFxuICAgIHRvcCxcbiAgICByaWdodCxcbiAgICBib3R0b20sXG4gICAgd2lkdGgsXG4gICAgaGVpZ2h0LFxuICAgIHpvb21YOiB4RW5hYmxlZCAmJiB3aWR0aCA/IDEgKyAoKGNoYXJ0V2lkdGggLSB3aWR0aCkgLyBjaGFydFdpZHRoKSA6IDEsXG4gICAgem9vbVk6IHlFbmFibGVkICYmIGhlaWdodCA/IDEgKyAoKGNoYXJ0SGVpZ2h0IC0gaGVpZ2h0KSAvIGNoYXJ0SGVpZ2h0KSA6IDFcbiAgfTtcbn1cblxuZnVuY3Rpb24gbW91c2VVcChjaGFydCwgZXZlbnQpIHtcbiAgY29uc3Qgc3RhdGUgPSBnZXRTdGF0ZShjaGFydCk7XG4gIGlmICghc3RhdGUuZHJhZ1N0YXJ0KSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgcmVtb3ZlSGFuZGxlcihjaGFydCwgJ21vdXNlbW92ZScpO1xuICBjb25zdCB7bW9kZSwgb25ab29tQ29tcGxldGUsIGRyYWc6IHt0aHJlc2hvbGQgPSAwfX0gPSBzdGF0ZS5vcHRpb25zLnpvb207XG4gIGNvbnN0IHJlY3QgPSBjb21wdXRlRHJhZ1JlY3QoY2hhcnQsIG1vZGUsIHN0YXRlLmRyYWdTdGFydCwgZXZlbnQpO1xuICBjb25zdCBkaXN0YW5jZVggPSBkaXJlY3Rpb25FbmFibGVkKG1vZGUsICd4JywgY2hhcnQpID8gcmVjdC53aWR0aCA6IDA7XG4gIGNvbnN0IGRpc3RhbmNlWSA9IGRpcmVjdGlvbkVuYWJsZWQobW9kZSwgJ3knLCBjaGFydCkgPyByZWN0LmhlaWdodCA6IDA7XG4gIGNvbnN0IGRpc3RhbmNlID0gTWF0aC5zcXJ0KGRpc3RhbmNlWCAqIGRpc3RhbmNlWCArIGRpc3RhbmNlWSAqIGRpc3RhbmNlWSk7XG5cbiAgLy8gUmVtb3ZlIGRyYWcgc3RhcnQgYW5kIGVuZCBiZWZvcmUgY2hhcnQgdXBkYXRlIHRvIHN0b3AgZHJhd2luZyBzZWxlY3RlZCBhcmVhXG4gIHN0YXRlLmRyYWdTdGFydCA9IHN0YXRlLmRyYWdFbmQgPSBudWxsO1xuXG4gIGlmIChkaXN0YW5jZSA8PSB0aHJlc2hvbGQpIHtcbiAgICBzdGF0ZS5kcmFnZ2luZyA9IGZhbHNlO1xuICAgIGNoYXJ0LnVwZGF0ZSgnbm9uZScpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHpvb21SZWN0KGNoYXJ0LCB7eDogcmVjdC5sZWZ0LCB5OiByZWN0LnRvcH0sIHt4OiByZWN0LnJpZ2h0LCB5OiByZWN0LmJvdHRvbX0sICd6b29tJyk7XG5cbiAgc2V0VGltZW91dCgoKSA9PiAoc3RhdGUuZHJhZ2dpbmcgPSBmYWxzZSksIDUwMCk7XG4gIGNhbGxiYWNrKG9uWm9vbUNvbXBsZXRlLCBbe2NoYXJ0fV0pO1xufVxuXG5mdW5jdGlvbiB3aGVlbFByZWNvbmRpdGlvbnMoY2hhcnQsIGV2ZW50LCB6b29tT3B0aW9ucykge1xuICAvLyBCZWZvcmUgcHJldmVudERlZmF1bHQsIGNoZWNrIGlmIHRoZSBtb2RpZmllciBrZXkgcmVxdWlyZWQgYW5kIHByZXNzZWRcbiAgaWYgKGtleU5vdFByZXNzZWQoZ2V0TW9kaWZpZXJLZXkoem9vbU9wdGlvbnMud2hlZWwpLCBldmVudCkpIHtcbiAgICBjYWxsYmFjayh6b29tT3B0aW9ucy5vblpvb21SZWplY3RlZCwgW3tjaGFydCwgZXZlbnR9XSk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKHpvb21TdGFydChjaGFydCwgZXZlbnQsIHpvb21PcHRpb25zKSA9PT0gZmFsc2UpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBQcmV2ZW50IHRoZSBldmVudCBmcm9tIHRyaWdnZXJpbmcgdGhlIGRlZmF1bHQgYmVoYXZpb3IgKGUuZy4gY29udGVudCBzY3JvbGxpbmcpLlxuICBpZiAoZXZlbnQuY2FuY2VsYWJsZSkge1xuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gIH1cblxuICAvLyBGaXJlZm94IGFsd2F5cyBmaXJlcyB0aGUgd2hlZWwgZXZlbnQgdHdpY2U6XG4gIC8vIEZpcnN0IHdpdGhvdXQgdGhlIGRlbHRhIGFuZCByaWdodCBhZnRlciB0aGF0IG9uY2Ugd2l0aCB0aGUgZGVsdGEgcHJvcGVydGllcy5cbiAgaWYgKGV2ZW50LmRlbHRhWSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiB3aGVlbChjaGFydCwgZXZlbnQpIHtcbiAgY29uc3Qge2hhbmRsZXJzOiB7b25ab29tQ29tcGxldGV9LCBvcHRpb25zOiB7em9vbTogem9vbU9wdGlvbnN9fSA9IGdldFN0YXRlKGNoYXJ0KTtcblxuICBpZiAoIXdoZWVsUHJlY29uZGl0aW9ucyhjaGFydCwgZXZlbnQsIHpvb21PcHRpb25zKSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGNvbnN0IHJlY3QgPSBldmVudC50YXJnZXQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gIGNvbnN0IHNwZWVkID0gMSArIChldmVudC5kZWx0YVkgPj0gMCA/IC16b29tT3B0aW9ucy53aGVlbC5zcGVlZCA6IHpvb21PcHRpb25zLndoZWVsLnNwZWVkKTtcbiAgY29uc3QgYW1vdW50ID0ge1xuICAgIHg6IHNwZWVkLFxuICAgIHk6IHNwZWVkLFxuICAgIGZvY2FsUG9pbnQ6IHtcbiAgICAgIHg6IGV2ZW50LmNsaWVudFggLSByZWN0LmxlZnQsXG4gICAgICB5OiBldmVudC5jbGllbnRZIC0gcmVjdC50b3BcbiAgICB9XG4gIH07XG5cbiAgem9vbShjaGFydCwgYW1vdW50KTtcblxuICBpZiAob25ab29tQ29tcGxldGUpIHtcbiAgICBvblpvb21Db21wbGV0ZSgpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGFkZERlYm91bmNlZEhhbmRsZXIoY2hhcnQsIG5hbWUsIGhhbmRsZXIsIGRlbGF5KSB7XG4gIGlmIChoYW5kbGVyKSB7XG4gICAgZ2V0U3RhdGUoY2hhcnQpLmhhbmRsZXJzW25hbWVdID0gZGVib3VuY2UoKCkgPT4gY2FsbGJhY2soaGFuZGxlciwgW3tjaGFydH1dKSwgZGVsYXkpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGFkZExpc3RlbmVycyhjaGFydCwgb3B0aW9ucykge1xuICBjb25zdCBjYW52YXMgPSBjaGFydC5jYW52YXM7XG4gIGNvbnN0IHt3aGVlbDogd2hlZWxPcHRpb25zLCBkcmFnOiBkcmFnT3B0aW9ucywgb25ab29tQ29tcGxldGV9ID0gb3B0aW9ucy56b29tO1xuXG4gIC8vIEluc3RhbGwgbGlzdGVuZXJzLiBEbyB0aGlzIGR5bmFtaWNhbGx5IGJhc2VkIG9uIG9wdGlvbnMgc28gdGhhdCB3ZSBjYW4gdHVybiB6b29tIG9uIGFuZCBvZmZcbiAgLy8gV2UgYWxzbyB3YW50IHRvIG1ha2Ugc3VyZSBsaXN0ZW5lcnMgYXJlbid0IGFsd2F5cyBvbi4gRS5nLiBpZiB5b3UncmUgc2Nyb2xsaW5nIGRvd24gYSBwYWdlXG4gIC8vIGFuZCB0aGUgbW91c2UgZ29lcyBvdmVyIGEgY2hhcnQgeW91IGRvbid0IHdhbnQgaXQgaW50ZXJjZXB0ZWQgdW5sZXNzIHRoZSBwbHVnaW4gaXMgZW5hYmxlZFxuICBpZiAod2hlZWxPcHRpb25zLmVuYWJsZWQpIHtcbiAgICBhZGRIYW5kbGVyKGNoYXJ0LCBjYW52YXMsICd3aGVlbCcsIHdoZWVsKTtcbiAgICBhZGREZWJvdW5jZWRIYW5kbGVyKGNoYXJ0LCAnb25ab29tQ29tcGxldGUnLCBvblpvb21Db21wbGV0ZSwgMjUwKTtcbiAgfSBlbHNlIHtcbiAgICByZW1vdmVIYW5kbGVyKGNoYXJ0LCAnd2hlZWwnKTtcbiAgfVxuICBpZiAoZHJhZ09wdGlvbnMuZW5hYmxlZCkge1xuICAgIGFkZEhhbmRsZXIoY2hhcnQsIGNhbnZhcywgJ21vdXNlZG93bicsIG1vdXNlRG93bik7XG4gICAgYWRkSGFuZGxlcihjaGFydCwgY2FudmFzLm93bmVyRG9jdW1lbnQsICdtb3VzZXVwJywgbW91c2VVcCk7XG4gIH0gZWxzZSB7XG4gICAgcmVtb3ZlSGFuZGxlcihjaGFydCwgJ21vdXNlZG93bicpO1xuICAgIHJlbW92ZUhhbmRsZXIoY2hhcnQsICdtb3VzZW1vdmUnKTtcbiAgICByZW1vdmVIYW5kbGVyKGNoYXJ0LCAnbW91c2V1cCcpO1xuICAgIHJlbW92ZUhhbmRsZXIoY2hhcnQsICdrZXlkb3duJyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVtb3ZlTGlzdGVuZXJzKGNoYXJ0KSB7XG4gIHJlbW92ZUhhbmRsZXIoY2hhcnQsICdtb3VzZWRvd24nKTtcbiAgcmVtb3ZlSGFuZGxlcihjaGFydCwgJ21vdXNlbW92ZScpO1xuICByZW1vdmVIYW5kbGVyKGNoYXJ0LCAnbW91c2V1cCcpO1xuICByZW1vdmVIYW5kbGVyKGNoYXJ0LCAnd2hlZWwnKTtcbiAgcmVtb3ZlSGFuZGxlcihjaGFydCwgJ2NsaWNrJyk7XG4gIHJlbW92ZUhhbmRsZXIoY2hhcnQsICdrZXlkb3duJyk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUVuYWJsZXIoY2hhcnQsIHN0YXRlKSB7XG4gIHJldHVybiBmdW5jdGlvbihyZWNvZ25pemVyLCBldmVudCkge1xuICAgIGNvbnN0IHtwYW46IHBhbk9wdGlvbnMsIHpvb206IHpvb21PcHRpb25zID0ge319ID0gc3RhdGUub3B0aW9ucztcbiAgICBpZiAoIXBhbk9wdGlvbnMgfHwgIXBhbk9wdGlvbnMuZW5hYmxlZCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCBzcmNFdmVudCA9IGV2ZW50ICYmIGV2ZW50LnNyY0V2ZW50O1xuICAgIGlmICghc3JjRXZlbnQpIHsgLy8gU29tZXRpbWVzIEhhbW1lciBxdWVyaWVzIHRoaXMgd2l0aCBhIG51bGwgZXZlbnQuXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKCFzdGF0ZS5wYW5uaW5nICYmIGV2ZW50LnBvaW50ZXJUeXBlID09PSAnbW91c2UnICYmIChcbiAgICAgIGtleU5vdFByZXNzZWQoZ2V0TW9kaWZpZXJLZXkocGFuT3B0aW9ucyksIHNyY0V2ZW50KSB8fCBrZXlQcmVzc2VkKGdldE1vZGlmaWVyS2V5KHpvb21PcHRpb25zLmRyYWcpLCBzcmNFdmVudCkpXG4gICAgKSB7XG4gICAgICBjYWxsYmFjayhwYW5PcHRpb25zLm9uUGFuUmVqZWN0ZWQsIFt7Y2hhcnQsIGV2ZW50fV0pO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gcGluY2hBeGVzKHAwLCBwMSkge1xuICAvLyBmaW5nZXJzIHBvc2l0aW9uIGRpZmZlcmVuY2VcbiAgY29uc3QgcGluY2hYID0gTWF0aC5hYnMocDAuY2xpZW50WCAtIHAxLmNsaWVudFgpO1xuICBjb25zdCBwaW5jaFkgPSBNYXRoLmFicyhwMC5jbGllbnRZIC0gcDEuY2xpZW50WSk7XG5cbiAgLy8gZGlhZ29uYWwgZmluZ2VycyB3aWxsIGNoYW5nZSBib3RoICh4eSkgYXhlc1xuICBjb25zdCBwID0gcGluY2hYIC8gcGluY2hZO1xuICBsZXQgeCwgeTtcbiAgaWYgKHAgPiAwLjMgJiYgcCA8IDEuNykge1xuICAgIHggPSB5ID0gdHJ1ZTtcbiAgfSBlbHNlIGlmIChwaW5jaFggPiBwaW5jaFkpIHtcbiAgICB4ID0gdHJ1ZTtcbiAgfSBlbHNlIHtcbiAgICB5ID0gdHJ1ZTtcbiAgfVxuICByZXR1cm4ge3gsIHl9O1xufVxuXG5mdW5jdGlvbiBoYW5kbGVQaW5jaChjaGFydCwgc3RhdGUsIGUpIHtcbiAgaWYgKHN0YXRlLnNjYWxlKSB7XG4gICAgY29uc3Qge2NlbnRlciwgcG9pbnRlcnN9ID0gZTtcbiAgICAvLyBIYW1tZXIgcmVwb3J0cyB0aGUgdG90YWwgc2NhbGluZy4gV2UgbmVlZCB0aGUgaW5jcmVtZW50YWwgYW1vdW50XG4gICAgY29uc3Qgem9vbVBlcmNlbnQgPSAxIC8gc3RhdGUuc2NhbGUgKiBlLnNjYWxlO1xuICAgIGNvbnN0IHJlY3QgPSBlLnRhcmdldC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICBjb25zdCBwaW5jaCA9IHBpbmNoQXhlcyhwb2ludGVyc1swXSwgcG9pbnRlcnNbMV0pO1xuICAgIGNvbnN0IG1vZGUgPSBzdGF0ZS5vcHRpb25zLnpvb20ubW9kZTtcbiAgICBjb25zdCBhbW91bnQgPSB7XG4gICAgICB4OiBwaW5jaC54ICYmIGRpcmVjdGlvbkVuYWJsZWQobW9kZSwgJ3gnLCBjaGFydCkgPyB6b29tUGVyY2VudCA6IDEsXG4gICAgICB5OiBwaW5jaC55ICYmIGRpcmVjdGlvbkVuYWJsZWQobW9kZSwgJ3knLCBjaGFydCkgPyB6b29tUGVyY2VudCA6IDEsXG4gICAgICBmb2NhbFBvaW50OiB7XG4gICAgICAgIHg6IGNlbnRlci54IC0gcmVjdC5sZWZ0LFxuICAgICAgICB5OiBjZW50ZXIueSAtIHJlY3QudG9wXG4gICAgICB9XG4gICAgfTtcblxuICAgIHpvb20oY2hhcnQsIGFtb3VudCk7XG5cbiAgICAvLyBLZWVwIHRyYWNrIG9mIG92ZXJhbGwgc2NhbGVcbiAgICBzdGF0ZS5zY2FsZSA9IGUuc2NhbGU7XG4gIH1cbn1cblxuZnVuY3Rpb24gc3RhcnRQaW5jaChjaGFydCwgc3RhdGUpIHtcbiAgaWYgKHN0YXRlLm9wdGlvbnMuem9vbS5waW5jaC5lbmFibGVkKSB7XG4gICAgc3RhdGUuc2NhbGUgPSAxO1xuICB9XG59XG5cbmZ1bmN0aW9uIGVuZFBpbmNoKGNoYXJ0LCBzdGF0ZSwgZSkge1xuICBpZiAoc3RhdGUuc2NhbGUpIHtcbiAgICBoYW5kbGVQaW5jaChjaGFydCwgc3RhdGUsIGUpO1xuICAgIHN0YXRlLnNjYWxlID0gbnVsbDsgLy8gcmVzZXRcbiAgICBjYWxsYmFjayhzdGF0ZS5vcHRpb25zLnpvb20ub25ab29tQ29tcGxldGUsIFt7Y2hhcnR9XSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaGFuZGxlUGFuKGNoYXJ0LCBzdGF0ZSwgZSkge1xuICBjb25zdCBkZWx0YSA9IHN0YXRlLmRlbHRhO1xuICBpZiAoZGVsdGEpIHtcbiAgICBzdGF0ZS5wYW5uaW5nID0gdHJ1ZTtcbiAgICBwYW4oY2hhcnQsIHt4OiBlLmRlbHRhWCAtIGRlbHRhLngsIHk6IGUuZGVsdGFZIC0gZGVsdGEueX0sIHN0YXRlLnBhblNjYWxlcyk7XG4gICAgc3RhdGUuZGVsdGEgPSB7eDogZS5kZWx0YVgsIHk6IGUuZGVsdGFZfTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzdGFydFBhbihjaGFydCwgc3RhdGUsIGV2ZW50KSB7XG4gIGNvbnN0IHtlbmFibGVkLCBvblBhblN0YXJ0LCBvblBhblJlamVjdGVkfSA9IHN0YXRlLm9wdGlvbnMucGFuO1xuICBpZiAoIWVuYWJsZWQpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgcmVjdCA9IGV2ZW50LnRhcmdldC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgY29uc3QgcG9pbnQgPSB7XG4gICAgeDogZXZlbnQuY2VudGVyLnggLSByZWN0LmxlZnQsXG4gICAgeTogZXZlbnQuY2VudGVyLnkgLSByZWN0LnRvcFxuICB9O1xuXG4gIGlmIChjYWxsYmFjayhvblBhblN0YXJ0LCBbe2NoYXJ0LCBldmVudCwgcG9pbnR9XSkgPT09IGZhbHNlKSB7XG4gICAgcmV0dXJuIGNhbGxiYWNrKG9uUGFuUmVqZWN0ZWQsIFt7Y2hhcnQsIGV2ZW50fV0pO1xuICB9XG5cbiAgc3RhdGUucGFuU2NhbGVzID0gZ2V0RW5hYmxlZFNjYWxlc0J5UG9pbnQoc3RhdGUub3B0aW9ucy5wYW4sIHBvaW50LCBjaGFydCk7XG4gIHN0YXRlLmRlbHRhID0ge3g6IDAsIHk6IDB9O1xuICBjbGVhclRpbWVvdXQoc3RhdGUucGFuRW5kVGltZW91dCk7XG4gIGhhbmRsZVBhbihjaGFydCwgc3RhdGUsIGV2ZW50KTtcbn1cblxuZnVuY3Rpb24gZW5kUGFuKGNoYXJ0LCBzdGF0ZSkge1xuICBzdGF0ZS5kZWx0YSA9IG51bGw7XG4gIGlmIChzdGF0ZS5wYW5uaW5nKSB7XG4gICAgc3RhdGUucGFuRW5kVGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4gKHN0YXRlLnBhbm5pbmcgPSBmYWxzZSksIDUwMCk7XG4gICAgY2FsbGJhY2soc3RhdGUub3B0aW9ucy5wYW4ub25QYW5Db21wbGV0ZSwgW3tjaGFydH1dKTtcbiAgfVxufVxuXG5jb25zdCBoYW1tZXJzID0gbmV3IFdlYWtNYXAoKTtcbmZ1bmN0aW9uIHN0YXJ0SGFtbWVyKGNoYXJ0LCBvcHRpb25zKSB7XG4gIGNvbnN0IHN0YXRlID0gZ2V0U3RhdGUoY2hhcnQpO1xuICBjb25zdCBjYW52YXMgPSBjaGFydC5jYW52YXM7XG4gIGNvbnN0IHtwYW46IHBhbk9wdGlvbnMsIHpvb206IHpvb21PcHRpb25zfSA9IG9wdGlvbnM7XG5cbiAgY29uc3QgbWMgPSBuZXcgSGFtbWVyLk1hbmFnZXIoY2FudmFzKTtcbiAgaWYgKHpvb21PcHRpb25zICYmIHpvb21PcHRpb25zLnBpbmNoLmVuYWJsZWQpIHtcbiAgICBtYy5hZGQobmV3IEhhbW1lci5QaW5jaCgpKTtcbiAgICBtYy5vbigncGluY2hzdGFydCcsICgpID0+IHN0YXJ0UGluY2goY2hhcnQsIHN0YXRlKSk7XG4gICAgbWMub24oJ3BpbmNoJywgKGUpID0+IGhhbmRsZVBpbmNoKGNoYXJ0LCBzdGF0ZSwgZSkpO1xuICAgIG1jLm9uKCdwaW5jaGVuZCcsIChlKSA9PiBlbmRQaW5jaChjaGFydCwgc3RhdGUsIGUpKTtcbiAgfVxuXG4gIGlmIChwYW5PcHRpb25zICYmIHBhbk9wdGlvbnMuZW5hYmxlZCkge1xuICAgIG1jLmFkZChuZXcgSGFtbWVyLlBhbih7XG4gICAgICB0aHJlc2hvbGQ6IHBhbk9wdGlvbnMudGhyZXNob2xkLFxuICAgICAgZW5hYmxlOiBjcmVhdGVFbmFibGVyKGNoYXJ0LCBzdGF0ZSlcbiAgICB9KSk7XG4gICAgbWMub24oJ3BhbnN0YXJ0JywgKGUpID0+IHN0YXJ0UGFuKGNoYXJ0LCBzdGF0ZSwgZSkpO1xuICAgIG1jLm9uKCdwYW5tb3ZlJywgKGUpID0+IGhhbmRsZVBhbihjaGFydCwgc3RhdGUsIGUpKTtcbiAgICBtYy5vbigncGFuZW5kJywgKCkgPT4gZW5kUGFuKGNoYXJ0LCBzdGF0ZSkpO1xuICB9XG5cbiAgaGFtbWVycy5zZXQoY2hhcnQsIG1jKTtcbn1cblxuZnVuY3Rpb24gc3RvcEhhbW1lcihjaGFydCkge1xuICBjb25zdCBtYyA9IGhhbW1lcnMuZ2V0KGNoYXJ0KTtcbiAgaWYgKG1jKSB7XG4gICAgbWMucmVtb3ZlKCdwaW5jaHN0YXJ0Jyk7XG4gICAgbWMucmVtb3ZlKCdwaW5jaCcpO1xuICAgIG1jLnJlbW92ZSgncGluY2hlbmQnKTtcbiAgICBtYy5yZW1vdmUoJ3BhbnN0YXJ0Jyk7XG4gICAgbWMucmVtb3ZlKCdwYW4nKTtcbiAgICBtYy5yZW1vdmUoJ3BhbmVuZCcpO1xuICAgIG1jLmRlc3Ryb3koKTtcbiAgICBoYW1tZXJzLmRlbGV0ZShjaGFydCk7XG4gIH1cbn1cblxudmFyIHZlcnNpb24gPSBcIjIuMC4xXCI7XG5cbmZ1bmN0aW9uIGRyYXcoY2hhcnQsIGNhbGxlciwgb3B0aW9ucykge1xuICBjb25zdCBkcmFnT3B0aW9ucyA9IG9wdGlvbnMuem9vbS5kcmFnO1xuICBjb25zdCB7ZHJhZ1N0YXJ0LCBkcmFnRW5kfSA9IGdldFN0YXRlKGNoYXJ0KTtcblxuICBpZiAoZHJhZ09wdGlvbnMuZHJhd1RpbWUgIT09IGNhbGxlciB8fCAhZHJhZ0VuZCkge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCB7bGVmdCwgdG9wLCB3aWR0aCwgaGVpZ2h0fSA9IGNvbXB1dGVEcmFnUmVjdChjaGFydCwgb3B0aW9ucy56b29tLm1vZGUsIGRyYWdTdGFydCwgZHJhZ0VuZCk7XG4gIGNvbnN0IGN0eCA9IGNoYXJ0LmN0eDtcblxuICBjdHguc2F2ZSgpO1xuICBjdHguYmVnaW5QYXRoKCk7XG4gIGN0eC5maWxsU3R5bGUgPSBkcmFnT3B0aW9ucy5iYWNrZ3JvdW5kQ29sb3IgfHwgJ3JnYmEoMjI1LDIyNSwyMjUsMC4zKSc7XG4gIGN0eC5maWxsUmVjdChsZWZ0LCB0b3AsIHdpZHRoLCBoZWlnaHQpO1xuXG4gIGlmIChkcmFnT3B0aW9ucy5ib3JkZXJXaWR0aCA+IDApIHtcbiAgICBjdHgubGluZVdpZHRoID0gZHJhZ09wdGlvbnMuYm9yZGVyV2lkdGg7XG4gICAgY3R4LnN0cm9rZVN0eWxlID0gZHJhZ09wdGlvbnMuYm9yZGVyQ29sb3IgfHwgJ3JnYmEoMjI1LDIyNSwyMjUpJztcbiAgICBjdHguc3Ryb2tlUmVjdChsZWZ0LCB0b3AsIHdpZHRoLCBoZWlnaHQpO1xuICB9XG4gIGN0eC5yZXN0b3JlKCk7XG59XG5cbnZhciBwbHVnaW4gPSB7XG4gIGlkOiAnem9vbScsXG5cbiAgdmVyc2lvbixcblxuICBkZWZhdWx0czoge1xuICAgIHBhbjoge1xuICAgICAgZW5hYmxlZDogZmFsc2UsXG4gICAgICBtb2RlOiAneHknLFxuICAgICAgdGhyZXNob2xkOiAxMCxcbiAgICAgIG1vZGlmaWVyS2V5OiBudWxsLFxuICAgIH0sXG4gICAgem9vbToge1xuICAgICAgd2hlZWw6IHtcbiAgICAgICAgZW5hYmxlZDogZmFsc2UsXG4gICAgICAgIHNwZWVkOiAwLjEsXG4gICAgICAgIG1vZGlmaWVyS2V5OiBudWxsXG4gICAgICB9LFxuICAgICAgZHJhZzoge1xuICAgICAgICBlbmFibGVkOiBmYWxzZSxcbiAgICAgICAgZHJhd1RpbWU6ICdiZWZvcmVEYXRhc2V0c0RyYXcnLFxuICAgICAgICBtb2RpZmllcktleTogbnVsbFxuICAgICAgfSxcbiAgICAgIHBpbmNoOiB7XG4gICAgICAgIGVuYWJsZWQ6IGZhbHNlXG4gICAgICB9LFxuICAgICAgbW9kZTogJ3h5JyxcbiAgICB9XG4gIH0sXG5cbiAgc3RhcnQ6IGZ1bmN0aW9uKGNoYXJ0LCBfYXJncywgb3B0aW9ucykge1xuICAgIGNvbnN0IHN0YXRlID0gZ2V0U3RhdGUoY2hhcnQpO1xuICAgIHN0YXRlLm9wdGlvbnMgPSBvcHRpb25zO1xuXG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvcHRpb25zLnpvb20sICdlbmFibGVkJykpIHtcbiAgICAgIGNvbnNvbGUud2FybignVGhlIG9wdGlvbiBgem9vbS5lbmFibGVkYCBpcyBubyBsb25nZXIgc3VwcG9ydGVkLiBQbGVhc2UgdXNlIGB6b29tLndoZWVsLmVuYWJsZWRgLCBgem9vbS5kcmFnLmVuYWJsZWRgLCBvciBgem9vbS5waW5jaC5lbmFibGVkYC4nKTtcbiAgICB9XG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvcHRpb25zLnpvb20sICdvdmVyU2NhbGVNb2RlJylcbiAgICAgIHx8IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvcHRpb25zLnBhbiwgJ292ZXJTY2FsZU1vZGUnKSkge1xuICAgICAgY29uc29sZS53YXJuKCdUaGUgb3B0aW9uIGBvdmVyU2NhbGVNb2RlYCBpcyBkZXByZWNhdGVkLiBQbGVhc2UgdXNlIGBzY2FsZU1vZGVgIGluc3RlYWQgKGFuZCB1cGRhdGUgYG1vZGVgIGFzIGRlc2lyZWQpLicpO1xuICAgIH1cblxuICAgIGlmIChIYW1tZXIpIHtcbiAgICAgIHN0YXJ0SGFtbWVyKGNoYXJ0LCBvcHRpb25zKTtcbiAgICB9XG5cbiAgICBjaGFydC5wYW4gPSAoZGVsdGEsIHBhblNjYWxlcywgdHJhbnNpdGlvbikgPT4gcGFuKGNoYXJ0LCBkZWx0YSwgcGFuU2NhbGVzLCB0cmFuc2l0aW9uKTtcbiAgICBjaGFydC56b29tID0gKGFyZ3MsIHRyYW5zaXRpb24pID0+IHpvb20oY2hhcnQsIGFyZ3MsIHRyYW5zaXRpb24pO1xuICAgIGNoYXJ0Lnpvb21SZWN0ID0gKHAwLCBwMSwgdHJhbnNpdGlvbikgPT4gem9vbVJlY3QoY2hhcnQsIHAwLCBwMSwgdHJhbnNpdGlvbik7XG4gICAgY2hhcnQuem9vbVNjYWxlID0gKGlkLCByYW5nZSwgdHJhbnNpdGlvbikgPT4gem9vbVNjYWxlKGNoYXJ0LCBpZCwgcmFuZ2UsIHRyYW5zaXRpb24pO1xuICAgIGNoYXJ0LnJlc2V0Wm9vbSA9ICh0cmFuc2l0aW9uKSA9PiByZXNldFpvb20oY2hhcnQsIHRyYW5zaXRpb24pO1xuICAgIGNoYXJ0LmdldFpvb21MZXZlbCA9ICgpID0+IGdldFpvb21MZXZlbChjaGFydCk7XG4gICAgY2hhcnQuZ2V0SW5pdGlhbFNjYWxlQm91bmRzID0gKCkgPT4gZ2V0SW5pdGlhbFNjYWxlQm91bmRzKGNoYXJ0KTtcbiAgICBjaGFydC5pc1pvb21lZE9yUGFubmVkID0gKCkgPT4gaXNab29tZWRPclBhbm5lZChjaGFydCk7XG4gIH0sXG5cbiAgYmVmb3JlRXZlbnQoY2hhcnQpIHtcbiAgICBjb25zdCBzdGF0ZSA9IGdldFN0YXRlKGNoYXJ0KTtcbiAgICBpZiAoc3RhdGUucGFubmluZyB8fCBzdGF0ZS5kcmFnZ2luZykge1xuICAgICAgLy8gY2FuY2VsIGFueSBldmVudCBoYW5kbGluZyB3aGlsZSBwYW5uaW5nIG9yIGRyYWdnaW5nXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9LFxuXG4gIGJlZm9yZVVwZGF0ZTogZnVuY3Rpb24oY2hhcnQsIGFyZ3MsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBzdGF0ZSA9IGdldFN0YXRlKGNoYXJ0KTtcbiAgICBzdGF0ZS5vcHRpb25zID0gb3B0aW9ucztcbiAgICBhZGRMaXN0ZW5lcnMoY2hhcnQsIG9wdGlvbnMpO1xuICB9LFxuXG4gIGJlZm9yZURhdGFzZXRzRHJhdyhjaGFydCwgX2FyZ3MsIG9wdGlvbnMpIHtcbiAgICBkcmF3KGNoYXJ0LCAnYmVmb3JlRGF0YXNldHNEcmF3Jywgb3B0aW9ucyk7XG4gIH0sXG5cbiAgYWZ0ZXJEYXRhc2V0c0RyYXcoY2hhcnQsIF9hcmdzLCBvcHRpb25zKSB7XG4gICAgZHJhdyhjaGFydCwgJ2FmdGVyRGF0YXNldHNEcmF3Jywgb3B0aW9ucyk7XG4gIH0sXG5cbiAgYmVmb3JlRHJhdyhjaGFydCwgX2FyZ3MsIG9wdGlvbnMpIHtcbiAgICBkcmF3KGNoYXJ0LCAnYmVmb3JlRHJhdycsIG9wdGlvbnMpO1xuICB9LFxuXG4gIGFmdGVyRHJhdyhjaGFydCwgX2FyZ3MsIG9wdGlvbnMpIHtcbiAgICBkcmF3KGNoYXJ0LCAnYWZ0ZXJEcmF3Jywgb3B0aW9ucyk7XG4gIH0sXG5cbiAgc3RvcDogZnVuY3Rpb24oY2hhcnQpIHtcbiAgICByZW1vdmVMaXN0ZW5lcnMoY2hhcnQpO1xuXG4gICAgaWYgKEhhbW1lcikge1xuICAgICAgc3RvcEhhbW1lcihjaGFydCk7XG4gICAgfVxuICAgIHJlbW92ZVN0YXRlKGNoYXJ0KTtcbiAgfSxcblxuICBwYW5GdW5jdGlvbnMsXG4gIHpvb21GdW5jdGlvbnMsXG4gIHpvb21SZWN0RnVuY3Rpb25zLFxufTtcblxuZXhwb3J0IHsgcGx1Z2luIGFzIGRlZmF1bHQsIHBhbiwgcmVzZXRab29tLCB6b29tLCB6b29tUmVjdCwgem9vbVNjYWxlIH07XG4iLCAiaW1wb3J0IHsgTWFya2Rvd25Qb3N0UHJvY2Vzc29yQ29udGV4dCB9IGZyb20gXCJvYnNpZGlhblwiO1xuXG5leHBvcnQgZnVuY3Rpb24gcmVnaXN0ZXJDU1ZUYWJsZVByb2Nlc3Nvcihzb3VyY2U6IHN0cmluZywgZWw6IEhUTUxFbGVtZW50LCBjdHg6IE1hcmtkb3duUG9zdFByb2Nlc3NvckNvbnRleHQpIHtcbiAgICBjb25zdCByYXdDb250ZW50ID0gY3R4LmdldFNlY3Rpb25JbmZvKGVsKTtcbiAgICBjb25zdCBmaXJzdExpbmUgPSByYXdDb250ZW50Py50ZXh0LnNwbGl0KFwiXFxuXCIpW3Jhd0NvbnRlbnQ/LmxpbmVTdGFydF0gPz8gXCJcIjtcbiAgICBjb25zdCBvcHRpb25zID0gZmlyc3RMaW5lLnNwbGl0KFwiIFwiKTtcbiAgICBsZXQgY29sb3JUaGVtZSA9IG9wdGlvbnMubGVuZ3RoID4gMSA/IG9wdGlvbnNbMV0gOiBcIm9yYW5nZVwiO1xuICAgIGNvbG9yVGhlbWUgPSBjb2xvclRoZW1lLnRvTG93ZXJDYXNlKCk7XG5cbiAgICBjb25zdCByb3dzID0gc291cmNlLnNwbGl0KFwiXFxuXCIpLmZpbHRlcihyb3cgPT4gcm93Lmxlbmd0aCA+IDApO1xuXG4gICAgY29uc3QgdGFibGUgPSBlbC5jcmVhdGVFbChcInRhYmxlXCIpO1xuICAgIHRhYmxlLmFkZENsYXNzKGAke2NvbG9yVGhlbWV9LXRoZW1lYCk7XG4gICAgY29uc3QgdGhlYWQgPSB0YWJsZS5jcmVhdGVFbChcInRoZWFkXCIpO1xuICAgIGNvbnN0IHRib2R5ID0gdGFibGUuY3JlYXRlRWwoXCJ0Ym9keVwiKTtcblxuICAgIGNvbnN0IGNzdkRhdGEgPSByb3dzLm1hcChyb3cgPT4gcm93LnNwbGl0KFwiLFwiKSk7XG4gICAgXG4gICAgLy8gQ3JlYXRlIGhlYWRlciByb3cgd2l0aCBjbGlja2FibGUgc29ydGluZyBidXR0b25zXG4gICAgY29uc3QgaGVhZGVyUm93ID0gY3N2RGF0YVswXTtcbiAgICBjb25zdCBoZWFkZXIgPSB0aGVhZC5jcmVhdGVFbChcInRyXCIpO1xuXG4gICAgaGVhZGVyUm93LmZvckVhY2goKGhlYWRlckNlbGwsIGluZGV4KSA9PiB7XG4gICAgICAgIGNvbnN0IHRoID0gaGVhZGVyLmNyZWF0ZUVsKFwidGhcIik7XG4gICAgICAgIHRoLmNyZWF0ZUVsKFwic3BhblwiLCB7IHRleHQ6IGhlYWRlckNlbGwudHJpbSgpIH0pO1xuICAgICAgICBsZXQgc29ydERpcmVjdGlvbiA9ICdhc2MnOyAvLyBkZWZhdWx0IHNvcnRpbmcgb3JkZXJcblxuICAgICAgICB0aC5zdHlsZS5jdXJzb3IgPSBcInBvaW50ZXJcIjsgLy8gbWFrZSBoZWFkZXIgY2xpY2thYmxlXG4gICAgICAgIHRoLm9uY2xpY2sgPSAoKSA9PiB7XG4gICAgICAgICAgICAvLyBUb2dnbGUgc29ydGluZyBkaXJlY3Rpb25cbiAgICAgICAgICAgIHNvcnREaXJlY3Rpb24gPSBzb3J0RGlyZWN0aW9uID09PSAnYXNjJyA/ICdkZXNjJyA6ICdhc2MnO1xuXG4gICAgICAgICAgICAvLyBTb3J0IGRhdGFcbiAgICAgICAgICAgIGNvbnN0IHNvcnRlZFJvd3MgPSBjc3ZEYXRhLnNsaWNlKDEpLnNvcnQoKGEsIGIpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZUEgPSBhW2luZGV4XS50cmltKCk7XG4gICAgICAgICAgICAgICAgY29uc3QgdmFsdWVCID0gYltpbmRleF0udHJpbSgpO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIC8vIFNvcnQgYmFzZWQgb24gbnVtYmVyIG9yIHN0cmluZ1xuICAgICAgICAgICAgICAgIGlmICghaXNOYU4oTnVtYmVyKHZhbHVlQSkpICYmICFpc05hTihOdW1iZXIodmFsdWVCKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNvcnREaXJlY3Rpb24gPT09ICdhc2MnIFxuICAgICAgICAgICAgICAgICAgICAgICAgPyBOdW1iZXIodmFsdWVBKSAtIE51bWJlcih2YWx1ZUIpIFxuICAgICAgICAgICAgICAgICAgICAgICAgOiBOdW1iZXIodmFsdWVCKSAtIE51bWJlcih2YWx1ZUEpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzb3J0RGlyZWN0aW9uID09PSAnYXNjJyBcbiAgICAgICAgICAgICAgICAgICAgICAgID8gdmFsdWVBLmxvY2FsZUNvbXBhcmUodmFsdWVCKSBcbiAgICAgICAgICAgICAgICAgICAgICAgIDogdmFsdWVCLmxvY2FsZUNvbXBhcmUodmFsdWVBKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgLy8gVXBkYXRlIHNvcnQgaWNvblxuICAgICAgICAgICAgdXBkYXRlU29ydEljb25zKGhlYWRlciwgaW5kZXgsIHNvcnREaXJlY3Rpb24pO1xuXG4gICAgICAgICAgICAvLyBDbGVhciBhbmQgcmUtcmVuZGVyIHRhYmxlIGJvZHlcbiAgICAgICAgICAgIHRib2R5LmVtcHR5KCk7XG4gICAgICAgICAgICByZW5kZXJSb3dzKHNvcnRlZFJvd3MsIHRib2R5KTtcbiAgICAgICAgfTtcbiAgICB9KTtcblxuICAgIC8vIFJlbmRlciBpbml0aWFsIGJvZHlcbiAgICByZW5kZXJSb3dzKGNzdkRhdGEuc2xpY2UoMSksIHRib2R5KTtcbn1cblxuLy8gSGVscGVyIGZ1bmN0aW9uIHRvIHJlbmRlciB0YWJsZSByb3dzXG5mdW5jdGlvbiByZW5kZXJSb3dzKHJvd3M6IHN0cmluZ1tdW10sIHRib2R5OiBIVE1MRWxlbWVudCkge1xuICAgIHJvd3MuZm9yRWFjaChyb3dEYXRhID0+IHtcbiAgICAgICAgY29uc3Qgcm93ID0gdGJvZHkuY3JlYXRlRWwoXCJ0clwiKTtcbiAgICAgICAgcm93RGF0YS5mb3JFYWNoKGNlbGxEYXRhID0+IHtcbiAgICAgICAgICAgIHJvdy5jcmVhdGVFbChcInRkXCIsIHsgdGV4dDogY2VsbERhdGEudHJpbSgpIH0pO1xuICAgICAgICB9KTtcbiAgICB9KTtcbn1cblxuLy8gSGVscGVyIGZ1bmN0aW9uIHRvIHVwZGF0ZSBzb3J0aW5nIGljb25zIGluIGhlYWRlcnNcbmZ1bmN0aW9uIHVwZGF0ZVNvcnRJY29ucyhoZWFkZXJSb3c6IEhUTUxFbGVtZW50LCBhY3RpdmVJbmRleDogbnVtYmVyLCBkaXJlY3Rpb246IHN0cmluZykge1xuICAgIGNvbnN0IGhlYWRlcnMgPSBBcnJheS5mcm9tKGhlYWRlclJvdy5jaGlsZHJlbik7XG4gICAgXG4gICAgaGVhZGVycy5mb3JFYWNoKChoZWFkZXIsIGluZGV4KSA9PiB7XG4gICAgICAgIGNvbnN0IGhlYWRlclNwYW4gPSBoZWFkZXIucXVlcnlTZWxlY3RvcihcInNwYW5cIik7XG4gICAgICAgIGlmIChoZWFkZXJTcGFuKSB7XG4gICAgICAgICAgICBpZiAoaW5kZXggPT09IGFjdGl2ZUluZGV4KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyU3Bhbi50ZXh0Q29udGVudCA9IChoZWFkZXJTcGFuLnRleHRDb250ZW50IHx8ICcnKS5yZXBsYWNlKC9cdTI1QjJ8XHUyNUJDLywgJycpICsgKGRpcmVjdGlvbiA9PT0gJ2FzYycgPyAnIFx1MjVCMicgOiAnIFx1MjVCQycpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBSZW1vdmUgc29ydCBpY29ucyBmcm9tIG5vbi1hY3RpdmUgY29sdW1uc1xuICAgICAgICAgICAgICAgIGhlYWRlclNwYW4udGV4dENvbnRlbnQgPSAoaGVhZGVyU3Bhbi50ZXh0Q29udGVudCB8fCAnJykucmVwbGFjZSgvXHUyNUIyfFx1MjVCQy8sICcnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xufVxuIiwgIlxuZXhwb3J0IGZ1bmN0aW9uIGlzVmFsaWRDU1YodGV4dDogc3RyaW5nKTogYm9vbGVhbiB7XG4gICAgY29uc3QgbGluZXMgPSB0ZXh0LnRyaW0oKS5zcGxpdCgnXFxuJyk7XG4gICAgaWYgKGxpbmVzLmxlbmd0aCA8IDIpIHJldHVybiBmYWxzZTtcbiAgICBjb25zdCBoZWFkZXJDb2x1bW5zID0gbGluZXNbMF0uc3BsaXQoJywnKS5sZW5ndGg7XG4gICAgcmV0dXJuIGxpbmVzLmV2ZXJ5KGxpbmUgPT4gbGluZS5zcGxpdCgnLCcpLmxlbmd0aCA9PT0gaGVhZGVyQ29sdW1ucyk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjb252ZXJ0Q1NWVG9NYXJrZG93blRhYmxlKGNzdjogc3RyaW5nKTogc3RyaW5nIHtcbiAgICBjb25zdCBsaW5lcyA9IGNzdi50cmltKCkuc3BsaXQoJ1xcbicpO1xuICAgIGNvbnN0IGhlYWRlcnMgPSBsaW5lc1swXS5zcGxpdCgnLCcpO1xuICAgIGxldCBtYXJrZG93blRhYmxlID0gJ3wgJyArIGhlYWRlcnMubWFwKGhlYWRlciA9PiBoZWFkZXIudHJpbSgpKS5qb2luKCcgfCAnKSArICcgfFxcbic7XG4gICAgbWFya2Rvd25UYWJsZSArPSAnfCcgKyBoZWFkZXJzLm1hcCgoKSA9PiAnLS0tJykuam9pbignfCcpICsgJ3xcXG4nO1xuICAgIGZvciAobGV0IGkgPSAxOyBpIDwgbGluZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgY2VsbHMgPSBsaW5lc1tpXS5zcGxpdCgnLCcpO1xuICAgICAgICBtYXJrZG93blRhYmxlICs9ICd8ICcgKyBjZWxscy5tYXAoY2VsbCA9PiBjZWxsLnRyaW0oKSkuam9pbignIHwgJykgKyAnIHxcXG4nO1xuICAgIH1cbiAgICByZXR1cm4gbWFya2Rvd25UYWJsZTtcbn1cblxuIl0sCiAgIm1hcHBpbmdzIjogIjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFBQSw2Q0FBQUEsU0FBQTtBQUtBLEtBQUMsU0FBU0MsU0FBUUMsV0FBVSxZQUFZQyxZQUFXO0FBQ2pEO0FBRUYsVUFBSSxrQkFBa0IsQ0FBQyxJQUFJLFVBQVUsT0FBTyxNQUFNLE1BQU0sR0FBRztBQUMzRCxVQUFJLGVBQWVELFVBQVMsY0FBYyxLQUFLO0FBRS9DLFVBQUksZ0JBQWdCO0FBRXBCLFVBQUlFLFNBQVEsS0FBSztBQUNqQixVQUFJLE1BQU0sS0FBSztBQUNmLFVBQUksTUFBTSxLQUFLO0FBU2YsZUFBUyxrQkFBa0IsSUFBSSxTQUFTLFNBQVM7QUFDN0MsZUFBTyxXQUFXLE9BQU8sSUFBSSxPQUFPLEdBQUcsT0FBTztBQUFBLE1BQ2xEO0FBV0EsZUFBUyxlQUFlLEtBQUssSUFBSSxTQUFTO0FBQ3RDLFlBQUksTUFBTSxRQUFRLEdBQUcsR0FBRztBQUNwQixVQUFBQyxNQUFLLEtBQUssUUFBUSxFQUFFLEdBQUcsT0FBTztBQUM5QixpQkFBTztBQUFBLFFBQ1g7QUFDQSxlQUFPO0FBQUEsTUFDWDtBQVFBLGVBQVNBLE1BQUssS0FBSyxVQUFVLFNBQVM7QUFDbEMsWUFBSTtBQUVKLFlBQUksQ0FBQyxLQUFLO0FBQ047QUFBQSxRQUNKO0FBRUEsWUFBSSxJQUFJLFNBQVM7QUFDYixjQUFJLFFBQVEsVUFBVSxPQUFPO0FBQUEsUUFDakMsV0FBVyxJQUFJLFdBQVdGLFlBQVc7QUFDakMsY0FBSTtBQUNKLGlCQUFPLElBQUksSUFBSSxRQUFRO0FBQ25CLHFCQUFTLEtBQUssU0FBUyxJQUFJLENBQUMsR0FBRyxHQUFHLEdBQUc7QUFDckM7QUFBQSxVQUNKO0FBQUEsUUFDSixPQUFP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YixNQUFNO0FBQUEsRUFDTixXQUFXO0FBQUEsRUFDWCxNQUFNO0FBQUEsRUFDTixPQUFPO0FBQUEsRUFDUCxRQUFRO0FBQUEsRUFDUixPQUFPO0FBQUEsRUFDUCxjQUFjO0FBQUEsRUFDZCxJQUFJO0FBQUEsRUFDSixTQUFTO0FBQUEsRUFDVCxNQUFNO0FBQUEsRUFDTixXQUFXO0FBQUEsRUFDWCxRQUFRO0FBQUEsRUFDUixVQUFVO0FBQUEsRUFDVixTQUFTO0FBQUEsRUFDVCxLQUFLO0FBQUEsRUFDTCxhQUFhO0FBQUEsRUFDYixTQUFTO0FBQUEsRUFDVCxTQUFTO0FBQUEsRUFDVCxNQUFNO0FBQUEsRUFDTixLQUFLO0FBQUEsRUFDTCxPQUFPO0FBQUEsRUFDUCxTQUFTO0FBQUEsRUFDVCxNQUFNO0FBQUEsRUFDTixNQUFNO0FBQUEsRUFDTixNQUFNO0FBQUEsRUFDTixRQUFRO0FBQUEsRUFDUixTQUFTO0FBQUEsRUFDVCxVQUFVO0FBQUEsRUFDVixRQUFRO0FBQUEsRUFDUixPQUFPO0FBQUEsRUFDUCxLQUFLO0FBQUEsRUFDTCxRQUFRO0FBQUEsRUFDUixRQUFRO0FBQUEsRUFDUixNQUFNO0FBQUEsRUFDTixPQUFPO0FBQUEsRUFDUCxPQUFPO0FBQUEsRUFDUCxLQUFLO0FBQUEsRUFDTCxRQUFRO0FBQUEsRUFDUixRQUFRO0FBQUEsRUFDUixVQUFVO0FBQUEsRUFDVixRQUFRO0FBQUEsRUFDUixRQUFRO0FBQUEsRUFDUixVQUFVO0FBQUEsRUFDVixVQUFVO0FBQUEsRUFDVixVQUFVO0FBQUEsRUFDVixVQUFVO0FBQUEsRUFDVixRQUFRO0FBQUEsRUFDUixTQUFTO0FBQUEsRUFDVCxXQUFXO0FBQUEsRUFDWCxLQUFLO0FBQUEsRUFDTCxRQUFRO0FBQUEsRUFDUixLQUFLO0FBQUEsRUFDTCxLQUFLO0FBQUEsRUFDTCxPQUFPO0FBQUEsRUFDUCxLQUFLO0FBQUEsRUFDTCxTQUFTO0FBQUEsRUFDVCxRQUFRO0FBQUEsRUFDUixTQUFTO0FBQUEsRUFDVCxPQUFPO0FBQUEsRUFDUCxNQUFNO0FBQUEsRUFDTixPQUFPO0FBQUEsRUFDUCxRQUFRO0FBQUEsRUFDUixXQUFXO0FBQUEsRUFDWCxTQUFTO0FBQUEsRUFDVCxZQUFZO0FBQUEsRUFDWixLQUFLO0FBQUEsRUFDTCxNQUFNO0FBQUEsRUFDTixPQUFPO0FBQUEsRUFDUCxXQUFXO0FBQUEsRUFDWCxNQUFNO0FBQUEsRUFDTixNQUFNO0FBQUEsRUFDTixNQUFNO0FBQUEsRUFDTixNQUFNO0FBQUEsRUFDTixRQUFRO0FBQUEsRUFDUixRQUFRO0FBQUEsRUFDUixRQUFRO0FBQUEsRUFDUixPQUFPO0FBQUEsRUFDUCxPQUFPO0FBQUEsRUFDUCxTQUFTO0FBQUEsRUFDVCxLQUFLO0FBQUEsRUFDTCxNQUFNO0FBQUEsRUFDTixTQUFTO0FBQUEsRUFDVCxLQUFLO0FBQUEsRUFDTCxRQUFRO0FBQUEsRUFDUixPQUFPO0FBQUEsRUFDUCxZQUFZO0FBQUEsRUFDWixLQUFLO0FBQUEsRUFDTCxPQUFPO0FBQUEsRUFDUCxRQUFRO0FBQUEsRUFDUixRQUFRO0FBQUEsRUFDUixNQUFNO0FBQUEsRUFDTixXQUFXO0FBQUEsRUFDWCxLQUFLO0FBQUEsRUFDTCxVQUFVO0FBQUEsRUFDVixZQUFZO0FBQUEsRUFDWixTQUFTO0FBQUEsRUFDVCxVQUFVO0FBQUEsRUFDVixTQUFTO0FBQUEsRUFDVCxZQUFZO0FBQUEsRUFDWixNQUFNO0FBQUEsRUFDTixRQUFRO0FBQUEsRUFDUixNQUFNO0FBQUEsRUFDTixTQUFTO0FBQUEsRUFDVCxPQUFPO0FBQUEsRUFDUCxTQUFTO0FBQUEsRUFDVCxNQUFNO0FBQUEsRUFDTixXQUFXO0FBQUEsRUFDWCxRQUFRO0FBQUEsRUFDUixPQUFPO0FBQUEsRUFDUCxZQUFZO0FBQUEsRUFDWixXQUFXO0FBQUEsRUFDWCxTQUFTO0FBQUEsRUFDVCxNQUFNO0FBQUEsRUFDTixLQUFLO0FBQUEsRUFDTCxNQUFNO0FBQUEsRUFDTixTQUFTO0FBQUEsRUFDVCxPQUFPO0FBQUEsRUFDUCxhQUFhO0FBQUEsRUFDYixJQUFJO0FBQUEsRUFDSixVQUFVO0FBQUEsRUFD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QUEsRUFDekU7QUFDQSxTQUFPO0FBQ1g7OztBaEZYQSxJQUFxQixvQkFBckIsY0FBK0Msd0JBQU87QUFBQSxFQUlsRCxNQUFNLFNBQVM7QUFDWCxVQUFNLEtBQUssYUFBYTtBQUd4QixTQUFLLG1DQUFtQyxhQUFhLENBQUMsUUFBUSxJQUFJLFFBQVE7QUFDdEUsZ0NBQTBCLFFBQVEsSUFBSSxLQUFLLFdBQVc7QUFBQSxJQUMxRCxDQUFDO0FBR0QsU0FBSyxtQ0FBbUMsYUFBYSxDQUFDLFFBQVEsSUFBSSxRQUFRO0FBQ3RFLGdDQUEwQixRQUFRLElBQUksR0FBRztBQUFBLElBQzdDLENBQUM7QUFNRCxTQUFLLFdBQVc7QUFBQSxNQUNyQixJQUFJO0FBQUEsTUFDSixNQUFNO0FBQUE7QUFBQSxNQUVHLFNBQVMsQ0FBQztBQUFBLE1BQ25CLGdCQUFnQixDQUFDLFFBQWdCLFNBQXVCO0FBQ3ZELGNBQU0sWUFBWSxPQUFPLGFBQWE7QUFDdEMsWUFBSSxXQUFXLFNBQVMsR0FBRztBQUMxQixnQkFBTSxnQkFBZ0IsMEJBQTBCLFNBQVM7QUFDekQsaUJBQU8saUJBQWlCLGFBQWE7QUFBQSxRQUN0QyxPQUFPO0FBQ04sY0FBSSx3QkFBTyx5Q0FBeUM7QUFBQSxRQUNyRDtBQUFBLE1BQ0Q7QUFBQSxJQUNELENBQUM7QUFHSyxTQUFLLGNBQWMsSUFBSSw0QkFBNEIsS0FBSyxLQUFLLElBQUksQ0FBQztBQUFBLEVBQ3RFO0FBQUEsRUFFQSxNQUFNLGVBQWU7QUFDakIsU0FBSyxXQUFXLE9BQU8sT0FBTyxDQUFDLEdBQUc7QUFBQSxNQUM5QixXQUFXO0FBQUEsSUFDZixHQUFHLE1BQU0sS0FBSyxTQUFTLENBQUM7QUFBQSxFQUM1QjtBQUFBLEVBRUEsTUFBTSxlQUFlO0FBQ2pCLFVBQU0sS0FBSyxTQUFTLEtBQUssUUFBUTtBQUFBLEVBQ3JDO0FBQ0o7IiwKICAibmFtZXMiOiBbIm1vZHVsZSIsICJ3aW5kb3ciLCAiZG9jdW1lbnQiLCAidW5kZWZpbmVkIiwgInJvdW5kIiwgImVhY2giLCAiYXNzaWduIiwgImluZGV4IiwgImV4dGVuZCIsICJtZXJnZSIsICJjYWxsYmFjayIsICJzZWxmIiwgImdldENlbnRlciIsICJIYW1tZXIiLCAiaW1wb3J0X29ic2lkaWFuIiwgInBsdWdpbiIsICJpbXBvcnRfb2JzaWRpYW4iLCAiY29sb3IiLCAibm9vcCIsICJ1aWQiLCAiaWQiLCAiaXNOdWxsT3JVbmRlZiIsICJ2YWx1ZSIsICJpc0FycmF5IiwgIkFycmF5IiwgInR5cGUiLCAiT2JqZWN0IiwgInByb3RvdHlwZSIsICJ0b1N0cmluZyIsICJjYWxsIiwgInNsaWNlIiwgImlzT2JqZWN0IiwgImlzTnVtYmVyRmluaXRlIiwgIk51bWJlciIsICJpc0Zpbml0ZSIsICJmaW5pdGVPckRlZmF1bHQiLCAiZGVmYXVsdFZhbHVlIiwgInZhbHVlT3JEZWZhdWx0IiwgInRvUGVyY2VudGFnZSIsICJkaW1lbnNpb24iLCAiZW5kc1dpdGgiLCAicGFyc2VGbG9hdCIsICJ0b0RpbWVuc2lvbiIsICJjYWxsYmFjayIsICJmbiIsICJhcmdzIiwgInRoaXNBcmciLCAiYXBwbHkiLCAiZWFjaCIsICJsb29wYWJsZSIsICJyZXZlcnNlIiwgImkiLCAibGVuIiwgImtleXMiLCAibGVuZ3RoIiwgIl9lbGVtZW50c0VxdWFsIiwgImEwIiwgImExIiwgImlsZW4iLCAidjAiLCAidjEiLCAiZGF0YXNldEluZGV4IiwgImluZGV4IiwgImNsb25lIiwgInNvdXJjZSIsICJtYXAiLCAidGFyZ2V0IiwgImNyZWF0ZSIsICJrbGVuIiwgImsiLCAiaXNWYWxpZEtleSIsICJrZXkiLCAiaW5kZXhPZiIsICJfbWVyZ2VyIiwgIm9wdGlvbnMiLCAidHZhbCIsICJzdmFsIiwgIm1lcmdlIiwgInNvdXJjZXMiLCAibWVyZ2VyIiwgImN1cnJlbnQiLCAibWVyZ2VJZiIsICJfbWVyZ2VySWYiLCAiaGFzT3duUHJvcGVydHkiLCAia2V5UmVzb2x2ZXJzIiwgInYiLCAieCIsICJvIiwgInkiLCAiX3NwbGl0S2V5IiwgImtleSIsICJwYXJ0cyIsICJzcGxpdCIsICJrZXlzIiwgInRtcCIsICJwYXJ0IiwgImVuZHNXaXRoIiwgInNsaWNlIiwgInB1c2giLCAiX2dldEtleVJlc29sdmVyIiwgIm9iaiIsICJrIiwgInJlc29sdmVPYmplY3RLZXkiLCAicmVzb2x2ZXIiLCAiX2NhcGl0YWxpemUiLCAic3RyIiwgImNoYXJBdCIsICJ0b1VwcGVyQ2FzZSIsICJkZWZpbmVkIiwgInZhbHVlIiwgImlzRnVuY3Rpb24iLCAic2V0c0VxdWFsIiwgImEiLCAiYiIsICJzaXplIiwgIml0ZW0iLCAiaGFzIiwgIl9pc0NsaWNrRXZlbnQiLCAiZSIsICJ0eXBlIiwgIlBJIiwgIk1hdGgiLCAiVEFVIiwgIlBJVEFVIiwgIklORklOSVRZIiwgIk51bWJlciIsICJQT1NJVElWRV9JTkZJTklUWSIsICJSQURfUEVSX0RFRyIsICJIQUxGX1BJIiwgIlFVQVJURVJfUEkiLCAiVFdPX1RISVJEU19QSSIsICJsb2cxMCIsICJzaWduIiwgImFsbW9zdEVxdWFscyIsICJlcHNpbG9uIiwgImFicyIsICJuaWNlTnVtIiwgInJhbmdlIiwgInJvdW5kZWRSYW5nZSIsICJyb3VuZCIsICJuaWNlUmFuZ2UiLCAicG93IiwgImZsb29yIiwgImZyYWN0aW9uIiwgIm5pY2VGcmFjdGlvbiIsICJfZmFjdG9yaXplIiwgInJlc3VsdCIsICJzcXJ0IiwgImkiLCAic29ydCIsICJwb3AiLCAiaXNOdW1iZXIiLCAibiIsICJpc05hTiIsICJwYXJzZUZsb2F0IiwgImlzRmluaXRlIiwgImFsbW9zdFdob2xlIiwgInJvdW5kZWQiLCAiX3NldE1pbkFuZE1heEJ5S2V5IiwgImFycmF5IiwgInRhcmdldCIsICJwcm9wZXJ0eSIsICJpbGVuIiwgImxlbmd0aCIsICJtaW4iLCAibWF4IiwgInRvUmFkaWFucyIsICJkZWdyZWVzIiwgInRvRGVncmVlcyIsICJyYWRpYW5zIiwgIl9kZWNpbWFsUGxhY2VzIiwgImlzRmluaXRlTnVtYmVyIiwgInAiLCAiZ2V0QW5nbGVGcm9tUG9pbnQiLCAiY2VudHJlUG9pbnQiLCAiYW5nbGVQb2ludCIsICJkaXN0YW5jZUZyb21YQ2VudGVyIiwgImRpc3RhbmNlRnJvbVlDZW50ZXIiLCAicmFkaWFsRGlzdGFuY2VGcm9tQ2VudGVyIiwgImFuZ2xlIiwgImF0YW4yIiwgImRpc3RhbmNlIiwgImRpc3RhbmNlQmV0d2VlblBvaW50cyIsICJwdDEiLCAicHQyIiwgIl9hbmdsZURpZmYiLCAiX25vcm1hbGl6ZUFuZ2xlIiwgIl9hbmdsZUJldHdlZW4iLCAic3RhcnQiLCAiZW5kIiwgInNhbWVBbmdsZUlzRnVsbENpcmNsZSIsICJzIiwgImFuZ2xlVG9TdGFydCIsICJhbmdsZVRvRW5kIiwgInN0YXJ0VG9BbmdsZSIsICJlbmRUb0FuZ2xlIiwgIl9saW1pdFZhbHVlIiwgIl9pbnQxNlJhbmdlIiwgIl9pc0JldHdlZW4iLCAiX2xvb2t1cCIsICJ0YWJsZSIsICJjbXAiLCAiaW5kZXgiLCAiaGkiLCAibG8iLCAibWlkIiwgIl9sb29rdXBCeUtleSIsICJsYXN0IiwgInRpIiwgIl9ybG9va3VwQnlLZXkiLCAiX2ZpbHRlckJldHdlZW4iLCAidmFsdWVzIiwgImFycmF5RXZlbnRzIiwgImxpc3RlbkFycmF5RXZlbnRzIiwgImxpc3RlbmVyIiwgIl9jaGFydGpzIiwgImxpc3RlbmVycyIsICJPYmplY3QiLCAiZGVmaW5lUHJvcGVydHkiLCAiY29uZmlndXJhYmxlIiwgImVudW1lcmFibGUiLCAiZm9yRWFjaCIsICJtZXRob2QiLCAiYmFzZSIsICJhcmdzIiwgInJlcyIsICJhcHBseSIsICJvYmplY3QiLCAidW5saXN0ZW5BcnJheUV2ZW50cyIsICJzdHViIiwgImluZGV4T2YiLCAic3BsaWNlIiwgIl9hcnJheVVuaXF1ZSIsICJpdGVtcyIsICJzZXQiLCAiU2V0IiwgIkFycmF5IiwgImZyb20iLCAicmVxdWVzdEFuaW1GcmFtZSIsICJ3aW5kb3ciLCAiY2FsbGJhY2siLCAicmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwgInRocm90dGxlZCIsICJmbiIsICJ0aGlzQXJnIiwgImFyZ3NUb1VzZSIsICJ0aWNraW5nIiwgImFyZ3MiLCAiY2FsbCIsICJhcHBseSIsICJkZWJvdW5jZSIsICJkZWxheSIsICJ0aW1lb3V0IiwgImNsZWFyVGltZW91dCIsICJzZXRUaW1lb3V0IiwgIl90b0xlZnRSaWdodENlbnRlciIsICJhbGlnbiIsICJfYWxpZ25TdGFydEVuZCIsICJzdGFydCIsICJlbmQiLCAiX3RleHRYIiwgImxlZnQiLCAicmlnaHQiLCAicnRsIiwgImNoZWNrIiwgIl9nZXRTdGFydEFuZENvdW50T2ZWaXNpYmxlUG9pbnRzIiwgIm1ldGEiLCAicG9pbnRzIiwgImFuaW1hdGlvbnNEaXNhYmxlZCIsICJwb2ludENvdW50IiwgImxlbmd0aCIsICJjb3VudCIsICJfc29ydGVkIiwgImlTY2FsZSIsICJfcGFyc2VkIiwgImF4aXMiLCAibWluIiwgIm1heCIsICJtaW5EZWZpbmVkIiwgIm1heERlZmluZWQiLCAiZ2V0VXNlckJvdW5kcyIsICJfbGltaXRWYWx1ZSIsICJNYXRoIiwgIl9sb29rdXBCeUtleSIsICJsbyIsICJnZXRQaXhlbEZvclZhbHVlIiwgImhpIiwgIl9zY2FsZVJhbmdlc0NoYW5nZWQiLCAieFNjYWxlIiwgInlTY2FsZSIsICJfc2NhbGVSYW5nZXMiLCAibmV3UmFuZ2VzIiwgInhtaW4iLCAieG1heCIsICJ5bWluIiwgInltYXgiLCAiY2hhbmdlZCIsICJPYmplY3QiLCAiYXNzaWduIiwgImF0RWRnZSIsICJ0IiwgImVsYXN0aWNJbiIsICJzIiwgInAiLCAicG93IiwgInNpbiIsICJUQVUiLCAiZWxhc3RpY091dCIsICJlZmZlY3RzIiwgImxpbmVhciIsICJlYXNlSW5RdWFkIiwgImVhc2VPdXRRdWFkIiwgImVhc2VJbk91dFF1YWQiLCAiZWFzZUluQ3ViaWMiLCAiZWFzZU91dEN1YmljIiwgImVhc2VJbk91dEN1YmljIiwgImVhc2VJblF1YXJ0IiwgImVhc2VPdXRRdWFydCIsICJlYXNlSW5PdXRRdWFydCIsICJlYXNlSW5RdWludCIsICJlYXNlT3V0UXVpbnQiLCAiZWFzZUluT3V0UXVpbnQiLCAiZWFzZUluU2luZSIsICJjb3MiLCAiSEFMRl9QSSIsICJlYXNlT3V0U2luZSIsICJlYXNlSW5PdXRTaW5lIiwgIlBJIiwgImVhc2VJbkV4cG8iLCAiZWFzZU91dEV4cG8iLCAiZWFzZUluT3V0RXhwbyIsICJlYXNlSW5DaXJjIiwgInNxcnQiLCAiZWFzZU91dENpcmMiLCAiZWFzZUluT3V0Q2lyYyIsICJlYXNlSW5FbGFzdGljIiwgImVhc2VPdXRFbGFzdGljIiwgImVhc2VJbk91dEVsYXN0aWMiLCAiZWFzZUluQmFjayIsICJlYXNlT3V0QmFjayIsICJlYXNlSW5PdXRCYWNrIiwgImVhc2VJbkJvdW5jZSIsICJlYXNlT3V0Qm91bmNlIiwgIm0iLCAiZCIsICJlYXNlSW5PdXRCb3VuY2UiLCAiaXNQYXR0ZXJuT3JHcmFkaWVudCIsICJ2YWx1ZSIsICJ0eXBlIiwgInRvU3RyaW5nIiwgImNvbG9yIiwgIkNvbG9yIiwgImdldEhvdmVyQ29sb3IiLCAic2F0dXJhdGUiLCAiZGFya2VuIiwgImhleFN0cmluZyIsICJudW1iZXJzIiwgImNvbG9ycyIsICJhcHBseUFuaW1hdGlvbnNEZWZhdWx0cyIsICJkZWZhdWx0cyIsICJzZXQiLCAidW5kZWZpbmVkIiwgImR1cmF0aW9uIiwgImVhc2luZyIsICJmcm9tIiwgImxvb3AiLCAidG8iLCAiZGVzY3JpYmUiLCAiX2ZhbGxiYWNrIiwgIl9pbmRleGFibGUiLCAiX3NjcmlwdGFibGUiLCAibmFtZSIsICJwcm9wZXJ0aWVzIiwgImFjdGl2ZSIsICJhbmltYXRpb24iLCAicmVzaXplIiwgInNob3ciLCAiYW5pbWF0aW9ucyIsICJ2aXNpYmxlIiwgImhpZGUiLCAidiIsICJhcHBseUxheW91dHNEZWZhdWx0cyIsICJhdXRvUGFkZGluZyIsICJwYWRkaW5nIiwgInRvcCIsICJib3R0b20iLCAiaW50bENhY2hlIiwgIk1hcCIsICJnZXROdW1iZXJGb3JtYXQiLCAibG9jYWxlIiwgIm9wdGlvbnMiLCAiY2FjaGVLZXkiLCAiSlNPTiIsICJzdHJpbmdpZnkiLCAiZm9ybWF0dGVyIiwgImdldCIsICJJbnRsIiwgIk51bWJlckZvcm1hdCIsICJmb3JtYXROdW1iZXIiLCAibnVtIiwgImZvcm1hdCIsICJmb3JtYXR0ZXJzIiwgInZhbHVlcyIsICJpc0FycmF5IiwgIm51bWVyaWMiLCAidGlja1ZhbHVlIiwgImluZGV4IiwgInRpY2tzIiwgImNoYXJ0IiwgIm5vdGF0aW9uIiwgImRlbHRhIiwgIm1heFRpY2siLCAiYWJzIiwgImNhbGN1bGF0ZURlbHRhIiwgImxvZ0RlbHRhIiwgImxvZzEwIiwgIm51bURlY2ltYWwiLCAiaXNOYU4iLCAiZmxvb3IiLCAibWluaW11bUZyYWN0aW9uRGlnaXRzIiwgIm1heGltdW1GcmFjdGlvbkRpZ2l0cyIsICJsb2dhcml0aG1pYyIsICJyZW1haW4iLCAic2lnbmlmaWNhbmQiLCAiaW5jbHVkZXMiLCAiYXBwbHlTY2FsZURlZmF1bHRzIiwgImRpc3BsYXkiLCAib2Zmc2V0IiwgInJldmVyc2UiLCAiYmVnaW5BdFplcm8iLCAiYm91bmRzIiwgImNsaXAiLCAiZ3JhY2UiLCAiZ3JpZCIsICJsaW5lV2lkdGgiLCAiZHJhd09uQ2hhcnRBcmVhIiwgImRyYXdUaWNrcyIsICJ0aWNrTGVuZ3RoIiwgInRpY2tXaWR0aCIsICJfY3R4IiwgInRpY2tDb2xvciIsICJib3JkZXIiLCAiZGFzaCIsICJkYXNoT2Zmc2V0IiwgIndpZHRoIiwgInRpdGxlIiwgInRleHQiLCAibWluUm90YXRpb24iLCAibWF4Um90YXRpb24iLCAibWlycm9yIiwgInRleHRTdHJva2VXaWR0aCIsICJ0ZXh0U3Ryb2tlQ29sb3IiLCAiYXV0b1NraXAiLCAiYXV0b1NraXBQYWRkaW5nIiwgImxhYmVsT2Zmc2V0IiwgIlRpY2tzIiwgIm1pbm9yIiwgIm1ham9yIiwgImNyb3NzQWxpZ24iLCAic2hvd0xhYmVsQmFja2Ryb3AiLCAiYmFja2Ryb3BDb2xvciIsICJiYWNrZHJvcFBhZGRpbmciLCAicm91dGUiLCAic3RhcnRzV2l0aCIsICJvdmVycmlkZXMiLCAiY3JlYXRlIiwgImRlc2NyaXB0b3JzIiwgImdldFNjb3BlIiwgIm5vZGUiLCAia2V5IiwgImtleXMiLCAic3BsaXQiLCAiaSIsICJuIiwgImsiLCAicm9vdCIsICJzY29wZSIsICJtZXJnZSIsICJEZWZhdWx0cyIsICJjb25zdHJ1Y3RvciIsICJfZGVzY3JpcHRvcnMiLCAiX2FwcGxpZXJzIiwgImJhY2tncm91bmRDb2xvciIsICJib3JkZXJDb2xvciIsICJkYXRhc2V0cyIsICJkZXZpY2VQaXhlbFJhdGlvIiwgImNvbnRleHQiLCAicGxhdGZvcm0iLCAiZ2V0RGV2aWNlUGl4ZWxSYXRpbyIsICJlbGVtZW50cyIsICJldmVudHMiLCAiZm9udCIsICJmYW1pbHkiLCAic2l6ZSIsICJzdHlsZSIsICJsaW5lSGVpZ2h0IiwgIndlaWdodCIsICJob3ZlciIsICJob3ZlckJhY2tncm91bmRDb2xvciIsICJjdHgiLCAiaG92ZXJCb3JkZXJDb2xvciIsICJob3ZlckNvbG9yIiwgImluZGV4QXhpcyIsICJpbnRlcmFjdGlvbiIsICJtb2RlIiwgImludGVyc2VjdCIsICJpbmNsdWRlSW52aXNpYmxlIiwgIm1haW50YWluQXNwZWN0UmF0aW8iLCAib25Ib3ZlciIsICJvbkNsaWNrIiwgInBhcnNpbmciLCAicGx1Z2lucyIsICJyZXNwb25zaXZlIiwgInNjYWxlIiwgInNjYWxlcyIsICJzaG93TGluZSIsICJkcmF3QWN0aXZlRWxlbWVudHNPblRvcCIsICJvdmVycmlkZSIsICJ0YXJnZXRTY29wZSIsICJ0YXJnZXROYW1lIiwgInNjb3BlT2JqZWN0IiwgInRhcmdldFNjb3BlT2JqZWN0IiwgInByaXZhdGVOYW1lIiwgImRlZmluZVByb3BlcnRpZXMiLCAid3JpdGFibGUiLCAiZW51bWVyYWJsZSIsICJsb2NhbCIsICJ0YXJnZXQiLCAiaXNPYmplY3QiLCAidmFsdWVPckRlZmF1bHQiLCAiYXBwbGllcnMiLCAiZm9yRWFjaCIsICJ0b0ZvbnRTdHJpbmciLCAiaXNOdWxsT3JVbmRlZiIsICJfbWVhc3VyZVRleHQiLCAiZGF0YSIsICJnYyIsICJsb25nZXN0IiwgInN0cmluZyIsICJ0ZXh0V2lkdGgiLCAibWVhc3VyZVRleHQiLCAicHVzaCIsICJfbG9uZ2VzdFRleHQiLCAiYXJyYXlPZlRoaW5ncyIsICJjYWNoZSIsICJnYXJiYWdlQ29sbGVjdCIsICJzYXZlIiwgImlsZW4iLCAiaiIsICJqbGVuIiwgInRoaW5nIiwgIm5lc3RlZFRoaW5nIiwgInJlc3RvcmUiLCAiZ2NMZW4iLCAic3BsaWNlIiwgIl9hbGlnblBpeGVsIiwgInBpeGVsIiwgImN1cnJlbnREZXZpY2VQaXhlbFJhdGlvIiwgImhhbGZXaWR0aCIsICJyb3VuZCIsICJjbGVhckNhbnZhcyIsICJjYW52YXMiLCAiZ2V0Q29udGV4dCIsICJyZXNldFRyYW5zZm9ybSIsICJjbGVhclJlY3QiLCAiaGVpZ2h0IiwgImRyYXdQb2ludCIsICJ4IiwgInkiLCAiZHJhd1BvaW50TGVnZW5kIiwgInciLCAieE9mZnNldCIsICJ5T2Zmc2V0IiwgImNvcm5lclJhZGl1cyIsICJ4T2Zmc2V0VyIsICJ5T2Zmc2V0VyIsICJwb2ludFN0eWxlIiwgInJvdGF0aW9uIiwgInJhZGl1cyIsICJyYWQiLCAiUkFEX1BFUl9ERUciLCAidHJhbnNsYXRlIiwgInJvdGF0ZSIsICJkcmF3SW1hZ2UiLCAiYmVnaW5QYXRoIiwgImVsbGlwc2UiLCAiYXJjIiwgImNsb3NlUGF0aCIsICJtb3ZlVG8iLCAiVFdPX1RISVJEU19QSSIsICJsaW5lVG8iLCAiUVVBUlRFUl9QSSIsICJTUVJUMV8yIiwgInJlY3QiLCAiZmlsbCIsICJib3JkZXJXaWR0aCIsICJzdHJva2UiLCAiX2lzUG9pbnRJbkFyZWEiLCAicG9pbnQiLCAiYXJlYSIsICJtYXJnaW4iLCAiY2xpcEFyZWEiLCAidW5jbGlwQXJlYSIsICJfc3RlcHBlZExpbmVUbyIsICJwcmV2aW91cyIsICJmbGlwIiwgIm1pZHBvaW50IiwgIl9iZXppZXJDdXJ2ZVRvIiwgImJlemllckN1cnZlVG8iLCAiY3AxeCIsICJjcDJ4IiwgImNwMXkiLCAiY3AyeSIsICJzZXRSZW5kZXJPcHRzIiwgIm9wdHMiLCAidHJhbnNsYXRpb24iLCAiZmlsbFN0eWxlIiwgInRleHRBbGlnbiIsICJ0ZXh0QmFzZWxpbmUiLCAiZGVjb3JhdGVUZXh0IiwgImxpbmUiLCAic3RyaWtldGhyb3VnaCIsICJ1bmRlcmxpbmUiLCAibWV0cmljcyIsICJhY3R1YWxCb3VuZGluZ0JveExlZnQiLCAiYWN0dWFsQm91bmRpbmdCb3hSaWdodCIsICJhY3R1YWxCb3VuZGluZ0JveEFzY2VudCIsICJhY3R1YWxCb3VuZGluZ0JveERlc2NlbnQiLCAieURlY29yYXRpb24iLCAic3Ryb2tlU3R5bGUiLCAiZGVjb3JhdGlvbldpZHRoIiwgImRyYXdCYWNrZHJvcCIsICJvbGRDb2xvciIsICJmaWxsUmVjdCIsICJyZW5kZXJUZXh0IiwgImxpbmVzIiwgInN0cm9rZVdpZHRoIiwgInN0cm9rZUNvbG9yIiwgImJhY2tkcm9wIiwgInN0cm9rZVRleHQiLCAibWF4V2lkdGgiLCAiZmlsbFRleHQiLCAiTnVtYmVyIiwgImFkZFJvdW5kZWRSZWN0UGF0aCIsICJoIiwgInRvcExlZnQiLCAiYm90dG9tTGVmdCIsICJib3R0b21SaWdodCIsICJ0b3BSaWdodCIsICJMSU5FX0hFSUdIVCIsICJGT05UX1NUWUxFIiwgInRvTGluZUhlaWdodCIsICJtYXRjaGVzIiwgIm1hdGNoIiwgIm51bWJlck9yWmVybyIsICJfcmVhZFZhbHVlVG9Qcm9wcyIsICJwcm9wcyIsICJyZXQiLCAib2JqUHJvcHMiLCAicmVhZCIsICJwcm9wIiwgInRvVFJCTCIsICJ0b1RSQkxDb3JuZXJzIiwgInRvUGFkZGluZyIsICJvYmoiLCAidG9Gb250IiwgImZhbGxiYWNrIiwgInBhcnNlSW50IiwgImNvbnNvbGUiLCAid2FybiIsICJyZXNvbHZlIiwgImlucHV0cyIsICJpbmZvIiwgImNhY2hlYWJsZSIsICJfYWRkR3JhY2UiLCAibWlubWF4IiwgImNoYW5nZSIsICJ0b0RpbWVuc2lvbiIsICJrZWVwWmVybyIsICJhZGQiLCAiY3JlYXRlQ29udGV4dCIsICJwYXJlbnRDb250ZXh0IiwgIl9jcmVhdGVSZXNvbHZlciIsICJzY29wZXMiLCAicHJlZml4ZXMiLCAicm9vdFNjb3BlcyIsICJnZXRUYXJnZXQiLCAiZmluYWxSb290U2NvcGVzIiwgIl9yZXNvbHZlIiwgIlN5bWJvbCIsICJ0b1N0cmluZ1RhZyIsICJfY2FjaGVhYmxlIiwgIl9zY29wZXMiLCAiX3Jvb3RTY29wZXMiLCAiX2dldFRhcmdldCIsICJQcm94eSIsICJkZWxldGVQcm9wZXJ0eSIsICJfa2V5cyIsICJfY2FjaGVkIiwgIl9yZXNvbHZlV2l0aFByZWZpeGVzIiwgImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsICJSZWZsZWN0IiwgImdldFByb3RvdHlwZU9mIiwgImhhcyIsICJnZXRLZXlzRnJvbUFsbFNjb3BlcyIsICJvd25LZXlzIiwgInN0b3JhZ2UiLCAiX3N0b3JhZ2UiLCAiX2F0dGFjaENvbnRleHQiLCAicHJveHkiLCAic3ViUHJveHkiLCAiZGVzY3JpcHRvckRlZmF1bHRzIiwgIl9wcm94eSIsICJfY29udGV4dCIsICJfc3ViUHJveHkiLCAiX3N0YWNrIiwgIlNldCIsICJzZXRDb250ZXh0IiwgInJlY2VpdmVyIiwgIl9yZXNvbHZlV2l0aENvbnRleHQiLCAiYWxsS2V5cyIsICJjb25maWd1cmFibGUiLCAic2NyaXB0YWJsZSIsICJpbmRleGFibGUiLCAiX2FsbEtleXMiLCAiaXNTY3JpcHRhYmxlIiwgImlzRnVuY3Rpb24iLCAiaXNJbmRleGFibGUiLCAicmVhZEtleSIsICJwcmVmaXgiLCAiX2NhcGl0YWxpemUiLCAibmVlZHNTdWJSZXNvbHZlciIsICJwcm90b3R5cGUiLCAiaGFzT3duUHJvcGVydHkiLCAiX3Jlc29sdmVTY3JpcHRhYmxlIiwgIl9yZXNvbHZlQXJyYXkiLCAiZ2V0VmFsdWUiLCAiRXJyb3IiLCAiQXJyYXkiLCAiam9pbiIsICJkZWxldGUiLCAiY3JlYXRlU3ViUmVzb2x2ZXIiLCAiYXJyIiwgImZpbHRlciIsICJpdGVtIiwgInJlc29sdmVyIiwgInJlc29sdmVGYWxsYmFjayIsICJwYXJlbnQiLCAicmVzb2x2ZU9iamVjdEtleSIsICJhZGRTY29wZXMiLCAicGFyZW50U2NvcGVzIiwgInBhcmVudEZhbGxiYWNrIiwgImFsbFNjb3BlcyIsICJhZGRTY29wZXNGcm9tS2V5IiwgInN1YkdldFRhcmdldCIsICJyZXNvbHZlS2V5c0Zyb21BbGxTY29wZXMiLCAiX3BhcnNlT2JqZWN0RGF0YVJhZGlhbFNjYWxlIiwgIl9wYXJzaW5nIiwgInBhcnNlZCIsICJyIiwgInBhcnNlIiwgIkVQU0lMT04iLCAiZ2V0UG9pbnQiLCAic2tpcCIsICJnZXRWYWx1ZUF4aXMiLCAic3BsaW5lQ3VydmUiLCAiZmlyc3RQb2ludCIsICJtaWRkbGVQb2ludCIsICJhZnRlclBvaW50IiwgImN1cnJlbnQiLCAibmV4dCIsICJkMDEiLCAiZGlzdGFuY2VCZXR3ZWVuUG9pbnRzIiwgImQxMiIsICJzMDEiLCAiczEyIiwgImZhIiwgImZiIiwgIm1vbm90b25lQWRqdXN0IiwgImRlbHRhSyIsICJtSyIsICJwb2ludHNMZW4iLCAiYWxwaGFLIiwgImJldGFLIiwgInRhdUsiLCAic3F1YXJlZE1hZ25pdHVkZSIsICJwb2ludEN1cnJlbnQiLCAicG9pbnRBZnRlciIsICJhbG1vc3RFcXVhbHMiLCAibW9ub3RvbmVDb21wdXRlIiwgInZhbHVlQXhpcyIsICJwb2ludEJlZm9yZSIsICJpUGl4ZWwiLCAidlBpeGVsIiwgInNwbGluZUN1cnZlTW9ub3RvbmUiLCAic2xvcGVEZWx0YSIsICJzaWduIiwgImNhcENvbnRyb2xQb2ludCIsICJwdCIsICJjYXBCZXppZXJQb2ludHMiLCAiaW5BcmVhIiwgImluQXJlYVByZXYiLCAiaW5BcmVhTmV4dCIsICJfdXBkYXRlQmV6aWVyQ29udHJvbFBvaW50cyIsICJjb250cm9sUG9pbnRzIiwgInNwYW5HYXBzIiwgImN1YmljSW50ZXJwb2xhdGlvbk1vZGUiLCAicHJldiIsICJ0ZW5zaW9uIiwgIl9pc0RvbVN1cHBvcnRlZCIsICJkb2N1bWVudCIsICJfZ2V0UGFyZW50Tm9kZSIsICJkb21Ob2RlIiwgInBhcmVudE5vZGUiLCAiaG9zdCIsICJwYXJzZU1heFN0eWxlIiwgInN0eWxlVmFsdWUiLCAicGFyZW50UHJvcGVydHkiLCAidmFsdWVJblBpeGVscyIsICJpbmRleE9mIiwgImdldENvbXB1dGVkU3R5bGUiLCAiZWxlbWVudCIsICJvd25lckRvY3VtZW50IiwgImRlZmF1bHRWaWV3IiwgImdldFN0eWxlIiwgImVsIiwgInByb3BlcnR5IiwgImdldFByb3BlcnR5VmFsdWUiLCAicG9zaXRpb25zIiwgImdldFBvc2l0aW9uZWRTdHlsZSIsICJzdHlsZXMiLCAic3VmZml4IiwgInJlc3VsdCIsICJwb3MiLCAicGFyc2VGbG9hdCIsICJ1c2VPZmZzZXRQb3MiLCAic2hhZG93Um9vdCIsICJnZXRDYW52YXNQb3NpdGlvbiIsICJlIiwgInRvdWNoZXMiLCAic291cmNlIiwgIm9mZnNldFgiLCAib2Zmc2V0WSIsICJib3giLCAiZ2V0Qm91bmRpbmdDbGllbnRSZWN0IiwgImNsaWVudFgiLCAiY2xpZW50WSIsICJnZXRSZWxhdGl2ZVBvc2l0aW9uIiwgImV2ZW50IiwgImJvcmRlckJveCIsICJib3hTaXppbmciLCAicGFkZGluZ3MiLCAiYm9yZGVycyIsICJnZXRDb250YWluZXJTaXplIiwgIm1heEhlaWdodCIsICJjb250YWluZXIiLCAiY2xpZW50V2lkdGgiLCAiY2xpZW50SGVpZ2h0IiwgImNvbnRhaW5lclN0eWxlIiwgImNvbnRhaW5lckJvcmRlciIsICJjb250YWluZXJQYWRkaW5nIiwgIklORklOSVRZIiwgInJvdW5kMSIsICJnZXRNYXhpbXVtU2l6ZSIsICJiYldpZHRoIiwgImJiSGVpZ2h0IiwgImFzcGVjdFJhdGlvIiwgIm1hcmdpbnMiLCAiY29udGFpbmVyU2l6ZSIsICJtYWludGFpbkhlaWdodCIsICJyZXRpbmFTY2FsZSIsICJmb3JjZVJhdGlvIiwgImZvcmNlU3R5bGUiLCAicGl4ZWxSYXRpbyIsICJkZXZpY2VIZWlnaHQiLCAiZGV2aWNlV2lkdGgiLCAic2V0VHJhbnNmb3JtIiwgInN1cHBvcnRzRXZlbnRMaXN0ZW5lck9wdGlvbnMiLCAicGFzc2l2ZVN1cHBvcnRlZCIsICJwYXNzaXZlIiwgImFkZEV2ZW50TGlzdGVuZXIiLCAicmVtb3ZlRXZlbnRMaXN0ZW5lciIsICJyZWFkVXNlZFNpemUiLCAiX3BvaW50SW5MaW5lIiwgInAxIiwgInAyIiwgIl9zdGVwcGVkSW50ZXJwb2xhdGlvbiIsICJfYmV6aWVySW50ZXJwb2xhdGlvbiIsICJjcDEiLCAiY3AyIiwgImEiLCAiYiIsICJjIiwgImdldFJpZ2h0VG9MZWZ0QWRhcHRlciIsICJyZWN0WCIsICJzZXRXaWR0aCIsICJ4UGx1cyIsICJsZWZ0Rm9yTHRyIiwgIml0ZW1XaWR0aCIsICJnZXRMZWZ0VG9SaWdodEFkYXB0ZXIiLCAiX2l0ZW1XaWR0aCIsICJnZXRSdGxBZGFwdGVyIiwgIm92ZXJyaWRlVGV4dERpcmVjdGlvbiIsICJkaXJlY3Rpb24iLCAib3JpZ2luYWwiLCAiZ2V0UHJvcGVydHlQcmlvcml0eSIsICJzZXRQcm9wZXJ0eSIsICJwcmV2VGV4dERpcmVjdGlvbiIsICJyZXN0b3JlVGV4dERpcmVjdGlvbiIsICJwcm9wZXJ0eUZuIiwgImJldHdlZW4iLCAiX2FuZ2xlQmV0d2VlbiIsICJjb21wYXJlIiwgIl9hbmdsZURpZmYiLCAibm9ybWFsaXplIiwgIl9ub3JtYWxpemVBbmdsZSIsICJfaXNCZXR3ZWVuIiwgIm5vcm1hbGl6ZVNlZ21lbnQiLCAiZ2V0U2VnbWVudCIsICJzZWdtZW50IiwgInN0YXJ0Qm91bmQiLCAiZW5kQm91bmQiLCAiX2JvdW5kU2VnbWVudCIsICJpbnNpZGUiLCAic3ViU3RhcnQiLCAicHJldlZhbHVlIiwgInN0YXJ0SXNCZWZvcmUiLCAiZW5kSXNCZWZvcmUiLCAic2hvdWxkU3RhcnQiLCAic2hvdWxkU3RvcCIsICJfYm91bmRTZWdtZW50cyIsICJzZWdtZW50cyIsICJzdWIiLCAiZmluZFN0YXJ0QW5kRW5kIiwgInNvbGlkU2VnbWVudHMiLCAibGFzdCIsICJjdXIiLCAic3RvcCIsICJfY29tcHV0ZVNlZ21lbnRzIiwgInNlZ21lbnRPcHRpb25zIiwgIl9sb29wIiwgInNwbGl0QnlTdHlsZXMiLCAiY29tcGxldGVMb29wIiwgIl9mdWxsTG9vcCIsICJkb1NwbGl0QnlTdHlsZXMiLCAiY2hhcnRDb250ZXh0IiwgIl9jaGFydCIsICJiYXNlU3R5bGUiLCAicmVhZFN0eWxlIiwgIl9kYXRhc2V0SW5kZXgiLCAiZGF0YXNldEluZGV4IiwgInByZXZTdHlsZSIsICJhZGRTdHlsZSIsICJsIiwgInN0IiwgImRpciIsICJwMCIsICJwMERhdGFJbmRleCIsICJwMURhdGFJbmRleCIsICJzdHlsZUNoYW5nZWQiLCAiYm9yZGVyQ2FwU3R5bGUiLCAiYm9yZGVyRGFzaCIsICJib3JkZXJEYXNoT2Zmc2V0IiwgImJvcmRlckpvaW5TdHlsZSIsICJyZXBsYWNlciIsICJBbmltYXRvciIsICJjb25zdHJ1Y3RvciIsICJfcmVxdWVzdCIsICJfY2hhcnRzIiwgIk1hcCIsICJfcnVubmluZyIsICJfbGFzdERhdGUiLCAidW5kZWZpbmVkIiwgIl9ub3RpZnkiLCAiY2hhcnQiLCAiYW5pbXMiLCAiZGF0ZSIsICJ0eXBlIiwgImNhbGxiYWNrcyIsICJsaXN0ZW5lcnMiLCAibnVtU3RlcHMiLCAiZHVyYXRpb24iLCAiZm9yRWFjaCIsICJmbiIsICJpbml0aWFsIiwgImN1cnJlbnRTdGVwIiwgIk1hdGgiLCAibWluIiwgInN0YXJ0IiwgIl9yZWZyZXNoIiwgInJlcXVlc3RBbmltRnJhbWUiLCAiY2FsbCIsICJ3aW5kb3ciLCAiX3VwZGF0ZSIsICJEYXRlIiwgIm5vdyIsICJyZW1haW5pbmciLCAicnVubmluZyIsICJpdGVtcyIsICJsZW5ndGgiLCAiaSIsICJkcmF3IiwgIml0ZW0iLCAiX2FjdGl2ZSIsICJfdG90YWwiLCAidGljayIsICJwb3AiLCAiX2dldEFuaW1zIiwgImNoYXJ0cyIsICJnZXQiLCAiY29tcGxldGUiLCAicHJvZ3Jlc3MiLCAic2V0IiwgImxpc3RlbiIsICJldmVudCIsICJjYiIsICJwdXNoIiwgImFkZCIsICJoYXMiLCAicmVkdWNlIiwgImFjYyIsICJjdXIiLCAibWF4IiwgIl9kdXJhdGlvbiIsICJzdG9wIiwgImNhbmNlbCIsICJyZW1vdmUiLCAiZGVsZXRlIiwgInRyYW5zcGFyZW50IiwgImludGVycG9sYXRvcnMiLCAiYm9vbGVhbiIsICJmcm9tIiwgInRvIiwgImZhY3RvciIsICJjb2xvciIsICJjMCIsICJoZWxwZXJzQ29sb3IiLCAiYzEiLCAidmFsaWQiLCAibWl4IiwgImhleFN0cmluZyIsICJudW1iZXIiLCAiQW5pbWF0aW9uIiwgImNmZyIsICJ0YXJnZXQiLCAicHJvcCIsICJjdXJyZW50VmFsdWUiLCAicmVzb2x2ZSIsICJfZm4iLCAiX2Vhc2luZyIsICJlZmZlY3RzIiwgImVhc2luZyIsICJsaW5lYXIiLCAiX3N0YXJ0IiwgImZsb29yIiwgImRlbGF5IiwgIl9sb29wIiwgImxvb3AiLCAiX3RhcmdldCIsICJfcHJvcCIsICJfZnJvbSIsICJfdG8iLCAiX3Byb21pc2VzIiwgImFjdGl2ZSIsICJ1cGRhdGUiLCAiZWxhcHNlZCIsICJyZW1haW4iLCAid2FpdCIsICJwcm9taXNlcyIsICJQcm9taXNlIiwgInJlcyIsICJyZWoiLCAicmVzb2x2ZWQiLCAibWV0aG9kIiwgIkFuaW1hdGlvbnMiLCAiY29uZmlnIiwgIl9jaGFydCIsICJfcHJvcGVydGllcyIsICJjb25maWd1cmUiLCAiaXNPYmplY3QiLCAiYW5pbWF0aW9uT3B0aW9ucyIsICJPYmplY3QiLCAia2V5cyIsICJkZWZhdWx0cyIsICJhbmltYXRpb24iLCAiYW5pbWF0ZWRQcm9wcyIsICJnZXRPd25Qcm9wZXJ0eU5hbWVzIiwgImtleSIsICJvcHRpb24iLCAiaXNBcnJheSIsICJwcm9wZXJ0aWVzIiwgIl9hbmltYXRlT3B0aW9ucyIsICJ2YWx1ZXMiLCAibmV3T3B0aW9ucyIsICJvcHRpb25zIiwgInJlc29sdmVUYXJnZXRPcHRpb25zIiwgImFuaW1hdGlvbnMiLCAiX2NyZWF0ZUFuaW1hdGlvbnMiLCAiJHNoYXJlZCIsICJhd2FpdEFsbCIsICIkYW5pbWF0aW9ucyIsICJ0aGVuIiwgInByb3BzIiwgImNoYXJBdCIsICJ2YWx1ZSIsICJzaXplIiwgImFzc2lnbiIsICJhbmltYXRvciIsICJhbmltIiwgImFsbCIsICJzY2FsZUNsaXAiLCAic2NhbGUiLCAiYWxsb3dlZE92ZXJmbG93IiwgIm9wdHMiLCAicmV2ZXJzZSIsICJlbmQiLCAiZGVmYXVsdENsaXAiLCAieFNjYWxlIiwgInlTY2FsZSIsICJ4IiwgInkiLCAidG9wIiwgInJpZ2h0IiwgImJvdHRvbSIsICJsZWZ0IiwgInRvQ2xpcCIsICJ0IiwgInIiLCAiYiIsICJsIiwgImRpc2FibGVkIiwgImdldFNvcnRlZERhdGFzZXRJbmRpY2VzIiwgImZpbHRlclZpc2libGUiLCAibWV0YXNldHMiLCAiX2dldFNvcnRlZERhdGFzZXRNZXRhcyIsICJpbGVuIiwgImluZGV4IiwgImFwcGx5U3RhY2siLCAic3RhY2siLCAiZHNJbmRleCIsICJzaW5nbGVNb2RlIiwgIm1vZGUiLCAiZGF0YXNldEluZGV4IiwgIm90aGVyVmFsdWUiLCAiaXNGaW5pdGUiLCAic2lnbiIsICJjb252ZXJ0T2JqZWN0RGF0YVRvQXJyYXkiLCAiZGF0YSIsICJtZXRhIiwgImlTY2FsZSIsICJ2U2NhbGUiLCAiaUF4aXNLZXkiLCAiYXhpcyIsICJ2QXhpc0tleSIsICJhZGF0YSIsICJBcnJheSIsICJpc1N0YWNrZWQiLCAic3RhY2tlZCIsICJnZXRTdGFja0tleSIsICJpbmRleFNjYWxlIiwgInZhbHVlU2NhbGUiLCAiaWQiLCAiZ2V0VXNlckJvdW5kcyIsICJtaW5EZWZpbmVkIiwgIm1heERlZmluZWQiLCAiTnVtYmVyIiwgIk5FR0FUSVZFX0lORklOSVRZIiwgIlBPU0lUSVZFX0lORklOSVRZIiwgImdldE9yQ3JlYXRlU3RhY2siLCAic3RhY2tzIiwgInN0YWNrS2V5IiwgImluZGV4VmFsdWUiLCAic3ViU3RhY2siLCAiZ2V0TGFzdEluZGV4SW5TdGFjayIsICJwb3NpdGl2ZSIsICJnZXRNYXRjaGluZ1Zpc2libGVNZXRhcyIsICJ1cGRhdGVTdGFja3MiLCAiY29udHJvbGxlciIsICJwYXJzZWQiLCAiX2NhY2hlZE1ldGEiLCAiX3N0YWNrcyIsICJpQXhpcyIsICJ2QXhpcyIsICJpdGVtU3RhY2tzIiwgIl90b3AiLCAiX2JvdHRvbSIsICJ2aXN1YWxWYWx1ZXMiLCAiX3Zpc3VhbFZhbHVlcyIsICJnZXRGaXJzdFNjYWxlSWQiLCAic2NhbGVzIiwgImZpbHRlciIsICJzaGlmdCIsICJjcmVhdGVEYXRhc2V0Q29udGV4dCIsICJwYXJlbnQiLCAiY3JlYXRlQ29udGV4dCIsICJkYXRhc2V0IiwgImNyZWF0ZURhdGFDb250ZXh0IiwgImVsZW1lbnQiLCAiZGF0YUluZGV4IiwgInJhdyIsICJjbGVhclN0YWNrcyIsICJfcGFyc2VkIiwgImlzRGlyZWN0VXBkYXRlTW9kZSIsICJjbG9uZUlmTm90U2hhcmVkIiwgImNhY2hlZCIsICJzaGFyZWQiLCAiY3JlYXRlU3RhY2siLCAiY2FuU3RhY2siLCAiaGlkZGVuIiwgIl9zdGFja2VkIiwgIkRhdGFzZXRDb250cm9sbGVyIiwgIl9jdHgiLCAiY3R4IiwgIl9jYWNoZWREYXRhT3B0cyIsICJnZXRNZXRhIiwgIl90eXBlIiwgIl9wYXJzaW5nIiwgIl9kYXRhIiwgIl9vYmplY3REYXRhIiwgIl9zaGFyZWRPcHRpb25zIiwgIl9kcmF3U3RhcnQiLCAiX2RyYXdDb3VudCIsICJlbmFibGVPcHRpb25TaGFyaW5nIiwgInN1cHBvcnRzRGVjaW1hdGlvbiIsICIkY29udGV4dCIsICJfc3luY0xpc3QiLCAiZGF0YXNldEVsZW1lbnRUeXBlIiwgImRhdGFFbGVtZW50VHlwZSIsICJpbml0aWFsaXplIiwgImxpbmtTY2FsZXMiLCAiYWRkRWxlbWVudHMiLCAiZmlsbCIsICJpc1BsdWdpbkVuYWJsZWQiLCAiY29uc29sZSIsICJ3YXJuIiwgInVwZGF0ZUluZGV4IiwgImdldERhdGFzZXQiLCAiY2hvb3NlSWQiLCAieGlkIiwgInhBeGlzSUQiLCAidmFsdWVPckRlZmF1bHQiLCAieWlkIiwgInlBeGlzSUQiLCAicmlkIiwgInJBeGlzSUQiLCAiaW5kZXhBeGlzIiwgImlpZCIsICJpQXhpc0lEIiwgInZpZCIsICJ2QXhpc0lEIiwgImdldFNjYWxlRm9ySWQiLCAiclNjYWxlIiwgImRhdGFzZXRzIiwgImdldERhdGFzZXRNZXRhIiwgInNjYWxlSUQiLCAiX2dldE90aGVyU2NhbGUiLCAicmVzZXQiLCAiX2Rlc3Ryb3kiLCAidW5saXN0ZW5BcnJheUV2ZW50cyIsICJfZGF0YUNoZWNrIiwgImlzRXh0ZW5zaWJsZSIsICJsaXN0ZW5BcnJheUV2ZW50cyIsICJidWlsZE9yVXBkYXRlRWxlbWVudHMiLCAicmVzZXROZXdFbGVtZW50cyIsICJzdGFja0NoYW5nZWQiLCAib2xkU3RhY2tlZCIsICJfcmVzeW5jRWxlbWVudHMiLCAic2NvcGVLZXlzIiwgImRhdGFzZXRTY29wZUtleXMiLCAic2NvcGVzIiwgImdldE9wdGlvblNjb3BlcyIsICJjcmVhdGVSZXNvbHZlciIsICJnZXRDb250ZXh0IiwgInBhcnNpbmciLCAicGFyc2UiLCAiY291bnQiLCAic29ydGVkIiwgIl9zb3J0ZWQiLCAicHJldiIsICJwYXJzZUFycmF5RGF0YSIsICJwYXJzZU9iamVjdERhdGEiLCAicGFyc2VQcmltaXRpdmVEYXRhIiwgImlzTm90SW5PcmRlckNvbXBhcmVkVG9QcmV2IiwgImxhYmVscyIsICJnZXRMYWJlbHMiLCAic2luZ2xlU2NhbGUiLCAieEF4aXNLZXkiLCAieUF4aXNLZXkiLCAicmVzb2x2ZU9iamVjdEtleSIsICJnZXRQYXJzZWQiLCAiZ2V0RGF0YUVsZW1lbnQiLCAidXBkYXRlUmFuZ2VGcm9tUGFyc2VkIiwgInJhbmdlIiwgInBhcnNlZFZhbHVlIiwgIk5hTiIsICJnZXRNaW5NYXgiLCAib3RoZXJTY2FsZSIsICJvdGhlck1pbiIsICJvdGhlck1heCIsICJfc2tpcCIsICJnZXRBbGxQYXJzZWRWYWx1ZXMiLCAiZ2V0TWF4T3ZlcmZsb3ciLCAiZ2V0TGFiZWxBbmRWYWx1ZSIsICJsYWJlbCIsICJnZXRMYWJlbEZvclZhbHVlIiwgIl9jbGlwIiwgImNsaXAiLCAiZWxlbWVudHMiLCAiYXJlYSIsICJjaGFydEFyZWEiLCAiZHJhd0FjdGl2ZUVsZW1lbnRzT25Ub3AiLCAiZ2V0U3R5bGUiLCAicmVzb2x2ZURhdGFzZXRFbGVtZW50T3B0aW9ucyIsICJyZXNvbHZlRGF0YUVsZW1lbnRPcHRpb25zIiwgImNvbnRleHQiLCAiX3Jlc29sdmVFbGVtZW50T3B0aW9ucyIsICJlbGVtZW50VHlwZSIsICJjYWNoZSIsICJjYWNoZUtleSIsICJzaGFyaW5nIiwgImRlZmluZWQiLCAiZGF0YXNldEVsZW1lbnRTY29wZUtleXMiLCAicHJlZml4ZXMiLCAibmFtZXMiLCAicmVzb2x2ZU5hbWVkT3B0aW9ucyIsICJmcmVlemUiLCAiX3Jlc29sdmVBbmltYXRpb25zIiwgInRyYW5zaXRpb24iLCAiZGF0YXNldEFuaW1hdGlvblNjb3BlS2V5cyIsICJfY2FjaGVhYmxlIiwgImdldFNoYXJlZE9wdGlvbnMiLCAiaW5jbHVkZU9wdGlvbnMiLCAic2hhcmVkT3B0aW9ucyIsICJfYW5pbWF0aW9uc0Rpc2FibGVkIiwgIl9nZXRTaGFyZWRPcHRpb25zIiwgImZpcnN0T3B0cyIsICJwcmV2aW91c2x5U2hhcmVkT3B0aW9ucyIsICJ1cGRhdGVTaGFyZWRPcHRpb25zIiwgInVwZGF0ZUVsZW1lbnQiLCAiX3NldFN0eWxlIiwgInJlbW92ZUhvdmVyU3R5bGUiLCAic2V0SG92ZXJTdHlsZSIsICJfcmVtb3ZlRGF0YXNldEhvdmVyU3R5bGUiLCAiX3NldERhdGFzZXRIb3ZlclN0eWxlIiwgImFyZzEiLCAiYXJnMiIsICJudW1NZXRhIiwgIm51bURhdGEiLCAiX2luc2VydEVsZW1lbnRzIiwgIl9yZW1vdmVFbGVtZW50cyIsICJtb3ZlIiwgImFyciIsICJ1cGRhdGVFbGVtZW50cyIsICJyZW1vdmVkIiwgInNwbGljZSIsICJfc3luYyIsICJhcmdzIiwgIl9kYXRhQ2hhbmdlcyIsICJfb25EYXRhUHVzaCIsICJhcmd1bWVudHMiLCAiX29uRGF0YVBvcCIsICJfb25EYXRhU2hpZnQiLCAiX29uRGF0YVNwbGljZSIsICJuZXdDb3VudCIsICJfb25EYXRhVW5zaGlmdCIsICJnZXRBbGxTY2FsZVZhbHVlcyIsICJfY2FjaGUiLCAiJGJhciIsICJ2aXNpYmxlTWV0YXMiLCAiY29uY2F0IiwgIl9hcnJheVVuaXF1ZSIsICJzb3J0IiwgImEiLCAiY29tcHV0ZU1pblNhbXBsZVNpemUiLCAiX2xlbmd0aCIsICJjdXJyIiwgInVwZGF0ZU1pbkFuZFByZXYiLCAiYWJzIiwgImdldFBpeGVsRm9yVmFsdWUiLCAidGlja3MiLCAiZ2V0UGl4ZWxGb3JUaWNrIiwgImNvbXB1dGVGaXRDYXRlZ29yeVRyYWl0cyIsICJydWxlciIsICJzdGFja0NvdW50IiwgInRoaWNrbmVzcyIsICJiYXJUaGlja25lc3MiLCAicmF0aW8iLCAiaXNOdWxsT3JVbmRlZiIsICJjYXRlZ29yeVBlcmNlbnRhZ2UiLCAiYmFyUGVyY2VudGFnZSIsICJjaHVuayIsICJwaXhlbHMiLCAiY29tcHV0ZUZsZXhDYXRlZ29yeVRyYWl0cyIsICJuZXh0IiwgInBlcmNlbnQiLCAicGFyc2VGbG9hdEJhciIsICJlbnRyeSIsICJzdGFydFZhbHVlIiwgImVuZFZhbHVlIiwgImJhclN0YXJ0IiwgImJhckVuZCIsICJfY3VzdG9tIiwgInBhcnNlVmFsdWUiLCAicGFyc2VBcnJheU9yUHJpbWl0aXZlIiwgImlzRmxvYXRCYXIiLCAiY3VzdG9tIiwgImJhclNpZ24iLCAiYWN0dWFsQmFzZSIsICJpc0hvcml6b250YWwiLCAiYm9yZGVyUHJvcHMiLCAiaG9yaXpvbnRhbCIsICJiYXNlIiwgInNldEJvcmRlclNraXBwZWQiLCAiZWRnZSIsICJib3JkZXJTa2lwcGVkIiwgImVuYWJsZUJvcmRlclJhZGl1cyIsICJwYXJzZUVkZ2UiLCAic3dhcCIsICJzdGFydEVuZCIsICJvcmlnIiwgInYxIiwgInYyIiwgInYiLCAic2V0SW5mbGF0ZUFtb3VudCIsICJpbmZsYXRlQW1vdW50IiwgIkJhckNvbnRyb2xsZXIiLCAib2JqIiwgImJhcnMiLCAiZ2V0QmFzZVBpeGVsIiwgIl9nZXRSdWxlciIsICJ2cGl4ZWxzIiwgImhlYWQiLCAiX2NhbGN1bGF0ZUJhclZhbHVlUGl4ZWxzIiwgImlwaXhlbHMiLCAiX2NhbGN1bGF0ZUJhckluZGV4UGl4ZWxzIiwgImNlbnRlciIsICJoZWlnaHQiLCAid2lkdGgiLCAiX2dldFN0YWNrcyIsICJsYXN0IiwgImdyb3VwZWQiLCAiY3VycmVudFBhcnNlZCIsICJpU2NhbGVWYWx1ZSIsICJza2lwTnVsbCIsICJmaW5kIiwgInZhbCIsICJpc05hTiIsICJpbmRleE9mIiwgIl9nZXRTdGFja0NvdW50IiwgIl9nZXRTdGFja0luZGV4IiwgIm5hbWUiLCAiX3N0YXJ0UGl4ZWwiLCAiX2VuZFBpeGVsIiwgImJhc2VWYWx1ZSIsICJtaW5CYXJMZW5ndGgiLCAiZmxvYXRpbmciLCAiZ2V0RGF0YVZpc2liaWxpdHkiLCAic3RhcnRQaXhlbCIsICJnZXRQaXhlbEZvckRlY2ltYWwiLCAiZW5kUGl4ZWwiLCAiZ2V0VmFsdWVGb3JQaXhlbCIsICJoYWxmR3JpZCIsICJnZXRMaW5lV2lkdGhGb3JWYWx1ZSIsICJtYXhCYXJUaGlja25lc3MiLCAiSW5maW5pdHkiLCAic3RhY2tJbmRleCIsICJyZWN0cyIsICJudW1iZXJzIiwgIm92ZXJyaWRlcyIsICJfaW5kZXhfIiwgIm9mZnNldCIsICJncmlkIiwgIl92YWx1ZV8iLCAiYmVnaW5BdFplcm8iLCAiQnViYmxlQ29udHJvbGxlciIsICJyYWRpdXMiLCAicG9pbnRzIiwgInBvaW50IiwgImlQaXhlbCIsICJ2UGl4ZWwiLCAic2tpcCIsICJnZXRSYXRpb0FuZE9mZnNldCIsICJyb3RhdGlvbiIsICJjaXJjdW1mZXJlbmNlIiwgImN1dG91dCIsICJyYXRpb1giLCAicmF0aW9ZIiwgIm9mZnNldFgiLCAib2Zmc2V0WSIsICJUQVUiLCAic3RhcnRBbmdsZSIsICJlbmRBbmdsZSIsICJzdGFydFgiLCAiY29zIiwgInN0YXJ0WSIsICJzaW4iLCAiZW5kWCIsICJlbmRZIiwgImNhbGNNYXgiLCAiYW5nbGUiLCAiX2FuZ2xlQmV0d2VlbiIsICJjYWxjTWluIiwgIm1heFgiLCAibWF4WSIsICJIQUxGX1BJIiwgIm1pblgiLCAiUEkiLCAibWluWSIsICJEb3VnaG51dENvbnRyb2xsZXIiLCAiaW5uZXJSYWRpdXMiLCAib3V0ZXJSYWRpdXMiLCAiZ2V0dGVyIiwgIl9nZXRSb3RhdGlvbiIsICJ0b1JhZGlhbnMiLCAiX2dldENpcmN1bWZlcmVuY2UiLCAiX2dldFJvdGF0aW9uRXh0ZW50cyIsICJpc0RhdGFzZXRWaXNpYmxlIiwgImFyY3MiLCAic3BhY2luZyIsICJnZXRNYXhCb3JkZXJXaWR0aCIsICJnZXRNYXhPZmZzZXQiLCAibWF4U2l6ZSIsICJ0b1BlcmNlbnRhZ2UiLCAiY2hhcnRXZWlnaHQiLCAiX2dldFJpbmdXZWlnaHQiLCAibWF4V2lkdGgiLCAibWF4SGVpZ2h0IiwgIm1heFJhZGl1cyIsICJ0b0RpbWVuc2lvbiIsICJyYWRpdXNMZW5ndGgiLCAiX2dldFZpc2libGVEYXRhc2V0V2VpZ2h0VG90YWwiLCAidG90YWwiLCAiY2FsY3VsYXRlVG90YWwiLCAiX2dldFJpbmdXZWlnaHRPZmZzZXQiLCAiX2NpcmN1bWZlcmVuY2UiLCAiYW5pbWF0ZVJvdGF0ZSIsICJjYWxjdWxhdGVDaXJjdW1mZXJlbmNlIiwgImFuaW1hdGlvbk9wdHMiLCAiY2VudGVyWCIsICJjZW50ZXJZIiwgImFuaW1hdGVTY2FsZSIsICJhcmMiLCAibWV0YURhdGEiLCAiZm9ybWF0TnVtYmVyIiwgImxvY2FsZSIsICJib3JkZXJBbGlnbiIsICJib3JkZXJXaWR0aCIsICJob3ZlckJvcmRlcldpZHRoIiwgImhvdmVyT2Zmc2V0IiwgInJpbmdXZWlnaHRPZmZzZXQiLCAid2VpZ2h0IiwgImRlc2NyaXB0b3JzIiwgIl9zY3JpcHRhYmxlIiwgIl9pbmRleGFibGUiLCAic3RhcnRzV2l0aCIsICJhc3BlY3RSYXRpbyIsICJwbHVnaW5zIiwgImxlZ2VuZCIsICJnZW5lcmF0ZUxhYmVscyIsICJwb2ludFN0eWxlIiwgIm1hcCIsICJzdHlsZSIsICJ0ZXh0IiwgImZpbGxTdHlsZSIsICJiYWNrZ3JvdW5kQ29sb3IiLCAic3Ryb2tlU3R5bGUiLCAiYm9yZGVyQ29sb3IiLCAiZm9udENvbG9yIiwgImxpbmVXaWR0aCIsICJvbkNsaWNrIiwgImUiLCAibGVnZW5kSXRlbSIsICJ0b2dnbGVEYXRhVmlzaWJpbGl0eSIsICJMaW5lQ29udHJvbGxlciIsICJsaW5lIiwgIl9kYXRhc2V0IiwgImFuaW1hdGlvbnNEaXNhYmxlZCIsICJfZ2V0U3RhcnRBbmRDb3VudE9mVmlzaWJsZVBvaW50cyIsICJfc2NhbGVSYW5nZXNDaGFuZ2VkIiwgIl9kYXRhc2V0SW5kZXgiLCAiX2RlY2ltYXRlZCIsICJzaG93TGluZSIsICJzZWdtZW50IiwgImFuaW1hdGVkIiwgInNwYW5HYXBzIiwgIm1heEdhcExlbmd0aCIsICJpc051bWJlciIsICJkaXJlY3RVcGRhdGUiLCAicG9pbnRzQ291bnQiLCAicHJldlBhcnNlZCIsICJudWxsRGF0YSIsICJib3JkZXIiLCAiZmlyc3RQb2ludCIsICJsYXN0UG9pbnQiLCAidXBkYXRlQ29udHJvbFBvaW50cyIsICJQb2xhckFyZWFDb250cm9sbGVyIiwgIl9wYXJzZU9iamVjdERhdGFSYWRpYWxTY2FsZSIsICJiaW5kIiwgIl91cGRhdGVSYWRpdXMiLCAibWluU2l6ZSIsICJjdXRvdXRQZXJjZW50YWdlIiwgImdldFZpc2libGVEYXRhc2V0Q291bnQiLCAieENlbnRlciIsICJ5Q2VudGVyIiwgImRhdGFzZXRTdGFydEFuZ2xlIiwgImdldEluZGV4QW5nbGUiLCAiZGVmYXVsdEFuZ2xlIiwgImNvdW50VmlzaWJsZUVsZW1lbnRzIiwgIl9jb21wdXRlQW5nbGUiLCAiZ2V0RGlzdGFuY2VGcm9tQ2VudGVyRm9yVmFsdWUiLCAiYW5nbGVMaW5lcyIsICJkaXNwbGF5IiwgImNpcmN1bGFyIiwgInBvaW50TGFiZWxzIiwgIlBpZUNvbnRyb2xsZXIiLCAiUmFkYXJDb250cm9sbGVyIiwgIl9mdWxsTG9vcCIsICJwb2ludFBvc2l0aW9uIiwgImdldFBvaW50UG9zaXRpb25Gb3JWYWx1ZSIsICJTY2F0dGVyQ29udHJvbGxlciIsICJyZWdpc3RyeSIsICJnZXRFbGVtZW50IiwgImludGVyYWN0aW9uIiwgImFic3RyYWN0IiwgIkVycm9yIiwgIkRhdGVBZGFwdGVyQmFzZSIsICJvdmVycmlkZSIsICJtZW1iZXJzIiwgInByb3RvdHlwZSIsICJpbml0IiwgImZvcm1hdHMiLCAiZm9ybWF0IiwgImRpZmYiLCAic3RhcnRPZiIsICJlbmRPZiIsICJfZGF0ZSIsICJiaW5hcnlTZWFyY2giLCAibWV0YXNldCIsICJpbnRlcnNlY3QiLCAibG9va3VwTWV0aG9kIiwgIl9yZXZlcnNlUGl4ZWxzIiwgIl9ybG9va3VwQnlLZXkiLCAiX2xvb2t1cEJ5S2V5IiwgImVsIiwgImdldFJhbmdlIiwgImxvIiwgImhpIiwgImV2YWx1YXRlSW50ZXJhY3Rpb25JdGVtcyIsICJwb3NpdGlvbiIsICJoYW5kbGVyIiwgImdldFNvcnRlZFZpc2libGVEYXRhc2V0TWV0YXMiLCAiaiIsICJnZXREaXN0YW5jZU1ldHJpY0ZvckF4aXMiLCAidXNlWCIsICJ1c2VZIiwgInB0MSIsICJwdDIiLCAiZGVsdGFYIiwgImRlbHRhWSIsICJzcXJ0IiwgInBvdyIsICJnZXRJbnRlcnNlY3RJdGVtcyIsICJ1c2VGaW5hbFBvc2l0aW9uIiwgImluY2x1ZGVJbnZpc2libGUiLCAiaXNQb2ludEluQXJlYSIsICJldmFsdWF0aW9uRnVuYyIsICJfaXNQb2ludEluQXJlYSIsICJpblJhbmdlIiwgImdldE5lYXJlc3RSYWRpYWxJdGVtcyIsICJnZXRQcm9wcyIsICJnZXRBbmdsZUZyb21Qb2ludCIsICJnZXROZWFyZXN0Q2FydGVzaWFuSXRlbXMiLCAiZGlzdGFuY2VNZXRyaWMiLCAibWluRGlzdGFuY2UiLCAiZ2V0Q2VudGVyUG9pbnQiLCAicG9pbnRJbkFyZWEiLCAiZGlzdGFuY2UiLCAiZ2V0TmVhcmVzdEl0ZW1zIiwgImdldEF4aXNJdGVtcyIsICJyYW5nZU1ldGhvZCIsICJpbnRlcnNlY3RzSXRlbSIsICJtb2RlcyIsICJnZXRSZWxhdGl2ZVBvc2l0aW9uIiwgIm5lYXJlc3QiLCAiU1RBVElDX1BPU0lUSU9OUyIsICJmaWx0ZXJCeVBvc2l0aW9uIiwgImFycmF5IiwgInBvcyIsICJmaWx0ZXJEeW5hbWljUG9zaXRpb25CeUF4aXMiLCAiYm94IiwgInNvcnRCeVdlaWdodCIsICJ2MCIsICJ3cmFwQm94ZXMiLCAiYm94ZXMiLCAibGF5b3V0Qm94ZXMiLCAic3RhY2tXZWlnaHQiLCAiYnVpbGRTdGFja3MiLCAibGF5b3V0cyIsICJ3cmFwIiwgImluY2x1ZGVzIiwgIl9zdGFjayIsICJwbGFjZWQiLCAic2V0TGF5b3V0RGltcyIsICJwYXJhbXMiLCAidkJveE1heFdpZHRoIiwgImhCb3hNYXhIZWlnaHQiLCAibGF5b3V0IiwgImZ1bGxTaXplIiwgImF2YWlsYWJsZVdpZHRoIiwgImF2YWlsYWJsZUhlaWdodCIsICJidWlsZExheW91dEJveGVzIiwgImNlbnRlckhvcml6b250YWwiLCAiY2VudGVyVmVydGljYWwiLCAibGVmdEFuZFRvcCIsICJyaWdodEFuZEJvdHRvbSIsICJ2ZXJ0aWNhbCIsICJnZXRDb21iaW5lZE1heCIsICJtYXhQYWRkaW5nIiwgInVwZGF0ZU1heFBhZGRpbmciLCAiYm94UGFkZGluZyIsICJ1cGRhdGVEaW1zIiwgImdldFBhZGRpbmciLCAibmV3V2lkdGgiLCAib3V0ZXJXaWR0aCIsICJuZXdIZWlnaHQiLCAib3V0ZXJIZWlnaHQiLCAid2lkdGhDaGFuZ2VkIiwgInciLCAiaGVpZ2h0Q2hhbmdlZCIsICJoIiwgInNhbWUiLCAib3RoZXIiLCAiaGFuZGxlTWF4UGFkZGluZyIsICJ1cGRhdGVQb3MiLCAiY2hhbmdlIiwgImdldE1hcmdpbnMiLCAibWFyZ2luRm9yUG9zaXRpb25zIiwgInBvc2l0aW9ucyIsICJtYXJnaW4iLCAiZml0Qm94ZXMiLCAicmVmaXRCb3hlcyIsICJyZWZpdCIsICJjaGFuZ2VkIiwgInNldEJveERpbXMiLCAicGxhY2VCb3hlcyIsICJ1c2VyUGFkZGluZyIsICJwYWRkaW5nIiwgImFkZEJveCIsICJfbGF5ZXJzIiwgInoiLCAicmVtb3ZlQm94IiwgImxheW91dEl0ZW0iLCAibWluUGFkZGluZyIsICJ0b1BhZGRpbmciLCAidmVydGljYWxCb3hlcyIsICJob3Jpem9udGFsQm94ZXMiLCAiZWFjaCIsICJiZWZvcmVMYXlvdXQiLCAidmlzaWJsZVZlcnRpY2FsQm94Q291bnQiLCAiQmFzZVBsYXRmb3JtIiwgImFjcXVpcmVDb250ZXh0IiwgImNhbnZhcyIsICJyZWxlYXNlQ29udGV4dCIsICJhZGRFdmVudExpc3RlbmVyIiwgImxpc3RlbmVyIiwgInJlbW92ZUV2ZW50TGlzdGVuZXIiLCAiZ2V0RGV2aWNlUGl4ZWxSYXRpbyIsICJnZXRNYXhpbXVtU2l6ZSIsICJpc0F0dGFjaGVkIiwgInVwZGF0ZUNvbmZpZyIsICJCYXNpY1BsYXRmb3JtIiwgIkVYUEFORE9fS0VZIiwgIkVWRU5UX1RZUEVTIiwgInRvdWNoc3RhcnQiLCAidG91Y2htb3ZlIiwgInRvdWNoZW5kIiwgInBvaW50ZXJlbnRlciIsICJwb2ludGVyZG93biIsICJwb2ludGVybW92ZSIsICJwb2ludGVydXAiLCAicG9pbnRlcmxlYXZlIiwgInBvaW50ZXJvdXQiLCAiaXNOdWxsT3JFbXB0eSIsICJpbml0Q2FudmFzIiwgInJlbmRlckhlaWdodCIsICJnZXRBdHRyaWJ1dGUiLCAicmVuZGVyV2lkdGgiLCAiYm94U2l6aW5nIiwgImRpc3BsYXlXaWR0aCIsICJyZWFkVXNlZFNpemUiLCAiZGlzcGxheUhlaWdodCIsICJldmVudExpc3RlbmVyT3B0aW9ucyIsICJzdXBwb3J0c0V2ZW50TGlzdGVuZXJPcHRpb25zIiwgInBhc3NpdmUiLCAiYWRkTGlzdGVuZXIiLCAibm9kZSIsICJyZW1vdmVMaXN0ZW5lciIsICJmcm9tTmF0aXZlRXZlbnQiLCAibmF0aXZlIiwgIm5vZGVMaXN0Q29udGFpbnMiLCAibm9kZUxpc3QiLCAiY29udGFpbnMiLCAiY3JlYXRlQXR0YWNoT2JzZXJ2ZXIiLCAib2JzZXJ2ZXIiLCAiTXV0YXRpb25PYnNlcnZlciIsICJlbnRyaWVzIiwgInRyaWdnZXIiLCAiYWRkZWROb2RlcyIsICJyZW1vdmVkTm9kZXMiLCAib2JzZXJ2ZSIsICJkb2N1bWVudCIsICJjaGlsZExpc3QiLCAic3VidHJlZSIsICJjcmVhdGVEZXRhY2hPYnNlcnZlciIsICJkcnBMaXN0ZW5pbmdDaGFydHMiLCAib2xkRGV2aWNlUGl4ZWxSYXRpbyIsICJvbldpbmRvd1Jlc2l6ZSIsICJkcHIiLCAiZGV2aWNlUGl4ZWxSYXRpbyIsICJyZXNpemUiLCAiY3VycmVudERldmljZVBpeGVsUmF0aW8iLCAibGlzdGVuRGV2aWNlUGl4ZWxSYXRpb0NoYW5nZXMiLCAidW5saXN0ZW5EZXZpY2VQaXhlbFJhdGlvQ2hhbmdlcyIsICJjcmVhdGVSZXNpemVPYnNlcnZlciIsICJjb250YWluZXIiLCAiX2dldFBhcmVudE5vZGUiLCAidGhyb3R0bGVkIiwgImNsaWVudFdpZHRoIiwgIlJlc2l6ZU9ic2VydmVyIiwgImNvbnRlbnRSZWN0IiwgInJlbGVhc2VPYnNlcnZlciIsICJkaXNjb25uZWN0IiwgImNyZWF0ZVByb3h5QW5kTGlzdGVuIiwgInByb3h5IiwgIkRvbVBsYXRmb3JtIiwgInJlbW92ZUF0dHJpYnV0ZSIsICJzZXRBdHRyaWJ1dGUiLCAicHJveGllcyIsICIkcHJveGllcyIsICJoYW5kbGVycyIsICJhdHRhY2giLCAiZGV0YWNoIiwgImlzQ29ubmVjdGVkIiwgIl9kZXRlY3RQbGF0Zm9ybSIsICJfaXNEb21TdXBwb3J0ZWQiLCAiT2Zmc2NyZWVuQ2FudmFzIiwgIkVsZW1lbnQiLCAidG9vbHRpcFBvc2l0aW9uIiwgImhhc1ZhbHVlIiwgImZpbmFsIiwgInJldCIsICJkZWZhdWx0Um91dGVzIiwgImF1dG9Ta2lwIiwgInRpY2tPcHRzIiwgImRldGVybWluZWRNYXhUaWNrcyIsICJkZXRlcm1pbmVNYXhUaWNrcyIsICJ0aWNrc0xpbWl0IiwgIm1heFRpY2tzTGltaXQiLCAibWFqb3JJbmRpY2VzIiwgIm1ham9yIiwgImVuYWJsZWQiLCAiZ2V0TWFqb3JJbmRpY2VzIiwgIm51bU1ham9ySW5kaWNlcyIsICJmaXJzdCIsICJuZXdUaWNrcyIsICJza2lwTWFqb3JzIiwgImNhbGN1bGF0ZVNwYWNpbmciLCAiYXZnTWFqb3JTcGFjaW5nIiwgInJvdW5kIiwgInRpY2tMZW5ndGgiLCAiX3RpY2tTaXplIiwgIm1heFNjYWxlIiwgIm1heENoYXJ0IiwgIl9tYXhMZW5ndGgiLCAiZXZlbk1ham9yU3BhY2luZyIsICJnZXRFdmVuU3BhY2luZyIsICJmYWN0b3JzIiwgIl9mYWN0b3JpemUiLCAicmVzdWx0IiwgImNlaWwiLCAibWFqb3JTdGFydCIsICJtYWpvckVuZCIsICJsZW4iLCAicmV2ZXJzZUFsaWduIiwgImFsaWduIiwgIm9mZnNldEZyb21FZGdlIiwgImdldFRpY2tzTGltaXQiLCAidGlja3NMZW5ndGgiLCAic2FtcGxlIiwgIm51bUl0ZW1zIiwgImluY3JlbWVudCIsICJnZXRQaXhlbEZvckdyaWRMaW5lIiwgIm9mZnNldEdyaWRMaW5lcyIsICJ2YWxpZEluZGV4IiwgImVwc2lsb24iLCAibGluZVZhbHVlIiwgImdhcmJhZ2VDb2xsZWN0IiwgImNhY2hlcyIsICJnYyIsICJnY0xlbiIsICJnZXRUaWNrTWFya0xlbmd0aCIsICJkcmF3VGlja3MiLCAiZ2V0VGl0bGVIZWlnaHQiLCAiZmFsbGJhY2siLCAiZm9udCIsICJ0b0ZvbnQiLCAibGluZXMiLCAibGluZUhlaWdodCIsICJjcmVhdGVTY2FsZUNvbnRleHQiLCAiY3JlYXRlVGlja0NvbnRleHQiLCAidGl0bGVBbGlnbiIsICJfdG9MZWZ0UmlnaHRDZW50ZXIiLCAidGl0bGVBcmdzIiwgInRpdGxlWCIsICJ0aXRsZVkiLCAiX2FsaWduU3RhcnRFbmQiLCAicG9zaXRpb25BeGlzSUQiLCAiU2NhbGUiLCAiX21hcmdpbnMiLCAicGFkZGluZ1RvcCIsICJwYWRkaW5nQm90dG9tIiwgInBhZGRpbmdMZWZ0IiwgInBhZGRpbmdSaWdodCIsICJsYWJlbFJvdGF0aW9uIiwgIl9yYW5nZSIsICJfZ3JpZExpbmVJdGVtcyIsICJfbGFiZWxJdGVtcyIsICJfbGFiZWxTaXplcyIsICJfbG9uZ2VzdFRleHRDYWNoZSIsICJfdXNlck1heCIsICJfdXNlck1pbiIsICJfc3VnZ2VzdGVkTWF4IiwgIl9zdWdnZXN0ZWRNaW4iLCAiX3RpY2tzTGVuZ3RoIiwgIl9ib3JkZXJWYWx1ZSIsICJfZGF0YUxpbWl0c0NhY2hlZCIsICJzZXRDb250ZXh0IiwgInN1Z2dlc3RlZE1pbiIsICJzdWdnZXN0ZWRNYXgiLCAiZmluaXRlT3JEZWZhdWx0IiwgIm1ldGFzIiwgImdldFRpY2tzIiwgInhMYWJlbHMiLCAieUxhYmVscyIsICJnZXRMYWJlbEl0ZW1zIiwgIl9jb21wdXRlTGFiZWxJdGVtcyIsICJiZWZvcmVVcGRhdGUiLCAibWFyZ2lucyIsICJncmFjZSIsICJzYW1wbGVTaXplIiwgImJlZm9yZVNldERpbWVuc2lvbnMiLCAic2V0RGltZW5zaW9ucyIsICJhZnRlclNldERpbWVuc2lvbnMiLCAiYmVmb3JlRGF0YUxpbWl0cyIsICJkZXRlcm1pbmVEYXRhTGltaXRzIiwgImFmdGVyRGF0YUxpbWl0cyIsICJfYWRkR3JhY2UiLCAiYmVmb3JlQnVpbGRUaWNrcyIsICJidWlsZFRpY2tzIiwgImFmdGVyQnVpbGRUaWNrcyIsICJzYW1wbGluZ0VuYWJsZWQiLCAiX2NvbnZlcnRUaWNrc1RvTGFiZWxzIiwgImJlZm9yZUNhbGN1bGF0ZUxhYmVsUm90YXRpb24iLCAiY2FsY3VsYXRlTGFiZWxSb3RhdGlvbiIsICJhZnRlckNhbGN1bGF0ZUxhYmVsUm90YXRpb24iLCAic291cmNlIiwgImFmdGVyQXV0b1NraXAiLCAiYmVmb3JlRml0IiwgImZpdCIsICJhZnRlckZpdCIsICJhZnRlclVwZGF0ZSIsICJyZXZlcnNlUGl4ZWxzIiwgIl9hbGlnblRvUGl4ZWxzIiwgImFsaWduVG9QaXhlbHMiLCAiX2NhbGxIb29rcyIsICJub3RpZnlQbHVnaW5zIiwgImJlZm9yZVRpY2tUb0xhYmVsQ29udmVyc2lvbiIsICJnZW5lcmF0ZVRpY2tMYWJlbHMiLCAiY2FsbGJhY2siLCAiYWZ0ZXJUaWNrVG9MYWJlbENvbnZlcnNpb24iLCAibnVtVGlja3MiLCAibWluUm90YXRpb24iLCAibWF4Um90YXRpb24iLCAidGlja1dpZHRoIiwgIm1heExhYmVsRGlhZ29uYWwiLCAiX2lzVmlzaWJsZSIsICJsYWJlbFNpemVzIiwgIl9nZXRMYWJlbFNpemVzIiwgIm1heExhYmVsV2lkdGgiLCAid2lkZXN0IiwgIm1heExhYmVsSGVpZ2h0IiwgImhpZ2hlc3QiLCAiX2xpbWl0VmFsdWUiLCAidGl0bGUiLCAidG9EZWdyZWVzIiwgImFzaW4iLCAidGl0bGVPcHRzIiwgImdyaWRPcHRzIiwgInRpdGxlSGVpZ2h0IiwgInRpY2tQYWRkaW5nIiwgImFuZ2xlUmFkaWFucyIsICJsYWJlbEhlaWdodCIsICJtaXJyb3IiLCAibGFiZWxXaWR0aCIsICJfY2FsY3VsYXRlUGFkZGluZyIsICJfaGFuZGxlTWFyZ2lucyIsICJpc1JvdGF0ZWQiLCAibGFiZWxzQmVsb3dUaWNrcyIsICJvZmZzZXRMZWZ0IiwgIm9mZnNldFJpZ2h0IiwgImlzRnVsbFNpemUiLCAiX2NvbXB1dGVMYWJlbFNpemVzIiwgIndpZHRocyIsICJoZWlnaHRzIiwgIndpZGVzdExhYmVsU2l6ZSIsICJoaWdoZXN0TGFiZWxTaXplIiwgImpsZW4iLCAidGlja0ZvbnQiLCAiZm9udFN0cmluZyIsICJuZXN0ZWRMYWJlbCIsICJfcmVzb2x2ZVRpY2tGb250T3B0aW9ucyIsICJzdHJpbmciLCAiX21lYXN1cmVUZXh0IiwgInZhbHVlQXQiLCAiaWR4IiwgInBpeGVsIiwgImRlY2ltYWwiLCAiX2ludDE2UmFuZ2UiLCAiX2FsaWduUGl4ZWwiLCAiZ2V0RGVjaW1hbEZvclBpeGVsIiwgImdldEJhc2VWYWx1ZSIsICJvcHRpb25UaWNrcyIsICJyb3QiLCAiYXV0b1NraXBQYWRkaW5nIiwgIl9jb21wdXRlR3JpZExpbmVJdGVtcyIsICJ0bCIsICJib3JkZXJPcHRzIiwgImF4aXNXaWR0aCIsICJheGlzSGFsZldpZHRoIiwgImFsaWduQm9yZGVyVmFsdWUiLCAiYm9yZGVyVmFsdWUiLCAiYWxpZ25lZExpbmVWYWx1ZSIsICJ0eDEiLCAidHkxIiwgInR4MiIsICJ0eTIiLCAieDEiLCAieTEiLCAieDIiLCAieTIiLCAibGltaXQiLCAic3RlcCIsICJvcHRzQXRJbmRleCIsICJvcHRzQXRJbmRleEJvcmRlciIsICJsaW5lQ29sb3IiLCAiYm9yZGVyRGFzaCIsICJkYXNoIiwgImJvcmRlckRhc2hPZmZzZXQiLCAiZGFzaE9mZnNldCIsICJ0aWNrQ29sb3IiLCAidGlja0JvcmRlckRhc2giLCAidGlja0JvcmRlckRhc2hPZmZzZXQiLCAiY3Jvc3NBbGlnbiIsICJ0aWNrQW5kUGFkZGluZyIsICJoVGlja0FuZFBhZGRpbmciLCAidGV4dEFsaWduIiwgImxpbmVDb3VudCIsICJ0ZXh0T2Zmc2V0IiwgInRleHRCYXNlbGluZSIsICJfZ2V0WEF4aXNMYWJlbEFsaWdubWVudCIsICJfZ2V0WUF4aXNMYWJlbEFsaWdubWVudCIsICJsYWJlbE9mZnNldCIsICJoYWxmQ291bnQiLCAic3Ryb2tlQ29sb3IiLCAidGV4dFN0cm9rZUNvbG9yIiwgInN0cm9rZVdpZHRoIiwgInRleHRTdHJva2VXaWR0aCIsICJ0aWNrVGV4dEFsaWduIiwgInNob3dMYWJlbEJhY2tkcm9wIiwgImJhY2tkcm9wIiwgImxhYmVsUGFkZGluZyIsICJiYWNrZHJvcFBhZGRpbmciLCAiYmFja2Ryb3BDb2xvciIsICJ0cmFuc2xhdGlvbiIsICJfY29tcHV0ZUxhYmVsQXJlYSIsICJkcmF3QmFja2dyb3VuZCIsICJzYXZlIiwgImZpbGxSZWN0IiwgInJlc3RvcmUiLCAiZmluZEluZGV4IiwgImRyYXdHcmlkIiwgImRyYXdMaW5lIiwgInAxIiwgInAyIiwgInNldExpbmVEYXNoIiwgImxpbmVEYXNoT2Zmc2V0IiwgImJlZ2luUGF0aCIsICJtb3ZlVG8iLCAibGluZVRvIiwgInN0cm9rZSIsICJkcmF3T25DaGFydEFyZWEiLCAiZHJhd0JvcmRlciIsICJsYXN0TGluZVdpZHRoIiwgImRyYXdMYWJlbHMiLCAiY2xpcEFyZWEiLCAicmVuZGVyVGV4dE9wdGlvbnMiLCAicmVuZGVyVGV4dCIsICJ1bmNsaXBBcmVhIiwgImRyYXdUaXRsZSIsICJ0eiIsICJneiIsICJieiIsICJheGlzSUQiLCAiX21heERpZ2l0cyIsICJmb250U2l6ZSIsICJUeXBlZFJlZ2lzdHJ5IiwgInNjb3BlIiwgImNyZWF0ZSIsICJpc0ZvclR5cGUiLCAiaXNQcm90b3R5cGVPZiIsICJyZWdpc3RlciIsICJwcm90byIsICJnZXRQcm90b3R5cGVPZiIsICJwYXJlbnRTY29wZSIsICJpc0lDaGFydENvbXBvbmVudCIsICJyZWdpc3RlckRlZmF1bHRzIiwgInVucmVnaXN0ZXIiLCAiaXRlbURlZmF1bHRzIiwgIm1lcmdlIiwgInJvdXRlRGVmYXVsdHMiLCAiZGVzY3JpYmUiLCAicm91dGVzIiwgInByb3BlcnR5IiwgInByb3BlcnR5UGFydHMiLCAic3BsaXQiLCAic291cmNlTmFtZSIsICJzb3VyY2VTY29wZSIsICJqb2luIiwgInBhcnRzIiwgInRhcmdldE5hbWUiLCAidGFyZ2V0U2NvcGUiLCAicm91dGUiLCAiUmVnaXN0cnkiLCAiY29udHJvbGxlcnMiLCAiX3R5cGVkUmVnaXN0cmllcyIsICJfZWFjaCIsICJhZGRDb250cm9sbGVycyIsICJhZGRQbHVnaW5zIiwgImFkZFNjYWxlcyIsICJnZXRDb250cm9sbGVyIiwgIl9nZXQiLCAiZ2V0UGx1Z2luIiwgImdldFNjYWxlIiwgInJlbW92ZUNvbnRyb2xsZXJzIiwgInJlbW92ZUVsZW1lbnRzIiwgInJlbW92ZVBsdWdpbnMiLCAicmVtb3ZlU2NhbGVzIiwgInR5cGVkUmVnaXN0cnkiLCAiYXJnIiwgInJlZyIsICJfZ2V0UmVnaXN0cnlGb3JUeXBlIiwgIl9leGVjIiwgIml0ZW1SZWciLCAiY29tcG9uZW50IiwgImNhbWVsTWV0aG9kIiwgIl9jYXBpdGFsaXplIiwgIlBsdWdpblNlcnZpY2UiLCAiX2luaXQiLCAibm90aWZ5IiwgImhvb2siLCAiX2NyZWF0ZURlc2NyaXB0b3JzIiwgIl9kZXNjcmlwdG9ycyIsICJkZXNjcmlwdG9yIiwgInBsdWdpbiIsICJjYWxsQ2FsbGJhY2siLCAiY2FuY2VsYWJsZSIsICJpbnZhbGlkYXRlIiwgIl9vbGRDYWNoZSIsICJfbm90aWZ5U3RhdGVDaGFuZ2VzIiwgImFsbFBsdWdpbnMiLCAiY3JlYXRlRGVzY3JpcHRvcnMiLCAicHJldmlvdXNEZXNjcmlwdG9ycyIsICJzb21lIiwgImxvY2FsSWRzIiwgImxvY2FsIiwgImdldE9wdHMiLCAicGx1Z2luT3B0cyIsICJwbHVnaW5TY29wZUtleXMiLCAic2NyaXB0YWJsZSIsICJpbmRleGFibGUiLCAiYWxsS2V5cyIsICJnZXRJbmRleEF4aXMiLCAiZGF0YXNldERlZmF1bHRzIiwgImRhdGFzZXRPcHRpb25zIiwgImdldEF4aXNGcm9tRGVmYXVsdFNjYWxlSUQiLCAiZ2V0RGVmYXVsdFNjYWxlSURGcm9tQXhpcyIsICJpZE1hdGNoZXNBeGlzIiwgImF4aXNGcm9tUG9zaXRpb24iLCAiZGV0ZXJtaW5lQXhpcyIsICJzY2FsZU9wdGlvbnMiLCAidG9Mb3dlckNhc2UiLCAiZ2V0QXhpc0Zyb21EYXRhc2V0IiwgInJldHJpZXZlQXhpc0Zyb21EYXRhc2V0cyIsICJib3VuZERzIiwgImQiLCAibWVyZ2VTY2FsZUNvbmZpZyIsICJjaGFydERlZmF1bHRzIiwgImNvbmZpZ1NjYWxlcyIsICJjaGFydEluZGV4QXhpcyIsICJzY2FsZUNvbmYiLCAiZXJyb3IiLCAiX3Byb3h5IiwgImRlZmF1bHRJZCIsICJkZWZhdWx0U2NhbGVPcHRpb25zIiwgIm1lcmdlSWYiLCAiZGVmYXVsdElEIiwgImluaXRPcHRpb25zIiwgImluaXREYXRhIiwgImluaXRDb25maWciLCAia2V5Q2FjaGUiLCAia2V5c0NhY2hlZCIsICJTZXQiLCAiY2FjaGVkS2V5cyIsICJnZW5lcmF0ZSIsICJhZGRJZkZvdW5kIiwgIkNvbmZpZyIsICJfY29uZmlnIiwgIl9zY29wZUNhY2hlIiwgIl9yZXNvbHZlckNhY2hlIiwgInBsYXRmb3JtIiwgImNsZWFyQ2FjaGUiLCAiY2xlYXIiLCAiZGF0YXNldFR5cGUiLCAiYWRkaXRpb25hbE9wdGlvblNjb3BlcyIsICJfY2FjaGVkU2NvcGVzIiwgIm1haW5TY29wZSIsICJyZXNldENhY2hlIiwgImtleUxpc3RzIiwgImNoYXJ0T3B0aW9uU2NvcGVzIiwgInJlc29sdmVyIiwgInN1YlByZWZpeGVzIiwgImdldFJlc29sdmVyIiwgIm5lZWRDb250ZXh0IiwgImlzRnVuY3Rpb24iLCAic3ViUmVzb2x2ZXIiLCAiX2F0dGFjaENvbnRleHQiLCAiZGVzY3JpcHRvckRlZmF1bHRzIiwgInJlc29sdmVyQ2FjaGUiLCAiX2NyZWF0ZVJlc29sdmVyIiwgInAiLCAiaGFzRnVuY3Rpb24iLCAiaXNTY3JpcHRhYmxlIiwgImlzSW5kZXhhYmxlIiwgIktOT1dOX1BPU0lUSU9OUyIsICJwb3NpdGlvbklzSG9yaXpvbnRhbCIsICJjb21wYXJlMkxldmVsIiwgImwxIiwgImwyIiwgIm9uQW5pbWF0aW9uc0NvbXBsZXRlIiwgIm9uQ29tcGxldGUiLCAib25BbmltYXRpb25Qcm9ncmVzcyIsICJvblByb2dyZXNzIiwgImdldENhbnZhcyIsICJnZXRFbGVtZW50QnlJZCIsICJpbnN0YW5jZXMiLCAiZ2V0Q2hhcnQiLCAiYyIsICJtb3ZlTnVtZXJpY0tleXMiLCAiaW50S2V5IiwgImRldGVybWluZUxhc3RFdmVudCIsICJsYXN0RXZlbnQiLCAiaW5DaGFydEFyZWEiLCAiaXNDbGljayIsICJnZXRTaXplRm9yQXJlYSIsICJmaWVsZCIsICJnZXREYXRhc2V0QXJlYSIsICJDaGFydCIsICJpbnZhbGlkYXRlUGx1Z2lucyIsICJ1c2VyQ29uZmlnIiwgImluaXRpYWxDYW52YXMiLCAiZXhpc3RpbmdDaGFydCIsICJ1aWQiLCAiX29wdGlvbnMiLCAiX2FzcGVjdFJhdGlvIiwgIl9tZXRhc2V0cyIsICJfbGFzdEV2ZW50IiwgIl9saXN0ZW5lcnMiLCAiX3Jlc3BvbnNpdmVMaXN0ZW5lcnMiLCAiX3NvcnRlZE1ldGFzZXRzIiwgIl9wbHVnaW5zIiwgIl9oaWRkZW5JbmRpY2VzIiwgImF0dGFjaGVkIiwgIl9kb1Jlc2l6ZSIsICJkZWJvdW5jZSIsICJyZXNpemVEZWxheSIsICJfaW5pdGlhbGl6ZSIsICJtYWludGFpbkFzcGVjdFJhdGlvIiwgInJlc3BvbnNpdmUiLCAicmV0aW5hU2NhbGUiLCAiYmluZEV2ZW50cyIsICJjbGVhckNhbnZhcyIsICJfcmVzaXplIiwgIl9yZXNpemVCZWZvcmVEcmF3IiwgIm5ld1NpemUiLCAibmV3UmF0aW8iLCAib25SZXNpemUiLCAicmVuZGVyIiwgImVuc3VyZVNjYWxlc0hhdmVJRHMiLCAic2NhbGVzT3B0aW9ucyIsICJheGlzT3B0aW9ucyIsICJidWlsZE9yVXBkYXRlU2NhbGVzIiwgInNjYWxlT3B0cyIsICJ1cGRhdGVkIiwgImlzUmFkaWFsIiwgImRwb3NpdGlvbiIsICJkdHlwZSIsICJzY2FsZVR5cGUiLCAic2NhbGVDbGFzcyIsICJoYXNVcGRhdGVkIiwgIl91cGRhdGVNZXRhc2V0cyIsICJfZGVzdHJveURhdGFzZXRNZXRhIiwgInNsaWNlIiwgIl9yZW1vdmVVbnJlZmVyZW5jZWRNZXRhc2V0cyIsICJidWlsZE9yVXBkYXRlQ29udHJvbGxlcnMiLCAibmV3Q29udHJvbGxlcnMiLCAib3JkZXIiLCAidmlzaWJsZSIsICJDb250cm9sbGVyQ2xhc3MiLCAiX3Jlc2V0RWxlbWVudHMiLCAiYW5pbXNEaXNhYmxlZCIsICJfdXBkYXRlU2NhbGVzIiwgIl9jaGVja0V2ZW50QmluZGluZ3MiLCAiX3VwZGF0ZUhpZGRlbkluZGljZXMiLCAiX21pblBhZGRpbmciLCAiYXV0b1BhZGRpbmciLCAiX3VwZGF0ZUxheW91dCIsICJfdXBkYXRlRGF0YXNldHMiLCAiX2V2ZW50SGFuZGxlciIsICJfdXBkYXRlSG92ZXJTdHlsZXMiLCAiZXhpc3RpbmdFdmVudHMiLCAibmV3RXZlbnRzIiwgImV2ZW50cyIsICJzZXRzRXF1YWwiLCAidW5iaW5kRXZlbnRzIiwgImNoYW5nZXMiLCAiX2dldFVuaWZvcm1EYXRhQ2hhbmdlcyIsICJkYXRhc2V0Q291bnQiLCAibWFrZVNldCIsICJjaGFuZ2VTZXQiLCAibm9BcmVhIiwgIl9pZHgiLCAiX3VwZGF0ZURhdGFzZXQiLCAibGF5ZXJzIiwgIl9kcmF3RGF0YXNldHMiLCAiX2RyYXdEYXRhc2V0IiwgInVzZUNsaXAiLCAiZ2V0RWxlbWVudHNBdEV2ZW50Rm9yTW9kZSIsICJJbnRlcmFjdGlvbiIsICJzZXREYXRhc2V0VmlzaWJpbGl0eSIsICJfdXBkYXRlVmlzaWJpbGl0eSIsICJoaWRlIiwgInNob3ciLCAiX3N0b3AiLCAiZGVzdHJveSIsICJ0b0Jhc2U2NEltYWdlIiwgInRvRGF0YVVSTCIsICJiaW5kVXNlckV2ZW50cyIsICJiaW5kUmVzcG9uc2l2ZUV2ZW50cyIsICJfYWRkIiwgIl9yZW1vdmUiLCAiZGV0YWNoZWQiLCAidXBkYXRlSG92ZXJTdHlsZSIsICJwcmVmaXgiLCAiZ2V0QWN0aXZlRWxlbWVudHMiLCAic2V0QWN0aXZlRWxlbWVudHMiLCAiYWN0aXZlRWxlbWVudHMiLCAibGFzdEFjdGl2ZSIsICJfZWxlbWVudHNFcXVhbCIsICJwbHVnaW5JZCIsICJyZXBsYXkiLCAiaG92ZXJPcHRpb25zIiwgImhvdmVyIiwgImRlYWN0aXZhdGVkIiwgImFjdGl2YXRlZCIsICJldmVudEZpbHRlciIsICJfaGFuZGxlRXZlbnQiLCAiX2dldEFjdGl2ZUVsZW1lbnRzIiwgIl9pc0NsaWNrRXZlbnQiLCAib25Ib3ZlciIsICJ2ZXJzaW9uIiwgImNsaXBBcmMiLCAicGl4ZWxNYXJnaW4iLCAiYW5nbGVNYXJnaW4iLCAiY2xvc2VQYXRoIiwgInRvUmFkaXVzQ29ybmVycyIsICJfcmVhZFZhbHVlVG9Qcm9wcyIsICJwYXJzZUJvcmRlclJhZGl1cyIsICJhbmdsZURlbHRhIiwgIm8iLCAiYm9yZGVyUmFkaXVzIiwgImhhbGZUaGlja25lc3MiLCAiaW5uZXJMaW1pdCIsICJjb21wdXRlT3V0ZXJMaW1pdCIsICJvdXRlckFyY0xpbWl0IiwgIm91dGVyU3RhcnQiLCAib3V0ZXJFbmQiLCAiaW5uZXJTdGFydCIsICJpbm5lckVuZCIsICJyVGhldGFUb1hZIiwgInRoZXRhIiwgInBhdGhBcmMiLCAiaW5uZXJSIiwgInNwYWNpbmdPZmZzZXQiLCAiYWxwaGEiLCAibm9TcGFjaW5nSW5uZXJSYWRpdXMiLCAibm9TcGFjaW5nT3V0ZXJSYWRpdXMiLCAiYXZOb2dTcGFjaW5nUmFkaXVzIiwgImFkanVzdGVkQW5nbGUiLCAiYmV0YSIsICJhbmdsZU9mZnNldCIsICJvdXRlclN0YXJ0QWRqdXN0ZWRSYWRpdXMiLCAib3V0ZXJFbmRBZGp1c3RlZFJhZGl1cyIsICJvdXRlclN0YXJ0QWRqdXN0ZWRBbmdsZSIsICJvdXRlckVuZEFkanVzdGVkQW5nbGUiLCAiaW5uZXJTdGFydEFkanVzdGVkUmFkaXVzIiwgImlubmVyRW5kQWRqdXN0ZWRSYWRpdXMiLCAiaW5uZXJTdGFydEFkanVzdGVkQW5nbGUiLCAiaW5uZXJFbmRBZGp1c3RlZEFuZ2xlIiwgIm91dGVyTWlkQWRqdXN0ZWRBbmdsZSIsICJwQ2VudGVyIiwgInA0IiwgImlubmVyTWlkQWRqdXN0ZWRBbmdsZSIsICJwOCIsICJvdXRlclN0YXJ0WCIsICJvdXRlclN0YXJ0WSIsICJvdXRlckVuZFgiLCAib3V0ZXJFbmRZIiwgImRyYXdBcmMiLCAiZnVsbENpcmNsZXMiLCAiYm9yZGVySm9pblN0eWxlIiwgImlubmVyIiwgImxpbmVKb2luIiwgIkFyY0VsZW1lbnQiLCAiY2hhcnRYIiwgImNoYXJ0WSIsICJyQWRqdXN0IiwgIm5vblplcm9CZXR3ZWVuIiwgImJldHdlZW5BbmdsZXMiLCAid2l0aGluUmFkaXVzIiwgIl9pc0JldHdlZW4iLCAiaGFsZkFuZ2xlIiwgImhhbGZSYWRpdXMiLCAidHJhbnNsYXRlIiwgImZpeCIsICJyYWRpdXNPZmZzZXQiLCAic2V0U3R5bGUiLCAibGluZUNhcCIsICJib3JkZXJDYXBTdHlsZSIsICJwcmV2aW91cyIsICJnZXRMaW5lTWV0aG9kIiwgInN0ZXBwZWQiLCAiX3N0ZXBwZWRMaW5lVG8iLCAidGVuc2lvbiIsICJjdWJpY0ludGVycG9sYXRpb25Nb2RlIiwgIl9iZXppZXJDdXJ2ZVRvIiwgInBhdGhWYXJzIiwgInBhcmFtc1N0YXJ0IiwgInBhcmFtc0VuZCIsICJzZWdtZW50U3RhcnQiLCAic2VnbWVudEVuZCIsICJvdXRzaWRlIiwgInBhdGhTZWdtZW50IiwgImxpbmVNZXRob2QiLCAiZmFzdFBhdGhTZWdtZW50IiwgImF2Z1giLCAiY291bnRYIiwgInByZXZYIiwgImxhc3RZIiwgInBvaW50SW5kZXgiLCAiZHJhd1giLCAidHJ1bmNYIiwgIl9nZXRTZWdtZW50TWV0aG9kIiwgInVzZUZhc3RQYXRoIiwgIl9nZXRJbnRlcnBvbGF0aW9uTWV0aG9kIiwgIl9zdGVwcGVkSW50ZXJwb2xhdGlvbiIsICJfYmV6aWVySW50ZXJwb2xhdGlvbiIsICJfcG9pbnRJbkxpbmUiLCAic3Ryb2tlUGF0aFdpdGhDYWNoZSIsICJwYXRoIiwgIl9wYXRoIiwgIlBhdGgyRCIsICJzdHJva2VQYXRoRGlyZWN0IiwgInNlZ21lbnRzIiwgInNlZ21lbnRNZXRob2QiLCAidXNlUGF0aDJEIiwgIkxpbmVFbGVtZW50IiwgIl9wb2ludHMiLCAiX3NlZ21lbnRzIiwgIl9wb2ludHNVcGRhdGVkIiwgIl91cGRhdGVCZXppZXJDb250cm9sUG9pbnRzIiwgIl9jb21wdXRlU2VnbWVudHMiLCAiaW50ZXJwb2xhdGUiLCAiX2JvdW5kU2VnbWVudHMiLCAiX2ludGVycG9sYXRlIiwgImludGVycG9sYXRlZCIsICJjYXBCZXppZXJQb2ludHMiLCAiaGl0UmFkaXVzIiwgIlBvaW50RWxlbWVudCIsICJtb3VzZVgiLCAibW91c2VZIiwgImluWFJhbmdlIiwgImluWVJhbmdlIiwgImhvdmVyUmFkaXVzIiwgImRyYXdQb2ludCIsICJnZXRCYXJCb3VuZHMiLCAiYmFyIiwgImhhbGYiLCAic2tpcE9yTGltaXQiLCAicGFyc2VCb3JkZXJXaWR0aCIsICJtYXhXIiwgIm1heEgiLCAidG9UUkJMIiwgInRvVFJCTENvcm5lcnMiLCAibWF4UiIsICJlbmFibGVCb3JkZXIiLCAidG9wTGVmdCIsICJ0b3BSaWdodCIsICJib3R0b21MZWZ0IiwgImJvdHRvbVJpZ2h0IiwgImJvdW5kaW5nUmVjdHMiLCAiYm91bmRzIiwgIm91dGVyIiwgInNraXBYIiwgInNraXBZIiwgInNraXBCb3RoIiwgImhhc1JhZGl1cyIsICJhZGROb3JtYWxSZWN0UGF0aCIsICJyZWN0IiwgImluZmxhdGVSZWN0IiwgImFtb3VudCIsICJyZWZSZWN0IiwgIkJhckVsZW1lbnQiLCAiYWRkUmVjdFBhdGgiLCAiYWRkUm91bmRlZFJlY3RQYXRoIiwgIkJPUkRFUl9DT0xPUlMiLCAiQkFDS0dST1VORF9DT0xPUlMiLCAicmVwbGFjZSIsICJnZXRCb3JkZXJDb2xvciIsICJnZXRCYWNrZ3JvdW5kQ29sb3IiLCAiY29sb3JpemVEZWZhdWx0RGF0YXNldCIsICJjb2xvcml6ZURvdWdobnV0RGF0YXNldCIsICJjb2xvcml6ZVBvbGFyQXJlYURhdGFzZXQiLCAiZ2V0Q29sb3JpemVyIiwgImNvbnRhaW5zQ29sb3JzRGVmaW5pdGlvbnMiLCAiayIsICJjb250YWluc0NvbG9yc0RlZmluaXRpb24iLCAiZm9yY2VPdmVycmlkZSIsICJfYXJncyIsICJjaGFydE9wdGlvbnMiLCAiY29sb3JpemVyIiwgImx0dGJEZWNpbWF0aW9uIiwgInNhbXBsZXMiLCAiZGVjaW1hdGVkIiwgImJ1Y2tldFdpZHRoIiwgInNhbXBsZWRJbmRleCIsICJlbmRJbmRleCIsICJtYXhBcmVhUG9pbnQiLCAibWF4QXJlYSIsICJuZXh0QSIsICJhdmdZIiwgImF2Z1JhbmdlU3RhcnQiLCAiYXZnUmFuZ2VFbmQiLCAiYXZnUmFuZ2VMZW5ndGgiLCAicmFuZ2VPZmZzIiwgInJhbmdlVG8iLCAicG9pbnRBeCIsICJwb2ludEF5IiwgIm1pbk1heERlY2ltYXRpb24iLCAibWluSW5kZXgiLCAibWF4SW5kZXgiLCAic3RhcnRJbmRleCIsICJ4TWluIiwgInhNYXgiLCAiZHgiLCAibGFzdEluZGV4IiwgImludGVybWVkaWF0ZUluZGV4MSIsICJpbnRlcm1lZGlhdGVJbmRleDIiLCAiY2xlYW5EZWNpbWF0ZWREYXRhc2V0IiwgImRlZmluZVByb3BlcnR5IiwgImNvbmZpZ3VyYWJsZSIsICJlbnVtZXJhYmxlIiwgIndyaXRhYmxlIiwgImNsZWFuRGVjaW1hdGVkRGF0YSIsICJnZXRTdGFydEFuZENvdW50T2ZWaXNpYmxlUG9pbnRzU2ltcGxpZmllZCIsICJwb2ludENvdW50IiwgImFsZ29yaXRobSIsICJiZWZvcmVFbGVtZW50c1VwZGF0ZSIsICJ4QXhpcyIsICJ0aHJlc2hvbGQiLCAidHBvaW50cyIsICJfZmluZFNlZ21lbnRFbmQiLCAiX2dldEJvdW5kcyIsICJ0YXJnZXRTZWdtZW50cyIsICJ0Z3QiLCAic3ViQm91bmRzIiwgImZpbGxTb3VyY2VzIiwgIl9ib3VuZFNlZ21lbnQiLCAiZmlsbFNvdXJjZSIsICJfZ2V0RWRnZSIsICJfbm9ybWFsaXplQW5nbGUiLCAiX3BvaW50c0Zyb21TZWdtZW50cyIsICJib3VuZGFyeSIsICJsaW5lUG9pbnRzIiwgIl9jcmVhdGVCb3VuZGFyeUxpbmUiLCAiX3Nob3VsZEFwcGx5RmlsbCIsICJfcmVzb2x2ZVRhcmdldCIsICJzb3VyY2VzIiwgInByb3BhZ2F0ZSIsICJ2aXNpdGVkIiwgIl9kZWNvZGVGaWxsIiwgInBhcnNlRmlsbE9wdGlvbiIsICJwYXJzZUZsb2F0IiwgImRlY29kZVRhcmdldEluZGV4IiwgImZpcnN0Q2giLCAiX2dldFRhcmdldFBpeGVsIiwgIl9nZXRUYXJnZXRWYWx1ZSIsICJmaWxsT3B0aW9uIiwgIl9idWlsZFN0YWNrTGluZSIsICJzb3VyY2VQb2ludHMiLCAibGluZXNCZWxvdyIsICJnZXRMaW5lc0JlbG93IiwgImFkZFBvaW50c0JlbG93IiwgImJlbG93IiwgInVuc2hpZnQiLCAic291cmNlUG9pbnQiLCAicG9zdHBvbmVkIiwgImZpbmRQb2ludCIsICJwb2ludFZhbHVlIiwgImZpcnN0VmFsdWUiLCAibGFzdFZhbHVlIiwgInNpbXBsZUFyYyIsICJfZ2V0VGFyZ2V0IiwgImdldExpbmVCeUluZGV4IiwgImNvbXB1dGVCb3VuZGFyeSIsICJjb21wdXRlQ2lyY3VsYXJCb3VuZGFyeSIsICJjb21wdXRlTGluZWFyQm91bmRhcnkiLCAiX2RyYXdmaWxsIiwgImxpbmVPcHRzIiwgImFib3ZlIiwgImRvRmlsbCIsICJjbGlwVmVydGljYWwiLCAiY2xpcFkiLCAibGluZUxvb3AiLCAic3JjIiwgIm5vdFNoYXBlIiwgImNsaXBCb3VuZHMiLCAiaW50ZXJwb2xhdGVkTGluZVRvIiwgInRhcmdldExvb3AiLCAiaW50ZXJwb2xhdGVkUG9pbnQiLCAiYWZ0ZXJEYXRhc2V0c1VwZGF0ZSIsICIkZmlsbGVyIiwgImJlZm9yZURyYXciLCAiZHJhd1RpbWUiLCAiYmVmb3JlRGF0YXNldHNEcmF3IiwgImJlZm9yZURhdGFzZXREcmF3IiwgImdldEJveFNpemUiLCAibGFiZWxPcHRzIiwgImJveEhlaWdodCIsICJib3hXaWR0aCIsICJ1c2VQb2ludFN0eWxlIiwgInBvaW50U3R5bGVXaWR0aCIsICJpdGVtSGVpZ2h0IiwgIml0ZW1zRXF1YWwiLCAiTGVnZW5kIiwgIl9hZGRlZCIsICJsZWdlbmRIaXRCb3hlcyIsICJfaG92ZXJlZEl0ZW0iLCAiZG91Z2hudXRNb2RlIiwgImxlZ2VuZEl0ZW1zIiwgImNvbHVtblNpemVzIiwgImxpbmVXaWR0aHMiLCAiYnVpbGRMYWJlbHMiLCAibGFiZWxGb250IiwgIl9jb21wdXRlVGl0bGVIZWlnaHQiLCAiX2ZpdFJvd3MiLCAiX2ZpdENvbHMiLCAiaGl0Ym94ZXMiLCAidG90YWxIZWlnaHQiLCAicm93IiwgIml0ZW1XaWR0aCIsICJtZWFzdXJlVGV4dCIsICJfaXRlbUhlaWdodCIsICJoZWlnaHRMaW1pdCIsICJ0b3RhbFdpZHRoIiwgImN1cnJlbnRDb2xXaWR0aCIsICJjdXJyZW50Q29sSGVpZ2h0IiwgImNvbCIsICJjYWxjdWxhdGVJdGVtU2l6ZSIsICJhZGp1c3RIaXRCb3hlcyIsICJydGwiLCAicnRsSGVscGVyIiwgImdldFJ0bEFkYXB0ZXIiLCAiaGl0Ym94IiwgImxlZnRGb3JMdHIiLCAiX2RyYXciLCAiZGVmYXVsdENvbG9yIiwgImhhbGZGb250U2l6ZSIsICJjdXJzb3IiLCAiZHJhd0xlZ2VuZEJveCIsICJsaW5lRGFzaCIsICJkcmF3T3B0aW9ucyIsICJTUVJUMiIsICJ4UGx1cyIsICJkcmF3UG9pbnRMZWdlbmQiLCAieUJveFRvcCIsICJ4Qm94TGVmdCIsICJmaWxsVGV4dCIsICJzdHJpa2V0aHJvdWdoIiwgIm92ZXJyaWRlVGV4dERpcmVjdGlvbiIsICJ0ZXh0RGlyZWN0aW9uIiwgInRleHRXaWR0aCIsICJzZXRXaWR0aCIsICJyZWFsWCIsICJfdGV4dFgiLCAiZm9udExpbmVIZWlnaHQiLCAiY2FsY3VsYXRlTGVnZW5kSXRlbUhlaWdodCIsICJyZXN0b3JlVGV4dERpcmVjdGlvbiIsICJ0aXRsZUZvbnQiLCAidGl0bGVQYWRkaW5nIiwgInRvcFBhZGRpbmdQbHVzSGFsZkZvbnRTaXplIiwgIl9nZXRMZWdlbmRJdGVtQXQiLCAiaGl0Qm94IiwgImxoIiwgImhhbmRsZUV2ZW50IiwgImlzTGlzdGVuZWQiLCAiaG92ZXJlZEl0ZW0iLCAic2FtZUl0ZW0iLCAib25MZWF2ZSIsICJjYWxjdWxhdGVJdGVtV2lkdGgiLCAiY2FsY3VsYXRlSXRlbUhlaWdodCIsICJsZWdlbmRJdGVtVGV4dCIsICJfZWxlbWVudCIsICJhZnRlckV2ZW50IiwgImNpIiwgInVzZUJvcmRlclJhZGl1cyIsICJUaXRsZSIsICJfcGFkZGluZyIsICJ0ZXh0U2l6ZSIsICJfZHJhd0FyZ3MiLCAiZm9udE9wdHMiLCAiY3JlYXRlVGl0bGUiLCAidGl0bGVCbG9jayIsICJXZWFrTWFwIiwgInBvc2l0aW9uZXJzIiwgImF2ZXJhZ2UiLCAieFNldCIsICJ4QXZlcmFnZSIsICJldmVudFBvc2l0aW9uIiwgIm5lYXJlc3RFbGVtZW50IiwgImRpc3RhbmNlQmV0d2VlblBvaW50cyIsICJ0cCIsICJwdXNoT3JDb25jYXQiLCAidG9QdXNoIiwgImFwcGx5IiwgInNwbGl0TmV3bGluZXMiLCAic3RyIiwgIlN0cmluZyIsICJjcmVhdGVUb29sdGlwSXRlbSIsICJmb3JtYXR0ZWRWYWx1ZSIsICJnZXRUb29sdGlwU2l6ZSIsICJ0b29sdGlwIiwgImJvZHkiLCAiZm9vdGVyIiwgImJvZHlGb250IiwgImZvb3RlckZvbnQiLCAidGl0bGVMaW5lQ291bnQiLCAiZm9vdGVyTGluZUNvdW50IiwgImJvZHlMaW5lSXRlbUNvdW50IiwgImNvbWJpbmVkQm9keUxlbmd0aCIsICJib2R5SXRlbSIsICJiZWZvcmUiLCAiYWZ0ZXIiLCAiYmVmb3JlQm9keSIsICJhZnRlckJvZHkiLCAidGl0bGVTcGFjaW5nIiwgInRpdGxlTWFyZ2luQm90dG9tIiwgImJvZHlMaW5lSGVpZ2h0IiwgImRpc3BsYXlDb2xvcnMiLCAiYm9keVNwYWNpbmciLCAiZm9vdGVyTWFyZ2luVG9wIiwgImZvb3RlclNwYWNpbmciLCAid2lkdGhQYWRkaW5nIiwgIm1heExpbmVXaWR0aCIsICJkZXRlcm1pbmVZQWxpZ24iLCAiZG9lc05vdEZpdFdpdGhBbGlnbiIsICJ4QWxpZ24iLCAiY2FyZXQiLCAiY2FyZXRTaXplIiwgImNhcmV0UGFkZGluZyIsICJkZXRlcm1pbmVYQWxpZ24iLCAieUFsaWduIiwgImNoYXJ0V2lkdGgiLCAiZGV0ZXJtaW5lQWxpZ25tZW50IiwgImFsaWduWCIsICJhbGlnblkiLCAicGFkZGluZ0FuZFNpemUiLCAiZ2V0QmFja2dyb3VuZFBvaW50IiwgImFsaWdubWVudCIsICJjb3JuZXJSYWRpdXMiLCAiZ2V0QWxpZ25lZFgiLCAiZ2V0QmVmb3JlQWZ0ZXJCb2R5TGluZXMiLCAiY3JlYXRlVG9vbHRpcENvbnRleHQiLCAidG9vbHRpcEl0ZW1zIiwgIm92ZXJyaWRlQ2FsbGJhY2tzIiwgImRlZmF1bHRDYWxsYmFja3MiLCAiYmVmb3JlVGl0bGUiLCAibm9vcCIsICJsYWJlbENvdW50IiwgImFmdGVyVGl0bGUiLCAiYmVmb3JlTGFiZWwiLCAidG9vbHRpcEl0ZW0iLCAibGFiZWxDb2xvciIsICJsYWJlbFRleHRDb2xvciIsICJib2R5Q29sb3IiLCAibGFiZWxQb2ludFN0eWxlIiwgImFmdGVyTGFiZWwiLCAiYmVmb3JlRm9vdGVyIiwgImFmdGVyRm9vdGVyIiwgImludm9rZUNhbGxiYWNrV2l0aEZhbGxiYWNrIiwgIlRvb2x0aXAiLCAib3BhY2l0eSIsICJfZXZlbnRQb3NpdGlvbiIsICJfc2l6ZSIsICJfY2FjaGVkQW5pbWF0aW9ucyIsICJfdG9vbHRpcEl0ZW1zIiwgImRhdGFQb2ludHMiLCAiY2FyZXRYIiwgImNhcmV0WSIsICJsYWJlbENvbG9ycyIsICJsYWJlbFBvaW50U3R5bGVzIiwgImxhYmVsVGV4dENvbG9ycyIsICJnZXRUaXRsZSIsICJnZXRCZWZvcmVCb2R5IiwgImdldEJvZHkiLCAiYm9keUl0ZW1zIiwgInNjb3BlZCIsICJnZXRBZnRlckJvZHkiLCAiZ2V0Rm9vdGVyIiwgIl9jcmVhdGVJdGVtcyIsICJpdGVtU29ydCIsICJwb3NpdGlvbkFuZFNpemUiLCAiYmFja2dyb3VuZFBvaW50IiwgImV4dGVybmFsIiwgImRyYXdDYXJldCIsICJ0b29sdGlwUG9pbnQiLCAiY2FyZXRQb3NpdGlvbiIsICJnZXRDYXJldFBvc2l0aW9uIiwgIngzIiwgInkzIiwgInB0WCIsICJwdFkiLCAicHQiLCAidGl0bGVDb2xvciIsICJfZHJhd0NvbG9yQm94IiwgImNvbG9yWCIsICJydGxDb2xvclgiLCAieU9mZlNldCIsICJjb2xvclkiLCAibXVsdGlLZXlCYWNrZ3JvdW5kIiwgIm91dGVyWCIsICJpbm5lclgiLCAic3Ryb2tlUmVjdCIsICJkcmF3Qm9keSIsICJib2R5QWxpZ24iLCAieExpbmVQYWRkaW5nIiwgImZpbGxMaW5lT2ZUZXh0IiwgImJvZHlBbGlnbkZvckNhbGN1bGF0aW9uIiwgInRleHRDb2xvciIsICJkcmF3Rm9vdGVyIiwgImZvb3RlckFsaWduIiwgImZvb3RlckNvbG9yIiwgInRvb2x0aXBTaXplIiwgInF1YWRyYXRpY0N1cnZlVG8iLCAiX3VwZGF0ZUFuaW1hdGlvblRhcmdldCIsICJhbmltWCIsICJhbmltWSIsICJfd2lsbFJlbmRlciIsICJoYXNUb29sdGlwQ29udGVudCIsICJnbG9iYWxBbHBoYSIsICJwb3NpdGlvbkNoYW5nZWQiLCAiX3Bvc2l0aW9uQ2hhbmdlZCIsICJfaWdub3JlUmVwbGF5RXZlbnRzIiwgImFmdGVySW5pdCIsICJhZnRlckRyYXciLCAiX2ZhbGxiYWNrIiwgImFkZElmU3RyaW5nIiwgImFkZGVkTGFiZWxzIiwgImZpbmRPckFkZExhYmVsIiwgImxhc3RJbmRleE9mIiwgIl9nZXRMYWJlbEZvclZhbHVlIiwgIkNhdGVnb3J5U2NhbGUiLCAiX3N0YXJ0VmFsdWUiLCAiX3ZhbHVlUmFuZ2UiLCAiX2FkZGVkTGFiZWxzIiwgImFkZGVkIiwgImdlbmVyYXRlVGlja3MiLCAiZ2VuZXJhdGlvbk9wdGlvbnMiLCAiZGF0YVJhbmdlIiwgIk1JTl9TUEFDSU5HIiwgInByZWNpc2lvbiIsICJtYXhUaWNrcyIsICJtYXhEaWdpdHMiLCAiaW5jbHVkZUJvdW5kcyIsICJ1bml0IiwgIm1heFNwYWNlcyIsICJybWluIiwgInJtYXgiLCAiY291bnREZWZpbmVkIiwgIm1pblNwYWNpbmciLCAibmljZU51bSIsICJuaWNlTWluIiwgIm5pY2VNYXgiLCAibnVtU3BhY2VzIiwgImFsbW9zdFdob2xlIiwgImFsbW9zdEVxdWFscyIsICJkZWNpbWFsUGxhY2VzIiwgIl9kZWNpbWFsUGxhY2VzIiwgInJlbGF0aXZlTGFiZWxTaXplIiwgInRpY2tWYWx1ZSIsICJyYWQiLCAiTGluZWFyU2NhbGVCYXNlIiwgIl9lbmRWYWx1ZSIsICJoYW5kbGVUaWNrUmFuZ2VPcHRpb25zIiwgInNldE1pbiIsICJzZXRNYXgiLCAibWluU2lnbiIsICJtYXhTaWduIiwgImdldFRpY2tMaW1pdCIsICJzdGVwU2l6ZSIsICJjb21wdXRlVGlja0xpbWl0IiwgIm51bWVyaWNHZW5lcmF0b3JPcHRpb25zIiwgIl9zZXRNaW5BbmRNYXhCeUtleSIsICJMaW5lYXJTY2FsZSIsICJUaWNrcyIsICJmb3JtYXR0ZXJzIiwgIm51bWVyaWMiLCAibG9nMTBGbG9vciIsICJsb2cxMCIsICJjaGFuZ2VFeHBvbmVudCIsICJtIiwgImlzTWFqb3IiLCAidGlja1ZhbCIsICJzdGVwcyIsICJyYW5nZUV4cCIsICJyYW5nZVN0ZXAiLCAic3RhcnRFeHAiLCAibWluRXhwIiwgImV4cCIsICJzaWduaWZpY2FuZCIsICJsYXN0VGljayIsICJMb2dhcml0aG1pY1NjYWxlIiwgIl96ZXJvIiwgImxvZ2FyaXRobWljIiwgImdldFRpY2tCYWNrZHJvcEhlaWdodCIsICJtZWFzdXJlTGFiZWxTaXplIiwgIl9sb25nZXN0VGV4dCIsICJkZXRlcm1pbmVMaW1pdHMiLCAiZml0V2l0aFBvaW50TGFiZWxzIiwgImxpbWl0cyIsICJ2YWx1ZUNvdW50IiwgIl9wb2ludExhYmVscyIsICJwb2ludExhYmVsT3B0cyIsICJhZGRpdGlvbmFsQW5nbGUiLCAiY2VudGVyUG9pbnRMYWJlbHMiLCAiZ2V0UG9pbnRMYWJlbENvbnRleHQiLCAiZ2V0UG9pbnRQb3NpdGlvbiIsICJkcmF3aW5nQXJlYSIsICJwbEZvbnQiLCAiaExpbWl0cyIsICJ2TGltaXRzIiwgInVwZGF0ZUxpbWl0cyIsICJzZXRDZW50ZXJQb2ludCIsICJfcG9pbnRMYWJlbEl0ZW1zIiwgImJ1aWxkUG9pbnRMYWJlbEl0ZW1zIiwgImNyZWF0ZVBvaW50TGFiZWxJdGVtIiwgIml0ZW1PcHRzIiwgIm91dGVyRGlzdGFuY2UiLCAiZXh0cmEiLCAicG9pbnRMYWJlbFBvc2l0aW9uIiwgInlGb3JBbmdsZSIsICJnZXRUZXh0QWxpZ25Gb3JBbmdsZSIsICJsZWZ0Rm9yVGV4dEFsaWduIiwgImlzTm90T3ZlcmxhcHBlZCIsICJhcGV4ZXNJbkFyZWEiLCAiZHJhd1BvaW50TGFiZWxCb3giLCAiYmFja2Ryb3BMZWZ0IiwgImJhY2tkcm9wVG9wIiwgImJhY2tkcm9wV2lkdGgiLCAiYmFja2Ryb3BIZWlnaHQiLCAiZHJhd1BvaW50TGFiZWxzIiwgInBhdGhSYWRpdXNMaW5lIiwgImRyYXdSYWRpdXNMaW5lIiwgImdyaWRMaW5lT3B0cyIsICJjcmVhdGVQb2ludExhYmVsQ29udGV4dCIsICJSYWRpYWxMaW5lYXJTY2FsZSIsICJsZWZ0TW92ZW1lbnQiLCAicmlnaHRNb3ZlbWVudCIsICJ0b3BNb3ZlbWVudCIsICJib3R0b21Nb3ZlbWVudCIsICJhbmdsZU11bHRpcGxpZXIiLCAic2NhbGluZ0ZhY3RvciIsICJnZXRWYWx1ZUZvckRpc3RhbmNlRnJvbUNlbnRlciIsICJzY2FsZWREaXN0YW5jZSIsICJwb2ludExhYmVsIiwgImRpc3RhbmNlRnJvbUNlbnRlciIsICJnZXRCYXNlUG9zaXRpb24iLCAiZ2V0UG9pbnRMYWJlbFBvc2l0aW9uIiwgInJvdGF0ZSIsICJhbmltYXRlIiwgIklOVEVSVkFMUyIsICJtaWxsaXNlY29uZCIsICJjb21tb24iLCAic2Vjb25kIiwgIm1pbnV0ZSIsICJob3VyIiwgImRheSIsICJ3ZWVrIiwgIm1vbnRoIiwgInF1YXJ0ZXIiLCAieWVhciIsICJVTklUUyIsICJzb3J0ZXIiLCAiaW5wdXQiLCAiYWRhcHRlciIsICJfYWRhcHRlciIsICJwYXJzZXIiLCAiaXNvV2Vla2RheSIsICJfcGFyc2VPcHRzIiwgImRldGVybWluZVVuaXRGb3JBdXRvVGlja3MiLCAibWluVW5pdCIsICJjYXBhY2l0eSIsICJpbnRlcnZhbCIsICJNQVhfU0FGRV9JTlRFR0VSIiwgImRldGVybWluZVVuaXRGb3JGb3JtYXR0aW5nIiwgImRldGVybWluZU1ham9yVW5pdCIsICJhZGRUaWNrIiwgInRpbWUiLCAidGltZXN0YW1wcyIsICJfbG9va3VwIiwgInRpbWVzdGFtcCIsICJzZXRNYWpvclRpY2tzIiwgIm1ham9yVW5pdCIsICJ0aWNrc0Zyb21UaW1lc3RhbXBzIiwgIlRpbWVTY2FsZSIsICJfdW5pdCIsICJfbWFqb3JVbml0IiwgIl9vZmZzZXRzIiwgIl9ub3JtYWxpemVkIiwgImFkYXB0ZXJzIiwgImRpc3BsYXlGb3JtYXRzIiwgIm5vcm1hbGl6ZWQiLCAiX2FwcGx5Qm91bmRzIiwgIl9nZXRMYWJlbEJvdW5kcyIsICJnZXRMYWJlbFRpbWVzdGFtcHMiLCAidGltZU9wdHMiLCAiX2dlbmVyYXRlIiwgIl9maWx0ZXJCZXR3ZWVuIiwgIl9nZXRMYWJlbENhcGFjaXR5IiwgImluaXRPZmZzZXRzIiwgIm9mZnNldEFmdGVyQXV0b3NraXAiLCAiZ2V0RGVjaW1hbEZvclZhbHVlIiwgIm1pbm9yIiwgIndlZWtkYXkiLCAiaGFzV2Vla2RheSIsICJnZXREYXRhVGltZXN0YW1wcyIsICJ0b29sdGlwRm9ybWF0IiwgImRhdGV0aW1lIiwgImZtdCIsICJfdGlja0Zvcm1hdEZ1bmN0aW9uIiwgImZvcm1hdHRlciIsICJtaW5vckZvcm1hdCIsICJtYWpvckZvcm1hdCIsICJvZmZzZXRzIiwgIl9nZXRMYWJlbFNpemUiLCAidGlja3NPcHRzIiwgInRpY2tMYWJlbFdpZHRoIiwgImNvc1JvdGF0aW9uIiwgInNpblJvdGF0aW9uIiwgInRpY2tGb250U2l6ZSIsICJleGFtcGxlVGltZSIsICJleGFtcGxlTGFiZWwiLCAibm9ybWFsaXplIiwgInRhYmxlIiwgInByZXZTb3VyY2UiLCAibmV4dFNvdXJjZSIsICJwcmV2VGFyZ2V0IiwgIm5leHRUYXJnZXQiLCAic3BhbiIsICJUaW1lU2VyaWVzU2NhbGUiLCAiX3RhYmxlIiwgIl9taW5Qb3MiLCAiX3RhYmxlUmFuZ2UiLCAiX2dldFRpbWVzdGFtcHNGb3JUYWJsZSIsICJidWlsZExvb2t1cFRhYmxlIiwgInJlZ2lzdGVyYWJsZXMiLCAiZGVib3VuY2UiLCAic2NhbGVzIiwgInpvb20iLCAiZnJvbSIsICJ0byIsICJyb3VuZCIsICJIYW1tZXIiLCAidmVyc2lvbiIsICJkcmF3IiwgInRoZW1lQ29sb3JzIiwgImNvbG9ycyIsICJpbmRleCJdCn0K
